From 09c602d685107779a3fb35be201411143548ef78 Mon Sep 17 00:00:00 2001
From: w01230 <4585006@gmail.com>
Date: Wed, 27 Jun 2018 10:30:21 +0800
Subject: [PATCH] add ath79 for Openwrt-18.06

---
 target/linux/ath79/Makefile                   |   19 +
 .../ath79/base-files/etc/board.d/01_leds      |   52 +
 .../ath79/base-files/etc/board.d/02_network   |  131 ++
 target/linux/ath79/base-files/etc/diag.sh     |   22 +
 .../etc/hotplug.d/firmware/10-ath9k-eeprom    |   69 +
 .../etc/hotplug.d/firmware/11-ath10k-caldata  |  117 ++
 .../etc/hotplug.d/ieee80211/10_fix_wifi_mac   |   24 +
 .../ath79/base-files/lib/functions/k2t.sh     |   55 +
 .../ath79/base-files/lib/upgrade/platform.sh  |   20 +
 target/linux/ath79/config-4.14                |  240 +++
 target/linux/ath79/dts/ar7100.dtsi            |  204 +++
 .../ath79/dts/ar7161_netgear_wndr3800.dts     |  217 +++
 target/linux/ath79/dts/ar7240.dtsi            |   66 +
 .../ath79/dts/ar7240_netgear_wnr612-v2.dts    |   10 +
 .../ath79/dts/ar7240_netgear_wnr612-v2.dtsi   |  147 ++
 target/linux/ath79/dts/ar7240_on_n150r.dts    |   10 +
 .../linux/ath79/dts/ar7240_tl-wr740n-v2.dts   |  174 ++
 target/linux/ath79/dts/ar7241.dtsi            |   78 +
 .../linux/ath79/dts/ar7241_ubnt_bullet-m.dts  |   13 +
 target/linux/ath79/dts/ar7241_ubnt_nano-m.dts |    9 +
 .../linux/ath79/dts/ar7241_ubnt_rocket-m.dts  |   21 +
 target/linux/ath79/dts/ar7241_ubnt_unifi.dts  |  145 ++
 target/linux/ath79/dts/ar7241_ubnt_xm.dtsi    |  152 ++
 target/linux/ath79/dts/ar7242.dtsi            |   69 +
 .../linux/ath79/dts/ar7242_avm_fritz300e.dts  |  174 ++
 .../ath79/dts/ar7242_buffalo_wzr-hp-g450h.dts |  122 ++
 .../linux/ath79/dts/ar7242_tl-wr2543-v1.dts   |  186 ++
 target/linux/ath79/dts/ar724x.dtsi            |  154 ++
 target/linux/ath79/dts/ar9132.dtsi            |  196 ++
 .../linux/ath79/dts/ar9132_tl-wr1043nd-v1.dts |  173 ++
 target/linux/ath79/dts/ar9330.dtsi            |  169 ++
 .../linux/ath79/dts/ar9330_glinet_ar150.dts   |  170 ++
 target/linux/ath79/dts/ar9331.dtsi            |   11 +
 target/linux/ath79/dts/ar9331_dpt_module.dts  |   79 +
 .../linux/ath79/dts/ar9331_dragino_ms14.dts   |  103 ++
 .../dts/ar9331_embeddedwireless_dorin.dts     |  132 ++
 .../linux/ath79/dts/ar9331_etactica-eg200.dts |  143 ++
 target/linux/ath79/dts/ar9331_omega.dts       |   79 +
 target/linux/ath79/dts/ar9331_tl-mr10u.dts    |   13 +
 .../linux/ath79/dts/ar9331_tl-mr3020-v1.dts   |  192 ++
 target/linux/ath79/dts/ar9331_tl-wr703n.dts   |   13 +
 .../ath79/dts/ar9331_tl-wr703n_tl-mr10u.dtsi  |  135 ++
 target/linux/ath79/dts/ar9341.dtsi            |   18 +
 target/linux/ath79/dts/ar9344.dtsi            |   62 +
 target/linux/ath79/dts/ar9344_tl-wdr3600.dts  |    9 +
 target/linux/ath79/dts/ar9344_tl-wdr4300.dts  |    9 +
 target/linux/ath79/dts/ar9344_tl-wdr4300.dtsi |  246 +++
 target/linux/ath79/dts/ar934x.dtsi            |  220 +++
 target/linux/ath79/dts/ath79.dtsi             |   85 +
 target/linux/ath79/dts/qca9533.dtsi           |  235 +++
 .../ath79/dts/qca9533_glinet_ar300m.dtsi      |  141 ++
 .../ath79/dts/qca9533_glinet_ar300m_nand.dts  |   67 +
 .../ath79/dts/qca9533_glinet_ar300m_nor.dts   |   46 +
 target/linux/ath79/dts/qca9557.dtsi           |  313 ++++
 .../ath79/dts/qca9558_openmesh_om5p-ac-v2.dts |  176 ++
 .../ath79/dts/qca9558_tl-archer-c7-v2.dts     |   16 +
 .../linux/ath79/dts/qca9558_tl-archer-c7.dtsi |  232 +++
 .../ath79/dts/qca9558_tl-wr1043nd-v2.dts      |   12 +
 .../ath79/dts/qca9558_tl-wr1043nd-v3.dts      |   12 +
 .../linux/ath79/dts/qca9558_tl-wr1043nd.dtsi  |  194 ++
 .../linux/ath79/dts/qca9563_phicomm-k2t.dts   |  151 ++
 .../linux/ath79/dts/qca9563_tl-wr1043n.dtsi   |  223 +++
 .../ath79/dts/qca9563_tl-wr1043nd-v4.dts      |   12 +
 .../ath79/dts/qca9563_ubnt-unifiac-lite.dts   |  148 ++
 target/linux/ath79/dts/qca956x.dtsi           |  283 +++
 .../files/arch/mips/ath79/pci-ath9k-fixup.c   |  126 ++
 .../files/arch/mips/ath79/pci-ath9k-fixup.h   |    6 +
 .../mips/include/asm/fw/myloader/myloader.h   |   34 +
 .../ath79/files/drivers/mtd/tplinkpart.c      |  235 +++
 .../ath79/files/drivers/net/dsa/mv88e6063.c   |  289 +++
 .../net/ethernet/atheros/ag71xx/Kconfig       |   25 +
 .../net/ethernet/atheros/ag71xx/Makefile      |   14 +
 .../net/ethernet/atheros/ag71xx/ag71xx.h      |  453 +++++
 .../ethernet/atheros/ag71xx/ag71xx_ar7240.c   | 1340 ++++++++++++++
 .../ethernet/atheros/ag71xx/ag71xx_debugfs.c  |  285 +++
 .../ethernet/atheros/ag71xx/ag71xx_ethtool.c  |  120 ++
 .../net/ethernet/atheros/ag71xx/ag71xx_main.c | 1612 +++++++++++++++++
 .../net/ethernet/atheros/ag71xx/ag71xx_mdio.c |  218 +++
 .../net/ethernet/atheros/ag71xx/ag71xx_phy.c  |   92 +
 target/linux/ath79/generic/config-default     |   16 +
 .../ath79/generic/profiles/00-default.mk      |   16 +
 target/linux/ath79/generic/target.mk          |    8 +
 target/linux/ath79/image/Makefile             |   81 +
 target/linux/ath79/image/common-netgear.mk    |   22 +
 target/linux/ath79/image/common-tp-link.mk    |   90 +
 target/linux/ath79/image/generic-tp-link.mk   |   90 +
 target/linux/ath79/image/generic-ubnt.mk      |  100 +
 target/linux/ath79/image/generic.mk           |  100 +
 target/linux/ath79/image/lzma-loader/Makefile |   70 +
 .../ath79/image/lzma-loader/src/LzmaDecode.c  |  584 ++++++
 .../ath79/image/lzma-loader/src/LzmaDecode.h  |  113 ++
 .../ath79/image/lzma-loader/src/LzmaTypes.h   |   45 +
 .../ath79/image/lzma-loader/src/Makefile      |  108 ++
 .../ath79/image/lzma-loader/src/ar71xx_regs.h |  725 ++++++++
 .../linux/ath79/image/lzma-loader/src/board.c |   56 +
 .../linux/ath79/image/lzma-loader/src/cache.c |   43 +
 .../linux/ath79/image/lzma-loader/src/cache.h |   17 +
 .../ath79/image/lzma-loader/src/cacheops.h    |   85 +
 .../ath79/image/lzma-loader/src/config.h      |   31 +
 .../ath79/image/lzma-loader/src/cp0regdef.h   |   39 +
 .../linux/ath79/image/lzma-loader/src/head.S  |  134 ++
 .../ath79/image/lzma-loader/src/loader.c      |  264 +++
 .../ath79/image/lzma-loader/src/loader.lds    |   34 +
 .../ath79/image/lzma-loader/src/loader2.lds   |   10 +
 .../ath79/image/lzma-loader/src/lzma-data.lds |    8 +
 .../ath79/image/lzma-loader/src/printf.c      |  350 ++++
 .../ath79/image/lzma-loader/src/printf.h      |   18 +
 target/linux/ath79/image/nand.mk              |   13 +
 target/linux/ath79/image/tiny-netgear.mk      |   36 +
 target/linux/ath79/image/tiny-tp-link.mk      |   41 +
 target/linux/ath79/modules.mk                 |   16 +
 target/linux/ath79/nand/config-default        |   14 +
 .../linux/ath79/nand/profiles/00-default.mk   |   18 +
 target/linux/ath79/nand/target.mk             |    7 +
 ...-serial-drop-QCA-pecific-SoC-symbols.patch |   21 +
 ...2-watchdog-ath79-fix-maximum-timeout.patch |   32 +
 ...ds-add-reset-controller-based-driver.patch |  186 ++
 .../0004-phy-add-ath79-usb-phys.patch         |  320 ++++
 ...005-usb-add-more-OF-quirk-properties.patch |   24 +
 .../0006-usb-drop-deprecated-symbols.patch    |   51 +
 ...9-intc-add-irq-cascade-driver-for-QC.patch |  168 ++
 ...ip-irq-ath79-cpu-drop-OF-init-helper.patch |   23 +
 ...-ath79-add-lots-of-missing-registers.patch |  971 ++++++++++
 ...S-ath79-select-the-PINCTRL-subsystem.patch |   20 +
 ...egister-address-in-ath79_ddr_wb_flus.patch |   27 +
 ...Avoid-using-unitialized-reg-variable.patch |   42 +
 .../0013-MIPS-ath79-fix-system-restart.patch  |   32 +
 ...14-MIPS-ath79-finetune-cpu-overrides.patch |   38 +
 ...ath79-enable-uart-during-early_prink.patch |   71 +
 ...PS-ath79-add-support-for-QCA953x-SoC.patch |  331 ++++
 ...PS-ath79-add-support-for-qca956x-soc.patch |  410 +++++
 ...h79-get-PCIe-controller-out-of-reset.patch |  100 +
 ...pci-ar71xx-driver-into-a-pure-OF-dri.patch |  197 ++
 ...pci-ar724x-driver-into-a-pure-OF-dri.patch |  199 ++
 .../0022-MIPS-ath79-drop-pci.c.patch          |  350 ++++
 .../0023-MIPS-ath79-drop-mach-files.patch     |  742 ++++++++
 .../0024-GPIO-add-named-gpio-exports.patch    |  166 ++
 .../0024-MIPS-ath79-drop-pdata-helpers.patch  |  922 ++++++++++
 .../0025-MIPS-ath79-drop-irq.c.patch          |  336 ++++
 ...-MIPS-ath79-sanitize-Kconfig-symbols.patch |  111 ++
 ...MIPS-ath79-drop-mips_machine-support.patch |  172 ++
 ...elpers-for-setting-clocks-and-expose.patch |  238 +++
 ...legacy-wdt-and-uart-clock-aliases-ou.patch |  110 ++
 ...ass-PLL-base-to-clock-init-functions.patch |  238 +++
 ...specifying-the-reference-clock-in-DT.patch |  225 +++
 ...rt-setting-up-clock-via-DT-on-all-So.patch |   73 +
 ...9-export-switch-MDIO-reference-clock.patch |   54 +
 .../0034-MIPS-ath79-ath9k-exports.patch       |   27 +
 .../0035-MIPS-ath79-fix-QCA956x-boot.patch    |   17 +
 .../004-register_gpio_driver_earlier.patch    |   18 +
 .../405-mtd-tp-link-partition-parser.patch    |   25 +
 .../420-net-ar71xx_mac_driver.patch           |   28 +
 .../430-drivers-link-spi-before-mtd.patch     |   12 +
 .../461-spi-ath79-add-fast-flash-read.patch   |   60 +
 ...ath79-swizzle-pci-address-for-ar71xx.patch |   98 +
 ...490-usb-ehci-add-quirks-for-qca-socs.patch |  103 ++
 .../900-mdio_bitbang_ignore_ta_value.patch    |   32 +
 ...-prevent-rescheduling-during-command.patch |   61 +
 .../910-unaligned_access_hacks.patch          |  900 +++++++++
 target/linux/ath79/tiny/config-default        |   14 +
 .../linux/ath79/tiny/profiles/00-default.mk   |    9 +
 target/linux/ath79/tiny/target.mk             |    6 +
 162 files changed, 23879 insertions(+)
 create mode 100644 target/linux/ath79/Makefile
 create mode 100755 target/linux/ath79/base-files/etc/board.d/01_leds
 create mode 100755 target/linux/ath79/base-files/etc/board.d/02_network
 create mode 100644 target/linux/ath79/base-files/etc/diag.sh
 create mode 100644 target/linux/ath79/base-files/etc/hotplug.d/firmware/10-ath9k-eeprom
 create mode 100644 target/linux/ath79/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
 create mode 100644 target/linux/ath79/base-files/etc/hotplug.d/ieee80211/10_fix_wifi_mac
 create mode 100755 target/linux/ath79/base-files/lib/functions/k2t.sh
 create mode 100644 target/linux/ath79/base-files/lib/upgrade/platform.sh
 create mode 100644 target/linux/ath79/config-4.14
 create mode 100644 target/linux/ath79/dts/ar7100.dtsi
 create mode 100644 target/linux/ath79/dts/ar7161_netgear_wndr3800.dts
 create mode 100644 target/linux/ath79/dts/ar7240.dtsi
 create mode 100644 target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dts
 create mode 100644 target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dtsi
 create mode 100644 target/linux/ath79/dts/ar7240_on_n150r.dts
 create mode 100644 target/linux/ath79/dts/ar7240_tl-wr740n-v2.dts
 create mode 100644 target/linux/ath79/dts/ar7241.dtsi
 create mode 100644 target/linux/ath79/dts/ar7241_ubnt_bullet-m.dts
 create mode 100644 target/linux/ath79/dts/ar7241_ubnt_nano-m.dts
 create mode 100644 target/linux/ath79/dts/ar7241_ubnt_rocket-m.dts
 create mode 100644 target/linux/ath79/dts/ar7241_ubnt_unifi.dts
 create mode 100644 target/linux/ath79/dts/ar7241_ubnt_xm.dtsi
 create mode 100644 target/linux/ath79/dts/ar7242.dtsi
 create mode 100644 target/linux/ath79/dts/ar7242_avm_fritz300e.dts
 create mode 100644 target/linux/ath79/dts/ar7242_buffalo_wzr-hp-g450h.dts
 create mode 100644 target/linux/ath79/dts/ar7242_tl-wr2543-v1.dts
 create mode 100644 target/linux/ath79/dts/ar724x.dtsi
 create mode 100644 target/linux/ath79/dts/ar9132.dtsi
 create mode 100644 target/linux/ath79/dts/ar9132_tl-wr1043nd-v1.dts
 create mode 100644 target/linux/ath79/dts/ar9330.dtsi
 create mode 100644 target/linux/ath79/dts/ar9330_glinet_ar150.dts
 create mode 100644 target/linux/ath79/dts/ar9331.dtsi
 create mode 100644 target/linux/ath79/dts/ar9331_dpt_module.dts
 create mode 100644 target/linux/ath79/dts/ar9331_dragino_ms14.dts
 create mode 100644 target/linux/ath79/dts/ar9331_embeddedwireless_dorin.dts
 create mode 100644 target/linux/ath79/dts/ar9331_etactica-eg200.dts
 create mode 100644 target/linux/ath79/dts/ar9331_omega.dts
 create mode 100644 target/linux/ath79/dts/ar9331_tl-mr10u.dts
 create mode 100644 target/linux/ath79/dts/ar9331_tl-mr3020-v1.dts
 create mode 100644 target/linux/ath79/dts/ar9331_tl-wr703n.dts
 create mode 100644 target/linux/ath79/dts/ar9331_tl-wr703n_tl-mr10u.dtsi
 create mode 100644 target/linux/ath79/dts/ar9341.dtsi
 create mode 100644 target/linux/ath79/dts/ar9344.dtsi
 create mode 100644 target/linux/ath79/dts/ar9344_tl-wdr3600.dts
 create mode 100644 target/linux/ath79/dts/ar9344_tl-wdr4300.dts
 create mode 100644 target/linux/ath79/dts/ar9344_tl-wdr4300.dtsi
 create mode 100644 target/linux/ath79/dts/ar934x.dtsi
 create mode 100644 target/linux/ath79/dts/ath79.dtsi
 create mode 100644 target/linux/ath79/dts/qca9533.dtsi
 create mode 100644 target/linux/ath79/dts/qca9533_glinet_ar300m.dtsi
 create mode 100644 target/linux/ath79/dts/qca9533_glinet_ar300m_nand.dts
 create mode 100644 target/linux/ath79/dts/qca9533_glinet_ar300m_nor.dts
 create mode 100644 target/linux/ath79/dts/qca9557.dtsi
 create mode 100644 target/linux/ath79/dts/qca9558_openmesh_om5p-ac-v2.dts
 create mode 100644 target/linux/ath79/dts/qca9558_tl-archer-c7-v2.dts
 create mode 100644 target/linux/ath79/dts/qca9558_tl-archer-c7.dtsi
 create mode 100644 target/linux/ath79/dts/qca9558_tl-wr1043nd-v2.dts
 create mode 100644 target/linux/ath79/dts/qca9558_tl-wr1043nd-v3.dts
 create mode 100644 target/linux/ath79/dts/qca9558_tl-wr1043nd.dtsi
 create mode 100644 target/linux/ath79/dts/qca9563_phicomm-k2t.dts
 create mode 100644 target/linux/ath79/dts/qca9563_tl-wr1043n.dtsi
 create mode 100644 target/linux/ath79/dts/qca9563_tl-wr1043nd-v4.dts
 create mode 100644 target/linux/ath79/dts/qca9563_ubnt-unifiac-lite.dts
 create mode 100644 target/linux/ath79/dts/qca956x.dtsi
 create mode 100644 target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.c
 create mode 100644 target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.h
 create mode 100644 target/linux/ath79/files/arch/mips/include/asm/fw/myloader/myloader.h
 create mode 100644 target/linux/ath79/files/drivers/mtd/tplinkpart.c
 create mode 100644 target/linux/ath79/files/drivers/net/dsa/mv88e6063.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Kconfig
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Makefile
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
 create mode 100644 target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
 create mode 100644 target/linux/ath79/generic/config-default
 create mode 100644 target/linux/ath79/generic/profiles/00-default.mk
 create mode 100644 target/linux/ath79/generic/target.mk
 create mode 100644 target/linux/ath79/image/Makefile
 create mode 100644 target/linux/ath79/image/common-netgear.mk
 create mode 100644 target/linux/ath79/image/common-tp-link.mk
 create mode 100644 target/linux/ath79/image/generic-tp-link.mk
 create mode 100644 target/linux/ath79/image/generic-ubnt.mk
 create mode 100644 target/linux/ath79/image/generic.mk
 create mode 100644 target/linux/ath79/image/lzma-loader/Makefile
 create mode 100644 target/linux/ath79/image/lzma-loader/src/LzmaDecode.c
 create mode 100644 target/linux/ath79/image/lzma-loader/src/LzmaDecode.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/LzmaTypes.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/Makefile
 create mode 100644 target/linux/ath79/image/lzma-loader/src/ar71xx_regs.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/board.c
 create mode 100644 target/linux/ath79/image/lzma-loader/src/cache.c
 create mode 100644 target/linux/ath79/image/lzma-loader/src/cache.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/cacheops.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/config.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/cp0regdef.h
 create mode 100644 target/linux/ath79/image/lzma-loader/src/head.S
 create mode 100644 target/linux/ath79/image/lzma-loader/src/loader.c
 create mode 100644 target/linux/ath79/image/lzma-loader/src/loader.lds
 create mode 100644 target/linux/ath79/image/lzma-loader/src/loader2.lds
 create mode 100644 target/linux/ath79/image/lzma-loader/src/lzma-data.lds
 create mode 100644 target/linux/ath79/image/lzma-loader/src/printf.c
 create mode 100644 target/linux/ath79/image/lzma-loader/src/printf.h
 create mode 100644 target/linux/ath79/image/nand.mk
 create mode 100644 target/linux/ath79/image/tiny-netgear.mk
 create mode 100644 target/linux/ath79/image/tiny-tp-link.mk
 create mode 100644 target/linux/ath79/modules.mk
 create mode 100644 target/linux/ath79/nand/config-default
 create mode 100644 target/linux/ath79/nand/profiles/00-default.mk
 create mode 100644 target/linux/ath79/nand/target.mk
 create mode 100644 target/linux/ath79/patches-4.14/0001-tty-serial-drop-QCA-pecific-SoC-symbols.patch
 create mode 100644 target/linux/ath79/patches-4.14/0002-watchdog-ath79-fix-maximum-timeout.patch
 create mode 100644 target/linux/ath79/patches-4.14/0003-leds-add-reset-controller-based-driver.patch
 create mode 100644 target/linux/ath79/patches-4.14/0004-phy-add-ath79-usb-phys.patch
 create mode 100644 target/linux/ath79/patches-4.14/0005-usb-add-more-OF-quirk-properties.patch
 create mode 100644 target/linux/ath79/patches-4.14/0006-usb-drop-deprecated-symbols.patch
 create mode 100644 target/linux/ath79/patches-4.14/0007-irqchip-irq-ath79-intc-add-irq-cascade-driver-for-QC.patch
 create mode 100644 target/linux/ath79/patches-4.14/0008-irqchip-irq-ath79-cpu-drop-OF-init-helper.patch
 create mode 100644 target/linux/ath79/patches-4.14/0009-MIPS-ath79-add-lots-of-missing-registers.patch
 create mode 100644 target/linux/ath79/patches-4.14/0010-MIPS-ath79-select-the-PINCTRL-subsystem.patch
 create mode 100644 target/linux/ath79/patches-4.14/0011-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
 create mode 100644 target/linux/ath79/patches-4.14/0012-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
 create mode 100644 target/linux/ath79/patches-4.14/0013-MIPS-ath79-fix-system-restart.patch
 create mode 100644 target/linux/ath79/patches-4.14/0014-MIPS-ath79-finetune-cpu-overrides.patch
 create mode 100644 target/linux/ath79/patches-4.14/0015-MIPS-ath79-enable-uart-during-early_prink.patch
 create mode 100644 target/linux/ath79/patches-4.14/0016-MIPS-ath79-add-support-for-QCA953x-SoC.patch
 create mode 100644 target/linux/ath79/patches-4.14/0017-MIPS-ath79-add-support-for-qca956x-soc.patch
 create mode 100644 target/linux/ath79/patches-4.14/0019-MIPS-ath79-get-PCIe-controller-out-of-reset.patch
 create mode 100644 target/linux/ath79/patches-4.14/0020-MIPS-ath79-turn-pci-ar71xx-driver-into-a-pure-OF-dri.patch
 create mode 100644 target/linux/ath79/patches-4.14/0021-MIPS-ath79-turn-pci-ar724x-driver-into-a-pure-OF-dri.patch
 create mode 100644 target/linux/ath79/patches-4.14/0022-MIPS-ath79-drop-pci.c.patch
 create mode 100644 target/linux/ath79/patches-4.14/0023-MIPS-ath79-drop-mach-files.patch
 create mode 100644 target/linux/ath79/patches-4.14/0024-GPIO-add-named-gpio-exports.patch
 create mode 100644 target/linux/ath79/patches-4.14/0024-MIPS-ath79-drop-pdata-helpers.patch
 create mode 100644 target/linux/ath79/patches-4.14/0025-MIPS-ath79-drop-irq.c.patch
 create mode 100644 target/linux/ath79/patches-4.14/0026-MIPS-ath79-sanitize-Kconfig-symbols.patch
 create mode 100644 target/linux/ath79/patches-4.14/0027-MIPS-ath79-drop-mips_machine-support.patch
 create mode 100644 target/linux/ath79/patches-4.14/0028-MIPS-ath79-add-helpers-for-setting-clocks-and-expose.patch
 create mode 100644 target/linux/ath79/patches-4.14/0029-MIPS-ath79-move-legacy-wdt-and-uart-clock-aliases-ou.patch
 create mode 100644 target/linux/ath79/patches-4.14/0030-MIPS-ath79-pass-PLL-base-to-clock-init-functions.patch
 create mode 100644 target/linux/ath79/patches-4.14/0031-MIPS-ath79-make-specifying-the-reference-clock-in-DT.patch
 create mode 100644 target/linux/ath79/patches-4.14/0032-MIPS-ath79-support-setting-up-clock-via-DT-on-all-So.patch
 create mode 100644 target/linux/ath79/patches-4.14/0033-MIPS-ath79-export-switch-MDIO-reference-clock.patch
 create mode 100644 target/linux/ath79/patches-4.14/0034-MIPS-ath79-ath9k-exports.patch
 create mode 100644 target/linux/ath79/patches-4.14/0035-MIPS-ath79-fix-QCA956x-boot.patch
 create mode 100644 target/linux/ath79/patches-4.14/004-register_gpio_driver_earlier.patch
 create mode 100644 target/linux/ath79/patches-4.14/405-mtd-tp-link-partition-parser.patch
 create mode 100644 target/linux/ath79/patches-4.14/420-net-ar71xx_mac_driver.patch
 create mode 100644 target/linux/ath79/patches-4.14/430-drivers-link-spi-before-mtd.patch
 create mode 100644 target/linux/ath79/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
 create mode 100644 target/linux/ath79/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
 create mode 100644 target/linux/ath79/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
 create mode 100644 target/linux/ath79/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
 create mode 100644 target/linux/ath79/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
 create mode 100644 target/linux/ath79/patches-4.14/910-unaligned_access_hacks.patch
 create mode 100644 target/linux/ath79/tiny/config-default
 create mode 100644 target/linux/ath79/tiny/profiles/00-default.mk
 create mode 100644 target/linux/ath79/tiny/target.mk

diff --git a/target/linux/ath79/Makefile b/target/linux/ath79/Makefile
new file mode 100644
index 0000000000..2d8ca7efdb
--- /dev/null
+++ b/target/linux/ath79/Makefile
@@ -0,0 +1,19 @@
+include $(TOPDIR)/rules.mk
+
+ARCH:=mips
+BOARD:=ath79
+BOARDNAME:=Atheros ATH79 (DTS)
+CPU_TYPE:=24kc
+SUBTARGETS:=generic nand tiny
+
+FEATURES:=ramdisk source-only
+
+KERNEL_PATCHVER:=4.14
+
+include $(INCLUDE_DIR)/target.mk
+
+DEFAULT_PACKAGES += \
+	kmod-gpio-button-hotplug swconfig \
+	kmod-ath9k wpad-mini uboot-envtools
+
+$(eval $(call BuildTarget))
diff --git a/target/linux/ath79/base-files/etc/board.d/01_leds b/target/linux/ath79/base-files/etc/board.d/01_leds
new file mode 100755
index 0000000000..29416ad83e
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/board.d/01_leds
@@ -0,0 +1,52 @@
+#!/bin/sh
+
+. /lib/functions/uci-defaults.sh
+
+board_config_update
+
+board=$(board_name)
+boardname="${board##*,}"
+
+case "$board" in
+"avm,fritz300e")
+	ucidef_set_led_netdev "lan" "LAN" "$boardname:green:lan" "eth0"
+	ucidef_set_rssimon "wlan0" "200000" "1"
+	ucidef_set_led_rssi "rssilow" "RSSILOW" "$boardname:green:rssi0" "wlan0" "1" "100"
+	ucidef_set_led_rssi "rssimediumlow" "RSSIMEDIUMLOW" "$boardname:green:rssi1" "wlan0" "20" "100"
+	ucidef_set_led_rssi "rssimedium" "RSSIMEDIUM" "$boardname:green:rssi2" "wlan0" "40" "100"
+	ucidef_set_led_rssi "rssimediumhigh" "RSSIMEDIUMHIGH" "$boardname:green:rssi3" "wlan0" "60" "100"
+	ucidef_set_led_rssi "rssihigh" "RSSIHIGH" "$boardname:green:rssi4" "wlan0" "80" "100"
+	;;
+"etactica,eg200")
+	ucidef_set_led_netdev "lan" "LAN" "$boardname:red:eth0" "eth0"
+	ucidef_set_led_oneshot "modbus" "Modbus" "$boardname:red:modbus" "100" "33"
+	ucidef_set_led_default "etactica" "etactica" "$boardname:red:etactica" "ignore"
+	;;
+"netgear,wnr612-v2"|\
+"on,n150r")
+	ucidef_set_led_netdev "wan" "WAN" "netgear:green:wan" "eth0"
+	ucidef_set_led_switch "lan1" "LAN1" "netgear:green:lan1" "switch0" "0x02" "0x0f"
+	ucidef_set_led_switch "lan2" "LAN2" "netgear:green:lan2" "switch0" "0x04" "0x0f"
+	;;
+"tplink,tl-mr3020-v1")
+	ucidef_set_led_switch "lan" "LAN" "tp-link:green:lan" "switch0" "0x02"
+	;;
+"tplink,tl-wr1043nd-v4")
+	ucidef_set_led_switch "wan" "WAN" "tp-link:green:wan" "switch0" "0x20"
+	ucidef_set_led_switch "lan1" "LAN1" "tp-link:green:lan1" "switch0" "0x10"
+	ucidef_set_led_switch "lan2" "LAN2" "tp-link:green:lan2" "switch0" "0x08"
+	ucidef_set_led_switch "lan3" "LAN3" "tp-link:green:lan3" "switch0" "0x04"
+	ucidef_set_led_switch "lan4" "LAN4" "tp-link:green:lan4" "switch0" "0x02"
+	;;
+"tplink,tl-wr740n-v2")
+	ucidef_set_led_netdev "wan" "WAN" "$boardname:green:wan" "eth0"
+	ucidef_set_led_switch "lan1" "LAN1" "$boardname:green:lan1" "switch0" "0x02"
+	ucidef_set_led_switch "lan2" "LAN2" "$boardname:green:lan2" "switch0" "0x04"
+	ucidef_set_led_switch "lan3" "LAN3" "$boardname:green:lan3" "switch0" "0x08"
+	ucidef_set_led_switch "lan4" "LAN4" "$boardname:green:lan4" "switch0" "0x10"
+	;;
+esac
+
+board_config_flush
+
+exit 0
diff --git a/target/linux/ath79/base-files/etc/board.d/02_network b/target/linux/ath79/base-files/etc/board.d/02_network
new file mode 100755
index 0000000000..e2a45b0526
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/board.d/02_network
@@ -0,0 +1,131 @@
+#!/bin/sh
+
+. /lib/functions/system.sh
+. /lib/functions/uci-defaults.sh
+. /lib/functions/k2t.sh
+
+ath79_setup_interfaces()
+{
+	local board="$1"
+
+	case "$board" in
+	"etactica,eg200")
+		ucidef_set_interface_lan "eth0" "dhcp"
+		;;
+	"avm,fritz300e"|\
+	"tplink,tl-mr10u"|\
+	"tplink,tl-wr703n"|\
+	"ubnt,ubnt-unifiac-lite"|\
+	"ubnt,unifi")
+		ucidef_set_interface_lan "eth0"
+		;;
+
+	"embeddedwireless,dorin")
+		ucidef_add_switch "switch0" \
+			"0@eth0" "1:wan" "2:lan:3" "3:lan:2"
+		;;
+
+	"glinet,ar150")
+		ucidef_set_interfaces_lan_wan "eth1" "eth0"
+		;;
+
+	"glinet,ar300m")
+		ucidef_set_interfaces_lan_wan "eth1" "eth0"
+		;;
+
+	"netgear,wnr612-v2"|\
+	"on,n150r")
+		ucidef_set_interfaces_lan_wan "eth1.1" "eth0"
+		ucidef_add_switch "switch0" \
+		"0@eth1" "1:lan" "2:lan" "3:lan:3" "4:lan:4"
+		;;
+
+	"tplink,tl-archer-c7-v2")
+		ucidef_set_interfaces_lan_wan "eth1.1" "eth0.2"
+		ucidef_add_switch "switch0" \
+			"0@eth1" "2:lan" "3:lan" "4:lan" "5:lan" "6@eth0" "1:wan"
+		;;
+
+	"tplink,tl-mr3020-v1")
+		ucidef_set_interface_lan "eth0.1"
+		ucidef_add_switch "switch0" "0@eth0" "1:lan"
+		;;
+	"tplink,tl-wdr3600"|\
+	"tplink,tl-wdr4300")
+		ucidef_add_switch "switch0" \
+			"0@eth0" "2:lan:1" "3:lan:2" "4:lan:3" "5:lan:4" "1:wan"
+		;;
+
+	"tplink,tl-wr740n-v2")
+		ucidef_set_interfaces_lan_wan "eth1.1" "eth0"
+		ucidef_add_switch "switch0" \
+			"0@eth1" "1:lan" "2:lan" "3:lan" "4:lan"
+		;;
+
+	"tplink,tl-wr1043nd-v1")
+		ucidef_add_switch "switch0" \
+			"1:lan" "2:lan" "3:lan" "4:lan" "0:wan" "5@eth0"
+		;;
+	"tplink,tl-wr1043nd-v4")
+		ucidef_add_switch "switch0" \
+			"0@eth0" "1:lan:4" "2:lan:3" "3:lan:2" "4:lan:1" "5:wan"
+		;;
+	"tplink,tl-wr1043nd-v2"|\
+	"tplink,tl-wr1043nd-v3")
+		ucidef_set_interfaces_lan_wan "eth1.1" "eth0.2"
+		ucidef_add_switch "switch0" \
+			"0@eth1" "1:lan:4" "2:lan:3" "3:lan:2" "4:lan:1" "5:wan" "6@eth0"
+		;;
+	"tplink,tl-wr2543-v1")
+		ucidef_add_switch "switch0" \
+			"1:lan" "2:lan" "3:lan" "4:lan" "0:wan" "9@eth0"
+		;;
+	"netgear,wndr3800")
+		ucidef_set_interfaces_lan_wan "eth0" "eth1"
+		ucidef_add_switch "switch0" \
+			"0:lan:4" "1:lan:3" "2:lan:2" "3:lan:1" "5u@eth0"
+
+		ucidef_add_switch_attr "switch0" "blinkrate" 2
+		ucidef_add_switch_port_attr "switch0" 1 led 6
+		ucidef_add_switch_port_attr "switch0" 2 led 9
+		ucidef_add_switch_port_attr "switch0" 5 led 2
+		;;
+	"buffalo,wzr-hp-g450h")
+		ucidef_add_switch "switch0" \
+			"0@eth0" "2:lan" "3:lan" "4:lan" "5:lan" "1:wan"
+		;;
+	"phicomm,k2t")
+		ucidef_add_switch "switch0" \
+			"0@eth0" "3:lan:1" "5:lan:2" "4:wan"
+		;;
+	*)
+		ucidef_set_interfaces_lan_wan "eth0" "eth1"
+		;;
+	esac
+}
+
+ath79_setup_macs()
+{
+	local board="$1"
+
+	case "$board" in
+	avm,fritz300e)
+		lan_mac=$(fritz_tffs -n maca -i $(find_mtd_part "tffs (1)"))
+		;;
+	phicomm,k2t)
+		lan_mac=$(k2t_get_mac "lan_mac")
+		wan_mac=$(k2t_get_mac "wan_mac")
+		;;
+	esac
+
+	[ -n "$lan_mac" ] && ucidef_set_interface_macaddr "lan" $lan_mac
+	[ -n "$wan_mac" ] && ucidef_set_interface_macaddr "wan" $wan_mac
+}
+
+board_config_update
+board=$(board_name)
+ath79_setup_interfaces $board
+ath79_setup_macs $board
+board_config_flush
+
+exit 0
diff --git a/target/linux/ath79/base-files/etc/diag.sh b/target/linux/ath79/base-files/etc/diag.sh
new file mode 100644
index 0000000000..5a21006528
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/diag.sh
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+. /lib/functions/leds.sh
+
+status_led="$(get_dt_led status)"
+
+set_state() {
+	case "$1" in
+	preinit)
+		status_led_blink_preinit
+		;;
+	failsafe)
+		status_led_blink_failsafe
+		;;
+	preinit_regular)
+		status_led_blink_preinit_regular
+		;;
+	done)
+		status_led_on
+		;;
+	esac
+}
diff --git a/target/linux/ath79/base-files/etc/hotplug.d/firmware/10-ath9k-eeprom b/target/linux/ath79/base-files/etc/hotplug.d/firmware/10-ath9k-eeprom
new file mode 100644
index 0000000000..7023fa5e58
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/hotplug.d/firmware/10-ath9k-eeprom
@@ -0,0 +1,69 @@
+#!/bin/sh
+
+[ -e /lib/firmware/$FIRMWARE ] && exit 0
+
+. /lib/functions.sh
+. /lib/functions/system.sh
+
+ath9k_eeprom_die() {
+	echo "ath9k eeprom: " "$*"
+	exit 1
+}
+
+ath9k_eeprom_extract() {
+	local part=$1
+	local offset=$2
+	local count=$3
+	local mtd
+
+	mtd=$(find_mtd_chardev $part)
+	[ -n "$mtd" ] || \
+		ath9k_eeprom_die "no mtd device found for partition $part"
+
+	dd if=$mtd of=/lib/firmware/$FIRMWARE bs=1 skip=$offset count=$count 2>/dev/null || \
+		ath9k_eeprom_die "failed to extract from $mtd"
+}
+
+ath9k_eeprom_extract_reverse() {
+	local part=$1
+	local offset=$2
+	local count=$3
+	local mtd
+	local reversed
+	local caldata
+
+	mtd=$(find_mtd_chardev "$part")
+	reversed=$(hexdump -v -s $offset -n $count -e '/1 "%02x "' $mtd)
+
+	for byte in $reversed; do
+		caldata="\x${byte}${caldata}"
+	done
+
+	printf "%b" "$caldata" > /lib/firmware/$FIRMWARE
+}
+
+board=$(board_name)
+
+case "$FIRMWARE" in
+"ath9k-eeprom-pci-0000:00:00.0.bin")
+	case $board in
+	"avm,fritz300e")
+		ath9k_eeprom_extract_reverse "urloader" 5441 1088
+		;;
+	"tplink,tl-wdr3600"|\
+	"tplink,tl-wdr4300")
+		ath9k_eeprom_extract "art" 20480 1088
+		;;
+	"netgear,wnr612-v2"|\
+	"on,n150r"|\
+	"tplink,tl-wr740n-v2"|\
+	"tplink,tl-wr2543-v1"|\
+	"ubnt,unifi")
+		ath9k_eeprom_extract "art" 4096 2048
+		;;
+	*)
+		ath9k_eeprom_die "board $board is not supported yet"
+		;;
+	esac
+	;;
+esac
diff --git a/target/linux/ath79/base-files/etc/hotplug.d/firmware/11-ath10k-caldata b/target/linux/ath79/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
new file mode 100644
index 0000000000..20df5a220f
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
@@ -0,0 +1,117 @@
+#!/bin/sh
+
+. /lib/functions/k2t.sh
+
+# xor multiple hex values of the same length
+xor() {
+	local val
+	local ret="0x$1"
+	local retlen=${#1}
+
+	shift
+	while [ -n "$1" ]; do
+		val="0x$1"
+		ret=$((ret ^ val))
+		shift
+	done
+
+	printf "%0${retlen}x" "$ret"
+}
+
+ath10kcal_die() {
+	echo "ath10cal: " "$*"
+	exit 1
+}
+
+ath10kcal_from_file() {
+	local source=$1
+	local offset=$2
+	local count=$3
+
+	dd if=$source of=/lib/firmware/$FIRMWARE bs=1 skip=$offset count=$count 2>/dev/null || \
+		ath10kcal_die "failed to extract calibration data from $source"
+}
+
+ath10kcal_extract() {
+	local part=$1
+	local offset=$2
+	local count=$3
+	local mtd
+
+	mtd=$(find_mtd_chardev $part)
+	[ -n "$mtd" ] || \
+		ath10kcal_die "no mtd device found for partition $part"
+
+	dd if=$mtd of=/lib/firmware/$FIRMWARE bs=1 skip=$offset count=$count 2>/dev/null || \
+		ath10kcal_die "failed to extract calibration data from $mtd"
+}
+
+ath10kcal_patch_mac() {
+	local mac=$1
+
+	[ -z "$mac" ] && return
+
+	macaddr_2bin $mac | dd of=/lib/firmware/$FIRMWARE conv=notrunc bs=1 seek=6 count=6
+}
+
+ath10kcal_patch_mac_crc() {
+	local mac=$1
+	local mac_offset=6
+	local chksum_offset=2
+	local xor_mac
+	local xor_fw_mac
+	local xor_fw_chksum
+
+	xor_fw_mac=$(hexdump -v -n 6 -s $mac_offset -e '/1 "%02x"' /lib/firmware/$FIRMWARE)
+	xor_fw_mac="${xor_fw_mac:0:4} ${xor_fw_mac:4:4} ${xor_fw_mac:8:4}"
+
+	ath10kcal_patch_mac "$mac" && {
+		xor_mac=${mac//:/}
+		xor_mac="${xor_mac:0:4} ${xor_mac:4:4} ${xor_mac:8:4}"
+
+		xor_fw_chksum=$(hexdump -v -n 2 -s $chksum_offset -e '/1 "%02x"' /lib/firmware/$FIRMWARE)
+		xor_fw_chksum=$(xor $xor_fw_chksum $xor_fw_mac $xor_mac)
+
+		printf "%b" "\x${xor_fw_chksum:0:2}\x${xor_fw_chksum:2:2}" | \
+			dd of=/lib/firmware/$FIRMWARE conv=notrunc bs=1 seek=$chksum_offset count=2
+	}
+}
+
+[ -e /lib/firmware/$FIRMWARE ] && exit 0
+
+. /lib/functions.sh
+. /lib/functions/system.sh
+
+board=$(board_name)
+
+case "$FIRMWARE" in
+"ath10k/cal-pci-0000:00:00.0.bin")
+	case $board in
+	"openmesh,om5p-ac-v2")
+		ath10kcal_extract "ART" 20480 2116
+		ath10kcal_patch_mac $(macaddr_add $(cat /sys/class/net/eth0/address) +16)
+		;;
+	"tplink,tl-archer-c7-v2")
+		ath10kcal_extract "art" 20480 2116
+		ath10kcal_patch_mac $(macaddr_add $(cat /sys/class/net/eth1/address) -2)
+		;;
+	"ubnt,ubnt-unifiac-lite")
+		ath10kcal_extract "EEPROM" 20480 2116
+		;;
+	esac
+	;;
+"ath10k/pre-cal-pci-0000:00:00.0.bin")
+	case $board in
+	phicomm,k2t)
+		ath10kcal_extract "art" 20480 12064
+		ath10kcal_patch_mac_crc $(k2t_get_mac "5g_mac")
+
+		ln -sf /lib/firmware/ath10k/pre-cal-pci-0000\:00\:00.0.bin \
+			/lib/firmware/ath10k/QCA9888/hw2.0/board.bin
+		;;
+	esac
+	;;
+*)
+	exit 1
+	;;
+esac
diff --git a/target/linux/ath79/base-files/etc/hotplug.d/ieee80211/10_fix_wifi_mac b/target/linux/ath79/base-files/etc/hotplug.d/ieee80211/10_fix_wifi_mac
new file mode 100644
index 0000000000..59c58f9c67
--- /dev/null
+++ b/target/linux/ath79/base-files/etc/hotplug.d/ieee80211/10_fix_wifi_mac
@@ -0,0 +1,24 @@
+#!/bin/ash
+
+[ "$ACTION" == "add" ] || exit 0
+
+PHYNBR=${DEVPATH##*/phy}
+
+[ -n $PHYNBR ] || exit 0
+
+. /lib/functions.sh
+. /lib/functions/system.sh
+. /lib/functions/k2t.sh
+
+board=$(board_name)
+
+case "$board" in
+	phicomm,k2t)
+		# The K2T factory firmware does use LAN mac address as the 2.4G wifi mac address
+		[ "$PHYNBR" -eq 1 ] && \
+			echo $(k2t_get_mac "lan_mac") > /sys${DEVPATH}/macaddress
+		;;
+	*)
+		;;
+esac
+
diff --git a/target/linux/ath79/base-files/lib/functions/k2t.sh b/target/linux/ath79/base-files/lib/functions/k2t.sh
new file mode 100755
index 0000000000..1158df818b
--- /dev/null
+++ b/target/linux/ath79/base-files/lib/functions/k2t.sh
@@ -0,0 +1,55 @@
+#!/bin/sh
+#
+# Copyright (C) 2018 Weijie Gao <hackpascal@gmail.com>
+#
+# Helper function to extract mac addresses from mtd part for Phicomm K2T
+#
+
+. /lib/functions.sh
+. /lib/functions/system.sh
+. /usr/share/libubox/jshn.sh
+
+k2t_config_load() {
+	local mtd_blk=$(find_mtd_part config)
+
+	if [ -z "$mtd_blk" ]; then
+		echo "k2t_config_load: no mtd part named config" >&2
+		exit 1
+	fi
+
+	local json_size=$(dd if=$mtd_blk bs=1 count=8 2>/dev/null)
+
+	json_size="0x$json_size"
+	json_size=$((json_size))
+
+	if [ "$?" -ne 0 ]; then
+		echo "k2t_config_load: invalid json data size" >&2
+		exit 2
+	fi
+
+	if [ "$json_size" -eq 0 ]; then
+		echo "k2t_config_load: empty json data" >&2
+		exit 3
+	fi
+
+	local json_data=$(dd if=$mtd_blk bs=1 skip=8 count=$json_size 2>/dev/null)
+
+	json_load "$json_data"
+}
+
+k2t_get_mac() {
+	local old_ns
+
+	json_set_namespace "k2t" old_ns
+
+	if k2t_config_load; then
+		json_select "this_dev_info"
+		json_get_var val "$1"
+		json_select ..
+	fi
+
+	json_set_namespace old_ns
+
+	echo $val
+}
+
diff --git a/target/linux/ath79/base-files/lib/upgrade/platform.sh b/target/linux/ath79/base-files/lib/upgrade/platform.sh
new file mode 100644
index 0000000000..dfcf70487b
--- /dev/null
+++ b/target/linux/ath79/base-files/lib/upgrade/platform.sh
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2011 OpenWrt.org
+#
+
+PART_NAME=firmware
+REQUIRE_IMAGE_METADATA=1
+
+platform_check_image() {
+	return 0
+}
+
+platform_do_upgrade() {
+	local board=$(board_name)
+
+	case "$board" in
+	*)
+		default_do_upgrade "$ARGV"
+		;;
+	esac
+}
diff --git a/target/linux/ath79/config-4.14 b/target/linux/ath79/config-4.14
new file mode 100644
index 0000000000..01d259572a
--- /dev/null
+++ b/target/linux/ath79/config-4.14
@@ -0,0 +1,240 @@
+CONFIG_AG71XX=y
+# CONFIG_AG71XX_DEBUG is not set
+CONFIG_AG71XX_DEBUG_FS=y
+CONFIG_AR8216_PHY=y
+CONFIG_AR8216_PHY_LEDS=y
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+# CONFIG_ARCH_HAS_GCOV_PROFILE_ALL is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_ARCH_HAS_STRICT_KERNEL_RWX is not set
+# CONFIG_ARCH_HAS_STRICT_MODULE_RWX is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_ARCH_MMAP_RND_BITS_MAX=15
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=15
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX is not set
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_AT803X_PHY=y
+CONFIG_ATH79=y
+CONFIG_ATH79_WDT=y
+CONFIG_CEVT_R4K=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMDLINE="rootfstype=squashfs,jffs2"
+CONFIG_CMDLINE_BOOL=y
+# CONFIG_CMDLINE_OVERRIDE is not set
+CONFIG_COMMON_CLK=y
+# CONFIG_COMMON_CLK_BOSTON is not set
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_CPU_GENERIC_DUMP_TLB=y
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_RIXI=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+CONFIG_CPU_R4K_CACHE_TLB=y
+CONFIG_CPU_R4K_FPU=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_MSA=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CSRC_R4K=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DTC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_ETHERNET_PACKET_MANGLE=y
+CONFIG_FIXED_PHY=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_GPIO_74X164=y
+CONFIG_GPIO_ATH79=y
+CONFIG_GPIO_GENERIC=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_GRO_CELLS is not set
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_HARDWARE_WATCHPOINTS=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_HAVE_CBPF_JIT=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HW_HAS_PCI=y
+CONFIG_HZ_PERIODIC=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IP17XX_PHY=y
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_MIPS_CPU=y
+CONFIG_IRQ_WORK=y
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_RESET is not set
+CONFIG_LIBFDT=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_GPIO=y
+CONFIG_MFD_SYSCON=y
+CONFIG_MICREL_PHY=y
+CONFIG_MIPS=y
+CONFIG_MIPS_ASID_BITS=8
+CONFIG_MIPS_ASID_SHIFT=0
+CONFIG_MIPS_CLOCK_VSYSCALL=y
+# CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND is not set
+# CONFIG_MIPS_CMDLINE_DTB_EXTEND is not set
+# CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_MIPS_CMDLINE_FROM_DTB=y
+# CONFIG_MIPS_ELF_APPENDED_DTB is not set
+# CONFIG_MIPS_HUGE_TLB_SUPPORT is not set
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+# CONFIG_MIPS_MACHINE is not set
+# CONFIG_MIPS_NO_APPENDED_DTB is not set
+CONFIG_MIPS_RAW_APPENDED_DTB=y
+CONFIG_MIPS_SPRAM=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_LZMA_FW=y
+CONFIG_MTD_SPLIT_SEAMA_FW=y
+CONFIG_MTD_SPLIT_TPLINK_FW=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_SPLIT_WRGG_FW=y
+CONFIG_MTD_TPLINK_PARTS=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
+# CONFIG_NO_IOPORT_MAP is not set
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_NET=y
+CONFIG_PCI_DRIVERS_LEGACY=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_PHYLIB=y
+# CONFIG_PHY_AR7100_USB is not set
+# CONFIG_PHY_AR7200_USB is not set
+CONFIG_PINCTRL=y
+CONFIG_RATIONAL=y
+# CONFIG_RCU_NEED_SEGCBLIST is not set
+# CONFIG_RCU_STALL_COMMON is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_RESET_ATH79=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RTL8366RB_PHY=y
+CONFIG_RTL8366S_PHY=y
+CONFIG_RTL8366_SMI=y
+CONFIG_RTL8367_PHY=y
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SERIAL_8250_FSL is not set
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+CONFIG_SERIAL_AR933X=y
+CONFIG_SERIAL_AR933X_CONSOLE=y
+CONFIG_SERIAL_AR933X_NR_UARTS=2
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_ATH79=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_RB4XX is not set
+CONFIG_SRCU=y
+CONFIG_SWCONFIG=y
+CONFIG_SWCONFIG_LEDS=y
+CONFIG_SWPHY=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_EARLY_PRINTK=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_MIPS16=y
+CONFIG_SYS_SUPPORTS_ZBOOT=y
+CONFIG_SYS_SUPPORTS_ZBOOT_UART_PROM=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TINY_SRCU=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USE_OF=y
diff --git a/target/linux/ath79/dts/ar7100.dtsi b/target/linux/ath79/dts/ar7100.dtsi
new file mode 100644
index 0000000000..9957b8df60
--- /dev/null
+++ b/target/linux/ath79/dts/ar7100.dtsi
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,ar7100";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips24Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar7100-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x20>;
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			usb_phy: usb-phy@18030000 {
+				compatible = "qca,ar7100-usb-phy";
+				reg = <0x18030000 0x10>;
+
+				reset-names = "usb-phy", "usb-host", "usb-ohci-dll";
+				resets = <&rst 4>, <&rst 5>, <&rst 6>;
+
+				#phy-cells = <0>;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar7100-gpio";
+				reg = <0x18040000 0x30>;
+				interrupts = <2>;
+
+				ngpios = <16>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar7100-pll", "syscon";
+				reg = <0x18050000 0x20>;
+
+				clock-names = "ref";
+				/* The board must provides the ref clock */
+
+				#clock-cells = <1>;
+				clock-output-names = "cpu", "ddr", "ahb";
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+
+			rst: reset-controller@18060024 {
+				compatible = "qca,ar7100-reset";
+				reg = <0x18060024 0x4>;
+
+				#reset-cells = <1>;
+			};
+
+			pcie0: pcie-controller@180c0000 {
+				compatible = "qca,ar7100-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x17010000 0x100>;
+				reg-names = "cfg_base";
+				ranges = <0x2000000 0 0x10000000 0x10000000 0 0x07000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&cpuintc>;
+				interrupts = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie0 0>;
+				status = "disabled";
+			};
+		};
+	};
+
+	usb2: usb@1b000000 {
+		compatible = "generic-ehci";
+		reg = <0x1b000000 0x1000>;
+
+		interrupt-parent = <&cpuintc>;
+		interrupts = <3>;
+
+		phy-names = "usb-phy";
+		phys = <&usb_phy>;
+
+		has-synopsys-hc-bug;
+
+		status = "disabled";
+	};
+
+	usb1: usb@1c000000 {
+		compatible = "generic-ohci";
+		reg = <0x1c000000 0x1000>;
+
+		interrupt-parent = <&miscintc>;
+		interrupts = <6>;
+
+		phy-names = "usb-phy";
+		phys = <&usb_phy>;
+
+		status = "disabled";
+	};
+
+	spi: spi@1f000000 {
+		compatible = "qca,ar7100-spi";
+		reg = <0x1f000000 0x10>;
+
+		clocks = <&pll ATH79_CLK_AHB>;
+		clock-names = "ahb";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&cpuintc {
+	qca,ddr-wb-channel-interrupts = <2>, <3>, <4>, <5>;
+	qca,ddr-wb-channels = <&ddr_ctrl 3>, <&ddr_ctrl 2>,
+				<&ddr_ctrl 0>, <&ddr_ctrl 1>;
+};
+
+&miscintc {
+	compatible = "qca,ar7100-misc-intc";
+};
+
+&eth0 {
+	compatible = "qca,ar7100-eth";
+	reg = <0x19000000 0x200
+		0x18070000 0x4>;
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+	pll-reg = <0x4 0x10 17>;
+	pll-handle = <&pll>;
+	phy-mode = "rgmii";
+
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "phy", "mac";
+};
+
+&mdio1 {
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar7100-eth";
+	reg = <0x1a000000 0x200
+		0x18070004 0x4>;
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+	pll-reg = <0x4 0x14 19>;
+	pll-handle = <&pll>;
+
+	phy-mode = "rgmii";
+
+	resets = <&rst 12>, <&rst 13>;
+	reset-names = "phy", "mac";
+};
diff --git a/target/linux/ath79/dts/ar7161_netgear_wndr3800.dts b/target/linux/ath79/dts/ar7161_netgear_wndr3800.dts
new file mode 100644
index 0000000000..7a7279bdf5
--- /dev/null
+++ b/target/linux/ath79/dts/ar7161_netgear_wndr3800.dts
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7100.dtsi"
+
+/ {
+	compatible = "netgear,wndr3800", "qca,ar7161";
+	model = "Netgear WNDR3800";
+
+	aliases {
+		led-status = &power_green;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-output-names = "ref";
+		clock-frequency = <40000000>;
+	};
+
+	reset-leds {
+		compatible = "reset-leds";
+
+		usb_led {
+			label = "netgear:green:usb";
+			resets = <&rst 12>;
+			trigger-sources = <&usb_ochi_port>, <&usb_echi_port>;
+			linux,default-trigger = "usbport";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		wps {
+			label = "netgear:orange:wps";
+			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		power_green: power_green {
+			label = "netgear:green:power";
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		power_orange {
+			label = "netgear:orange:power";
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wps_green {
+			label = "netgear:green:wps";
+			gpios = <&gpio 4 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wan_green {
+			label = "netgear:green:wan";
+			gpios = <&gpio 6 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 3 GPIO_ACTIVE_LOW>;
+		};
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 8 GPIO_ACTIVE_LOW>;
+		};
+
+		rfkill {
+			label = "rfkill";
+			linux,code = <KEY_RFKILL>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	rtl8366s {
+		compatible = "realtek,rtl8366s";
+		gpio-sda = <&gpio 5 GPIO_ACTIVE_HIGH>;
+		gpio-sck = <&gpio 7 GPIO_ACTIVE_HIGH>;
+
+		mdio-bus {
+			status = "okay";
+
+			phy-mask = <0x10>;
+
+			phy4: ethernet-phy@4 {
+				reg = <4>;
+				phy-mode = "rgmii";
+			};
+		};
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+
+	usb_ochi_port: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&usb2 {
+	status = "okay";
+
+	usb_echi_port: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&uart {
+	status = "okay";
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "mx25l12805d";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x050000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x050000 0x020000>;
+				read-only;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x070000 0xf80000>;
+			};
+
+			art: partition@3 {
+				label = "art";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	pll-data = <0x11110000 0x00001099 0x00991099>;
+
+	mtd-mac-address = <&art 0x00>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&eth1 {
+	status = "okay";
+
+	pll-data = <0x11110000 0x00001099 0x00991099>;
+
+	mtd-mac-address = <&art 0x06>;
+
+	resets = <&rst 13>;
+	reset-names = "mac";
+
+	phy-handle = <&phy4>;
+};
diff --git a/target/linux/ath79/dts/ar7240.dtsi b/target/linux/ath79/dts/ar7240.dtsi
new file mode 100644
index 0000000000..6805d1a786
--- /dev/null
+++ b/target/linux/ath79/dts/ar7240.dtsi
@@ -0,0 +1,66 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include "ar724x.dtsi"
+
+/ {
+	usb_phy: usb-phy {
+		compatible = "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-ohci-dll";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&ahb {
+	usb: usb@1b000000 {
+		compatible = "generic-ohci";
+		reg = <0x1b000000 0x1000>;
+
+		interrupts = <3>;
+
+		resets = <&rst 5>;
+		reset-names = "usb-host";
+
+		phy-names = "usb-phy";
+		phys = <&usb_phy>;
+
+		status = "disabled";
+	};
+};
+
+&mdio0 {
+	builtin-switch;
+};
+
+&eth0 {
+	compatible = "qca,ar7240-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "phy", "mac";
+};
+
+&mdio1 {
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar7240-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+
+	resets = <&rst 12>, <&rst 13>;
+	reset-names = "phy", "mac";
+
+	phy-mode = "gmii";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
diff --git a/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dts b/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dts
new file mode 100644
index 0000000000..d80406433f
--- /dev/null
+++ b/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar7240_netgear_wnr612-v2.dtsi"
+
+/ {
+	model = "Netgear WNR612 v2";
+	compatible = "netgear,wnr612-v2";
+};
+
diff --git a/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dtsi b/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dtsi
new file mode 100644
index 0000000000..c5ceb6e45f
--- /dev/null
+++ b/target/linux/ath79/dts/ar7240_netgear_wnr612-v2.dtsi
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7240.dtsi"
+
+/ {
+	compatible = "netgear,wnr612-v2", "qca,ar7240";
+	model = "Netgear WNR612 V2";
+
+	aliases {
+		led-status = &led_power;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&ath9k 7 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		led_power: power {
+			label = "netgear:green:power";
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+
+		lan1 {
+			label = "netgear:green:lan1";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+		};
+
+		lan2 {
+			label = "netgear:green:lan2";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+		};
+
+		wan {
+			label = "netgear:green:wan";
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+		};
+
+		wlan: wlan {
+			label = "netgear:green:wlan";
+			gpios = <&ath9k 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				reg = <0x0 0x40000>;
+				label = "u-boot";
+				read-only;
+			};
+
+			partition@40000 {
+				reg = <0x40000 0x10000>;
+				label = "u-boot-env";
+			};
+
+			partition@50000 {
+				reg = <0x50000 0x3a0000>;
+				label = "firmware";
+			};
+
+			partition@3f0000 {
+				reg = <0x3f0000 0x10000>;
+				label = "art";
+				read-only;
+			};
+		};
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-handle = <&phy4>;
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <(-1)>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <1>;
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k: wifi@168c,002b {
+		compatible = "pci168c,002b";
+		reg = <0x0000 0 0 0 0>;
+		qca,no-eeprom;
+		#gpio-cells = <2>;
+		gpio-controller;
+	};
+};
+
+&uart {
+	status = "okay";
+};
diff --git a/target/linux/ath79/dts/ar7240_on_n150r.dts b/target/linux/ath79/dts/ar7240_on_n150r.dts
new file mode 100644
index 0000000000..cb4cf92865
--- /dev/null
+++ b/target/linux/ath79/dts/ar7240_on_n150r.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar7240_netgear_wnr612-v2.dtsi"
+
+/ {
+	model = "ON Network N150R";
+	compatible = "on,n150r";
+};
+
diff --git a/target/linux/ath79/dts/ar7240_tl-wr740n-v2.dts b/target/linux/ath79/dts/ar7240_tl-wr740n-v2.dts
new file mode 100644
index 0000000000..f86cb50d47
--- /dev/null
+++ b/target/linux/ath79/dts/ar7240_tl-wr740n-v2.dts
@@ -0,0 +1,174 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7240.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr740n-v2", "qca,ar7240";
+	model = "TP-Link TL-WR740N v2";
+
+	aliases {
+		led-status = &led_system;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&switch_led_pins>;
+
+		led_system: system {
+			label = "tl-wr740n-v2:green:system";
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+		};
+
+		lan1 {
+			label = "tl-wr740n-v2:green:lan1";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+		};
+
+		lan2 {
+			label = "tl-wr740n-v2:green:lan2";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+		};
+
+		lan3 {
+			label = "tl-wr740n-v2:green:lan3";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+		};
+
+		lan4 {
+			label = "tl-wr740n-v2:green:lan4";
+			gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+		};
+
+		wan {
+			label = "tl-wr740n-v2:green:wan";
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+		};
+
+		wlan {
+			label = "tl-wr740n-v2:green:wlan";
+			gpios = <&ath9k 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		wps {
+			label = "tl-wr740n-v2:green:wps";
+			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				reg = <0x0 0x20000>;
+				label = "u-boot";
+				read-only;
+			};
+
+			firmware: partition@20000 {
+				reg = <0x20000 0x3d0000>;
+				label = "firmware";
+			};
+
+			art: partition@3f0000 {
+				reg = <0x3f0000 0x10000>;
+				label = "art";
+				read-only;
+			};
+		};
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-handle = <&phy4>;
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <(-1)>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <1>;
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k: wifi@168c,002b {
+		compatible = "pci168c,002b";
+		reg = <0x0000 0 0 0 0>;
+		qca,no-eeprom;
+		mtd-mac-address = <&uboot 0x1fc00>;
+		#gpio-cells = <2>;
+		gpio-controller;
+	};
+};
+
+&pinmux {
+	switch_led_pins: pinmux_switch_led_pins {
+		pinctrl-single,bits = <0x0 0x0 0xf8>;
+	};
+};
+
+&uart {
+	status = "okay";
+};
diff --git a/target/linux/ath79/dts/ar7241.dtsi b/target/linux/ath79/dts/ar7241.dtsi
new file mode 100644
index 0000000000..91ebea54e0
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241.dtsi
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include "ar724x.dtsi"
+
+/ {
+	usb_phy: usb-phy {
+		compatible = "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&gpio {
+	ngpios = <20>;
+};
+
+&ahb {
+	usb: usb@1b000000 {
+		compatible = "generic-ehci";
+		reg = <0x1b000000 0x1000>;
+
+		interrupts = <3>;
+
+		resets = <&rst 5>;
+		reset-names = "usb-host";
+
+		has-transaction-translator;
+		caps-offset = <0x100>;
+
+		phy-names = "usb-phy";
+		phys = <&usb_phy>;
+
+		status = "disabled";
+	};
+};
+
+&mdio0 {
+	regmap = <&eth1>;
+	builtin-switch;
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,ar7241-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "mac", "phy";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar7241-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+
+	resets = <&rst 12>, <&rst 13>;
+	reset-names = "mac", "phy";
+
+	phy-mode = "gmii";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
diff --git a/target/linux/ath79/dts/ar7241_ubnt_bullet-m.dts b/target/linux/ath79/dts/ar7241_ubnt_bullet-m.dts
new file mode 100644
index 0000000000..0de97ea933
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241_ubnt_bullet-m.dts
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar7241_ubnt_xm.dtsi"
+
+/ {
+	compatible = "ubnt,bullet-m", "qca,ar7241";
+	model = "Ubiquiti Bullet M";
+};
+
+&eth1 {
+	compatible = "syscon";
+};
diff --git a/target/linux/ath79/dts/ar7241_ubnt_nano-m.dts b/target/linux/ath79/dts/ar7241_ubnt_nano-m.dts
new file mode 100644
index 0000000000..417e503127
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241_ubnt_nano-m.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar7241_ubnt_xm.dtsi"
+
+/ {
+	compatible = "ubnt,nano-m", "qca,ar7241";
+	model = "Ubiquiti Nanostation M";
+};
diff --git a/target/linux/ath79/dts/ar7241_ubnt_rocket-m.dts b/target/linux/ath79/dts/ar7241_ubnt_rocket-m.dts
new file mode 100644
index 0000000000..36fa2750a7
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241_ubnt_rocket-m.dts
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar7241_ubnt_xm.dtsi"
+
+/ {
+	compatible = "ubnt,rocket-m", "qca,ar7241";
+	model = "Ubiquiti Rocket M";
+};
+
+&eth1 {
+	compatible = "syscon";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
diff --git a/target/linux/ath79/dts/ar7241_ubnt_unifi.dts b/target/linux/ath79/dts/ar7241_ubnt_unifi.dts
new file mode 100644
index 0000000000..923b3df770
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241_ubnt_unifi.dts
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7241.dtsi"
+
+/ {
+	compatible = "ubnt,unifi", "qca,ar7241";
+	model = "Ubiquiti UniFi AP";
+
+	aliases {
+		led-status = &dome_green;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		poll-interval = <20>;
+		reset {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		dome_green: dome-green {
+			label = "ubnt:green:dome";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+		};
+
+		dome-orange {
+			label = "ubnt:orange:dome";
+			gpios = <&gpio 1 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&pll {
+	clocks = <&extosc>;
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "mx25l6405d";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x050000 0x750000>;
+			};
+
+			partition@3 {
+				label = "board_config";
+				reg = <0x7a0000 0x010000>;
+				read-only;
+			};
+
+			partition@4 {
+				label = "cfg";
+				reg = <0x7b0000 0x040000>;
+				read-only;
+			};
+
+			art: partition@5 {
+				label = "art";
+				reg = <0x7f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k@0 {
+		reg = <0x0000 0 0 0 0>;
+		qca,no-eeprom;
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x0>;
+	phy-handle = <&phy4>;
+};
+
+&eth1 {
+	status = "okay";
+
+	compatible = "syscon";
+};
diff --git a/target/linux/ath79/dts/ar7241_ubnt_xm.dtsi b/target/linux/ath79/dts/ar7241_ubnt_xm.dtsi
new file mode 100644
index 0000000000..4c46176f95
--- /dev/null
+++ b/target/linux/ath79/dts/ar7241_ubnt_xm.dtsi
@@ -0,0 +1,152 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7241.dtsi"
+
+/ {
+	compatible = "ubnt,xm", "qca,ar7241";
+	model = "Ubiquiti Networks XM (rev 1.0) board";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+/*	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+	};
+*/
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		poll-interval = <20>;
+		reset {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		link1 {
+			label = "ubnt:red:link1";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+		};
+
+		link2 {
+			label = "ubnt:orange:link2";
+			gpios = <&gpio 1 GPIO_ACTIVE_HIGH>;
+		};
+
+		link3 {
+			label = "ubnt:green:link3";
+			gpios = <&gpio 11 GPIO_ACTIVE_HIGH>;
+		};
+
+		link4 {
+			label = "ubnt:green:link4";
+			gpios = <&gpio 7 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+/*&pll {
+	clocks = <&extosc>;
+};*/
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "mx25l6405d";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x050000 0x750000>;
+			};
+
+			partition@3 {
+				label = "board_config";
+				reg = <0x7a0000 0x010000>;
+				read-only;
+			};
+
+			partition@4 {
+				label = "cfg";
+				reg = <0x7b0000 0x040000>;
+				read-only;
+			};
+
+			art: partition@5 {
+				label = "art";
+				reg = <0x7f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k@0 {
+		reg = <0x0000 0 0 0 0>;
+		qca,no-eeprom;
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x0>;
+
+	phy-mode = "mii";
+	phy-handle = <&phy4>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x6>;
+};
diff --git a/target/linux/ath79/dts/ar7242.dtsi b/target/linux/ath79/dts/ar7242.dtsi
new file mode 100644
index 0000000000..a5909a9b31
--- /dev/null
+++ b/target/linux/ath79/dts/ar7242.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include "ar724x.dtsi"
+
+/ {
+	usb_phy: usb-phy {
+		compatible = "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&gpio {
+	ngpios = <20>;
+};
+
+&ahb {
+	usb: usb@1b000000 {
+		compatible = "generic-ehci";
+		reg = <0x1b000000 0x1000>;
+
+		interrupts = <3>;
+
+		resets = <&rst 5>;
+		reset-names = "usb-host";
+
+		has-transaction-translator;
+		caps-offset = <0x100>;
+
+		phy-names = "usb-phy";
+		phys = <&usb_phy>;
+
+		status = "disabled";
+	};
+};
+
+&mdio0 {
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,ar7242-eth", "syscon";
+
+	pll-data = <0x16000000 0x00000101 0x00001616>;
+	pll-reg = <0x4 0x2c 17>;
+	pll-handle = <&pll>;
+
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "mac", "phy";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar7242-eth", "syscon";
+
+	resets = <&rst 12>, <&rst 13>;
+	reset-names = "mac", "phy";
+};
diff --git a/target/linux/ath79/dts/ar7242_avm_fritz300e.dts b/target/linux/ath79/dts/ar7242_avm_fritz300e.dts
new file mode 100644
index 0000000000..07c1f637cb
--- /dev/null
+++ b/target/linux/ath79/dts/ar7242_avm_fritz300e.dts
@@ -0,0 +1,174 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7242.dtsi"
+
+/ {
+	compatible = "avm,fritz300e", "qca,ar7242";
+	model = "AVM FRITZ!WLAN Repeater 300E";
+
+	aliases {
+		led-status = &power;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		power: power {
+			label = "fritz300e:green:power";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+
+		lan {
+			label = "fritz300e:green:lan";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+		};
+
+		wlan {
+			label = "fritz300e:green:wlan";
+			gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+
+	ath9k-leds {
+		compatible = "gpio-leds";
+
+		rssi0 {
+			label = "fritz300e:green:rssi0";
+			gpios = <&ath9k 10 GPIO_ACTIVE_LOW>;
+		};
+
+		rssi1 {
+			label = "fritz300e:green:rssi1";
+			gpios = <&ath9k 4 GPIO_ACTIVE_LOW>;
+		};
+
+		rssi2 {
+			label = "fritz300e:green:rssi2";
+			gpios = <&ath9k 6 GPIO_ACTIVE_LOW>;
+		};
+
+		rssi3 {
+			label = "fritz300e:green:rssi3";
+			gpios = <&ath9k 7 GPIO_ACTIVE_LOW>;
+		};
+
+		rssi4 {
+			label = "fritz300e:green:rssi4";
+			gpios = <&ath9k 5 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	eth-phy-reset {
+		compatible = "regulator-fixed";
+
+		regulator-name = "eth-phy-reset";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&gpio 11 GPIO_ACTIVE_LOW>;
+		startup-delay-us = <300000>;
+		enable-active-high;
+
+		regulator-always-on;
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				reg = <0x0 0x20000>;
+				label = "urloader";
+				read-only;
+			};
+
+			partition@20000 {
+				reg = <0x20000 0xee0000>;
+				label = "firmware";
+			};
+
+			partition@f00000 {
+				reg = <0xf00000 0x80000>;
+				label = "tffs (1)";
+				read-only;
+			};
+
+			partition@f80000 {
+				reg = <0xf80000 0x80000>;
+				label = "tffs (2)";
+				read-only;
+			};
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k: wifi@0 {
+		reg = <0x0000 0 0 0 0>;
+		#gpio-cells = <2>;
+		gpio-controller;
+		qca,no-eeprom;
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		phy-mode = "rgmii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-mode = "rgmii";
+	phy-handle = <&phy0>;
+
+	pll-data = <0x16000000 0x00000101 0x00001313>;
+};
diff --git a/target/linux/ath79/dts/ar7242_buffalo_wzr-hp-g450h.dts b/target/linux/ath79/dts/ar7242_buffalo_wzr-hp-g450h.dts
new file mode 100644
index 0000000000..4d7a545665
--- /dev/null
+++ b/target/linux/ath79/dts/ar7242_buffalo_wzr-hp-g450h.dts
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7242.dtsi"
+
+/ {
+	compatible = "buffalo,wzr-hp-g450h", "qca,ar7242";
+	model = "Buffalo WZR-HP-G450H";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		poll-interval = <20>;
+		usb {
+			linux,code = <BTN_2>;
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		reset {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 6 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		movie_engine {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 7 GPIO_ACTIVE_HIGH>;
+			debounce-interval = <60>;
+		};
+
+		aoss {
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 8 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		router_off {
+			linux,code = <BTN_5>;
+			gpios = <&gpio 12 GPIO_ACTIVE_HIGH>;
+			debounce-interval = <60>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		security {
+			label = "buffalo:orange:security";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+		};
+
+		diag {
+			label = "buffalo:red:diag";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_usb_power {
+			gpio-export,name = "wzr-hp-g450h:usb-power";
+			gpio-export,output = <1>;
+			gpios = <&gpio 16 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+	phy-mask = <0x1>;
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		phy-mode = "rgmii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-mode = "rgmii";
+	pll-data = <0x62000000 0 0>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k@0 {
+		reg = <0x0000 0 0 0 0>;
+		qca,no-eeprom;
+	};
+};
diff --git a/target/linux/ath79/dts/ar7242_tl-wr2543-v1.dts b/target/linux/ath79/dts/ar7242_tl-wr2543-v1.dts
new file mode 100644
index 0000000000..0934fe0089
--- /dev/null
+++ b/target/linux/ath79/dts/ar7242_tl-wr2543-v1.dts
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar7242.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr2543-v1", "qca,ar7242";
+	model = "TP-LINK TL-WR2543N/ND";
+
+	aliases {
+		led-status = &system;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system: wps {
+			label = "tplink:green:wps";
+			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		usb {
+			label = "tplink:green:usb";
+			gpios = <&gpio 8 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port>;
+			linux,default-trigger = "usbport";
+		};
+	};
+
+	ath9k-leds {
+		compatible = "gpio-leds";
+
+		wlan2g {
+			label = "tplink:green:wlan2g";
+			gpios = <&ath9k 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		wlan5g {
+			label = "tplink:green:wlan5g";
+			gpios = <&ath9k 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+	};
+
+	rtl8367 {
+		compatible = "realtek,rtl8367";
+		gpio-sda = <&gpio 1 GPIO_ACTIVE_HIGH>;
+		gpio-sck = <&gpio 6 GPIO_ACTIVE_HIGH>;
+		realtek,extif0 = <1 0 1 1 1 1 1 1 2>;
+
+		mdio-bus {
+			status = "okay";
+
+			phy0: ethernet-phy@0 {
+				reg = <0>;
+			};
+		};
+	};
+};
+
+&pll {
+	clocks = <&extosc>;
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot:	partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0x7d0000>;
+			};
+
+			partition@7f0000 {
+				label = "art";
+				reg = <0x7f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+
+	hub_port: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k: wifi@0 {
+		reg = <0x0000 0 0 0 0>;
+		#gpio-cells = <2>;
+		gpio-controller;
+		qca,no-eeprom;
+		mtd-mac-address = <&uboot 0x1fc00>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-mode = "rgmii";
+	mtd-mac-address = <&uboot 0x1fc00>;
+
+	phy-handle = <&phy0>;
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
diff --git a/target/linux/ath79/dts/ar724x.dtsi b/target/linux/ath79/dts/ar724x.dtsi
new file mode 100644
index 0000000000..b2844bf179
--- /dev/null
+++ b/target/linux/ath79/dts/ar724x.dtsi
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,ar7240";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips24Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	ahb: ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar9132-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x20>;
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar7240-gpio",
+						"qca,ar7100-gpio";
+				reg = <0x18040000 0x30>;
+				interrupts = <2>;
+
+				ngpios = <18>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pinmux: pinmux@18040028 {
+				compatible = "pinctrl-single";
+
+				reg = <0x18040028 0x8>;
+
+				pinctrl-single,bit-per-mux;
+				pinctrl-single,register-width = <32>;
+				pinctrl-single,function-mask = <0x1>;
+				#pinctrl-cells = <2>;
+
+				jtag_disable_pins: pinmux_jtag_disable_pins {
+				pinctrl-single,bits = <0x0 0x1 0x1>;
+				};
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar7240-pll", "syscon";
+				reg = <0x18050000 0x3c>;
+
+				clock-names = "ref";
+				/* The board must provides the ref clock */
+
+				#clock-cells = <1>;
+				clock-output-names = "cpu", "ddr", "ahb";
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,ar7240-reset",
+						"qca,ar7100-reset";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+			};
+
+			pcie: pcie-controller@180c0000 {
+				compatible = "qcom,ar7240-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x180c0000 0x1000>, /* CRP */
+				      <0x180f0000 0x100>,  /* CTRL */
+				      <0x14000000 0x1000>; /* CFG */
+				reg-names = "crp_base", "ctrl_base", "cfg_base";
+				ranges = <0x2000000 0 0x10000000 0x10000000 0 0x04000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&cpuintc>;
+				interrupts = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie 0>;
+				status = "disabled";
+			};
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar7240-spi",
+					"qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+};
+
+&cpuintc {
+	qca,ddr-wb-channel-interrupts = <2>, <3>, <4>, <5>;
+	qca,ddr-wb-channels = <&ddr_ctrl 3>, <&ddr_ctrl 2>,
+				<&ddr_ctrl 0>, <&ddr_ctrl 1>;
+};
diff --git a/target/linux/ath79/dts/ar9132.dtsi b/target/linux/ath79/dts/ar9132.dtsi
new file mode 100644
index 0000000000..d079811fe6
--- /dev/null
+++ b/target/linux/ath79/dts/ar9132.dtsi
@@ -0,0 +1,196 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,ar9132";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips24Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	cpuintc: interrupt-controller {
+		compatible = "qca,ar9132-cpu-intc", "qca,ar7100-cpu-intc";
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		qca,ddr-wb-channel-interrupts = <2>, <3>, <4>, <5>;
+		qca,ddr-wb-channels = <&ddr_ctrl 3>, <&ddr_ctrl 2>,
+					<&ddr_ctrl 0>, <&ddr_ctrl 1>;
+	};
+
+	ahb {
+		compatible = "simple-bus";
+		ranges;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		interrupt-parent = <&cpuintc>;
+
+		apb {
+			compatible = "simple-bus";
+			ranges;
+
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			interrupt-parent = <&miscintc>;
+
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar9132-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns8250";
+				reg = <0x18020000 0x20>;
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar9132-gpio",
+						"qca,ar7100-gpio";
+				reg = <0x18040000 0x30>;
+				interrupts = <2>;
+
+				ngpios = <22>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar9132-pll",
+						"qca,ar9130-pll";
+				reg = <0x18050000 0x20>;
+
+				clock-names = "ref";
+				/* The board must provides the ref clock */
+
+				#clock-cells = <1>;
+				clock-output-names = "cpu", "ddr", "ahb";
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			miscintc: interrupt-controller@18060010 {
+				compatible = "qca,ar9132-misc-intc",
+					   "qca,ar7100-misc-intc";
+				reg = <0x18060010 0x8>;
+
+				interrupt-parent = <&cpuintc>;
+				interrupts = <6>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,ar9132-reset",
+						"qca,ar7100-reset";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+			};
+		};
+
+		usb: usb@1b000100 {
+			compatible = "qca,ar7100-ehci", "generic-ehci";
+			reg = <0x1b000100 0x100>;
+
+			interrupts = <3>;
+			resets = <&rst 5>;
+
+			has-transaction-translator;
+
+			phy-names = "usb";
+			phys = <&usb_phy>;
+
+			status = "disabled";
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar9132-spi", "qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		wmac: wmac@180c0000 {
+			compatible = "qca,ar9130-wmac";
+			reg = <0x180c0000 0x230000>;
+
+			interrupts = <2>;
+
+			status = "disabled";
+		};
+	};
+
+	usb_phy: usb-phy {
+		compatible = "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&eth0 {
+	compatible = "qca,ar9130-eth", "syscon";
+	reg = <0x19000000 0x200
+		0x18070000 0x4>;
+	pll-data = <0x1a000000 0x13000a44 0x00441099>;
+	pll-reg = <0x4 0x10 17>;
+	pll-handle = <&pll>;
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "phy", "mac";
+};
diff --git a/target/linux/ath79/dts/ar9132_tl-wr1043nd-v1.dts b/target/linux/ath79/dts/ar9132_tl-wr1043nd-v1.dts
new file mode 100644
index 0000000000..8d4cc7f4a6
--- /dev/null
+++ b/target/linux/ath79/dts/ar9132_tl-wr1043nd-v1.dts
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9132.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr1043nd-v1", "qca,ar9132";
+	model = "TP-Link TL-WR1043ND Version 1";
+
+	aliases {
+		led-status = &system;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		button0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 3 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		button1 {
+			label = "qss";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 7 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		usb {
+			label = "tp-link:green:usb";
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port>;
+			linux,default-trigger = "usbport";
+		};
+
+		system: system {
+			label = "tp-link:green:system";
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+		};
+
+		qss {
+			label = "tp-link:green:qss";
+			gpios = <&gpio 5 GPIO_ACTIVE_HIGH>;
+		};
+
+		wlan {
+			label = "tp-link:green:wlan";
+			gpios = <&gpio 9 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+
+	rtl8366rb {
+		compatible = "realtek,rtl8366rb";
+		gpio-sda = <&gpio 18 GPIO_ACTIVE_HIGH>;
+		gpio-sck = <&gpio 19 GPIO_ACTIVE_HIGH>;
+
+		resets = <&rst 8>;
+		reset-names = "switch";
+
+		mdio-bus {
+			status = "okay";
+
+			phy0: ethernet-phy@0 {
+				reg = <0>;
+			};
+		};
+        };
+
+};
+
+&uart {
+	status = "okay";
+};
+
+&pll {
+	clocks = <&extosc>;
+};
+
+&usb {
+	status = "okay";
+
+	hub_port: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0x7D0000>;
+			};
+
+			art: partition@7F0000 {
+				label = "art";
+				reg = <0x7F0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-mode = "rgmii";
+	mtd-mac-address = <&uboot 0x1fc00>;
+
+	resets = <&rst 9>;
+	reset-names = "mac";
+
+	phy-handle = <&phy0>;
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+};
diff --git a/target/linux/ath79/dts/ar9330.dtsi b/target/linux/ath79/dts/ar9330.dtsi
new file mode 100644
index 0000000000..3d3dd87f9b
--- /dev/null
+++ b/target/linux/ath79/dts/ar9330.dtsi
@@ -0,0 +1,169 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,ar9330";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips24Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	chosen {
+		bootargs = "console=ttyATH0,115200";
+	};
+
+	ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "qca,ar9330-uart";
+				reg = <0x18020000 0x14>;
+
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_REF>;
+				clock-names = "uart";
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar7100-gpio";
+				reg = <0x18040000 0x34>;
+				interrupts = <2>;
+
+				ngpios = <30>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+
+				status = "disabled";
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar9330-pll";
+				reg = <0x18050000 0x100>;
+
+				#clock-cells = <1>;
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,ar7100-reset";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+			};
+		};
+
+		usb: usb@1b000000 {
+			compatible = "chipidea,usb2";
+			reg = <0x1b000000 0x200>;
+
+			interrupts = <3>;
+			resets = <&rst 5>;
+			reset-names = "usb-host";
+
+			phy-names = "usb-phy";
+			phys = <&usb_phy>;
+
+			status = "disabled";
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			status = "disabled";
+		};
+
+		gmac: gmac@18070000 {
+			compatible = "qca,ar9330-gmac";
+			reg = <0x18070000 0x4>;
+		};
+
+		wmac: wmac@18100000 {
+			compatible = "qca,ar9330-wmac";
+			reg = <0x18100000 0x20000>;
+
+			interrupts = <2>;
+
+			status = "disabled";
+		};
+	};
+
+	usb_phy: usb-phy {
+		compatible = "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&cpuintc {
+	qca,ddr-wb-channel-interrupts = <2>, <3>;
+	qca,ddr-wb-channels = <&ddr_ctrl 3>, <&ddr_ctrl 2>;
+};
+
+&eth0 {
+	compatible = "qca,ar9330-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+
+	resets = <&rst 9>;
+	reset-names = "mac";
+};
+
+&mdio0 {
+	regmap = <&eth1>;
+	builtin-switch;
+	resets = <&rst 23>;
+	reset-names = "mdio";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar9330-eth", "syscon";
+
+	pll-data = <0x00110000 0x00001099 0x00991099>;
+	phy-mode = "gmii";
+
+	resets = <&rst 13>;
+	reset-names = "mac";
+};
diff --git a/target/linux/ath79/dts/ar9330_glinet_ar150.dts b/target/linux/ath79/dts/ar9330_glinet_ar150.dts
new file mode 100644
index 0000000000..721cbe7da5
--- /dev/null
+++ b/target/linux/ath79/dts/ar9330_glinet_ar150.dts
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9330.dtsi"
+
+/ {
+	model = "GL.iNet GL-AR150";
+	compatible = "glinet,ar150", "qca,ar9330";
+
+	aliases {
+		serial0 = &uart;
+		led-status = &wlan;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		wlan: wlan {
+			label = "gl-ar150:orange:wlan";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		lan {
+			label = "gl-ar150:green:lan";
+			gpios = <&gpio 13 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		wan {
+			label = "gl-ar150:green:wan";
+			gpios = <&gpio 15 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		manual {
+			label = "manual";
+			linux,code = <BTN_7>;
+			gpios = <&gpio 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		auto {
+			label = "auto";
+			linux,code = <BTN_8>;
+			gpios = <&gpio 8 GPIO_ACTIVE_HIGH>;
+		};
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+	gpios = <&gpio 6 GPIO_ACTIVE_HIGH>;
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	spiflash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x050000 0xfa0000>;
+			};
+
+			art: partition@3 {
+				label = "ART";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x0>;
+
+	phy-handle = <&phy4>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x0>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+
+	gmac-config {
+		device = <&gmac>;
+
+		switch-phy-addr-swap = <0>;
+		switch-phy-swap = <0>;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&art 0x0>;
+};
diff --git a/target/linux/ath79/dts/ar9331.dtsi b/target/linux/ath79/dts/ar9331.dtsi
new file mode 100644
index 0000000000..5ce755a592
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331.dtsi
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include "ar9330.dtsi"
+
+/ {
+	compatible = "qca,ar9331";
+
+	ref: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+};
diff --git a/target/linux/ath79/dts/ar9331_dpt_module.dts b/target/linux/ath79/dts/ar9331_dpt_module.dts
new file mode 100644
index 0000000000..dc4df6b276
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_dpt_module.dts
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "DPTechnics DPT-Module";
+	compatible = "dptechnics,dpt-module", "qca,ar9331";
+
+	aliases {
+		serial0 = &uart;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system {
+			label = "dpt-module:green:system";
+			gpios = <&gpio 27 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button@0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&ref {
+	clock-frequency = <25000000>;
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	/* Winbond 25Q128FVSG SPI flash */
+	spiflash: w25q128@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+	};
+};
diff --git a/target/linux/ath79/dts/ar9331_dragino_ms14.dts b/target/linux/ath79/dts/ar9331_dragino_ms14.dts
new file mode 100644
index 0000000000..9fb674eb2f
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_dragino_ms14.dts
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "Dragino MS14 (Dragino 2)";
+	compatible = "dragino,ms14", "qca,ar9331";
+
+	aliases {
+		serial0 = &uart;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		wlan {
+			label = "dragino2:red:wlan";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		lan {
+			label = "dragino2:red:lan";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wan {
+			label = "dragino2:red:wan";
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		system {
+			label = "dragino2:red:system";
+			gpios = <&gpio 28 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button@0 {
+			label = "jumpstart";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+
+		button@1 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&ref {
+	clock-frequency = <25000000>;
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	/* Winbond 25Q128BVFG SPI flash */
+	spiflash: w25q128@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+	};
+};
diff --git a/target/linux/ath79/dts/ar9331_embeddedwireless_dorin.dts b/target/linux/ath79/dts/ar9331_embeddedwireless_dorin.dts
new file mode 100644
index 0000000000..19ec733865
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_embeddedwireless_dorin.dts
@@ -0,0 +1,132 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "Embedded Wireless Dorin";
+	compatible = "embeddedwireless,dorin", "qca,ar9331";
+
+	aliases {
+		led-status = &status;
+		serial0 = &uart;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		status: status {
+			label = "dorin:green:status";
+			gpios = <&gpio 21 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 6 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	spiflash {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x050000 0xfa0000>;
+			};
+
+			art: partition@3 {
+				label = "ART";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x1002>;
+	mtd-mac-address-increment = <0x40>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+
+};
+
+&mdio1 {
+	status = "okay";
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&art 0x1002>;
+};
diff --git a/target/linux/ath79/dts/ar9331_etactica-eg200.dts b/target/linux/ath79/dts/ar9331_etactica-eg200.dts
new file mode 100644
index 0000000000..c245fac7c7
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_etactica-eg200.dts
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "eTactica EG200";
+	compatible = "etactica,eg200", "rme-eg200";
+
+        aliases {
+                serial0 = &uart;
+        };
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <50>;
+
+		restore {
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		modbus {
+			label = "eg200:red:modbus";
+			gpios = <&gpio 16 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		etactica {
+			label = "eg200:red:etactica";
+			gpios = <&gpio 15 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		eth0 {
+			label = "eg200:red:eth0";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wlan {
+			label = "eg200:red:wlan";
+			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&mdio0 {
+	status = "okay";
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+	mtd-mac-address = <&art 0x0>;
+	phy-handle = <&phy4>;
+
+	gmac-config {
+		device = <&gmac>;
+		switch-phy-addr-swap = <1>;
+		switch-phy-swap = <1>;
+	};
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot@0 {
+				reg = <0x0 0x40000>;
+				read-only;
+			};
+
+			uboot-env@40000 {
+				reg = <0x40000 0x10000>;
+				read-only;
+			};
+
+			firmware@50000 {
+				reg = <0x50000 0xfa0000>;
+			};
+
+			art: art@ff0000 {
+				reg = <0xff0000 0x10000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&art 0x1002>;
+};
diff --git a/target/linux/ath79/dts/ar9331_omega.dts b/target/linux/ath79/dts/ar9331_omega.dts
new file mode 100644
index 0000000000..32551427ea
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_omega.dts
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "Onion Omega";
+	compatible = "onion,omega", "qca,ar9331";
+
+	aliases {
+		serial0 = &uart;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system {
+			label = "onion:amber:system";
+			gpios = <&gpio 27 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button@0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ref {
+	clock-frequency = <25000000>;
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	/* Winbond 25Q128FVSG SPI flash */
+	spiflash: w25q128@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+	};
+};
diff --git a/target/linux/ath79/dts/ar9331_tl-mr10u.dts b/target/linux/ath79/dts/ar9331_tl-mr10u.dts
new file mode 100644
index 0000000000..d92b5623ba
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_tl-mr10u.dts
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar9331_tl-wr703n_tl-mr10u.dtsi"
+
+/ {
+	model = "TP-Link TL-MR10U";
+	compatible = "tplink,tl-mr10u", "qca,ar9331";
+};
+
+&reg_usb_vbus {
+	gpio = <&gpio 18 GPIO_ACTIVE_HIGH>;
+};
diff --git a/target/linux/ath79/dts/ar9331_tl-mr3020-v1.dts b/target/linux/ath79/dts/ar9331_tl-mr3020-v1.dts
new file mode 100644
index 0000000000..fc8101564d
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_tl-mr3020-v1.dts
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	model = "TP-Link TL-MR3020 V1";
+	compatible = "tplink,tl-mr3020-v1", "qca,ar9331";
+
+	aliases {
+		serial0 = &uart;
+		led-status = &system;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		wlan {
+			label = "tp-link:green:wlan";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		lan {
+			label = "tp-link:green:lan";
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		system: wps {
+			label = "tp-link:green:wps";
+			gpios = <&gpio 26 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		led3g {
+			label = "tp-link:green:3g";
+			gpios = <&gpio 27 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port>;
+			linux,default-trigger = "usbport";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		button0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_HIGH>;
+			debounce-interval = <60>;
+		};
+
+		button1 {
+			label = "sw1";
+			linux,input-type = <EV_SW>;
+			linux,code = <BTN_0>;
+			gpios = <&gpio 18 GPIO_ACTIVE_HIGH>;
+			debounce-interval = <60>;
+		};
+
+		button2 {
+			label = "sw2";
+			linux,input-type = <EV_SW>;
+			linux,code = <BTN_1>;
+			gpios = <&gpio 20 GPIO_ACTIVE_HIGH>;
+			debounce-interval = <60>;
+		};
+	};
+
+	reg_usb_vbus: reg_usb_vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+};
+
+&ref {
+	clock-frequency = <25000000>;
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	status = "okay";
+
+	hub_port: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&spi {
+	num-chipselects = <1>;
+	status = "okay";
+
+	/* Spansion S25FL032PIF SPI flash */
+	spiflash: s25sl032p@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		reg = <0>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot:	partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0x3c0000>;
+			};
+
+			partition@3e0000 {
+				label = "config";
+				reg = <0x3e0000 0x010000>;
+				read-only;
+			};
+
+			art: partition@3f0000 {
+				label = "art";
+				reg = <0x3f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio1 {
+	status = "okay";
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+	};
+};
+
+&eth1 {
+	status = "okay";
+	phy-handle = <&phy4>;
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+
+	gmac-config {
+	        device = <&gmac>;
+
+		switch-phy-addr-swap = <1>;
+		switch-phy-swap = <1>;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+};
diff --git a/target/linux/ath79/dts/ar9331_tl-wr703n.dts b/target/linux/ath79/dts/ar9331_tl-wr703n.dts
new file mode 100644
index 0000000000..da02e48662
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_tl-wr703n.dts
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar9331_tl-wr703n_tl-mr10u.dtsi"
+
+/ {
+	model = "TP-Link TL-WR703N";
+	compatible = "tplink,tl-wr703n", "qca,ar9331";
+};
+
+&reg_usb_vbus {
+	gpio = <&gpio 8 GPIO_ACTIVE_HIGH>;
+};
diff --git a/target/linux/ath79/dts/ar9331_tl-wr703n_tl-mr10u.dtsi b/target/linux/ath79/dts/ar9331_tl-wr703n_tl-mr10u.dtsi
new file mode 100644
index 0000000000..8a82d80706
--- /dev/null
+++ b/target/linux/ath79/dts/ar9331_tl-wr703n_tl-mr10u.dtsi
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9331.dtsi"
+
+/ {
+	aliases {
+		serial0 = &uart;
+		led-status = &led_system;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+	
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led_system: system {
+			label = "tl-wr703n:blue:system";
+			gpios = <&gpio 27 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	reg_usb_vbus: reg_usb_vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+	};
+
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				reg = <0x0 0x20000>;
+				label = "u-boot";
+				read-only;
+			};
+
+			firmware: partition@20000 {
+				reg = <0x20000 0x3d0000>;
+				label = "firmware";
+			};
+
+			art: partition@3f0000 {
+				reg = <0x3f0000 0x10000>;
+				label = "art";
+				read-only;
+			};
+		};
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-handle = <&phy4>;
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+
+	gmac-config {
+		device = <&gmac>;
+
+		switch-phy-addr-swap = <0>;
+		switch-phy-swap = <0>;
+	};
+};
+
+&gpio {
+	status = "okay";
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	status = "okay";
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+};
diff --git a/target/linux/ath79/dts/ar9341.dtsi b/target/linux/ath79/dts/ar9341.dtsi
new file mode 100644
index 0000000000..751db2a1e8
--- /dev/null
+++ b/target/linux/ath79/dts/ar9341.dtsi
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include "ar934x.dtsi"
+
+/ {
+	compatible = "qca,ar9341";
+};
+
+&cpuintc {
+	qca,ddr-wb-channel-interrupts = <2>, <3>, <4>, <5>;
+	qca,ddr-wb-channels = <&ddr_ctrl 4>, <&ddr_ctrl 2>,
+				<&ddr_ctrl 0>, <&ddr_ctrl 1>;
+};
+
+&wmac {
+	interrupt-parent = <&cpuintc>;
+	interrupts = <2>;
+};
diff --git a/target/linux/ath79/dts/ar9344.dtsi b/target/linux/ath79/dts/ar9344.dtsi
new file mode 100644
index 0000000000..39dd33fd67
--- /dev/null
+++ b/target/linux/ath79/dts/ar9344.dtsi
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include "ar934x.dtsi"
+
+/ {
+	compatible = "qca,ar9344";
+};
+
+&cpuintc {
+	qca,ddr-wb-channel-interrupts = <3>, <4>, <5>;
+	qca,ddr-wb-channels = <&ddr_ctrl 2>, <&ddr_ctrl 0>,
+			<&ddr_ctrl 1>;
+};
+
+&rst {
+	intc2: interrupt-controller@2 {
+		compatible = "qca,ar9340-intc";
+
+		interrupt-parent = <&cpuintc>;
+		interrupts = <2>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		qca,int-status-addr = <0xac>;
+		qca,pending-bits = <0xf>,	/* wmac */
+				<0x1f0>;	/* pcie rc1 */
+
+		qca,ddr-wb-channel-interrupts = <0>, <1>;
+		qca,ddr-wb-channels = <&ddr_ctrl 4>, <&ddr_ctrl 3>;
+	};
+};
+
+&apb {
+	pcie: pcie-controller@180c0000 {
+		compatible = "qcom,ar9340-pci", "qcom,ar7240-pci";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		bus-range = <0x0 0x0>;
+		reg = <0x180c0000 0x1000>, /* CRP */
+				<0x180f0000 0x100>, /* CTRL */
+				<0x14000000 0x1000>; /* CFG */
+		reg-names = "crp_base", "ctrl_base", "cfg_base";
+		ranges = <0x2000000 0 0x10000000 0x10000000 0 0x04000000 /* pci memory */
+				0x1000000 0 0x00000000 0x0000000 0 0x000001>; /* io space */
+		interrupt-parent = <&intc2>;
+		interrupts = <1>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		interrupt-map-mask = <0 0 0 1>;
+		interrupt-map = <0 0 0 0 &pcie 0>;
+		
+		status = "disabled";
+	};
+};
+
+&wmac {
+	interrupt-parent = <&intc2>;
+	interrupts = <0>;
+};
diff --git a/target/linux/ath79/dts/ar9344_tl-wdr3600.dts b/target/linux/ath79/dts/ar9344_tl-wdr3600.dts
new file mode 100644
index 0000000000..d0886ee86b
--- /dev/null
+++ b/target/linux/ath79/dts/ar9344_tl-wdr3600.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar9344_tl-wdr4300.dtsi"
+
+/ {
+	model = "TP-Link WDR3600";
+	compatible = "tplink,tl-wdr3600";
+};
diff --git a/target/linux/ath79/dts/ar9344_tl-wdr4300.dts b/target/linux/ath79/dts/ar9344_tl-wdr4300.dts
new file mode 100644
index 0000000000..617da57098
--- /dev/null
+++ b/target/linux/ath79/dts/ar9344_tl-wdr4300.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include "ar9344_tl-wdr4300.dtsi"
+
+/ {
+	model = "TP-Link WDR4300";
+	compatible = "tplink,tl-wdr4300";
+};
diff --git a/target/linux/ath79/dts/ar9344_tl-wdr4300.dtsi b/target/linux/ath79/dts/ar9344_tl-wdr4300.dtsi
new file mode 100644
index 0000000000..84dd721224
--- /dev/null
+++ b/target/linux/ath79/dts/ar9344_tl-wdr4300.dtsi
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "ar9344.dtsi"
+
+/ {
+	model = "TP-Link WDR4300";
+	compatible = "tplink,tl-wdr4300";
+
+	aliases {
+		led-status = &system;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		usb1 {
+			label = "tp-link:green:usb1";
+			gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port1>;
+			linux,default-trigger = "usbport";
+		};
+
+		usb2 {
+			label = "tp-link:green:usb2";
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port2>;
+			linux,default-trigger = "usbport";
+		};
+
+		wlan2g {
+			label = "tp-link:green:wlan2g";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		system: system {
+			label = "tp-link:green:system";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+
+		qss {
+			label = "tp-link:green:qss";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	ath9k-leds {
+		compatible = "gpio-leds";
+
+		wlan5g {
+			label = "tp-link:green:wlan5g";
+			gpios = <&ath9k 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy1tpt";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		wifi {
+			linux,code = <KEY_RFKILL>;
+			linux,input-type = <EV_SW>;
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_usb1_power {
+			gpio-export,name = "tp-link:power:usb1";
+			gpio-export,output = <1>;
+			gpios = <&gpio 22 GPIO_ACTIVE_HIGH>;
+		};
+
+		gpio_usb2_power {
+			gpio-export,name = "tp-link:power:usb2";
+			gpio-export,output = <1>;
+			gpios = <&gpio 21 GPIO_ACTIVE_HIGH>;
+		};
+
+		gpio_ext_lna0 {
+			gpio-export,name = "tp-link:ext:lna0";
+			gpio-export,output = <1>;
+			gpios = <&gpio 18 GPIO_ACTIVE_HIGH>;
+		};
+
+		gpio_ext_lna1 {
+			gpio-export,name = "tp-link:ext:lna1";
+			gpio-export,output = <1>;
+			gpios = <&gpio 19 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ref {
+	clock-frequency = <40000000>;
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&spi {
+	num-cs = <1>;
+
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0x7d0000>;
+			};
+
+			art: partition@7f0000 {
+				label = "art";
+				reg = <0x7f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&usb {
+	status = "okay";
+
+	port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+
+		hub_port1: port@1 {
+			reg = <1>;
+			#trigger-source-cells = <0>;
+		};
+
+		hub_port2: port@2 {
+			reg = <2>;
+			#trigger-source-cells = <0>;
+		};
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+
+	ath9k: wifi@168c,0033 {
+		compatible = "pci168c,0033";
+		reg = <0x0000 0 0 0 0>;
+		mtd-mac-address = <&uboot 0x1fc00>;
+		qca,no-eeprom;
+		#gpio-cells = <2>;
+		gpio-controller;
+	};
+};
+
+&wmac {
+	status = "okay";
+
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <(-1)>;
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy-mask = <0>;
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		phy-mode = "rgmii";
+
+		qca,ar8327-initvals = <
+			0x04 0x07600000 /* PORT0 PAD MODE CTRL */
+			0x10 0x80000080 /* POWER_ON_STRIP */
+			0x50 0xc737c737 /* LED_CTRL0 */
+			0x54 0x00000000 /* LED_CTRL1 */
+			0x58 0x00000000 /* LED_CTRL2 */
+			0x5c 0x0030c300 /* LED_CTRL3 */
+			0x7c 0x0000007e /* PORT0_STATUS */
+			>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	/* default for ar934x, except for 1000M */
+	pll-data = <0x06000000 0x00000101 0x00001616>;
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <(-2)>;
+
+	phy-mode = "rgmii";
+	phy-handle = <&phy0>;
+};
diff --git a/target/linux/ath79/dts/ar934x.dtsi b/target/linux/ath79/dts/ar934x.dtsi
new file mode 100644
index 0000000000..6d5e5262d8
--- /dev/null
+++ b/target/linux/ath79/dts/ar934x.dtsi
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+#include <dt-bindings/clock/ath79-clk.h>
+
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,ar9340";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips74Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		ref: ref {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-output-names = "ref";
+		};
+	};
+
+	ahb {
+		compatible = "simple-bus";
+		ranges;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		apb: apb {
+			compatible = "simple-bus";
+			ranges;
+
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar9340-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x12c>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x2c>;
+
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_REF>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar9340-gpio";
+				reg = <0x18040000 0x2c>;
+
+				interrupts = <2>;
+				ngpios = <23>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pinmux: pinmux@1804002c {
+				compatible = "pinctrl-single";
+
+				reg = <0x1804002c 0x44>;
+
+				#size-cells = <0>;
+
+				pinctrl-single,bit-per-mux;
+				pinctrl-single,register-width = <32>;
+				pinctrl-single,function-mask = <0x1>;
+				#pinctrl-cells = <2>;
+
+				jtag_disable_pins: pinmux_jtag_disable_pins {
+					pinctrl-single,bits = <0x40 0x2 0x2>;
+				};
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar9340-pll", "syscon";
+				reg = <0x18050000 0x4c>;
+
+				#clock-cells = <1>;
+				clocks = <&ref>;
+				clock-names = "ref";
+				clock-output-names = "cpu", "ddr", "ahb";
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar9340-wdt", "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,ar9340-reset", "qca,ar7100-reset";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+			};
+
+			gmac: gmac@18070000 {
+				compatible = "qca,ar9340-gmac", "qca,ar9330-gmac";
+				reg = <0x18070000 0x14>;
+			};
+
+			wmac: wmac@18100000 {
+				compatible = "qca,ar9340-wmac";
+				reg = <0x18100000 0x20000>;
+
+				status = "disabled";
+			};
+		};
+
+		usb: usb@1b000000 {
+			compatible = "generic-ehci";
+			reg = <0x1b000000 0x1d8>;
+
+			interrupts = <3>;
+			resets = <&rst 5>;
+			reset-names = "usb-host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy";
+			phys = <&usb_phy>;
+
+			status = "disabled";
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar9340-spi", "qca,ar7100-spi";
+			reg = <0x1f000000 0x1c>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			status = "disabled";
+		};
+	};
+
+	usb_phy: usb-phy {
+		compatible = "qca,ar9340-usb-phy", "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&mdio0 {
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,ar9340-eth", "syscon";
+
+	pll-data = <0x16000000 0x00000101 0x00001616>;
+	pll-reg = <0x4 0x2c 17>;
+	pll-handle = <&pll>;
+
+	resets = <&rst 8>, <&rst 9>;
+	reset-names = "mac", "phy";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,ar9340-eth", "syscon";
+
+	resets = <&rst 12>, <&rst 13>;
+	reset-names = "mac", "phy";
+};
diff --git a/target/linux/ath79/dts/ath79.dtsi b/target/linux/ath79/dts/ath79.dtsi
new file mode 100644
index 0000000000..cec4d0b6b0
--- /dev/null
+++ b/target/linux/ath79/dts/ath79.dtsi
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpuintc: interrupt-controller {
+		compatible = "qca,ar7100-cpu-intc";
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+
+	ahb {
+		compatible = "simple-bus";
+		ranges;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		interrupt-parent = <&cpuintc>;
+
+		apb {
+			compatible = "simple-bus";
+			ranges;
+
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			interrupt-parent = <&miscintc>;
+
+			miscintc: interrupt-controller@18060010 {
+				compatible = "qca,ar7240-misc-intc";
+				reg = <0x18060010 0x4>;
+
+				interrupt-parent = <&cpuintc>;
+				interrupts = <6>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+			};
+		};
+
+		eth0: eth@19000000 {
+			status = "disabled";
+
+			compatible = "qca,ath79-eth", "syscon";
+			reg = <0x19000000 0x200>;
+
+			interrupts = <4>;
+			phy-mode = "mii";
+
+			mdio0: mdio-bus {
+				status = "disabled";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				regmap = <&eth0>;
+
+				clocks = <&pll ATH79_CLK_MDIO>;
+				clock-names = "ref";
+			};
+		};
+
+		eth1: eth@1a000000 {
+			status = "disabled";
+
+			compatible = "qca,ath79-eth", "syscon";
+			reg = <0x1a000000 0x200>;
+
+			interrupts = <5>;
+			phy-mode = "mii";
+
+			mdio1: mdio-bus {
+				status = "disabled";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				regmap = <&eth1>;
+
+				clocks = <&pll ATH79_CLK_MDIO>;
+				clock-names = "ref";
+			};
+		};
+	};
+};
diff --git a/target/linux/ath79/dts/qca9533.dtsi b/target/linux/ath79/dts/qca9533.dtsi
new file mode 100644
index 0000000000..ff1e77e070
--- /dev/null
+++ b/target/linux/ath79/dts/qca9533.dtsi
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,qca9533";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips24Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	ref: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar9530-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x128>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x20>;
+
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_REF>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			usb_phy: usb-phy@18030000 {
+				compatible = "qca,ar7200-usb-phy";
+				reg = <0x18030000 0x100>;
+				#phy-cells = <0>;
+
+				reset-names = "usb-phy", "usb-suspend-override";
+				resets = <&rst 4>, <&rst 3>;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar9530-gpio",
+						"qca,ar9340-gpio";
+				reg = <0x18040000 0x28>;
+
+				interrupts = <2>;
+				ngpios = <20>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pinmux: pinmux@1804002c {
+				compatible = "pinctrl-single";
+
+				reg = <0x1804002c 0x48>;
+
+				#size-cells = <0>;
+
+				pinctrl-single,bit-per-mux;
+				pinctrl-single,register-width = <32>;
+				pinctrl-single,function-mask = <0x1>;
+				#pinctrl-cells = <2>;
+
+				jtag_disable_pins: pinmux_jtag_disable_pins {
+					pinctrl-single,bits = <
+						0x40 0x2 0x2
+						>;
+				};
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,qca9530-pll", "syscon";
+				reg = <0x18050000 0x48>;
+
+				#clock-cells = <1>;
+				clocks = <&ref>;
+				clock-names = "ref";
+				clock-output-names = "cpu", "ddr", "ahb";
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,qca9530-wdt", "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,qca9530-reset",
+						"qca,ar7100-reset";
+				reg = <0x1806001c 0xac>;
+
+				#reset-cells = <1>;
+
+				intc2: interrupt-controller@2 {
+					compatible = "qcom,qca9556-intc";
+
+					interrupts = <2>;
+
+					interrupt-controller;
+					#interrupt-cells = <1>;
+
+					qcom,pending-bits = <0x1f0>,	/* pcie rc1 */
+							    <0xf>;	/* wmac */
+				};
+			};
+
+			pcie0: pcie-controller@180c0000 {
+				compatible = "qcom,ar7240-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x180c0000 0x1000>, /* CRP */
+				      <0x180f0000 0x100>,  /* CTRL */
+				      <0x14000000 0x1000>; /* CFG */
+				reg-names = "crp_base", "ctrl_base", "cfg_base";
+				ranges = <0x2000000 0 0x10000000 0x10000000 0 0x04000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&intc2>;
+				interrupts = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie0 0>;
+				status = "disabled";
+			};
+
+			wmac: gmac@18100000 {
+				compatible = "qca,qca9530-wmac";
+				reg = <0x18100000 0x230000>;
+
+				interrupt-parent = <&cpuintc>;
+				interrupts = <2>;
+
+				status = "disabled";
+			};
+		};
+
+		usb0: usb@1b000000 {
+			compatible = "generic-ehci";
+			reg = <0x1b000000 0x1000>;
+
+			interrupts = <3>;
+			resets = <&rst 5>;
+			reset-names = "usb-host";
+			dr_mode = "host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy";
+			phys = <&usb_phy>;
+
+			status = "disabled";
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar9530-spi", "qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+	};
+
+};
+
+&mdio0 {
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,qca9530-eth", "syscon";
+	pll-data = <0x82000101 0x80000101 0x80001313>;
+	reg = <0x19000000 0x200
+		0x18070000 0x4>;
+	pll-reg = <0x4 0x2c 17>;
+	pll-handle = <&pll>;
+
+	reset-names = "mac";
+	resets = <&rst 9>;
+};
+
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,qca9530-eth", "syscon";
+	resets = <&rst 13>;
+	reset-names = "mac";
+};
diff --git a/target/linux/ath79/dts/qca9533_glinet_ar300m.dtsi b/target/linux/ath79/dts/qca9533_glinet_ar300m.dtsi
new file mode 100644
index 0000000000..351d313497
--- /dev/null
+++ b/target/linux/ath79/dts/qca9533_glinet_ar300m.dtsi
@@ -0,0 +1,141 @@
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9533.dtsi"
+
+/ {
+	compatible = "glinet,ar300m", "qca,qca9533";
+	model = "GL.iNet GL-AR300M";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-output-names = "ref";
+		clock-frequency = <25000000>;
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&jtag_disable_pins>;
+
+		button@0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 3 GPIO_ACTIVE_LOW>;
+		};
+
+		button@1 {
+			label = "button right";
+			linux,code = <BTN_0>;
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+		};
+
+		button@3 {
+			label = "button left";
+			linux,code = <BTN_1>;
+			gpios = <&gpio 1 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		usb {
+			label = "gl-ar300m:green:usb";
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			trigger-sources = <&hub_port>;
+			linux,default-trigger = "usbport";
+		};
+
+		wlan {
+			label = "gl-ar300m:green:wlan";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "phy0tpt";
+		};
+
+		lan {
+			label = "gl-ar300m:green:lan";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+		};
+
+		status {
+			label = "gl-ar300m:green:status";
+			gpios = <&gpio 3 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&uart {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+
+	hub_port: port@1 {
+		reg = <1>;
+		#trigger-soruce-cells = <0>;
+	};
+};
+
+&usb_phy {
+	status = "okay";
+};
+
+&pll {
+	clocks = <&extosc>;
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "mii";
+	};
+};
+
+&mdio1 {
+	status = "okay";
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x0>;
+	phy-handle = <&phy4>;
+	phy-mode = "mii";
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&art 0x6>;
+	phy-mode = "gmii";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&art 0x1002>;
+};
diff --git a/target/linux/ath79/dts/qca9533_glinet_ar300m_nand.dts b/target/linux/ath79/dts/qca9533_glinet_ar300m_nand.dts
new file mode 100644
index 0000000000..c1c4493a22
--- /dev/null
+++ b/target/linux/ath79/dts/qca9533_glinet_ar300m_nand.dts
@@ -0,0 +1,67 @@
+/dts-v1/;
+
+#include "qca9533_glinet_ar300m.dtsi"
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "reserved";
+				reg = <0x050000 0xfa0000>;
+			};
+
+			art: partition@3 {
+				label = "art";
+				reg = <0xff0000 0x010000>;
+			};
+		};
+	};
+
+	flash@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spinand,mt29f";
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "kernel";
+				reg = <0x000000 0x0200000>;
+			};
+
+			partition@1 {
+				label = "ubi";
+				reg = <0x200000 0x7e00000>;
+			};
+		};
+	};
+};
diff --git a/target/linux/ath79/dts/qca9533_glinet_ar300m_nor.dts b/target/linux/ath79/dts/qca9533_glinet_ar300m_nor.dts
new file mode 100644
index 0000000000..59793dc90b
--- /dev/null
+++ b/target/linux/ath79/dts/qca9533_glinet_ar300m_nor.dts
@@ -0,0 +1,46 @@
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9533_glinet_ar300m.dtsi"
+
+&spi {
+	status = "okay";
+	num-cs = <0>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x050000 0xfa0000>;
+			};
+
+			art: partition@3 {
+				label = "art";
+				reg = <0xff0000 0x010000>;
+			};
+		};
+	};
+};
diff --git a/target/linux/ath79/dts/qca9557.dtsi b/target/linux/ath79/dts/qca9557.dtsi
new file mode 100644
index 0000000000..802f2da725
--- /dev/null
+++ b/target/linux/ath79/dts/qca9557.dtsi
@@ -0,0 +1,313 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,qca9557";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips74Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-output-names = "ref";
+		clock-frequency = <40000000>;
+	};
+
+	ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,ar9557-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x20>;
+
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_REF>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			usb_phy0: usb-phy@18030000 {
+				compatible ="qca,qca9550-usb-phy", "qca,ar7200-usb-phy";
+
+				reset-names = "usb-phy", "usb-suspend-override";
+				resets = <&rst 4>, <&rst 3>;
+
+				#phy-cells = <0>;
+
+				status = "disabled";
+			};
+
+			usb_phy1: usb-phy {
+				compatible = "qca,qca9550-usb-phy", "qca,ar7200-usb-phy";
+
+				reset-names = "usb-phy", "usb-suspend-override";
+				resets = <&rst2 4>, <&rst2 3>;
+
+				#phy-cells = <0>;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,ar9557-gpio",
+						"qca,ar9340-gpio";
+				reg = <0x18040000 0x28>;
+
+				interrupts = <2>;
+				ngpios = <24>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pinmux: pinmux@1804002c {
+				compatible = "pinctrl-single";
+
+				reg = <0x1804002c 0x40>;
+
+				#size-cells = <0>;
+
+				pinctrl-single,bit-per-mux;
+				pinctrl-single,register-width = <32>;
+				pinctrl-single,function-mask = <0x1>;
+				#pinctrl-cells = <2>;
+
+				jtag_disable_pins: pinmux_jtag_disable_pins {
+					pinctrl-single,bits = <0x40 0x2  0x2>;
+				};
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,ar9557-pll",
+						"qca,qca9550-pll";
+				reg = <0x18050000 0x50>;
+
+				#clock-cells = <1>;
+				clock-output-names = "cpu", "ddr", "ahb";
+
+				clocks = <&extosc>;
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,qca9550-reset",
+						"qca,ar7100-reset",
+						 "simple-bus";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+				interrupt-parent = <&cpuintc>;
+
+				intc2: interrupt-controller@2 {
+					compatible = "qca,ar9340-intc";
+
+					interrupt-parent = <&cpuintc>;
+					interrupts = <2>;
+
+					interrupt-controller;
+					#interrupt-cells = <1>;
+
+					qca,int-status-addr = <0xac>;
+					qca,pending-bits = <0xf>,	/* wmac */
+							<0x1f0>;	/* pcie rc 0 */
+				};
+
+				intc3: interrupt-controller@3 {
+					compatible = "qca,ar9340-intc";
+
+					interrupt-parent = <&cpuintc>;
+					interrupts = <3>;
+
+					interrupt-controller;
+					#interrupt-cells = <1>;
+
+					qca,int-status-addr = <0xac>;
+					qca,pending-bits = <0x1f000>,		/* pcie rc 1 */
+							    <0x1000000>,	/* usb1 */
+							    <0x10000000>;	/* usb2 */
+				};
+			};
+
+			rst2: reset-controller@180600c0 {
+				compatible = "qca,qca9550-reset",
+						"qca,ar7100-reset",
+						 "simple-bus";
+				reg = <0x180600c0 0x4>;
+
+				#reset-cells = <1>;
+			};
+
+			pcie0: pcie-controller@180c0000 {
+				compatible = "qcom,ar7240-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x180c0000 0x1000>, /* CRP */
+				      <0x180f0000 0x100>,  /* CTRL */
+				      <0x14000000 0x1000>; /* CFG */
+				reg-names = "crp_base", "ctrl_base", "cfg_base";
+				ranges = <0x2000000 0 0x10000000 0x10000000 0 0x04000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&intc2>;
+				interrupts = <1>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie0 0>;
+				status = "disabled";
+			};
+
+			pcie1: pcie-controller@18250000 {
+				compatible = "qcom,ar7240-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x18250000 0x1000>, /* CRP */
+				      <0x18280000 0x100>,  /* CTRL */
+				      <0x16000000 0x1000>; /* CFG */
+				reg-names = "crp_base", "ctrl_base", "cfg_base";
+				ranges = <0x2000000 0 0x12000000 0x12000000 0 0x02000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&intc3>;
+				interrupts = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie1 0>;
+				status = "disabled";
+			};
+
+			wmac: wmac@18100000 {
+				compatible = "qca,qca9550-wmac";
+				reg = <0x18100000 0x10000>;
+
+				interrupt-parent = <&intc2>;
+				interrupts = <0>;
+
+				status = "disabled";
+			};
+		};
+
+		usb0: usb@1b000000 {
+			compatible = "generic-ehci";
+			reg = <0x1b000000 0x1fc>;
+
+			interrupt-parent = <&intc3>;
+			interrupts = <1>;
+			resets = <&rst 5>;
+			reset-names = "usb-host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy0";
+			phys = <&usb_phy0>;
+
+			status = "disabled";
+		};
+
+		usb1: usb@1b400000 {
+			compatible = "generic-ehci";
+			reg = <0x1b400000 0x1fc>;
+
+			interrupt-parent = <&intc3>;
+			interrupts = <2>;
+			resets = <&rst2 5>;
+			reset-names = "usb-host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy1";
+			phys = <&usb_phy1>;
+
+			status = "disabled";
+	};
+
+		spi: spi@1f000000 {
+			compatible = "qca,ar9557-spi", "qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+};
+
+&mdio0 {
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,qca9550-eth", "syscon";
+
+	pll-data = <0x82000101 0x80000101 0x80001313>;
+	phy-mode = "rgmii";
+
+	resets = <&rst 9>;
+	reset-names = "mac";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+};
+
+&eth1 {
+	compatible = "qca,qca9550-eth", "syscon";
+
+	pll-data = <0x82000101 0x80000101 0x80001313>;
+	phy-mode = "sgmii";
+
+	resets = <&rst 13>;
+	reset-names = "mac";
+};
diff --git a/target/linux/ath79/dts/qca9558_openmesh_om5p-ac-v2.dts b/target/linux/ath79/dts/qca9558_openmesh_om5p-ac-v2.dts
new file mode 100644
index 0000000000..974b1c61f0
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_openmesh_om5p-ac-v2.dts
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9557.dtsi"
+
+/ {
+	compatible = "openmesh,om5p-ac-v2", "qca,qca9557";
+	model = "OpenMesh OM5P-AC V2";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-output-names = "ref";
+		clock-frequency = <40000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		power {
+			label = "om5pac:blue:power";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wifi_green {
+			label = "om5pac:green:wifi";
+			gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wifi_yellow {
+			label = "om5pac:yellow:wifi";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wifi_red {
+			label = "om5pac:red:wifi";
+			gpios = <&gpio 23 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button@0 {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_pa_dcdc {
+			gpio-export,name = "om5pac:pa_dcdc";
+			gpio-export,output = <1>;
+			gpios = <&gpio 2 GPIO_ACTIVE_HIGH>;
+		};
+		gpio_pa_high {
+			gpio-export,name = "om5pac:pa_high";
+			gpio-export,output = <1>;
+			gpios = <&gpio 16 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&pinmux {
+	pinmux_pa_dcdc_pins {
+		pinctrl-single,bits = <0x0 0xff00 0x0>;
+	};
+
+	pinmux_pa_high_pins {
+		pinctrl-single,bits = <0x10 0xff 0x0>;
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&uart {
+	status = "okay";
+};
+
+&pll {
+	clocks = <&extosc>;
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "mx25l12805d";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x040000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "u-boot-env";
+				reg = <0x040000 0x010000>;
+			};
+
+			partition@2 {
+				label = "firmware";
+				reg = <0x850000 0x7a0000>;
+			};
+
+			partition@3 {
+				label = "ART";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+		phy-mode = "rgmii-id";
+	};
+};
+
+&mdio1 {
+	status = "okay";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+		phy-mode = "sgmii";
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	phy-handle = <&phy4>;
+	phy-mode = "rgmii";
+};
+
+&eth1 {
+	status = "okay";
+
+	phy-handle = <&phy1>;
+	phy-mode = "sgmii";
+};
diff --git a/target/linux/ath79/dts/qca9558_tl-archer-c7-v2.dts b/target/linux/ath79/dts/qca9558_tl-archer-c7-v2.dts
new file mode 100644
index 0000000000..980aa35b91
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_tl-archer-c7-v2.dts
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9558_tl-archer-c7.dtsi"
+
+/ {
+	compatible = "tplink,tl-archer-c7-v2", "qca,qca9558";
+	model = "TP-Link Archer C7 Version 2";
+};
+
+&rfkill {
+	gpios = <&gpio 23 GPIO_ACTIVE_LOW>;
+};
diff --git a/target/linux/ath79/dts/qca9558_tl-archer-c7.dtsi b/target/linux/ath79/dts/qca9558_tl-archer-c7.dtsi
new file mode 100644
index 0000000000..08bb510ea7
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_tl-archer-c7.dtsi
@@ -0,0 +1,232 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9557.dtsi"
+
+/ {
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	aliases {
+		led-status = &system;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system: system {
+			label = "tp-link:green:system";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+
+		usb1 {
+			label = "tp-link:green:usb1";
+			gpios = <&gpio 18 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port0>;
+			linux,default-trigger = "usbport";
+		};
+
+		usb2 {
+			label = "tp-link:green:usb2";
+			gpios = <&gpio 19 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port1>;
+			linux,default-trigger = "usbport";
+		};
+
+		wlan2g {
+			label = "tp-link:green:wlan2g";
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy1tpt";
+		};
+
+		qss {
+			label = "tp-link:green:qss";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wlan5g {
+			label = "tp-link:green:wlan5g";
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reset {
+			label = "Reset button";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		rfkill: wifi {
+			linux,code = <KEY_RFKILL>;
+			linux,input-type = <EV_SW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_usb1_power {
+			gpio-export,name = "tp-link:power:usb1";
+			gpio-export,output = <1>;
+			gpios = <&gpio 22 GPIO_ACTIVE_HIGH>;
+		};
+
+		gpio_usb2_power {
+			gpio-export,name = "tp-link:power:usb2";
+			gpio-export,output = <1>;
+			gpios = <&gpio 21 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+};
+
+&pcie1 {
+	status = "okay";
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb_phy0 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+
+	hub_port0: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&usb_phy1 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+
+	hub_port1: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot: partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0xfd0000>;
+			};
+
+			art: partition@ff0000 {
+				label = "art";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+
+		qca,ar8327-initvals = <
+			0x04 0x00080080 /* PORT0 PAD MODE CTRL */
+			0x0c 0x07600000 /* PORT6 PAD MODE CTRL */
+			0x50 0xc737c737 /* LED_CTRL0 */
+			0x54 0x00000000 /* LED_CTRL1 */
+			0x58 0x00000000 /* LED_CTRL2 */
+			0x5c 0x0030c300 /* LED_CTRL3 */
+			0x7c 0x0000007e /* PORT0_STATUS */
+			0x94 0x0000007e /* PORT6 STATUS */
+			>;
+	};
+};
+
+&mdio1 {
+	status = "okay";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <1>;
+	phy-handle = <&phy0>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	phy-handle = <&phy1>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+};
diff --git a/target/linux/ath79/dts/qca9558_tl-wr1043nd-v2.dts b/target/linux/ath79/dts/qca9558_tl-wr1043nd-v2.dts
new file mode 100644
index 0000000000..0cfc486883
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_tl-wr1043nd-v2.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9558_tl-wr1043nd.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr1043nd-v2", "qca,qca9557";
+	model = "TP-Link TL-WR1043ND Version 2";
+};
diff --git a/target/linux/ath79/dts/qca9558_tl-wr1043nd-v3.dts b/target/linux/ath79/dts/qca9558_tl-wr1043nd-v3.dts
new file mode 100644
index 0000000000..c41129837c
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_tl-wr1043nd-v3.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9558_tl-wr1043nd.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr1043nd-v3", "qca,qca9557";
+	model = "TP-Link TL-WR1043ND Version 3";
+};
diff --git a/target/linux/ath79/dts/qca9558_tl-wr1043nd.dtsi b/target/linux/ath79/dts/qca9558_tl-wr1043nd.dtsi
new file mode 100644
index 0000000000..1abee23b50
--- /dev/null
+++ b/target/linux/ath79/dts/qca9558_tl-wr1043nd.dtsi
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9557.dtsi"
+
+/ {
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	aliases {
+		led-status = &system;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system: system {
+			label = "tp-link:green:system";
+			gpios = <&gpio 19 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+		};
+
+		usb {
+			label = "tp-link:green:usb";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port0>;
+			linux,default-trigger = "usbport";
+		};
+
+		wifi_green {
+			label = "tp-link:green:wlan";
+			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		wifi_wps {
+			label = "tp-link:green:wps";
+			gpios = <&gpio 18 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reset {
+			label = "Reset button";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		wifi {
+			label = "RFKILL button";
+			linux,code = <KEY_RFKILL>;
+			gpios = <&gpio 17 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_usb_power {
+			gpio-export,name = "tp-link:power:usb";
+			gpio-export,output = <1>;
+			gpios = <&gpio 21 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb_phy0 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+
+	hub_port0: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uboot:	partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0x7d0000>;
+			};
+
+			art: partition@7f0000 {
+				label = "art";
+				reg = <0x7f0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		qca,ar8327-initvals = <
+		    0x04 0x00080080 /* PORT0 PAD MODE CTRL */
+		    0x0c 0x07600000 /* PORT6 PAD MODE CTRL */
+		    0x10 0x81000080 /* POWER_ON_STRIP */
+		    0x50 0xcc35cc35 /* LED_CTRL0 */
+		    0x54 0xca35ca35 /* LED_CTRL1 */
+		    0x58 0xc935c935 /* LED_CTRL2 */
+		    0x5c 0x03ffff00 /* LED_CTRL3 */
+		    0x7c 0x0000007e /* PORT0_STATUS */
+		    0x94 0x0000007e /* PORT6 STATUS */
+		>;
+	};
+};
+
+&mdio1 {
+	status = "okay";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	mtd-mac-address-increment = <1>;
+	phy-handle = <&phy0>;
+};
+
+&eth1 {
+	status = "okay";
+
+	mtd-mac-address = <&uboot 0x1fc00>;
+	phy-handle = <&phy1>;
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&uboot 0x1fc00>;
+};
diff --git a/target/linux/ath79/dts/qca9563_phicomm-k2t.dts b/target/linux/ath79/dts/qca9563_phicomm-k2t.dts
new file mode 100644
index 0000000000..4ff9320d5c
--- /dev/null
+++ b/target/linux/ath79/dts/qca9563_phicomm-k2t.dts
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca956x.dtsi"
+
+/ {
+	model = "Phicomm K2T";
+	compatible = "phicomm,k2t";
+
+	aliases {
+		led-status = &status_red;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		status_blue {
+			label = "phicomm:blue:status";
+			gpios = <&gpio 6 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		status_red: status_red {
+			label = "phicomm:red:status";
+			gpios = <&gpio 7 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		status_yellow {
+			label = "phicomm:yellow:status";
+			gpios = <&gpio 8 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&spi {
+	num-cs = <1>;
+
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x30000>;
+				read-only;
+			};
+
+			partition@30000 {
+				label = "config";
+				reg = <0x030000 0x10000>;
+				read-only;
+			};
+
+			partition@40000 {
+				label = "permanent";
+				reg = <0x040000 0x50000>;
+				read-only;
+			};
+
+			partition@90000 {
+				label = "firmware";
+				reg = <0x090000 0xf60000>;
+			};
+
+			art: partition@ff0000 {
+				label = "art";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy-mask = <0>;
+
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		phy-mode = "sgmii";
+
+		qca,ar8327-initvals = <
+			0x04 0x00080080 /* PORT0 PAD MODE CTRL */
+			0x10 0x81000080 /* POWER_ON_STRIP */
+			0x50 0xcc35cc35 /* LED_CTRL0 */
+			0x54 0xcb37cb37 /* LED_CTRL1 */
+			0x58 0x00000000 /* LED_CTRL2 */
+			0x5c 0x00f3cf00 /* LED_CTRL3 */
+			0x7c 0x0000007e /* PORT0_STATUS */
+			>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	pll-data = <0x03000101 0x00000101 0x00001919>;
+
+	phy-mode = "sgmii";
+	phy-handle = <&phy0>;
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+};
diff --git a/target/linux/ath79/dts/qca9563_tl-wr1043n.dtsi b/target/linux/ath79/dts/qca9563_tl-wr1043n.dtsi
new file mode 100644
index 0000000000..136a6f8a76
--- /dev/null
+++ b/target/linux/ath79/dts/qca9563_tl-wr1043n.dtsi
@@ -0,0 +1,223 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca956x.dtsi"
+
+/ {
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	aliases {
+		led-status = &system;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		system: system {
+			label = "tp-link:green:system";
+			gpios = <&gpio 6 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+		};
+
+		usb {
+			label = "tp-link:green:usb";
+			gpios = <&gpio 7 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			trigger-sources = <&hub_port0>;
+			linux,default-trigger = "usbport";
+		};
+
+		wifi_green {
+			label = "tp-link:green:wlan";
+			gpios = <&gpio 19 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		wifi_wps {
+			label = "tp-link:green:wps";
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		wan {
+			label = "tp-link:green:wan";
+			gpios = <&gpio 15 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		lan1 {
+			label = "tp-link:green:lan1";
+			gpios = <&gpio 9 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		lan2 {
+			label = "tp-link:green:lan2";
+			gpios = <&gpio 14 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		lan3 {
+			label = "tp-link:green:lan3";
+			gpios = <&gpio 21 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+
+		lan4 {
+			label = "tp-link:green:lan4";
+			gpios = <&gpio 20 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reset {
+			label = "Reset button";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+
+		wifi {
+			label = "RFKILL button";
+			linux,code = <KEY_RFKILL>;
+			gpios = <&gpio 5 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+
+	gpio-export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		gpio_usb_power {
+			gpio-export,name = "tp-link:power:usb";
+			gpio-export,output = <1>;
+			gpios = <&gpio 8 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&usb_phy0 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+
+	hub_port0: port@1 {
+		reg = <1>;
+		#trigger-source-cells = <0>;
+	};
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x020000>;
+				read-only;
+			};
+
+			partition@20000 {
+				label = "firmware";
+				reg = <0x020000 0xf30000>;
+			};
+
+			info: partition@f50000 {
+				label = "product-info";
+				reg = <0xf50000 0x020000>;
+				read-only;
+			};
+
+			partition@f70000 {
+				label = "config";
+				reg = <0xf70000 0x050000>;
+				read-only;
+			};
+
+			partition@fc0000 {
+				label = "partition-table";
+				reg = <0xfc0000 0x010000>;
+				read-only;
+			};
+
+			partition@fd0000 {
+				label = "logs";
+				reg = <0xfd0000 0x020000>;
+				read-only;
+			};
+
+			art: partition@ff0000 {
+				label = "ART";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy-mask = <0>;
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		phy-mode = "sgmii";
+
+		qca,ar8327-initvals = <
+		    0x04 0x00080080 /* PORT0 PAD MODE CTRL */
+		    0x7c 0x0000007e /* PORT0_STATUS */
+		>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&info 0x8>;
+	phy-handle = <&phy0>;
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&art 0x1000>;
+	mtd-mac-address = <&info 0x8>;
+};
diff --git a/target/linux/ath79/dts/qca9563_tl-wr1043nd-v4.dts b/target/linux/ath79/dts/qca9563_tl-wr1043nd-v4.dts
new file mode 100644
index 0000000000..e187de7a23
--- /dev/null
+++ b/target/linux/ath79/dts/qca9563_tl-wr1043nd-v4.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca9563_tl-wr1043n.dtsi"
+
+/ {
+	compatible = "tplink,tl-wr1043nd-v4", "qca,qca9563";
+	model = "TP-Link TL-WR1043ND Version 4";
+};
diff --git a/target/linux/ath79/dts/qca9563_ubnt-unifiac-lite.dts b/target/linux/ath79/dts/qca9563_ubnt-unifiac-lite.dts
new file mode 100644
index 0000000000..0bfda12421
--- /dev/null
+++ b/target/linux/ath79/dts/qca9563_ubnt-unifiac-lite.dts
@@ -0,0 +1,148 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+#include "qca956x.dtsi"
+
+/ {
+	compatible = "ubnt,ubnt-unifiac-lite", "qca,qca9563";
+	model = "Ubiquiti UniFi-AC-LITE/MESH/LR";
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		wifi_ac {
+			label = "ubnt:white:dome";
+			gpios = <&gpio 7 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy0tpt";
+		};
+
+		wifi_n {
+			label = "ubnt:blue:dome";
+			gpios = <&gpio 8 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "phy1tpt";
+		};
+
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reset {
+			label = "Reset button";
+			linux,code = <KEY_RESTART>;
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+			debounce-interval = <60>;
+		};
+	};
+};
+
+&uart {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&spi {
+	status = "okay";
+	num-cs = <1>;
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x000000 0x060000>;
+				read-only;
+			};
+
+			partition@60000 {
+				label = "u-boot-env";
+				reg = <0x060000 0x010000>;
+				read-only;
+			};
+
+			partition@70000 {
+				label = "firmware";
+				reg = <0x070000 0x790000>;
+			};
+
+			partition@800000 {
+				label = "ubnt-airos";
+				reg = <0x800000 0x790000>;
+				read-only;
+			};
+
+			partition@f90000 {
+				label = "bs";
+				reg = <0xf90000 0x020000>;
+				read-only;
+			};
+
+			partition@fb0000 {
+				label = "cfg";
+				reg = <0xfb0000 0x040000>;
+				read-only;
+			};
+
+			eeprom: partition@ff0000 {
+				label = "EEPROM";
+				reg = <0xff0000 0x010000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&mdio0 {
+	status = "okay";
+
+	phy-mask = <4>;
+	phy4: ethernet-phy@4 {
+		phy-mode = "sgmii";
+		reg = <4>;
+	};
+};
+
+&eth0 {
+	status = "okay";
+
+	mtd-mac-address = <&eeprom 0x0>;
+	phy-handle = <&phy4>;
+};
+
+&wmac {
+	status = "okay";
+	mtd-cal-data = <&eeprom 0x1000>;
+	mtd-mac-address = <&eeprom 0x0>;
+};
diff --git a/target/linux/ath79/dts/qca956x.dtsi b/target/linux/ath79/dts/qca956x.dtsi
new file mode 100644
index 0000000000..1b8733a585
--- /dev/null
+++ b/target/linux/ath79/dts/qca956x.dtsi
@@ -0,0 +1,283 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#include <dt-bindings/clock/ath79-clk.h>
+#include "ath79.dtsi"
+
+/ {
+	compatible = "qca,qca9560";
+
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "mips,mips74Kc";
+			clocks = <&pll ATH79_CLK_CPU>;
+			reg = <0>;
+		};
+	};
+
+	extosc: ref {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-output-names = "ref";
+		clock-frequency = <25000000>;
+	};
+
+	ahb {
+		apb {
+			ddr_ctrl: memory-controller@18000000 {
+				compatible = "qca,qca9560-ddr-controller",
+						"qca,ar7240-ddr-controller";
+				reg = <0x18000000 0x100>;
+
+				#qca,ddr-wb-channel-cells = <1>;
+			};
+
+			uart: uart@18020000 {
+				compatible = "ns16550a";
+				reg = <0x18020000 0x20>;
+
+				interrupts = <3>;
+
+				clocks = <&pll ATH79_CLK_REF>;
+				clock-names = "uart";
+
+				reg-io-width = <4>;
+				reg-shift = <2>;
+				no-loopback-test;
+
+				status = "disabled";
+			};
+
+			gpio: gpio@18040000 {
+				compatible = "qca,qca9560-gpio",
+						"qca,ar9340-gpio";
+				reg = <0x18040000 0x28>;
+
+				interrupts = <2>;
+				ngpios = <24>;
+
+				gpio-controller;
+				#gpio-cells = <2>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			pinmux: pinmux@1804002c {
+				compatible = "pinctrl-single";
+
+				reg = <0x1804002c 0x40>;
+
+				#size-cells = <0>;
+
+				pinctrl-single,bit-per-mux;
+				pinctrl-single,register-width = <32>;
+				pinctrl-single,function-mask = <0x1>;
+				#pinctrl-cells = <2>;
+
+				jtag_disable_pins: pinmux_jtag_disable_pins {
+					pinctrl-single,bits = <0x40 0x2 0x2>;
+				};
+			};
+
+			pll: pll-controller@18050000 {
+				compatible = "qca,qca9560-pll", "syscon";
+				reg = <0x18050000 0x50>;
+
+				#clock-cells = <1>;
+				clock-output-names = "cpu", "ddr", "ahb";
+
+				clocks = <&extosc>;
+			};
+
+			wdt: wdt@18060008 {
+				compatible = "qca,ar7130-wdt";
+				reg = <0x18060008 0x8>;
+
+				interrupts = <4>;
+
+				clocks = <&pll ATH79_CLK_AHB>;
+				clock-names = "wdt";
+			};
+
+			rst: reset-controller@1806001c {
+				compatible = "qca,qca9560-reset",
+						"qca,ar7100-reset",
+						 "simple-bus";
+				reg = <0x1806001c 0x4>;
+
+				#reset-cells = <1>;
+				interrupt-parent = <&cpuintc>;
+
+				intc3: interrupt-controller@3 {
+					compatible = "qca,ar9340-intc";
+
+					interrupt-parent = <&cpuintc>;
+					interrupts = <3>;
+
+					interrupt-controller;
+					#interrupt-cells = <1>;
+
+					qca,int-status-addr = <0xac>;
+					qca,pending-bits = <0x1f000>,		/* pcie rc */
+							    <0x1000000>,	/* usb1 */
+							    <0x10000000>;	/* usb2 */
+				};
+			};
+
+			rst2: reset-controller@180600c0 {
+				compatible = "qca,qca9560-reset",
+						"qca,ar7100-reset",
+						 "simple-bus";
+				reg = <0x180600c0 0x4>;
+
+				#reset-cells = <1>;
+			};
+
+			wmac: wmac@18100000 {
+				compatible = "qca,qca9560-wmac";
+				reg = <0x18100000 0x10000>;
+
+				interrupt-parent = <&cpuintc>;
+				interrupts = <2>;
+
+				status = "disabled";
+			};
+
+			pcie: pcie-controller@18250000 {
+				compatible = "qcom,ar7240-pci";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				bus-range = <0x0 0x0>;
+				reg = <0x18250000 0x1000>, /* CRP */
+				      <0x18280000 0x100>,  /* CTRL */
+				      <0x16000000 0x1000>; /* CFG */
+				reg-names = "crp_base", "ctrl_base", "cfg_base";
+				ranges = <0x2000000 0 0x12000000 0x12000000 0 0x02000000	/* pci memory */
+					  0x1000000 0 0x00000000 0x0000000 0 0x000001>;		/* io space */
+				interrupt-parent = <&intc3>;
+				interrupts = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <1>;
+
+				interrupt-map-mask = <0 0 0 1>;
+				interrupt-map = <0 0 0 0 &pcie 0>;
+				status = "disabled";
+			};
+		};
+
+		usb0: usb@1b000000 {
+			compatible = "generic-ehci";
+			reg = <0x1b000000 0x1d8>;
+
+			interrupt-parent = <&intc3>;
+			interrupts = <1>;
+
+			resets = <&rst 5>;
+			reset-names = "usb-host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy0";
+			phys = <&usb_phy0>;
+
+			status = "disabled";
+		};
+
+		usb1: usb@1b400000 {
+			compatible = "generic-ehci";
+			reg = <0x1b400000 0x1d8>;
+
+			interrupt-parent = <&intc3>;
+			interrupts = <2>;
+
+			resets = <&rst2 5>;
+			reset-names = "usb-host";
+
+			has-transaction-translator;
+			caps-offset = <0x100>;
+
+			phy-names = "usb-phy1";
+			phys = <&usb_phy1>;
+
+			status = "disabled";
+		};
+
+		spi: spi@1f000000 {
+			compatible = "qca,qca9560-spi", "qca,ar7100-spi";
+			reg = <0x1f000000 0x10>;
+
+			clocks = <&pll ATH79_CLK_AHB>;
+			clock-names = "ahb";
+
+			status = "disabled";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+
+	usb_phy0: usb-phy {
+		compatible = "qca,qca9560-usb-phy", "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst 4>, <&rst 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+
+	usb_phy1: usb-phy {
+		compatible = "qca,qca9560-usb-phy", "qca,ar7200-usb-phy";
+
+		reset-names = "usb-phy", "usb-suspend-override";
+		resets = <&rst2 4>, <&rst2 3>;
+
+		#phy-cells = <0>;
+
+		status = "disabled";
+	};
+};
+
+&mdio0 {
+	resets = <&rst 22>;
+	reset-names = "mdio";
+};
+
+&eth0 {
+	compatible = "qca,qca9560-eth", "syscon";
+
+	pll-data = <0x03000000 0x00000101 0x00001919>;
+	pll-reg = <0 0x48 0>;
+	pll-handle = <&pll>;
+
+	phy-mode = "sgmii";
+
+	resets = <&rst 9>;
+	reset-names = "mac";
+};
+
+&mdio1 {
+	resets = <&rst 23>;
+	reset-names = "mdio";
+	builtin-switch;
+};
+
+&eth1 {
+	compatible = "qca,qca9560-eth", "syscon";
+
+	phy-mode = "gmii";
+
+	resets = <&rst 13>;
+	reset-names = "mac";
+
+	status = "disabled";
+};
diff --git a/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.c b/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.c
new file mode 100644
index 0000000000..2202351806
--- /dev/null
+++ b/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.c
@@ -0,0 +1,126 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case ATH79_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+	case ATH79_SOC_AR9344:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff --git a/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.h b/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.h
new file mode 100644
index 0000000000..5794941f08
--- /dev/null
+++ b/target/linux/ath79/files/arch/mips/ath79/pci-ath9k-fixup.h
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff --git a/target/linux/ath79/files/arch/mips/include/asm/fw/myloader/myloader.h b/target/linux/ath79/files/arch/mips/include/asm/fw/myloader/myloader.h
new file mode 100644
index 0000000000..8a99d566d7
--- /dev/null
+++ b/target/linux/ath79/files/arch/mips/include/asm/fw/myloader/myloader.h
@@ -0,0 +1,34 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_MIPS_FW_MYLOADER_H
+#define _ASM_MIPS_FW_MYLOADER_H
+
+#include <linux/myloader.h>
+
+struct myloader_info {
+	uint32_t	vid;
+	uint32_t	did;
+	uint32_t	svid;
+	uint32_t	sdid;
+	uint8_t		macs[MYLO_ETHADDR_COUNT][6];
+};
+
+#ifdef CONFIG_MYLOADER
+extern struct myloader_info *myloader_get_info(void) __init;
+#else
+static inline struct myloader_info *myloader_get_info(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_MYLOADER */
+
+#endif /* _ASM_MIPS_FW_MYLOADER_H */
diff --git a/target/linux/ath79/files/drivers/mtd/tplinkpart.c b/target/linux/ath79/files/drivers/mtd/tplinkpart.c
new file mode 100644
index 0000000000..1b94163b83
--- /dev/null
+++ b/target/linux/ath79/files/drivers/mtd/tplinkpart.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/magic.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+
+#define TPLINK_NUM_PARTS	5
+#define TPLINK_HEADER_V1	0x01000000
+#define TPLINK_HEADER_V2	0x02000000
+#define MD5SUM_LEN		16
+
+#define TPLINK_ART_LEN		0x10000
+#define TPLINK_KERNEL_OFFS	0x20000
+#define TPLINK_64K_KERNEL_OFFS	0x10000
+
+struct tplink_fw_header {
+	uint32_t	version;	/* header version */
+	char		vendor_name[24];
+	char		fw_version[36];
+	uint32_t	hw_id;		/* hardware id */
+	uint32_t	hw_rev;		/* hardware revision */
+	uint32_t	unk1;
+	uint8_t		md5sum1[MD5SUM_LEN];
+	uint32_t	unk2;
+	uint8_t		md5sum2[MD5SUM_LEN];
+	uint32_t	unk3;
+	uint32_t	kernel_la;	/* kernel load address */
+	uint32_t	kernel_ep;	/* kernel entry point */
+	uint32_t	fw_length;	/* total length of the firmware */
+	uint32_t	kernel_ofs;	/* kernel data offset */
+	uint32_t	kernel_len;	/* kernel data length */
+	uint32_t	rootfs_ofs;	/* rootfs data offset */
+	uint32_t	rootfs_len;	/* rootfs data length */
+	uint32_t	boot_ofs;	/* bootloader data offset */
+	uint32_t	boot_len;	/* bootloader data length */
+	uint8_t		pad[360];
+} __attribute__ ((packed));
+
+static struct tplink_fw_header *
+tplink_read_header(struct mtd_info *mtd, size_t offset)
+{
+	struct tplink_fw_header *header;
+	size_t header_len;
+	size_t retlen;
+	int ret;
+	u32 t;
+
+	header = vmalloc(sizeof(*header));
+	if (!header)
+		goto err;
+
+	header_len = sizeof(struct tplink_fw_header);
+	ret = mtd_read(mtd, offset, header_len, &retlen,
+		       (unsigned char *) header);
+	if (ret)
+		goto err_free_header;
+
+	if (retlen != header_len)
+		goto err_free_header;
+
+	/* sanity checks */
+	t = be32_to_cpu(header->version);
+	if ((t != TPLINK_HEADER_V1) && (t != TPLINK_HEADER_V2))
+		goto err_free_header;
+
+	t = be32_to_cpu(header->kernel_ofs);
+	if (t != header_len)
+		goto err_free_header;
+
+	return header;
+
+err_free_header:
+	vfree(header);
+err:
+	return NULL;
+}
+
+static int tplink_check_rootfs_magic(struct mtd_info *mtd, size_t offset)
+{
+	u32 magic;
+	size_t retlen;
+	int ret;
+
+	ret = mtd_read(mtd, offset, sizeof(magic), &retlen,
+		       (unsigned char *) &magic);
+	if (ret)
+		return ret;
+
+	if (retlen != sizeof(magic))
+		return -EIO;
+
+	if (le32_to_cpu(magic) != SQUASHFS_MAGIC &&
+	    magic != 0x19852003)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tplink_parse_partitions_offset(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data,
+				   size_t offset)
+{
+	struct mtd_partition *parts;
+	struct tplink_fw_header *header;
+	int nr_parts;
+	size_t art_offset;
+	size_t rootfs_offset;
+	size_t squashfs_offset;
+	int ret;
+
+	nr_parts = TPLINK_NUM_PARTS;
+	parts = kzalloc(nr_parts * sizeof(struct mtd_partition), GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	header = tplink_read_header(master, offset);
+	if (!header) {
+		pr_notice("%s: no TP-Link header found\n", master->name);
+		ret = -ENODEV;
+		goto err_free_parts;
+	}
+
+	squashfs_offset = offset + sizeof(struct tplink_fw_header) +
+			  be32_to_cpu(header->kernel_len);
+
+	ret = tplink_check_rootfs_magic(master, squashfs_offset);
+	if (ret == 0)
+		rootfs_offset = squashfs_offset;
+	else
+		rootfs_offset = offset + be32_to_cpu(header->rootfs_ofs);
+
+	art_offset = master->size - TPLINK_ART_LEN;
+
+	parts[0].name = "u-boot";
+	parts[0].offset = 0;
+	parts[0].size = offset;
+	parts[0].mask_flags = MTD_WRITEABLE;
+
+	parts[1].name = "kernel";
+	parts[1].offset = offset;
+	parts[1].size = rootfs_offset - offset;
+
+	parts[2].name = "rootfs";
+	parts[2].offset = rootfs_offset;
+	parts[2].size = art_offset - rootfs_offset;
+
+	parts[3].name = "art";
+	parts[3].offset = art_offset;
+	parts[3].size = TPLINK_ART_LEN;
+	parts[3].mask_flags = MTD_WRITEABLE;
+
+	parts[4].name = "firmware";
+	parts[4].offset = offset;
+	parts[4].size = art_offset - offset;
+
+	vfree(header);
+
+	*pparts = parts;
+	return nr_parts;
+
+err_free_parts:
+	kfree(parts);
+err:
+	*pparts = NULL;
+	return ret;
+}
+
+static int tplink_parse_partitions(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_KERNEL_OFFS);
+}
+
+static int tplink_parse_64k_partitions(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_64K_KERNEL_OFFS);
+}
+
+static struct mtd_part_parser tplink_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_partitions,
+	.name		= "tp-link",
+};
+
+static struct mtd_part_parser tplink_64k_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_64k_partitions,
+	.name		= "tp-link-64k",
+};
+
+static int __init tplink_parser_init(void)
+{
+	register_mtd_parser(&tplink_parser);
+	register_mtd_parser(&tplink_64k_parser);
+
+	return 0;
+}
+
+module_init(tplink_parser_init);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
diff --git a/target/linux/ath79/files/drivers/net/dsa/mv88e6063.c b/target/linux/ath79/files/drivers/net/dsa/mv88e6063.c
new file mode 100644
index 0000000000..5b6da713f4
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/dsa/mv88e6063.c
@@ -0,0 +1,289 @@
+/*
+ * net/dsa/mv88e6063.c - Driver for Marvell 88e6063 switch chips
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This driver was base on: net/dsa/mv88e6060.c
+ *   net/dsa/mv88e6063.c - Driver for Marvell 88e6060 switch chips
+ *   Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <net/dsa.h>
+#include <linux/version.h>
+
+#define REG_BASE		0x10
+#define REG_PHY(p)		(REG_BASE + (p))
+#define REG_PORT(p)		(REG_BASE + 8 + (p))
+#define REG_GLOBAL		(REG_BASE + 0x0f)
+#define NUM_PORTS		7
+
+static int reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_read(bus, addr, reg);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->dev);
+	return mdiobus_read(bus, addr, reg);
+#endif
+}
+
+#define REG_READ(addr, reg)					\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_read(ds, addr, reg);		\
+		if (__ret < 0)					\
+			return __ret;				\
+		__ret;						\
+	})
+
+
+static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_write(bus, addr, reg, val);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->dev);
+	return mdiobus_write(bus, addr, reg, val);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+static enum dsa_tag_protocol mv88e6063_get_tag_protocol(struct dsa_switch *ds)
+{
+	return DSA_TAG_PROTO_TRAILER;
+}
+#endif
+
+#define REG_WRITE(addr, reg, val)				\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_write(ds, addr, reg, val);		\
+		if (__ret < 0)					\
+			return __ret;				\
+	})
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+static char *mv88e6063_drv_probe(struct device *host_dev, int sw_addr)
+#else
+static const char *mv88e6063_drv_probe(struct device *dsa_dev,
+				       struct device *host_dev, int sw_addr,
+				       void **_priv)
+#endif
+{
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(host_dev);
+	int ret;
+
+	if (!bus)
+		return NULL;
+
+	ret = mdiobus_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0) {
+		ret &= 0xfff0;
+		if (ret == 0x1530)
+			return "Marvell 88E6063";
+	}
+
+	return NULL;
+}
+
+static int mv88e6063_switch_reset(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Set all ports to the disabled state.
+	 */
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = REG_READ(REG_PORT(i), 0x04);
+		REG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);
+	}
+
+	/*
+	 * Wait for transmit queues to drain.
+	 */
+	msleep(2);
+
+	/*
+	 * Reset the switch.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0xa130);
+
+	/*
+	 * Wait up to one second for reset to complete.
+	 */
+	for (i = 0; i < 1000; i++) {
+		ret = REG_READ(REG_GLOBAL, 0x00);
+		if ((ret & 0x8000) == 0x0000)
+			break;
+
+		msleep(1);
+	}
+	if (i == 1000)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int mv88e6063_setup_global(struct dsa_switch *ds)
+{
+	/*
+	 * Disable discarding of frames with excessive collisions,
+	 * set the maximum frame size to 1536 bytes, and mask all
+	 * interrupt sources.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x04, 0x0800);
+
+	/*
+	 * Enable automatic address learning, set the address
+	 * database size to 1024 entries, and set the default aging
+	 * time to 5 minutes.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0x2130);
+
+	return 0;
+}
+
+static int mv88e6063_setup_port(struct dsa_switch *ds, int p)
+{
+	int addr = REG_PORT(p);
+
+	/*
+	 * Do not force flow control, disable Ingress and Egress
+	 * Header tagging, disable VLAN tunneling, and set the port
+	 * state to Forwarding.  Additionally, if this is the CPU
+	 * port, enable Ingress and Egress Trailer tagging mode.
+	 */
+	REG_WRITE(addr, 0x04, dsa_is_cpu_port(ds, p) ?  0x4103 : 0x0003);
+
+	/*
+	 * Port based VLAN map: give each port its own address
+	 * database, allow the CPU port to talk to each of the 'real'
+	 * ports, and allow each of the 'real' ports to only talk to
+	 * the CPU port.
+	 */
+	REG_WRITE(addr, 0x06,
+			((p & 0xf) << 12) |
+			 (dsa_is_cpu_port(ds, p) ?
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+				ds->phys_port_mask :
+#else
+				ds->enabled_port_mask :
+#endif
+				(1 << ds->dst->cpu_port)));
+
+	/*
+	 * Port Association Vector: when learning source addresses
+	 * of packets, add the address to the address database using
+	 * a port bitmap that has only the bit for this port set and
+	 * the other bits clear.
+	 */
+	REG_WRITE(addr, 0x0b, 1 << p);
+
+	return 0;
+}
+
+static int mv88e6063_setup(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	ret = mv88e6063_switch_reset(ds);
+	if (ret < 0)
+		return ret;
+
+	/* @@@ initialise atu */
+
+	ret = mv88e6063_setup_global(ds);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = mv88e6063_setup_port(ds, i);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mv88e6063_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	REG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);
+	REG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);
+	REG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);
+
+	return 0;
+}
+
+static int mv88e6063_port_to_phy_addr(int port)
+{
+	if (port >= 0 && port <= NUM_PORTS)
+		return REG_PHY(port);
+	return -1;
+}
+
+static int mv88e6063_phy_read(struct dsa_switch *ds, int port, int regnum)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_read(ds, addr, regnum);
+}
+
+static int
+mv88e6063_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_write(ds, addr, regnum, val);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+static struct dsa_switch_driver mv88e6063_switch_ops = {
+#else
+static struct dsa_switch_ops mv88e6063_switch_ops = {
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	.tag_protocol	= htons(ETH_P_TRAILER),
+#else
+	.get_tag_protocol = mv88e6063_get_tag_protocol,
+#endif
+	.probe		= mv88e6063_drv_probe,
+	.setup		= mv88e6063_setup,
+	.set_addr	= mv88e6063_set_addr,
+	.phy_read	= mv88e6063_phy_read,
+	.phy_write	= mv88e6063_phy_write,
+};
+
+static int __init mv88e6063_init(void)
+{
+	register_switch_driver(&mv88e6063_switch_ops);
+	return 0;
+}
+module_init(mv88e6063_init);
+
+static void __exit mv88e6063_cleanup(void)
+{
+	unregister_switch_driver(&mv88e6063_switch_ops);
+}
+module_exit(mv88e6063_cleanup);
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Kconfig b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Kconfig
new file mode 100644
index 0000000000..4df2d21e34
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Kconfig
@@ -0,0 +1,25 @@
+config AG71XX
+	tristate "Atheros AR7XXX/AR9XXX built-in ethernet mac support"
+	depends on ATH79
+	select PHYLIB
+	help
+	  If you wish to compile a kernel for AR7XXX/91XXX and enable
+	  ethernet support, then you should always answer Y to this.
+
+if AG71XX
+
+config AG71XX_DEBUG
+	bool "Atheros AR71xx built-in ethernet driver debugging"
+	default n
+	help
+	  Atheros AR71xx built-in ethernet driver debugging messages.
+
+config AG71XX_DEBUG_FS
+	bool "Atheros AR71xx built-in ethernet driver debugfs support"
+	depends on DEBUG_FS
+	default n
+	help
+	  Say Y, if you need access to various statistics provided by
+	  the ag71xx driver.
+
+endif
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Makefile b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Makefile
new file mode 100644
index 0000000000..7f396ad46e
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for the Atheros AR71xx built-in ethernet macs
+#
+
+ag71xx-y	+= ag71xx_main.o
+ag71xx-y	+= ag71xx_ethtool.o
+ag71xx-y	+= ag71xx_phy.o
+ag71xx-y	+= ag71xx_mdio.o
+ag71xx-y	+= ag71xx_ar7240.o
+
+ag71xx-$(CONFIG_AG71XX_DEBUG_FS)	+= ag71xx_debugfs.o
+
+obj-$(CONFIG_AG71XX)	+= ag71xx.o
+
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
new file mode 100644
index 0000000000..22b22522a3
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
@@ -0,0 +1,453 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AG71XX_H
+#define __AG71XX_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/phy.h>
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+#include <linux/reset.h>
+#include <linux/of.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#include <linux/bitops.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define AG71XX_DRV_NAME		"ag71xx"
+
+/*
+ * For our NAPI weight bigger does *NOT* mean better - it means more
+ * D-cache misses and lots more wasted cycles than we'll ever
+ * possibly gain from saving instructions.
+ */
+#define AG71XX_NAPI_WEIGHT	32
+#define AG71XX_OOM_REFILL	(1 + HZ/10)
+
+#define AG71XX_INT_ERR	(AG71XX_INT_RX_BE | AG71XX_INT_TX_BE)
+#define AG71XX_INT_TX	(AG71XX_INT_TX_PS)
+#define AG71XX_INT_RX	(AG71XX_INT_RX_PR | AG71XX_INT_RX_OF)
+
+#define AG71XX_INT_POLL	(AG71XX_INT_RX | AG71XX_INT_TX)
+#define AG71XX_INT_INIT	(AG71XX_INT_ERR | AG71XX_INT_POLL)
+
+#define AG71XX_TX_MTU_LEN	1540
+
+#define AG71XX_TX_RING_SPLIT		512
+#define AG71XX_TX_RING_DS_PER_PKT	DIV_ROUND_UP(AG71XX_TX_MTU_LEN, \
+						     AG71XX_TX_RING_SPLIT)
+#define AG71XX_TX_RING_SIZE_DEFAULT	128
+#define AG71XX_RX_RING_SIZE_DEFAULT	256
+
+#define AG71XX_TX_RING_SIZE_MAX		128
+#define AG71XX_RX_RING_SIZE_MAX		256
+
+#ifdef CONFIG_AG71XX_DEBUG
+#define DBG(fmt, args...)	pr_debug(fmt, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ag71xx_assert(_cond)						\
+do {									\
+	if (_cond)							\
+		break;							\
+	printk("%s,%d: assertion failed\n", __FILE__, __LINE__);	\
+	BUG();								\
+} while (0)
+
+struct ag71xx_desc {
+	u32	data;
+	u32	ctrl;
+#define DESC_EMPTY	BIT(31)
+#define DESC_MORE	BIT(24)
+#define DESC_PKTLEN_M	0xfff
+	u32	next;
+	u32	pad;
+} __attribute__((aligned(4)));
+
+#define AG71XX_DESC_SIZE	roundup(sizeof(struct ag71xx_desc), \
+					L1_CACHE_BYTES)
+
+struct ag71xx_buf {
+	union {
+		struct sk_buff	*skb;
+		void		*rx_buf;
+	};
+	union {
+		dma_addr_t	dma_addr;
+		unsigned int		len;
+	};
+};
+
+struct ag71xx_ring {
+	struct ag71xx_buf	*buf;
+	u8			*descs_cpu;
+	dma_addr_t		descs_dma;
+	u16			desc_split;
+	u16			order;
+	unsigned int		curr;
+	unsigned int		dirty;
+};
+
+struct ag71xx_int_stats {
+	unsigned long		rx_pr;
+	unsigned long		rx_be;
+	unsigned long		rx_of;
+	unsigned long		tx_ps;
+	unsigned long		tx_be;
+	unsigned long		tx_ur;
+	unsigned long		total;
+};
+
+struct ag71xx_napi_stats {
+	unsigned long		napi_calls;
+	unsigned long		rx_count;
+	unsigned long		rx_packets;
+	unsigned long		rx_packets_max;
+	unsigned long		tx_count;
+	unsigned long		tx_packets;
+	unsigned long		tx_packets_max;
+
+	unsigned long		rx[AG71XX_NAPI_WEIGHT + 1];
+	unsigned long		tx[AG71XX_NAPI_WEIGHT + 1];
+};
+
+struct ag71xx_debug {
+	struct dentry		*debugfs_dir;
+
+	struct ag71xx_int_stats int_stats;
+	struct ag71xx_napi_stats napi_stats;
+};
+
+struct ag71xx {
+	/*
+	 * Critical data related to the per-packet data path are clustered
+	 * early in this structure to help improve the D-cache footprint.
+	 */
+	struct ag71xx_ring	rx_ring ____cacheline_aligned;
+	struct ag71xx_ring	tx_ring ____cacheline_aligned;
+
+	u16			desc_pktlen_mask;
+	u16			rx_buf_size;
+	u8			rx_buf_offset;
+	u8			tx_hang_workaround:1;
+
+	struct net_device	*dev;
+	struct platform_device  *pdev;
+	spinlock_t		lock;
+	struct napi_struct	napi;
+	u32			msg_enable;
+
+	/*
+	 * From this point onwards we're not looking at per-packet fields.
+	 */
+	void __iomem		*mac_base;
+	void __iomem		*mii_base;
+	struct regmap		*mii_regmap;
+
+	struct ag71xx_desc	*stop_desc;
+	dma_addr_t		stop_desc_dma;
+
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	void			*phy_priv;
+	int			phy_if_mode;
+
+	unsigned int		link;
+	unsigned int		speed;
+	int			duplex;
+
+	struct delayed_work	restart_work;
+	struct timer_list	oom_timer;
+
+	struct reset_control *mac_reset;
+	struct reset_control *phy_reset;
+	struct reset_control *mdio_reset;
+
+	u32			fifodata[3];
+	u32			plldata[3];
+	u32			pllreg[3];
+	struct regmap		*pllregmap;
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+	struct ag71xx_debug	debug;
+#endif
+};
+
+extern struct ethtool_ops ag71xx_ethtool_ops;
+void ag71xx_link_adjust(struct ag71xx *ag);
+
+int ag71xx_phy_connect(struct ag71xx *ag);
+void ag71xx_phy_disconnect(struct ag71xx *ag);
+
+static inline int ag71xx_desc_empty(struct ag71xx_desc *desc)
+{
+	return (desc->ctrl & DESC_EMPTY) != 0;
+}
+
+static inline struct ag71xx_desc *
+ag71xx_ring_desc(struct ag71xx_ring *ring, int idx)
+{
+	return (struct ag71xx_desc *) &ring->descs_cpu[idx * AG71XX_DESC_SIZE];
+}
+
+static inline int
+ag71xx_ring_size_order(int size)
+{
+	return fls(size - 1);
+}
+
+/* Register offsets */
+#define AG71XX_REG_MAC_CFG1	0x0000
+#define AG71XX_REG_MAC_CFG2	0x0004
+#define AG71XX_REG_MAC_IPG	0x0008
+#define AG71XX_REG_MAC_HDX	0x000c
+#define AG71XX_REG_MAC_MFL	0x0010
+#define AG71XX_REG_MII_CFG	0x0020
+#define AG71XX_REG_MII_CMD	0x0024
+#define AG71XX_REG_MII_ADDR	0x0028
+#define AG71XX_REG_MII_CTRL	0x002c
+#define AG71XX_REG_MII_STATUS	0x0030
+#define AG71XX_REG_MII_IND	0x0034
+#define AG71XX_REG_MAC_IFCTL	0x0038
+#define AG71XX_REG_MAC_ADDR1	0x0040
+#define AG71XX_REG_MAC_ADDR2	0x0044
+#define AG71XX_REG_FIFO_CFG0	0x0048
+#define AG71XX_REG_FIFO_CFG1	0x004c
+#define AG71XX_REG_FIFO_CFG2	0x0050
+#define AG71XX_REG_FIFO_CFG3	0x0054
+#define AG71XX_REG_FIFO_CFG4	0x0058
+#define AG71XX_REG_FIFO_CFG5	0x005c
+#define AG71XX_REG_FIFO_RAM0	0x0060
+#define AG71XX_REG_FIFO_RAM1	0x0064
+#define AG71XX_REG_FIFO_RAM2	0x0068
+#define AG71XX_REG_FIFO_RAM3	0x006c
+#define AG71XX_REG_FIFO_RAM4	0x0070
+#define AG71XX_REG_FIFO_RAM5	0x0074
+#define AG71XX_REG_FIFO_RAM6	0x0078
+#define AG71XX_REG_FIFO_RAM7	0x007c
+
+#define AG71XX_REG_TX_CTRL	0x0180
+#define AG71XX_REG_TX_DESC	0x0184
+#define AG71XX_REG_TX_STATUS	0x0188
+#define AG71XX_REG_RX_CTRL	0x018c
+#define AG71XX_REG_RX_DESC	0x0190
+#define AG71XX_REG_RX_STATUS	0x0194
+#define AG71XX_REG_INT_ENABLE	0x0198
+#define AG71XX_REG_INT_STATUS	0x019c
+
+#define AG71XX_REG_FIFO_DEPTH	0x01a8
+#define AG71XX_REG_RX_SM	0x01b0
+#define AG71XX_REG_TX_SM	0x01b4
+
+#define MAC_CFG1_TXE		BIT(0)	/* Tx Enable */
+#define MAC_CFG1_STX		BIT(1)	/* Synchronize Tx Enable */
+#define MAC_CFG1_RXE		BIT(2)	/* Rx Enable */
+#define MAC_CFG1_SRX		BIT(3)	/* Synchronize Rx Enable */
+#define MAC_CFG1_TFC		BIT(4)	/* Tx Flow Control Enable */
+#define MAC_CFG1_RFC		BIT(5)	/* Rx Flow Control Enable */
+#define MAC_CFG1_LB		BIT(8)	/* Loopback mode */
+#define MAC_CFG1_SR		BIT(31)	/* Soft Reset */
+
+#define MAC_CFG2_FDX		BIT(0)
+#define MAC_CFG2_CRC_EN		BIT(1)
+#define MAC_CFG2_PAD_CRC_EN	BIT(2)
+#define MAC_CFG2_LEN_CHECK	BIT(4)
+#define MAC_CFG2_HUGE_FRAME_EN	BIT(5)
+#define MAC_CFG2_IF_1000	BIT(9)
+#define MAC_CFG2_IF_10_100	BIT(8)
+
+#define FIFO_CFG0_WTM		BIT(0)	/* Watermark Module */
+#define FIFO_CFG0_RXS		BIT(1)	/* Rx System Module */
+#define FIFO_CFG0_RXF		BIT(2)	/* Rx Fabric Module */
+#define FIFO_CFG0_TXS		BIT(3)	/* Tx System Module */
+#define FIFO_CFG0_TXF		BIT(4)	/* Tx Fabric Module */
+#define FIFO_CFG0_ALL	(FIFO_CFG0_WTM | FIFO_CFG0_RXS | FIFO_CFG0_RXF \
+			| FIFO_CFG0_TXS | FIFO_CFG0_TXF)
+
+#define FIFO_CFG0_ENABLE_SHIFT	8
+
+#define FIFO_CFG4_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG4_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG4_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG4_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG4_CR		BIT(4)	/* CRC error */
+#define FIFO_CFG4_LM		BIT(5)	/* Length Mismatch */
+#define FIFO_CFG4_LO		BIT(6)	/* Length out of range */
+#define FIFO_CFG4_OK		BIT(7)	/* Packet is OK */
+#define FIFO_CFG4_MC		BIT(8)	/* Multicast Packet */
+#define FIFO_CFG4_BC		BIT(9)	/* Broadcast Packet */
+#define FIFO_CFG4_DR		BIT(10)	/* Dribble */
+#define FIFO_CFG4_LE		BIT(11)	/* Long Event */
+#define FIFO_CFG4_CF		BIT(12)	/* Control Frame */
+#define FIFO_CFG4_PF		BIT(13)	/* Pause Frame */
+#define FIFO_CFG4_UO		BIT(14)	/* Unsupported Opcode */
+#define FIFO_CFG4_VT		BIT(15)	/* VLAN tag detected */
+#define FIFO_CFG4_FT		BIT(16)	/* Frame Truncated */
+#define FIFO_CFG4_UC		BIT(17)	/* Unicast Packet */
+
+#define FIFO_CFG5_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG5_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG5_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG5_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG5_LM		BIT(4)	/* Length Mismatch */
+#define FIFO_CFG5_LO		BIT(5)	/* Length Out of Range */
+#define FIFO_CFG5_OK		BIT(6)	/* Packet is OK */
+#define FIFO_CFG5_MC		BIT(7)	/* Multicast Packet */
+#define FIFO_CFG5_BC		BIT(8)	/* Broadcast Packet */
+#define FIFO_CFG5_DR		BIT(9)	/* Dribble */
+#define FIFO_CFG5_CF		BIT(10)	/* Control Frame */
+#define FIFO_CFG5_PF		BIT(11)	/* Pause Frame */
+#define FIFO_CFG5_UO		BIT(12)	/* Unsupported Opcode */
+#define FIFO_CFG5_VT		BIT(13)	/* VLAN tag detected */
+#define FIFO_CFG5_LE		BIT(14)	/* Long Event */
+#define FIFO_CFG5_FT		BIT(15)	/* Frame Truncated */
+#define FIFO_CFG5_16		BIT(16)	/* unknown */
+#define FIFO_CFG5_17		BIT(17)	/* unknown */
+#define FIFO_CFG5_SF		BIT(18)	/* Short Frame */
+#define FIFO_CFG5_BM		BIT(19)	/* Byte Mode */
+
+#define AG71XX_INT_TX_PS	BIT(0)
+#define AG71XX_INT_TX_UR	BIT(1)
+#define AG71XX_INT_TX_BE	BIT(3)
+#define AG71XX_INT_RX_PR	BIT(4)
+#define AG71XX_INT_RX_OF	BIT(6)
+#define AG71XX_INT_RX_BE	BIT(7)
+
+#define MAC_IFCTL_SPEED		BIT(16)
+
+#define MII_CFG_CLK_DIV_4	0
+#define MII_CFG_CLK_DIV_6	2
+#define MII_CFG_CLK_DIV_8	3
+#define MII_CFG_CLK_DIV_10	4
+#define MII_CFG_CLK_DIV_14	5
+#define MII_CFG_CLK_DIV_20	6
+#define MII_CFG_CLK_DIV_28	7
+#define MII_CFG_CLK_DIV_34	8
+#define MII_CFG_CLK_DIV_42	9
+#define MII_CFG_CLK_DIV_50	10
+#define MII_CFG_CLK_DIV_58	11
+#define MII_CFG_CLK_DIV_66	12
+#define MII_CFG_CLK_DIV_74	13
+#define MII_CFG_CLK_DIV_82	14
+#define MII_CFG_CLK_DIV_98	15
+#define MII_CFG_RESET		BIT(31)
+
+#define MII_CMD_WRITE		0x0
+#define MII_CMD_READ		0x1
+#define MII_ADDR_SHIFT		8
+#define MII_IND_BUSY		BIT(0)
+#define MII_IND_INVALID		BIT(2)
+
+#define TX_CTRL_TXE		BIT(0)	/* Tx Enable */
+
+#define TX_STATUS_PS		BIT(0)	/* Packet Sent */
+#define TX_STATUS_UR		BIT(1)	/* Tx Underrun */
+#define TX_STATUS_BE		BIT(3)	/* Bus Error */
+
+#define RX_CTRL_RXE		BIT(0)	/* Rx Enable */
+
+#define RX_STATUS_PR		BIT(0)	/* Packet Received */
+#define RX_STATUS_OF		BIT(2)	/* Rx Overflow */
+#define RX_STATUS_BE		BIT(3)	/* Bus Error */
+
+static inline void ag71xx_wr(struct ag71xx *ag, unsigned reg, u32 value)
+{
+	__raw_writel(value, ag->mac_base + reg);
+	/* flush write */
+	(void) __raw_readl(ag->mac_base + reg);
+}
+
+static inline u32 ag71xx_rr(struct ag71xx *ag, unsigned reg)
+{
+	return __raw_readl(ag->mac_base + reg);
+}
+
+static inline void ag71xx_sb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) | mask, r);
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline void ag71xx_cb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) & ~mask, r);
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline void ag71xx_int_enable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_sb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+static inline void ag71xx_int_disable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_cb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+int ag71xx_debugfs_root_init(void);
+void ag71xx_debugfs_root_exit(void);
+int ag71xx_debugfs_init(struct ag71xx *ag);
+void ag71xx_debugfs_exit(struct ag71xx *ag);
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status);
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx);
+#else
+static inline int ag71xx_debugfs_root_init(void) { return 0; }
+static inline void ag71xx_debugfs_root_exit(void) {}
+static inline int ag71xx_debugfs_init(struct ag71xx *ag) { return 0; }
+static inline void ag71xx_debugfs_exit(struct ag71xx *ag) {}
+static inline void ag71xx_debugfs_update_int_stats(struct ag71xx *ag,
+						   u32 status) {}
+static inline void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag,
+						    int rx, int tx) {}
+#endif /* CONFIG_AG71XX_DEBUG_FS */
+
+int ag71xx_ar7240_init(struct ag71xx *ag, struct device_node *np);
+void ag71xx_ar7240_cleanup(struct ag71xx *ag);
+void ag71xx_ar7240_start(struct ag71xx *ag);
+
+int ag71xx_mdio_init(struct ag71xx *ag);
+void ag71xx_mdio_cleanup(struct ag71xx *ag);
+int ag71xx_mdio_mii_read(struct mii_bus *bus, int addr, int reg);
+int ag71xx_mdio_mii_write(struct mii_bus *bus, int addr, int reg, u16 val);
+
+int ar7240sw_phy_read(struct mii_bus *mii, int addr, int reg);
+int ar7240sw_phy_write(struct mii_bus *mii, int addr, int reg, u16 val);
+
+#endif /* _AG71XX_H */
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
new file mode 100644
index 0000000000..52c0f964cf
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
@@ -0,0 +1,1340 @@
+/*
+ *  Driver for the built-in ethernet switch of the Atheros AR7240 SoC
+ *  Copyright (c) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (c) 2010 Felix Fietkau <nbd@nbd.name>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/mii.h>
+#include <linux/bitops.h>
+#include <linux/switch.h>
+#include "ag71xx.h"
+
+#define BITM(_count)	(BIT(_count) - 1)
+#define BITS(_shift, _count)	(BITM(_count) << _shift)
+
+#define AR7240_REG_MASK_CTRL		0x00
+#define AR7240_MASK_CTRL_REVISION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_S	8
+#define   AR7240_MASK_CTRL_VERSION_AR7240 0x01
+#define   AR7240_MASK_CTRL_VERSION_AR934X 0x02
+#define AR7240_MASK_CTRL_SOFT_RESET	BIT(31)
+
+#define AR7240_REG_MAC_ADDR0		0x20
+#define AR7240_REG_MAC_ADDR1		0x24
+
+#define AR7240_REG_FLOOD_MASK		0x2c
+#define AR7240_FLOOD_MASK_BROAD_TO_CPU	BIT(26)
+
+#define AR7240_REG_GLOBAL_CTRL		0x30
+#define AR7240_GLOBAL_CTRL_MTU_M	BITM(11)
+#define AR9340_GLOBAL_CTRL_MTU_M	BITM(14)
+
+#define AR7240_REG_VTU			0x0040
+#define   AR7240_VTU_OP			BITM(3)
+#define   AR7240_VTU_OP_NOOP		0x0
+#define   AR7240_VTU_OP_FLUSH		0x1
+#define   AR7240_VTU_OP_LOAD		0x2
+#define   AR7240_VTU_OP_PURGE		0x3
+#define   AR7240_VTU_OP_REMOVE_PORT	0x4
+#define   AR7240_VTU_ACTIVE		BIT(3)
+#define   AR7240_VTU_FULL		BIT(4)
+#define   AR7240_VTU_PORT		BITS(8, 4)
+#define   AR7240_VTU_PORT_S		8
+#define   AR7240_VTU_VID		BITS(16, 12)
+#define   AR7240_VTU_VID_S		16
+#define   AR7240_VTU_PRIO		BITS(28, 3)
+#define   AR7240_VTU_PRIO_S		28
+#define   AR7240_VTU_PRIO_EN		BIT(31)
+
+#define AR7240_REG_VTU_DATA		0x0044
+#define   AR7240_VTUDATA_MEMBER		BITS(0, 10)
+#define   AR7240_VTUDATA_VALID		BIT(11)
+
+#define AR7240_REG_ATU			0x50
+#define AR7240_ATU_FLUSH_ALL		0x1
+
+#define AR7240_REG_AT_CTRL		0x5c
+#define AR7240_AT_CTRL_AGE_TIME		BITS(0, 15)
+#define AR7240_AT_CTRL_AGE_EN		BIT(17)
+#define AR7240_AT_CTRL_LEARN_CHANGE	BIT(18)
+#define AR7240_AT_CTRL_RESERVED		BIT(19)
+#define AR7240_AT_CTRL_ARP_EN		BIT(20)
+
+#define AR7240_REG_TAG_PRIORITY		0x70
+
+#define AR7240_REG_SERVICE_TAG		0x74
+#define AR7240_SERVICE_TAG_M		BITM(16)
+
+#define AR7240_REG_CPU_PORT		0x78
+#define AR7240_MIRROR_PORT_S		4
+#define AR7240_MIRROR_PORT_M		BITM(4)
+#define AR7240_CPU_PORT_EN		BIT(8)
+
+#define AR7240_REG_MIB_FUNCTION0	0x80
+#define AR7240_MIB_TIMER_M		BITM(16)
+#define AR7240_MIB_AT_HALF_EN		BIT(16)
+#define AR7240_MIB_BUSY			BIT(17)
+#define AR7240_MIB_FUNC_S		24
+#define AR7240_MIB_FUNC_M		BITM(3)
+#define AR7240_MIB_FUNC_NO_OP		0x0
+#define AR7240_MIB_FUNC_FLUSH		0x1
+#define AR7240_MIB_FUNC_CAPTURE		0x3
+
+#define AR7240_REG_MDIO_CTRL		0x98
+#define AR7240_MDIO_CTRL_DATA_M		BITM(16)
+#define AR7240_MDIO_CTRL_REG_ADDR_S	16
+#define AR7240_MDIO_CTRL_PHY_ADDR_S	21
+#define AR7240_MDIO_CTRL_CMD_WRITE	0
+#define AR7240_MDIO_CTRL_CMD_READ	BIT(27)
+#define AR7240_MDIO_CTRL_MASTER_EN	BIT(30)
+#define AR7240_MDIO_CTRL_BUSY		BIT(31)
+
+#define AR7240_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR7240_REG_PORT_STATUS(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x00)
+#define AR7240_PORT_STATUS_SPEED_S	0
+#define AR7240_PORT_STATUS_SPEED_M	BITM(2)
+#define AR7240_PORT_STATUS_SPEED_10	0
+#define AR7240_PORT_STATUS_SPEED_100	1
+#define AR7240_PORT_STATUS_SPEED_1000	2
+#define AR7240_PORT_STATUS_TXMAC	BIT(2)
+#define AR7240_PORT_STATUS_RXMAC	BIT(3)
+#define AR7240_PORT_STATUS_TXFLOW	BIT(4)
+#define AR7240_PORT_STATUS_RXFLOW	BIT(5)
+#define AR7240_PORT_STATUS_DUPLEX	BIT(6)
+#define AR7240_PORT_STATUS_LINK_UP	BIT(8)
+#define AR7240_PORT_STATUS_LINK_AUTO	BIT(9)
+#define AR7240_PORT_STATUS_LINK_PAUSE	BIT(10)
+
+#define AR7240_REG_PORT_CTRL(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x04)
+#define AR7240_PORT_CTRL_STATE_M	BITM(3)
+#define	AR7240_PORT_CTRL_STATE_DISABLED	0
+#define AR7240_PORT_CTRL_STATE_BLOCK	1
+#define AR7240_PORT_CTRL_STATE_LISTEN	2
+#define AR7240_PORT_CTRL_STATE_LEARN	3
+#define AR7240_PORT_CTRL_STATE_FORWARD	4
+#define AR7240_PORT_CTRL_LEARN_LOCK	BIT(7)
+#define AR7240_PORT_CTRL_VLAN_MODE_S	8
+#define AR7240_PORT_CTRL_VLAN_MODE_KEEP	0
+#define AR7240_PORT_CTRL_VLAN_MODE_STRIP 1
+#define AR7240_PORT_CTRL_VLAN_MODE_ADD	2
+#define AR7240_PORT_CTRL_VLAN_MODE_DOUBLE_TAG 3
+#define AR7240_PORT_CTRL_IGMP_SNOOP	BIT(10)
+#define AR7240_PORT_CTRL_HEADER		BIT(11)
+#define AR7240_PORT_CTRL_MAC_LOOP	BIT(12)
+#define AR7240_PORT_CTRL_SINGLE_VLAN	BIT(13)
+#define AR7240_PORT_CTRL_LEARN		BIT(14)
+#define AR7240_PORT_CTRL_DOUBLE_TAG	BIT(15)
+#define AR7240_PORT_CTRL_MIRROR_TX	BIT(16)
+#define AR7240_PORT_CTRL_MIRROR_RX	BIT(17)
+
+#define AR7240_REG_PORT_VLAN(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x08)
+
+#define AR7240_PORT_VLAN_DEFAULT_ID_S	0
+#define AR7240_PORT_VLAN_DEST_PORTS_S	16
+#define AR7240_PORT_VLAN_MODE_S		30
+#define AR7240_PORT_VLAN_MODE_PORT_ONLY	0
+#define AR7240_PORT_VLAN_MODE_PORT_FALLBACK	1
+#define AR7240_PORT_VLAN_MODE_VLAN_ONLY	2
+#define AR7240_PORT_VLAN_MODE_SECURE	3
+
+
+#define AR7240_REG_STATS_BASE(_port)	(0x20000 + (_port) * 0x100)
+
+#define AR7240_STATS_RXBROAD		0x00
+#define AR7240_STATS_RXPAUSE		0x04
+#define AR7240_STATS_RXMULTI		0x08
+#define AR7240_STATS_RXFCSERR		0x0c
+#define AR7240_STATS_RXALIGNERR		0x10
+#define AR7240_STATS_RXRUNT		0x14
+#define AR7240_STATS_RXFRAGMENT		0x18
+#define AR7240_STATS_RX64BYTE		0x1c
+#define AR7240_STATS_RX128BYTE		0x20
+#define AR7240_STATS_RX256BYTE		0x24
+#define AR7240_STATS_RX512BYTE		0x28
+#define AR7240_STATS_RX1024BYTE		0x2c
+#define AR7240_STATS_RX1518BYTE		0x30
+#define AR7240_STATS_RXMAXBYTE		0x34
+#define AR7240_STATS_RXTOOLONG		0x38
+#define AR7240_STATS_RXGOODBYTE		0x3c
+#define AR7240_STATS_RXBADBYTE		0x44
+#define AR7240_STATS_RXOVERFLOW		0x4c
+#define AR7240_STATS_FILTERED		0x50
+#define AR7240_STATS_TXBROAD		0x54
+#define AR7240_STATS_TXPAUSE		0x58
+#define AR7240_STATS_TXMULTI		0x5c
+#define AR7240_STATS_TXUNDERRUN		0x60
+#define AR7240_STATS_TX64BYTE		0x64
+#define AR7240_STATS_TX128BYTE		0x68
+#define AR7240_STATS_TX256BYTE		0x6c
+#define AR7240_STATS_TX512BYTE		0x70
+#define AR7240_STATS_TX1024BYTE		0x74
+#define AR7240_STATS_TX1518BYTE		0x78
+#define AR7240_STATS_TXMAXBYTE		0x7c
+#define AR7240_STATS_TXOVERSIZE		0x80
+#define AR7240_STATS_TXBYTE		0x84
+#define AR7240_STATS_TXCOLLISION	0x8c
+#define AR7240_STATS_TXABORTCOL		0x90
+#define AR7240_STATS_TXMULTICOL		0x94
+#define AR7240_STATS_TXSINGLECOL	0x98
+#define AR7240_STATS_TXEXCDEFER		0x9c
+#define AR7240_STATS_TXDEFER		0xa0
+#define AR7240_STATS_TXLATECOL		0xa4
+
+#define AR7240_PORT_CPU		0
+#define AR7240_NUM_PORTS	6
+#define AR7240_NUM_PHYS		5
+
+#define AR7240_PHY_ID1		0x004d
+#define AR7240_PHY_ID2		0xd041
+
+#define AR934X_PHY_ID1		0x004d
+#define AR934X_PHY_ID2		0xd042
+
+#define AR7240_MAX_VLANS	16
+
+#define AR934X_REG_OPER_MODE0		0x04
+#define   AR934X_OPER_MODE0_MAC_GMII_EN	BIT(6)
+#define   AR934X_OPER_MODE0_PHY_MII_EN	BIT(10)
+
+#define AR934X_REG_OPER_MODE1		0x08
+#define   AR934X_REG_OPER_MODE1_PHY4_MII_EN	BIT(28)
+
+#define AR934X_REG_FLOOD_MASK		0x2c
+#define   AR934X_FLOOD_MASK_MC_DP(_p)	BIT(16 + (_p))
+#define   AR934X_FLOOD_MASK_BC_DP(_p)	BIT(25 + (_p))
+
+#define AR934X_REG_QM_CTRL		0x3c
+#define   AR934X_QM_CTRL_ARP_EN		BIT(15)
+
+#define AR934X_REG_AT_CTRL		0x5c
+#define   AR934X_AT_CTRL_AGE_TIME	BITS(0, 15)
+#define   AR934X_AT_CTRL_AGE_EN		BIT(17)
+#define   AR934X_AT_CTRL_LEARN_CHANGE	BIT(18)
+
+#define AR934X_MIB_ENABLE		BIT(30)
+
+#define AR934X_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR934X_REG_PORT_VLAN1(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x08)
+#define   AR934X_PORT_VLAN1_DEFAULT_SVID_S		0
+#define   AR934X_PORT_VLAN1_FORCE_DEFAULT_VID_EN 	BIT(12)
+#define   AR934X_PORT_VLAN1_PORT_TLS_MODE		BIT(13)
+#define   AR934X_PORT_VLAN1_PORT_VLAN_PROP_EN		BIT(14)
+#define   AR934X_PORT_VLAN1_PORT_CLONE_EN		BIT(15)
+#define   AR934X_PORT_VLAN1_DEFAULT_CVID_S		16
+#define   AR934X_PORT_VLAN1_FORCE_PORT_VLAN_EN		BIT(28)
+#define   AR934X_PORT_VLAN1_ING_PORT_PRI_S		29
+
+#define AR934X_REG_PORT_VLAN2(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x0c)
+#define   AR934X_PORT_VLAN2_PORT_VID_MEM_S		16
+#define   AR934X_PORT_VLAN2_8021Q_MODE_S		30
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_ONLY	0
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_FALLBACK	1
+#define   AR934X_PORT_VLAN2_8021Q_MODE_VLAN_ONLY	2
+#define   AR934X_PORT_VLAN2_8021Q_MODE_SECURE		3
+
+#define sw_to_ar7240(_dev) container_of(_dev, struct ar7240sw, swdev)
+
+struct ar7240sw_port_stat {
+	unsigned long rx_broadcast;
+	unsigned long rx_pause;
+	unsigned long rx_multicast;
+	unsigned long rx_fcs_error;
+	unsigned long rx_align_error;
+	unsigned long rx_runt;
+	unsigned long rx_fragments;
+	unsigned long rx_64byte;
+	unsigned long rx_128byte;
+	unsigned long rx_256byte;
+	unsigned long rx_512byte;
+	unsigned long rx_1024byte;
+	unsigned long rx_1518byte;
+	unsigned long rx_maxbyte;
+	unsigned long rx_toolong;
+	unsigned long rx_good_byte;
+	unsigned long rx_bad_byte;
+	unsigned long rx_overflow;
+	unsigned long filtered;
+
+	unsigned long tx_broadcast;
+	unsigned long tx_pause;
+	unsigned long tx_multicast;
+	unsigned long tx_underrun;
+	unsigned long tx_64byte;
+	unsigned long tx_128byte;
+	unsigned long tx_256byte;
+	unsigned long tx_512byte;
+	unsigned long tx_1024byte;
+	unsigned long tx_1518byte;
+	unsigned long tx_maxbyte;
+	unsigned long tx_oversize;
+	unsigned long tx_byte;
+	unsigned long tx_collision;
+	unsigned long tx_abortcol;
+	unsigned long tx_multicol;
+	unsigned long tx_singlecol;
+	unsigned long tx_excdefer;
+	unsigned long tx_defer;
+	unsigned long tx_xlatecol;
+};
+
+struct ar7240sw {
+	struct mii_bus	*mii_bus;
+	struct ag71xx_switch_platform_data *swdata;
+	struct switch_dev swdev;
+	int num_ports;
+	u8 ver;
+	bool vlan;
+	u16 vlan_id[AR7240_MAX_VLANS];
+	u8 vlan_table[AR7240_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR7240_NUM_PORTS];
+	char buf[80];
+
+	rwlock_t stats_lock;
+	struct ar7240sw_port_stat port_stats[AR7240_NUM_PORTS];
+};
+
+struct ar7240sw_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+static DEFINE_MUTEX(reg_mutex);
+
+static inline int sw_is_ar7240(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR7240;
+}
+
+static inline int sw_is_ar934x(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR934X;
+}
+
+static inline u32 ar7240sw_port_mask(struct ar7240sw *as, int port)
+{
+	return BIT(port);
+}
+
+static inline u32 ar7240sw_port_mask_all(struct ar7240sw *as)
+{
+	return BIT(as->swdev.ports) - 1;
+}
+
+static inline u32 ar7240sw_port_mask_but(struct ar7240sw *as, int port)
+{
+	return ar7240sw_port_mask_all(as) & ~BIT(port);
+}
+
+static inline u16 mk_phy_addr(u32 reg)
+{
+	return 0x17 & ((reg >> 4) | 0x10);
+}
+
+static inline u16 mk_phy_reg(u32 reg)
+{
+	return (reg << 1) & 0x1e;
+}
+
+static inline u16 mk_high_addr(u32 reg)
+{
+	return (reg >> 7) & 0x1ff;
+}
+
+static u32 __ar7240sw_reg_read(struct mii_bus *mii, u32 reg)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+	u32 hi, lo;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii, 0x1f, 0x10, mk_high_addr(reg));
+	lo = (u32) ag71xx_mdio_mii_read(mii, phy_addr, phy_reg);
+	hi = (u32) ag71xx_mdio_mii_read(mii, phy_addr, phy_reg + 1);
+	local_irq_restore(flags);
+
+	return (hi << 16) | lo;
+}
+
+static void __ar7240sw_reg_write(struct mii_bus *mii, u32 reg, u32 val)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii, 0x1f, 0x10, mk_high_addr(reg));
+	ag71xx_mdio_mii_write(mii, phy_addr, phy_reg + 1, (val >> 16));
+	ag71xx_mdio_mii_write(mii, phy_addr, phy_reg, (val & 0xffff));
+	local_irq_restore(flags);
+}
+
+static u32 ar7240sw_reg_read(struct mii_bus *mii, u32 reg_addr)
+{
+	u32 ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_read(mii, reg_addr);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static void ar7240sw_reg_write(struct mii_bus *mii, u32 reg_addr, u32 reg_val)
+{
+	mutex_lock(&reg_mutex);
+	__ar7240sw_reg_write(mii, reg_addr, reg_val);
+	mutex_unlock(&reg_mutex);
+}
+
+static u32 ar7240sw_reg_rmw(struct mii_bus *mii, u32 reg, u32 mask, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t &= ~mask;
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+
+	return t;
+}
+
+static void ar7240sw_reg_set(struct mii_bus *mii, u32 reg, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+}
+
+static int __ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			       unsigned timeout)
+{
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		u32 t;
+
+		t = __ar7240sw_reg_read(mii, reg);
+		if ((t & mask) == val)
+			return 0;
+
+		usleep_range(1000, 2000);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			     unsigned timeout)
+{
+	int ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_wait(mii, reg, mask, val, timeout);
+	mutex_unlock(&reg_mutex);
+	return ret;
+}
+
+int ar7240sw_phy_read(struct mii_bus *mii, int phy_addr, int reg_addr)
+{
+	u32 t, val = 0xffff;
+	int err;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return 0xffff;
+
+	mutex_lock(&reg_mutex);
+	t = (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_READ;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	err = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	if (!err)
+		val = __ar7240sw_reg_read(mii, AR7240_REG_MDIO_CTRL);
+	mutex_unlock(&reg_mutex);
+
+	return val & AR7240_MDIO_CTRL_DATA_M;
+}
+
+int ar7240sw_phy_write(struct mii_bus *mii, int phy_addr, int reg_addr,
+		       u16 reg_val)
+{
+	u32 t;
+	int ret;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return -EINVAL;
+
+	mutex_lock(&reg_mutex);
+	t = (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_WRITE |
+	    reg_val;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	ret = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static int ar7240sw_capture_stats(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int port;
+	int ret;
+
+	write_lock(&as->stats_lock);
+
+	/* Capture the hardware statistics for all ports */
+	ar7240sw_reg_rmw(mii, AR7240_REG_MIB_FUNCTION0,
+			 (AR7240_MIB_FUNC_M << AR7240_MIB_FUNC_S),
+			 (AR7240_MIB_FUNC_CAPTURE << AR7240_MIB_FUNC_S));
+
+	/* Wait for the capturing to complete. */
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MIB_FUNCTION0,
+				AR7240_MIB_BUSY, 0, 10);
+
+	if (ret)
+		goto unlock;
+
+	for (port = 0; port < AR7240_NUM_PORTS; port++) {
+		unsigned int base;
+		struct ar7240sw_port_stat *stats;
+
+		base = AR7240_REG_STATS_BASE(port);
+		stats = &as->port_stats[port];
+
+#define READ_STAT(_r) ar7240sw_reg_read(mii, base + AR7240_STATS_ ## _r)
+
+		stats->rx_good_byte += READ_STAT(RXGOODBYTE);
+		stats->tx_byte += READ_STAT(TXBYTE);
+
+#undef READ_STAT
+	}
+
+	ret = 0;
+
+unlock:
+	write_unlock(&as->stats_lock);
+	return ret;
+}
+
+static void ar7240sw_disable_port(struct ar7240sw *as, unsigned port)
+{
+	ar7240sw_reg_write(as->mii_bus, AR7240_REG_PORT_CTRL(port),
+			   AR7240_PORT_CTRL_STATE_DISABLED);
+}
+
+static void ar7240sw_setup(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	/* Enable CPU port, and disable mirror port */
+	ar7240sw_reg_write(mii, AR7240_REG_CPU_PORT,
+			   AR7240_CPU_PORT_EN |
+			   (15 << AR7240_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar7240sw_reg_write(mii, AR7240_REG_TAG_PRIORITY, 0xfa50);
+
+	if (sw_is_ar934x(as)) {
+		/* Enable aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR934X_REG_AT_CTRL,
+			0x2b /* 5 min age time */ |
+			AR934X_AT_CTRL_AGE_EN |
+			AR934X_AT_CTRL_LEARN_CHANGE);
+		/* Enable ARP frame acknowledge */
+		ar7240sw_reg_set(mii, AR934X_REG_QM_CTRL,
+				 AR934X_QM_CTRL_ARP_EN);
+		/* Enable Broadcast/Multicast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR934X_REG_FLOOD_MASK,
+				 AR934X_FLOOD_MASK_BC_DP(0) |
+				 AR934X_FLOOD_MASK_MC_DP(0));
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR9340_GLOBAL_CTRL_MTU_M,
+				 AR9340_GLOBAL_CTRL_MTU_M);
+
+		/* Enable MIB counters */
+		ar7240sw_reg_set(mii, AR7240_REG_MIB_FUNCTION0,
+				 AR934X_MIB_ENABLE);
+
+	} else {
+		/* Enable ARP frame acknowledge, aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR7240_REG_AT_CTRL,
+			AR7240_AT_CTRL_RESERVED |
+			0x2b /* 5 min age time */ |
+			AR7240_AT_CTRL_AGE_EN |
+			AR7240_AT_CTRL_ARP_EN |
+			AR7240_AT_CTRL_LEARN_CHANGE);
+		/* Enable Broadcast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR7240_REG_FLOOD_MASK,
+				 AR7240_FLOOD_MASK_BROAD_TO_CPU);
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR7240_GLOBAL_CTRL_MTU_M,
+				 AR7240_GLOBAL_CTRL_MTU_M);
+	}
+
+	/* setup Service TAG */
+	ar7240sw_reg_rmw(mii, AR7240_REG_SERVICE_TAG, AR7240_SERVICE_TAG_M, 0);
+}
+
+/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
+static int
+ar7240sw_phy_poll_reset(struct mii_bus *bus)
+{
+	const unsigned int sleep_msecs = 20;
+	int ret, elapsed, i;
+
+	for (elapsed = sleep_msecs; elapsed <= 600;
+	     elapsed += sleep_msecs) {
+		msleep(sleep_msecs);
+		for (i = 0; i < AR7240_NUM_PHYS; i++) {
+			ret = ar7240sw_phy_read(bus, i, MII_BMCR);
+			if (ret < 0)
+				return ret;
+			if (ret & BMCR_RESET)
+				break;
+			if (i == AR7240_NUM_PHYS - 1) {
+				usleep_range(1000, 2000);
+				return 0;
+			}
+		}
+	}
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reset(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int ret;
+	int i;
+
+	/* Set all ports to disabled state. */
+	for (i = 0; i < AR7240_NUM_PORTS; i++)
+		ar7240sw_disable_port(as, i);
+
+	/* Wait for transmit queues to drain. */
+	usleep_range(2000, 3000);
+
+	/* Reset the switch. */
+	ar7240sw_reg_write(mii, AR7240_REG_MASK_CTRL,
+			   AR7240_MASK_CTRL_SOFT_RESET);
+
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MASK_CTRL,
+				AR7240_MASK_CTRL_SOFT_RESET, 0, 1000);
+
+	/* setup PHYs */
+	for (i = 0; i < AR7240_NUM_PHYS; i++) {
+		ar7240sw_phy_write(mii, i, MII_ADVERTISE,
+				   ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
+				   ADVERTISE_PAUSE_ASYM);
+		ar7240sw_phy_write(mii, i, MII_BMCR,
+				   BMCR_RESET | BMCR_ANENABLE);
+	}
+	ret = ar7240sw_phy_poll_reset(mii);
+	if (ret)
+		return ret;
+
+	ar7240sw_setup(as);
+	return ret;
+}
+
+static void ar7240sw_setup_port(struct ar7240sw *as, unsigned port, u8 portmask)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 ctrl;
+	u32 vid, mode;
+
+	ctrl = AR7240_PORT_CTRL_STATE_FORWARD | AR7240_PORT_CTRL_LEARN |
+		AR7240_PORT_CTRL_SINGLE_VLAN;
+
+	if (port == AR7240_PORT_CPU) {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_SPEED_1000 |
+				   AR7240_PORT_STATUS_TXFLOW |
+				   AR7240_PORT_STATUS_RXFLOW |
+				   AR7240_PORT_STATUS_TXMAC |
+				   AR7240_PORT_STATUS_RXMAC |
+				   AR7240_PORT_STATUS_DUPLEX);
+	} else {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_LINK_AUTO);
+	}
+
+	/* Set the default VID for this port */
+	if (as->vlan) {
+		vid = as->vlan_id[as->pvid[port]];
+		mode = AR7240_PORT_VLAN_MODE_SECURE;
+	} else {
+		vid = port;
+		mode = AR7240_PORT_VLAN_MODE_PORT_ONLY;
+	}
+
+	if (as->vlan) {
+		if (as->vlan_tagged & BIT(port))
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_ADD <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+		else
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_STRIP <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+	} else {
+		ctrl |= AR7240_PORT_CTRL_VLAN_MODE_KEEP <<
+			AR7240_PORT_CTRL_VLAN_MODE_S;
+	}
+
+	if (!portmask) {
+		if (port == AR7240_PORT_CPU)
+			portmask = ar7240sw_port_mask_but(as, AR7240_PORT_CPU);
+		else
+			portmask = ar7240sw_port_mask(as, AR7240_PORT_CPU);
+	}
+
+	/* allow the port to talk to all other ports, but exclude its
+	 * own ID to prevent frames from being reflected back to the
+	 * port that they came from */
+	portmask &= ar7240sw_port_mask_but(as, port);
+
+	ar7240sw_reg_write(mii, AR7240_REG_PORT_CTRL(port), ctrl);
+	if (sw_is_ar934x(as)) {
+		u32 vlan1, vlan2;
+
+		vlan1 = (vid << AR934X_PORT_VLAN1_DEFAULT_CVID_S);
+		vlan2 = (portmask << AR934X_PORT_VLAN2_PORT_VID_MEM_S) |
+			(mode << AR934X_PORT_VLAN2_8021Q_MODE_S);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN1(port), vlan1);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN2(port), vlan2);
+	} else {
+		u32 vlan;
+
+		vlan = vid | (mode << AR7240_PORT_VLAN_MODE_S) |
+		       (portmask << AR7240_PORT_VLAN_DEST_PORTS_S);
+
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_VLAN(port), vlan);
+	}
+}
+
+static int ar7240_set_addr(struct ar7240sw *as, u8 *addr)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 t;
+
+	t = (addr[4] << 8) | addr[5];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR0, t);
+
+	t = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR1, t);
+
+	return 0;
+}
+
+static int
+ar7240_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan_id[val->port_vlan];
+	return 0;
+}
+
+static int
+ar7240_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	/* make sure no invalid PVIDs get set */
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	as->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar7240_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	*vlan = as->pvid[port];
+	return 0;
+}
+
+static int
+ar7240_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 ports = as->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < as->swdev.ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (as->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 *vt = &as->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+			as->vlan_tagged |= (1 << p->id);
+		else {
+			as->vlan_tagged &= ~(1 << p->id);
+			as->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR7240_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				as->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
+
+		*vt |= 1 << p->id;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan;
+	return 0;
+}
+
+static void
+ar7240_vtu_op(struct ar7240sw *as, u32 op, u32 val)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	if (ar7240sw_reg_wait(mii, AR7240_REG_VTU, AR7240_VTU_ACTIVE, 0, 5))
+		return;
+
+	if ((op & AR7240_VTU_OP) == AR7240_VTU_OP_LOAD) {
+		val &= AR7240_VTUDATA_MEMBER;
+		val |= AR7240_VTUDATA_VALID;
+		ar7240sw_reg_write(mii, AR7240_REG_VTU_DATA, val);
+	}
+	op |= AR7240_VTU_ACTIVE;
+	ar7240sw_reg_write(mii, AR7240_REG_VTU, op);
+}
+
+static int
+ar7240_hw_apply(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 portmask[AR7240_NUM_PORTS];
+	int i, j;
+
+	/* flush all vlan translation unit entries */
+	ar7240_vtu_op(as, AR7240_VTU_OP_FLUSH, 0);
+
+	memset(portmask, 0, sizeof(portmask));
+	if (as->vlan) {
+		/* calculate the port destination masks and load vlans
+		 * into the vlan translation unit */
+		for (j = 0; j < AR7240_MAX_VLANS; j++) {
+			u8 vp = as->vlan_table[j];
+
+			if (!vp)
+				continue;
+
+			for (i = 0; i < as->swdev.ports; i++) {
+				u8 mask = (1 << i);
+				if (vp & mask)
+					portmask[i] |= vp & ~mask;
+			}
+
+			ar7240_vtu_op(as,
+				AR7240_VTU_OP_LOAD |
+				(as->vlan_id[j] << AR7240_VTU_VID_S),
+				as->vlan_table[j]);
+		}
+	} else {
+		/* vlan disabled:
+		 * isolate all ports, but connect them to the cpu port */
+		for (i = 0; i < as->swdev.ports; i++) {
+			if (i == AR7240_PORT_CPU)
+				continue;
+
+			portmask[i] = 1 << AR7240_PORT_CPU;
+			portmask[AR7240_PORT_CPU] |= (1 << i);
+		}
+	}
+
+	/* update the port destination mask registers and tag settings */
+	for (i = 0; i < as->swdev.ports; i++)
+		ar7240sw_setup_port(as, i, portmask[i]);
+
+	return 0;
+}
+
+static int
+ar7240_reset_switch(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	ar7240sw_reset(as);
+	return 0;
+}
+
+static int
+ar7240_get_port_link(struct switch_dev *dev, int port,
+		     struct switch_port_link *link)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+	u32 status;
+
+	if (port >= AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	status = ar7240sw_reg_read(mii, AR7240_REG_PORT_STATUS(port));
+	link->aneg = !!(status & AR7240_PORT_STATUS_LINK_AUTO);
+	if (link->aneg) {
+		link->link = !!(status & AR7240_PORT_STATUS_LINK_UP);
+		if (!link->link)
+			return 0;
+	} else {
+		link->link = true;
+	}
+
+	link->duplex = !!(status & AR7240_PORT_STATUS_DUPLEX);
+	link->tx_flow = !!(status & AR7240_PORT_STATUS_TXFLOW);
+	link->rx_flow = !!(status & AR7240_PORT_STATUS_RXFLOW);
+	switch (status & AR7240_PORT_STATUS_SPEED_M) {
+	case AR7240_PORT_STATUS_SPEED_10:
+		link->speed = SWITCH_PORT_SPEED_10;
+		break;
+	case AR7240_PORT_STATUS_SPEED_100:
+		link->speed = SWITCH_PORT_SPEED_100;
+		break;
+	case AR7240_PORT_STATUS_SPEED_1000:
+		link->speed = SWITCH_PORT_SPEED_1000;
+		break;
+	}
+
+	return 0;
+}
+
+static int
+ar7240_get_port_stats(struct switch_dev *dev, int port,
+		      struct switch_port_stats *stats)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	if (port >= AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	ar7240sw_capture_stats(as);
+
+	read_lock(&as->stats_lock);
+	stats->rx_bytes = as->port_stats[port].rx_good_byte;
+	stats->tx_bytes = as->port_stats[port].tx_byte;
+	read_unlock(&as->stats_lock);
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_monitor_port(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->value.i;
+
+	if (port > 15)
+		return -EINVAL;
+
+	ar7240sw_reg_rmw(mii, AR7240_REG_CPU_PORT,
+		AR7240_MIRROR_PORT_M << AR7240_MIRROR_PORT_S,
+		port << AR7240_MIRROR_PORT_S);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_monitor_port(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ret;
+
+	ret = ar7240sw_reg_read(mii, AR7240_REG_CPU_PORT);
+	val->value.i = (ret >> AR7240_MIRROR_PORT_S) & AR7240_MIRROR_PORT_M;
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	if (val && val->value.i == 1)
+		ar7240sw_reg_set(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_RX);
+	else
+		ar7240sw_reg_rmw(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_RX, 0);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ctrl;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_PORT_CTRL(port));
+
+	if ((ctrl & AR7240_PORT_CTRL_MIRROR_RX) == AR7240_PORT_CTRL_MIRROR_RX)
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	if (val && val->value.i == 1)
+		ar7240sw_reg_set(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_TX);
+	else
+		ar7240sw_reg_rmw(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_TX, 0);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ctrl;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_PORT_CTRL(port));
+
+	if ((ctrl & AR7240_PORT_CTRL_MIRROR_TX) == AR7240_PORT_CTRL_MIRROR_TX)
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	return 0;
+}
+
+static struct switch_attr ar7240_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar7240_set_vlan,
+		.get = ar7240_get_vlan,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar7240_set_mirror_monitor_port,
+		.get = ar7240_get_mirror_monitor_port,
+		.max = 15
+	},
+};
+
+static struct switch_attr ar7240_port[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar7240_set_mirror_rx,
+		.get = ar7240_get_mirror_rx,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar7240_set_mirror_tx,
+		.get = ar7240_get_mirror_tx,
+		.max = 1
+	},
+};
+
+static struct switch_attr ar7240_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID",
+		.set = ar7240_set_vid,
+		.get = ar7240_get_vid,
+		.max = 4094,
+	},
+};
+
+static const struct switch_dev_ops ar7240_ops = {
+	.attr_global = {
+		.attr = ar7240_globals,
+		.n_attr = ARRAY_SIZE(ar7240_globals),
+	},
+	.attr_port = {
+		.attr = ar7240_port,
+		.n_attr = ARRAY_SIZE(ar7240_port),
+	},
+	.attr_vlan = {
+		.attr = ar7240_vlan,
+		.n_attr = ARRAY_SIZE(ar7240_vlan),
+	},
+	.get_port_pvid = ar7240_get_pvid,
+	.set_port_pvid = ar7240_set_pvid,
+	.get_vlan_ports = ar7240_get_ports,
+	.set_vlan_ports = ar7240_set_ports,
+	.apply_config = ar7240_hw_apply,
+	.reset_switch = ar7240_reset_switch,
+	.get_port_link = ar7240_get_port_link,
+	.get_port_stats = ar7240_get_port_stats,
+};
+
+static struct ar7240sw *
+ar7240_probe(struct ag71xx *ag, struct device_node *np)
+{
+	struct mii_bus *mii = ag->mii_bus;
+	struct ar7240sw *as;
+	struct switch_dev *swdev;
+	u32 ctrl;
+	u16 phy_id1;
+	u16 phy_id2;
+	int i;
+
+	phy_id1 = ar7240sw_phy_read(mii, 0, MII_PHYSID1);
+	phy_id2 = ar7240sw_phy_read(mii, 0, MII_PHYSID2);
+	if ((phy_id1 != AR7240_PHY_ID1 || phy_id2 != AR7240_PHY_ID2) &&
+	    (phy_id1 != AR934X_PHY_ID1 || phy_id2 != AR934X_PHY_ID2)) {
+		pr_err("%s: unknown phy id '%04x:%04x'\n",
+		       dev_name(&mii->dev), phy_id1, phy_id2);
+		return NULL;
+	}
+
+	as = kzalloc(sizeof(*as), GFP_KERNEL);
+	if (!as)
+		return NULL;
+
+	as->mii_bus = mii;
+
+	swdev = &as->swdev;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_MASK_CTRL);
+	as->ver = (ctrl >> AR7240_MASK_CTRL_VERSION_S) &
+		  AR7240_MASK_CTRL_VERSION_M;
+
+	if (sw_is_ar7240(as)) {
+		swdev->name = "AR7240/AR9330 built-in switch";
+		swdev->ports = AR7240_NUM_PORTS - 1;
+	} else if (sw_is_ar934x(as)) {
+		swdev->name = "AR934X built-in switch";
+
+		if (ag->phy_if_mode == PHY_INTERFACE_MODE_GMII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_MAC_GMII_EN);
+		} else if (ag->phy_if_mode == PHY_INTERFACE_MODE_MII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_PHY_MII_EN);
+		} else {
+			pr_err("%s: invalid PHY interface mode\n",
+			       dev_name(&mii->dev));
+			goto err_free;
+		}
+
+		if (of_property_read_bool(np, "phy4-mii-enable")) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE1,
+					 AR934X_REG_OPER_MODE1_PHY4_MII_EN);
+			swdev->ports = AR7240_NUM_PORTS - 1;
+		} else {
+			swdev->ports = AR7240_NUM_PORTS;
+		}
+	} else {
+		pr_err("%s: unsupported chip, ctrl=%08x\n",
+			dev_name(&mii->dev), ctrl);
+		goto err_free;
+	}
+
+	swdev->cpu_port = AR7240_PORT_CPU;
+	swdev->vlans = AR7240_MAX_VLANS;
+	swdev->ops = &ar7240_ops;
+
+	if (register_switch(&as->swdev, ag->dev) < 0)
+		goto err_free;
+
+	pr_info("%s: Found an %s\n", dev_name(&mii->dev), swdev->name);
+
+	/* initialize defaults */
+	for (i = 0; i < AR7240_MAX_VLANS; i++)
+		as->vlan_id[i] = i;
+
+	as->vlan_table[0] = ar7240sw_port_mask_all(as);
+
+	return as;
+
+err_free:
+	kfree(as);
+	return NULL;
+}
+
+void ag71xx_ar7240_start(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	if (!as)
+		return;
+
+	ar7240sw_reset(as);
+
+	ar7240_set_addr(as, ag->dev->dev_addr);
+	ar7240_hw_apply(&as->swdev);
+}
+
+int ag71xx_ar7240_init(struct ag71xx *ag, struct device_node *np)
+{
+	struct ar7240sw *as;
+
+	as = ar7240_probe(ag, np);
+	if (!as)
+		return -ENODEV;
+
+	ag->phy_priv = as;
+	ar7240sw_reset(as);
+
+	rwlock_init(&as->stats_lock);
+
+	return 0;
+}
+
+void ag71xx_ar7240_cleanup(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	if (!as)
+		return;
+
+	unregister_switch(&as->swdev);
+	kfree(as);
+	ag->phy_priv = NULL;
+}
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
new file mode 100644
index 0000000000..20cf1c15c8
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
@@ -0,0 +1,285 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/debugfs.h>
+
+#include "ag71xx.h"
+
+static struct dentry *ag71xx_debugfs_root;
+
+static int ag71xx_debugfs_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status)
+{
+	if (status)
+		ag->debug.int_stats.total++;
+	if (status & AG71XX_INT_TX_PS)
+		ag->debug.int_stats.tx_ps++;
+	if (status & AG71XX_INT_TX_UR)
+		ag->debug.int_stats.tx_ur++;
+	if (status & AG71XX_INT_TX_BE)
+		ag->debug.int_stats.tx_be++;
+	if (status & AG71XX_INT_RX_PR)
+		ag->debug.int_stats.rx_pr++;
+	if (status & AG71XX_INT_RX_OF)
+		ag->debug.int_stats.rx_of++;
+	if (status & AG71XX_INT_RX_BE)
+		ag->debug.int_stats.rx_be++;
+}
+
+static ssize_t read_file_int_stats(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+#define PR_INT_STAT(_label, _field)					\
+	len += snprintf(buf + len, sizeof(buf) - len,			\
+		"%20s: %10lu\n", _label, ag->debug.int_stats._field);
+
+	struct ag71xx *ag = file->private_data;
+	char buf[256];
+	unsigned int len = 0;
+
+	PR_INT_STAT("TX Packet Sent", tx_ps);
+	PR_INT_STAT("TX Underrun", tx_ur);
+	PR_INT_STAT("TX Bus Error", tx_be);
+	PR_INT_STAT("RX Packet Received", rx_pr);
+	PR_INT_STAT("RX Overflow", rx_of);
+	PR_INT_STAT("RX Bus Error", rx_be);
+	len += snprintf(buf + len, sizeof(buf) - len, "\n");
+	PR_INT_STAT("Total", total);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+#undef PR_INT_STAT
+}
+
+static const struct file_operations ag71xx_fops_int_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_int_stats,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx)
+{
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+
+	if (rx) {
+		stats->rx_count++;
+		stats->rx_packets += rx;
+		if (rx <= AG71XX_NAPI_WEIGHT)
+			stats->rx[rx]++;
+		if (rx > stats->rx_packets_max)
+			stats->rx_packets_max = rx;
+	}
+
+	if (tx) {
+		stats->tx_count++;
+		stats->tx_packets += tx;
+		if (tx <= AG71XX_NAPI_WEIGHT)
+			stats->tx[tx]++;
+		if (tx > stats->tx_packets_max)
+			stats->tx_packets_max = tx;
+	}
+}
+
+static ssize_t read_file_napi_stats(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long rx_avg = 0;
+	unsigned long tx_avg = 0;
+	int ret;
+	int i;
+
+	buflen = 2048;
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (stats->rx_count)
+		rx_avg = stats->rx_packets / stats->rx_count;
+
+	if (stats->tx_count)
+		tx_avg = stats->tx_packets / stats->tx_count;
+
+	len += snprintf(buf + len, buflen - len, "%3s  %10s %10s\n",
+			"len", "rx", "tx");
+
+	for (i = 1; i <= AG71XX_NAPI_WEIGHT; i++)
+		len += snprintf(buf + len, buflen - len,
+				"%3d: %10lu %10lu\n",
+				i, stats->rx[i], stats->tx[i]);
+
+	len += snprintf(buf + len, buflen - len, "\n");
+
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"sum", stats->rx_count, stats->tx_count);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"avg", rx_avg, tx_avg);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"max", stats->rx_packets_max, stats->tx_packets_max);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"pkt", stats->rx_packets, stats->tx_packets);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations ag71xx_fops_napi_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_napi_stats,
+	.owner	= THIS_MODULE
+};
+
+#define DESC_PRINT_LEN	64
+
+static ssize_t read_file_ring(struct file *file, char __user *user_buf,
+			      size_t count, loff_t *ppos,
+			      struct ag71xx *ag,
+			      struct ag71xx_ring *ring,
+			      unsigned desc_reg)
+{
+	int ring_size = BIT(ring->order);
+	int ring_mask = ring_size - 1;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long flags;
+	ssize_t ret;
+	int curr;
+	int dirty;
+	u32 desc_hw;
+	int i;
+
+	buflen = (ring_size * DESC_PRINT_LEN);
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += snprintf(buf + len, buflen - len,
+			"Idx ... %-8s %-8s %-8s %-8s .\n",
+			"desc", "next", "data", "ctrl");
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	curr = (ring->curr & ring_mask);
+	dirty = (ring->dirty & ring_mask);
+	desc_hw = ag71xx_rr(ag, desc_reg);
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		u32 desc_dma = ((u32) ring->descs_dma) + i * AG71XX_DESC_SIZE;
+
+		len += snprintf(buf + len, buflen - len,
+			"%3d %c%c%c %08x %08x %08x %08x %c\n",
+			i,
+			(i == curr) ? 'C' : ' ',
+			(i == dirty) ? 'D' : ' ',
+			(desc_hw == desc_dma) ? 'H' : ' ',
+			desc_dma,
+			desc->next,
+			desc->data,
+			desc->ctrl,
+			(desc->ctrl & DESC_EMPTY) ? 'E' : '*');
+	}
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t read_file_tx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->tx_ring,
+			      AG71XX_REG_TX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_tx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_tx_ring,
+	.owner	= THIS_MODULE
+};
+
+static ssize_t read_file_rx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->rx_ring,
+			      AG71XX_REG_RX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_rx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_rx_ring,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_exit(struct ag71xx *ag)
+{
+	debugfs_remove_recursive(ag->debug.debugfs_dir);
+}
+
+int ag71xx_debugfs_init(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+
+	ag->debug.debugfs_dir = debugfs_create_dir(dev_name(dev),
+						   ag71xx_debugfs_root);
+	if (!ag->debug.debugfs_dir) {
+		dev_err(dev, "unable to create debugfs directory\n");
+		return -ENOENT;
+	}
+
+	debugfs_create_file("int_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_int_stats);
+	debugfs_create_file("napi_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_napi_stats);
+	debugfs_create_file("tx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_tx_ring);
+	debugfs_create_file("rx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_rx_ring);
+
+	return 0;
+}
+
+int ag71xx_debugfs_root_init(void)
+{
+	if (ag71xx_debugfs_root)
+		return -EBUSY;
+
+	ag71xx_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!ag71xx_debugfs_root)
+		return -ENOENT;
+
+	return 0;
+}
+
+void ag71xx_debugfs_root_exit(void)
+{
+	debugfs_remove(ag71xx_debugfs_root);
+	ag71xx_debugfs_root = NULL;
+}
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
new file mode 100644
index 0000000000..6f37fda387
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
@@ -0,0 +1,120 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static int ag71xx_ethtool_get_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_ioctl(phydev, cmd);
+}
+
+static int ag71xx_ethtool_set_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_ioctl(phydev, cmd);
+}
+
+static u32 ag71xx_ethtool_get_msglevel(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	return ag->msg_enable;
+}
+
+static void ag71xx_ethtool_set_msglevel(struct net_device *dev, u32 msg_level)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	ag->msg_enable = msg_level;
+}
+
+static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	er->tx_max_pending = AG71XX_TX_RING_SIZE_MAX;
+	er->rx_max_pending = AG71XX_RX_RING_SIZE_MAX;
+	er->rx_mini_max_pending = 0;
+	er->rx_jumbo_max_pending = 0;
+
+	er->tx_pending = BIT(ag->tx_ring.order);
+	er->rx_pending = BIT(ag->rx_ring.order);
+	er->rx_mini_pending = 0;
+	er->rx_jumbo_pending = 0;
+
+	if (ag->tx_ring.desc_split)
+		er->tx_pending /= AG71XX_TX_RING_DS_PER_PKT;
+}
+
+static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
+					struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned tx_size;
+	unsigned rx_size;
+	int err = 0;
+
+	if (er->rx_mini_pending != 0||
+	    er->rx_jumbo_pending != 0 ||
+	    er->rx_pending == 0 ||
+	    er->tx_pending == 0)
+		return -EINVAL;
+
+	tx_size = er->tx_pending < AG71XX_TX_RING_SIZE_MAX ?
+		  er->tx_pending : AG71XX_TX_RING_SIZE_MAX;
+
+	rx_size = er->rx_pending < AG71XX_RX_RING_SIZE_MAX ?
+		  er->rx_pending : AG71XX_RX_RING_SIZE_MAX;
+
+	if (netif_running(dev)) {
+		err = dev->netdev_ops->ndo_stop(dev);
+		if (err)
+			return err;
+	}
+
+	if (ag->tx_ring.desc_split)
+		tx_size *= AG71XX_TX_RING_DS_PER_PKT;
+
+	ag->tx_ring.order = ag71xx_ring_size_order(tx_size);
+	ag->rx_ring.order = ag71xx_ring_size_order(rx_size);
+
+	if (netif_running(dev))
+		err = dev->netdev_ops->ndo_open(dev);
+
+	return err;
+}
+
+struct ethtool_ops ag71xx_ethtool_ops = {
+	.set_settings	= ag71xx_ethtool_set_settings,
+	.get_settings	= ag71xx_ethtool_get_settings,
+	.get_msglevel	= ag71xx_ethtool_get_msglevel,
+	.set_msglevel	= ag71xx_ethtool_set_msglevel,
+	.get_ringparam	= ag71xx_ethtool_get_ringparam,
+	.set_ringparam	= ag71xx_ethtool_set_ringparam,
+	.get_link	= ethtool_op_get_link,
+	.get_ts_info	= ethtool_op_get_ts_info,
+};
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
new file mode 100644
index 0000000000..635c3b9127
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
@@ -0,0 +1,1612 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/sizes.h>
+#include <linux/of_net.h>
+#include <linux/of_address.h>
+#include "ag71xx.h"
+
+#define AG71XX_DEFAULT_MSG_ENABLE	\
+	(NETIF_MSG_DRV			\
+	| NETIF_MSG_PROBE		\
+	| NETIF_MSG_LINK		\
+	| NETIF_MSG_TIMER		\
+	| NETIF_MSG_IFDOWN		\
+	| NETIF_MSG_IFUP		\
+	| NETIF_MSG_RX_ERR		\
+	| NETIF_MSG_TX_ERR)
+
+static int ag71xx_msg_level = -1;
+
+module_param_named(msg_level, ag71xx_msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
+
+#define ETH_SWITCH_HEADER_LEN	2
+
+static int ag71xx_tx_packets(struct ag71xx *ag, bool flush);
+
+static inline unsigned int ag71xx_max_frame_len(unsigned int mtu)
+{
+	return ETH_SWITCH_HEADER_LEN + ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;
+}
+
+static void ag71xx_dump_dma_regs(struct ag71xx *ag)
+{
+	DBG("%s: dma_tx_ctrl=%08x, dma_tx_desc=%08x, dma_tx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_TX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_TX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_TX_STATUS));
+
+	DBG("%s: dma_rx_ctrl=%08x, dma_rx_desc=%08x, dma_rx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_RX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_RX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_RX_STATUS));
+}
+
+static inline void ag71xx_dump_intr(struct ag71xx *ag, char *label, u32 intr)
+{
+	DBG("%s: %s intr=%08x %s%s%s%s%s%s\n",
+		ag->dev->name, label, intr,
+		(intr & AG71XX_INT_TX_PS) ? "TXPS " : "",
+		(intr & AG71XX_INT_TX_UR) ? "TXUR " : "",
+		(intr & AG71XX_INT_TX_BE) ? "TXBE " : "",
+		(intr & AG71XX_INT_RX_PR) ? "RXPR " : "",
+		(intr & AG71XX_INT_RX_OF) ? "RXOF " : "",
+		(intr & AG71XX_INT_RX_BE) ? "RXBE " : "");
+}
+
+static void ag71xx_ring_tx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct net_device *dev = ag->dev;
+	int ring_mask = BIT(ring->order) - 1;
+	u32 bytes_compl = 0, pkts_compl = 0;
+
+	while (ring->curr != ring->dirty) {
+		struct ag71xx_desc *desc;
+		u32 i = ring->dirty & ring_mask;
+
+		desc = ag71xx_ring_desc(ring, i);
+		if (!ag71xx_desc_empty(desc)) {
+			desc->ctrl = 0;
+			dev->stats.tx_errors++;
+		}
+
+		if (ring->buf[i].skb) {
+			bytes_compl += ring->buf[i].len;
+			pkts_compl++;
+			dev_kfree_skb_any(ring->buf[i].skb);
+		}
+		ring->buf[i].skb = NULL;
+		ring->dirty++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	netdev_completed_queue(dev, pkts_compl, bytes_compl);
+}
+
+static void ag71xx_ring_tx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int ring_size = BIT(ring->order);
+	int ring_mask = ring_size - 1;
+	int i;
+
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			AG71XX_DESC_SIZE * ((i + 1) & ring_mask));
+
+		desc->ctrl = DESC_EMPTY;
+		ring->buf[i].skb = NULL;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+	netdev_reset_queue(ag->dev);
+}
+
+static void ag71xx_ring_rx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_size = BIT(ring->order);
+	int i;
+
+	if (!ring->buf)
+		return;
+
+	for (i = 0; i < ring_size; i++)
+		if (ring->buf[i].rx_buf) {
+			dma_unmap_single(&ag->dev->dev, ring->buf[i].dma_addr,
+					 ag->rx_buf_size, DMA_FROM_DEVICE);
+			skb_free_frag(ring->buf[i].rx_buf);
+		}
+}
+
+static int ag71xx_buffer_size(struct ag71xx *ag)
+{
+	return ag->rx_buf_size +
+	       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+}
+
+static bool ag71xx_fill_rx_buf(struct ag71xx *ag, struct ag71xx_buf *buf,
+			       int offset,
+			       void *(*alloc)(unsigned int size))
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	struct ag71xx_desc *desc = ag71xx_ring_desc(ring, buf - &ring->buf[0]);
+	void *data;
+
+	data = alloc(ag71xx_buffer_size(ag));
+	if (!data)
+		return false;
+
+	buf->rx_buf = data;
+	buf->dma_addr = dma_map_single(&ag->dev->dev, data, ag->rx_buf_size,
+				       DMA_FROM_DEVICE);
+	desc->data = (u32) buf->dma_addr + offset;
+	return true;
+}
+
+static int ag71xx_ring_rx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_size = BIT(ring->order);
+	int ring_mask = BIT(ring->order) - 1;
+	unsigned int i;
+	int ret;
+
+	ret = 0;
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			AG71XX_DESC_SIZE * ((i + 1) & ring_mask));
+
+		DBG("ag71xx: RX desc at %p, next is %08x\n",
+			desc, desc->next);
+	}
+
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_fill_rx_buf(ag, &ring->buf[i], ag->rx_buf_offset,
+					netdev_alloc_frag)) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		desc->ctrl = DESC_EMPTY;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+
+	return ret;
+}
+
+static int ag71xx_ring_rx_refill(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_mask = BIT(ring->order) - 1;
+	unsigned int count;
+	int offset = ag->rx_buf_offset;
+
+	count = 0;
+	for (; ring->curr - ring->dirty > 0; ring->dirty++) {
+		struct ag71xx_desc *desc;
+		unsigned int i;
+
+		i = ring->dirty & ring_mask;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ring->buf[i].rx_buf &&
+		    !ag71xx_fill_rx_buf(ag, &ring->buf[i], offset,
+					napi_alloc_frag))
+			break;
+
+		desc->ctrl = DESC_EMPTY;
+		count++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	DBG("%s: %u rx descriptors refilled\n", ag->dev->name, count);
+
+	return count;
+}
+
+static int ag71xx_rings_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *tx = &ag->tx_ring;
+	struct ag71xx_ring *rx = &ag->rx_ring;
+	int ring_size = BIT(tx->order) + BIT(rx->order);
+	int tx_size = BIT(tx->order);
+
+	tx->buf = kzalloc(ring_size * sizeof(*tx->buf), GFP_KERNEL);
+	if (!tx->buf)
+		return -ENOMEM;
+
+	tx->descs_cpu = dma_alloc_coherent(NULL, ring_size * AG71XX_DESC_SIZE,
+					   &tx->descs_dma, GFP_ATOMIC);
+	if (!tx->descs_cpu) {
+		kfree(tx->buf);
+		tx->buf = NULL;
+		return -ENOMEM;
+	}
+
+	rx->buf = &tx->buf[BIT(tx->order)];
+	rx->descs_cpu = ((void *)tx->descs_cpu) + tx_size * AG71XX_DESC_SIZE;
+	rx->descs_dma = tx->descs_dma + tx_size * AG71XX_DESC_SIZE;
+
+	ag71xx_ring_tx_init(ag);
+	return ag71xx_ring_rx_init(ag);
+}
+
+static void ag71xx_rings_free(struct ag71xx *ag)
+{
+	struct ag71xx_ring *tx = &ag->tx_ring;
+	struct ag71xx_ring *rx = &ag->rx_ring;
+	int ring_size = BIT(tx->order) + BIT(rx->order);
+
+	if (tx->descs_cpu)
+		dma_free_coherent(NULL, ring_size * AG71XX_DESC_SIZE,
+				  tx->descs_cpu, tx->descs_dma);
+
+	kfree(tx->buf);
+
+	tx->descs_cpu = NULL;
+	rx->descs_cpu = NULL;
+	tx->buf = NULL;
+	rx->buf = NULL;
+}
+
+static void ag71xx_rings_cleanup(struct ag71xx *ag)
+{
+	ag71xx_ring_rx_clean(ag);
+	ag71xx_ring_tx_clean(ag);
+	ag71xx_rings_free(ag);
+
+	netdev_reset_queue(ag->dev);
+}
+
+static unsigned char *ag71xx_speed_str(struct ag71xx *ag)
+{
+	switch (ag->speed) {
+	case SPEED_1000:
+		return "1000";
+	case SPEED_100:
+		return "100";
+	case SPEED_10:
+		return "10";
+	}
+
+	return "?";
+}
+
+static void ag71xx_hw_set_macaddr(struct ag71xx *ag, unsigned char *mac)
+{
+	u32 t;
+
+	t = (((u32) mac[5]) << 24) | (((u32) mac[4]) << 16)
+	  | (((u32) mac[3]) << 8) | ((u32) mac[2]);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);
+
+	t = (((u32) mac[1]) << 24) | (((u32) mac[0]) << 16);
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);
+}
+
+static void ag71xx_dma_reset(struct ag71xx *ag)
+{
+	u32 val;
+	int i;
+
+	ag71xx_dump_dma_regs(ag);
+
+	/* stop RX and TX */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+
+	/*
+	 * give the hardware some time to really stop all rx/tx activity
+	 * clearing the descriptors too early causes random memory corruption
+	 */
+	mdelay(1);
+
+	/* clear descriptor addresses */
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);
+
+	/* clear pending RX/TX interrupts */
+	for (i = 0; i < 256; i++) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+		ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+	}
+
+	/* clear pending errors */
+	ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);
+	ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);
+
+	val = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (val)
+		pr_alert("%s: unable to clear DMA Rx status: %08x\n",
+			 ag->dev->name, val);
+
+	val = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+
+	/* mask out reserved bits */
+	val &= ~0xff000000;
+
+	if (val)
+		pr_alert("%s: unable to clear DMA Tx status: %08x\n",
+			 ag->dev->name, val);
+
+	ag71xx_dump_dma_regs(ag);
+}
+
+#define MAC_CFG1_INIT	(MAC_CFG1_RXE | MAC_CFG1_TXE | \
+			 MAC_CFG1_SRX | MAC_CFG1_STX)
+
+#define FIFO_CFG0_INIT	(FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT)
+
+#define FIFO_CFG4_INIT	(FIFO_CFG4_DE | FIFO_CFG4_DV | FIFO_CFG4_FC | \
+			 FIFO_CFG4_CE | FIFO_CFG4_CR | FIFO_CFG4_LM | \
+			 FIFO_CFG4_LO | FIFO_CFG4_OK | FIFO_CFG4_MC | \
+			 FIFO_CFG4_BC | FIFO_CFG4_DR | FIFO_CFG4_LE | \
+			 FIFO_CFG4_CF | FIFO_CFG4_PF | FIFO_CFG4_UO | \
+			 FIFO_CFG4_VT)
+
+#define FIFO_CFG5_INIT	(FIFO_CFG5_DE | FIFO_CFG5_DV | FIFO_CFG5_FC | \
+			 FIFO_CFG5_CE | FIFO_CFG5_LO | FIFO_CFG5_OK | \
+			 FIFO_CFG5_MC | FIFO_CFG5_BC | FIFO_CFG5_DR | \
+			 FIFO_CFG5_CF | FIFO_CFG5_PF | FIFO_CFG5_VT | \
+			 FIFO_CFG5_LE | FIFO_CFG5_FT | FIFO_CFG5_16 | \
+			 FIFO_CFG5_17 | FIFO_CFG5_SF)
+
+static void ag71xx_hw_stop(struct ag71xx *ag)
+{
+	/* disable all interrupts and stop the rx/tx engine */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+}
+
+static void ag71xx_hw_setup(struct ag71xx *ag)
+{
+	struct device_node *np = ag->pdev->dev.of_node;
+	u32 init = MAC_CFG1_INIT;
+
+	/* setup MAC configuration registers */
+	if (of_property_read_bool(np, "flow-control"))
+		init |= MAC_CFG1_TFC | MAC_CFG1_RFC;
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, init);
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG2,
+		  MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);
+
+	/* setup max frame length to zero */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, 0);
+
+	/* setup FIFO configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, ag->fifodata[0]);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, ag->fifodata[1]);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);
+}
+
+static void ag71xx_hw_init(struct ag71xx *ag)
+{
+	ag71xx_hw_stop(ag);
+
+	if (ag->phy_reset) {
+		reset_control_assert(ag->phy_reset);
+		msleep(50);
+		reset_control_deassert(ag->phy_reset);
+		msleep(200);
+	}
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);
+	udelay(20);
+
+	reset_control_assert(ag->mac_reset);
+	msleep(100);
+	reset_control_deassert(ag->mac_reset);
+	msleep(200);
+
+	ag71xx_hw_setup(ag);
+
+	ag71xx_dma_reset(ag);
+}
+
+static void ag71xx_fast_reset(struct ag71xx *ag)
+{
+	struct net_device *dev = ag->dev;
+	u32 rx_ds;
+	u32 mii_reg;
+
+	ag71xx_hw_stop(ag);
+	wmb();
+
+	mii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);
+	rx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);
+
+	ag71xx_tx_packets(ag, true);
+
+	reset_control_assert(ag->mac_reset);
+	udelay(10);
+	reset_control_deassert(ag->mac_reset);
+	udelay(10);
+
+	ag71xx_dma_reset(ag);
+	ag71xx_hw_setup(ag);
+	ag->tx_ring.curr = 0;
+	ag->tx_ring.dirty = 0;
+	netdev_reset_queue(ag->dev);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
+		  ag71xx_max_frame_len(ag->dev->mtu));
+
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+}
+
+static void ag71xx_hw_start(struct ag71xx *ag)
+{
+	/* start RX engine */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+
+	/* enable interrupts */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);
+
+	netif_wake_queue(ag->dev);
+}
+
+static void ath79_set_pllval(struct ag71xx *ag)
+{
+	u32 pll_reg = ag->pllreg[1];
+	u32 pll_val;
+
+	if (!ag->pllregmap)
+		return;
+
+	switch (ag->speed) {
+	case SPEED_10:
+		pll_val = ag->plldata[2];
+		break;
+	case SPEED_100:
+		pll_val = ag->plldata[1];
+		break;
+	case SPEED_1000:
+		pll_val = ag->plldata[0];
+		break;
+	default:
+		BUG();
+	}
+
+	if (pll_val)
+		regmap_write(ag->pllregmap, pll_reg, pll_val);
+}
+
+static void ath79_set_pll(struct ag71xx *ag)
+{
+	u32 pll_cfg = ag->pllreg[0];
+	u32 pll_shift = ag->pllreg[2];
+
+	if (!ag->pllregmap)
+		return;
+
+	regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 2 << pll_shift);
+	udelay(100);
+
+	ath79_set_pllval(ag);
+
+	regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 3 << pll_shift);
+	udelay(100);
+
+	regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 0);
+	udelay(100);
+}
+
+static void ath79_mii_ctrl_set_speed(struct ag71xx *ag)
+{
+	unsigned int mii_speed;
+	u32 t;
+
+	if (!ag->mii_base)
+		return;
+
+	switch (ag->speed) {
+	case SPEED_10:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_10;
+		break;
+	case SPEED_100:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_100;
+		break;
+	case SPEED_1000:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	t = __raw_readl(ag->mii_base);
+	t &= ~(AR71XX_MII_CTRL_IF_MASK);
+	t |= (mii_speed & AR71XX_MII_CTRL_IF_MASK);
+	__raw_writel(t, ag->mii_base);
+}
+
+static void
+__ag71xx_link_adjust(struct ag71xx *ag, bool update)
+{
+	struct device_node *np = ag->pdev->dev.of_node;
+	u32 cfg2;
+	u32 ifctl;
+	u32 fifo5;
+
+	if (!ag->link && update) {
+		ag71xx_hw_stop(ag);
+		netif_carrier_off(ag->dev);
+		if (netif_msg_link(ag))
+			pr_info("%s: link down\n", ag->dev->name);
+		return;
+	}
+
+	if (!of_device_is_compatible(np, "qca,ar9130-eth") &&
+	    !of_device_is_compatible(np, "qca,ar7100-eth"))
+		ag71xx_fast_reset(ag);
+
+	cfg2 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG2);
+	cfg2 &= ~(MAC_CFG2_IF_1000 | MAC_CFG2_IF_10_100 | MAC_CFG2_FDX);
+	cfg2 |= (ag->duplex) ? MAC_CFG2_FDX : 0;
+
+	ifctl = ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL);
+	ifctl &= ~(MAC_IFCTL_SPEED);
+
+	fifo5 = ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5);
+	fifo5 &= ~FIFO_CFG5_BM;
+
+	switch (ag->speed) {
+	case SPEED_1000:
+		cfg2 |= MAC_CFG2_IF_1000;
+		fifo5 |= FIFO_CFG5_BM;
+		break;
+	case SPEED_100:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		ifctl |= MAC_IFCTL_SPEED;
+		break;
+	case SPEED_10:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (ag->tx_ring.desc_split) {
+		ag->fifodata[2] &= 0xffff;
+		ag->fifodata[2] |= ((2048 - ag->tx_ring.desc_split) / 4) << 16;
+	}
+
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, ag->fifodata[2]);
+
+	if (update) {
+		if (of_device_is_compatible(np, "qca,ar7100-eth") ||
+		    of_device_is_compatible(np, "qca,ar9130-eth")) {
+			ath79_set_pll(ag);
+			ath79_mii_ctrl_set_speed(ag);
+		} else if (of_device_is_compatible(np, "qca,ar7242-eth") ||
+			   of_device_is_compatible(np, "qca,ar9340-eth") ||
+			   of_device_is_compatible(np, "qca,qca9550-eth") ||
+			   of_device_is_compatible(np, "qca,qca9560-eth")) {
+			ath79_set_pllval(ag);
+		}
+	}
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG2, cfg2);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, fifo5);
+	ag71xx_wr(ag, AG71XX_REG_MAC_IFCTL, ifctl);
+
+	if (of_device_is_compatible(np, "qca,qca9530-eth") ||
+	    of_device_is_compatible(np, "qca,qca9560-eth")) {
+		/*
+		 * The rx ring buffer can stall on small packets on QCA953x and
+		 * QCA956x. Disabling the inline checksum engine fixes the stall.
+		 * The wr, rr functions cannot be used since this hidden register
+		 * is outside of the normal ag71xx register block.
+		 */
+		void __iomem *dam = ioremap_nocache(0xb90001bc, 0x4);
+		if (dam) {
+			__raw_writel(__raw_readl(dam) & ~BIT(27), dam);
+			(void)__raw_readl(dam);
+			iounmap(dam);
+		}
+	}
+
+	ag71xx_hw_start(ag);
+
+	netif_carrier_on(ag->dev);
+	if (update && netif_msg_link(ag))
+		pr_info("%s: link up (%sMbps/%s duplex)\n",
+			ag->dev->name,
+			ag71xx_speed_str(ag),
+			(DUPLEX_FULL == ag->duplex) ? "Full" : "Half");
+
+	DBG("%s: fifo_cfg0=%#x, fifo_cfg1=%#x, fifo_cfg2=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+
+	DBG("%s: fifo_cfg3=%#x, fifo_cfg4=%#x, fifo_cfg5=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+
+	DBG("%s: mac_cfg2=%#x, mac_ifctl=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL));
+}
+
+void ag71xx_link_adjust(struct ag71xx *ag)
+{
+	__ag71xx_link_adjust(ag, true);
+}
+
+static int ag71xx_hw_enable(struct ag71xx *ag)
+{
+	int ret;
+
+	ret = ag71xx_rings_init(ag);
+	if (ret)
+		return ret;
+
+	napi_enable(&ag->napi);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);
+	netif_start_queue(ag->dev);
+
+	return 0;
+}
+
+static void ag71xx_hw_disable(struct ag71xx *ag)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	netif_stop_queue(ag->dev);
+
+	ag71xx_hw_stop(ag);
+	ag71xx_dma_reset(ag);
+
+	napi_disable(&ag->napi);
+	del_timer_sync(&ag->oom_timer);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ag71xx_rings_cleanup(ag);
+}
+
+static int ag71xx_open(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned int max_frame_len;
+	int ret;
+
+	netif_carrier_off(dev);
+	max_frame_len = ag71xx_max_frame_len(dev->mtu);
+	ag->rx_buf_size = SKB_DATA_ALIGN(max_frame_len + NET_SKB_PAD + NET_IP_ALIGN);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, max_frame_len);
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+
+	ret = ag71xx_hw_enable(ag);
+	if (ret)
+		goto err;
+
+	ag71xx_ar7240_start(ag);
+	phy_start(ag->phy_dev);
+
+	return 0;
+
+err:
+	ag71xx_rings_cleanup(ag);
+	return ret;
+}
+
+static int ag71xx_stop(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	netif_carrier_off(dev);
+	phy_stop(ag->phy_dev);
+	ag71xx_hw_disable(ag);
+
+	return 0;
+}
+
+static int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)
+{
+	int i;
+	struct ag71xx_desc *desc;
+	int ring_mask = BIT(ring->order) - 1;
+	int ndesc = 0;
+	int split = ring->desc_split;
+
+	if (!split)
+		split = len;
+
+	while (len > 0) {
+		unsigned int cur_len = len;
+
+		i = (ring->curr + ndesc) & ring_mask;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_desc_empty(desc))
+			return -1;
+
+		if (cur_len > split) {
+			cur_len = split;
+
+			/*
+			 * TX will hang if DMA transfers <= 4 bytes,
+			 * make sure next segment is more than 4 bytes long.
+			 */
+			if (len <= split + 4)
+				cur_len -= 4;
+		}
+
+		desc->data = addr;
+		addr += cur_len;
+		len -= cur_len;
+
+		if (len > 0)
+			cur_len |= DESC_MORE;
+
+		/* prevent early tx attempt of this descriptor */
+		if (!ndesc)
+			cur_len |= DESC_EMPTY;
+
+		desc->ctrl = cur_len;
+		ndesc++;
+	}
+
+	return ndesc;
+}
+
+static netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,
+					  struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	struct ag71xx_desc *desc;
+	dma_addr_t dma_addr;
+	int i, n, ring_min;
+
+	if (skb->len <= 4) {
+		DBG("%s: packet len is too small\n", ag->dev->name);
+		goto err_drop;
+	}
+
+	dma_addr = dma_map_single(&dev->dev, skb->data, skb->len,
+				  DMA_TO_DEVICE);
+
+	i = ring->curr & ring_mask;
+	desc = ag71xx_ring_desc(ring, i);
+
+	/* setup descriptor fields */
+	n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
+	if (n < 0)
+		goto err_drop_unmap;
+
+	i = (ring->curr + n - 1) & ring_mask;
+	ring->buf[i].len = skb->len;
+	ring->buf[i].skb = skb;
+
+	netdev_sent_queue(dev, skb->len);
+
+	skb_tx_timestamp(skb);
+
+	desc->ctrl &= ~DESC_EMPTY;
+	ring->curr += n;
+
+	/* flush descriptor */
+	wmb();
+
+	ring_min = 2;
+	if (ring->desc_split)
+	    ring_min *= AG71XX_TX_RING_DS_PER_PKT;
+
+	if (ring->curr - ring->dirty >= ring_size - ring_min) {
+		DBG("%s: tx queue full\n", dev->name);
+		netif_stop_queue(dev);
+	}
+
+	DBG("%s: packet injected into TX queue\n", ag->dev->name);
+
+	/* enable TX engine */
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);
+
+	return NETDEV_TX_OK;
+
+err_drop_unmap:
+	dma_unmap_single(&dev->dev, dma_addr, skb->len, DMA_TO_DEVICE);
+
+err_drop:
+	dev->stats.tx_dropped++;
+
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	int ret;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		if (ag->phy_dev == NULL)
+			break;
+
+		spin_lock_irq(&ag->lock);
+		ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
+		spin_unlock_irq(&ag->lock);
+		return ret;
+
+	case SIOCSIFHWADDR:
+		if (copy_from_user
+			(dev->dev_addr, ifr->ifr_data, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGIFHWADDR:
+		if (copy_to_user
+			(ifr->ifr_data, dev->dev_addr, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (ag->phy_dev == NULL)
+			break;
+
+		return phy_mii_ioctl(ag->phy_dev, ifr, cmd);
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static void ag71xx_oom_timer_handler(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ag71xx *ag = netdev_priv(dev);
+
+	napi_schedule(&ag->napi);
+}
+
+static void ag71xx_tx_timeout(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	if (netif_msg_tx_err(ag))
+		pr_info("%s: tx timeout\n", ag->dev->name);
+
+	schedule_delayed_work(&ag->restart_work, 1);
+}
+
+static void ag71xx_restart_work_func(struct work_struct *work)
+{
+	struct ag71xx *ag = container_of(work, struct ag71xx, restart_work.work);
+
+	rtnl_lock();
+	ag71xx_hw_disable(ag);
+	ag71xx_hw_enable(ag);
+	if (ag->link)
+		__ag71xx_link_adjust(ag, false);
+	rtnl_unlock();
+}
+
+static bool ag71xx_check_dma_stuck(struct ag71xx *ag)
+{
+	unsigned long timestamp;
+	u32 rx_sm, tx_sm, rx_fd;
+
+	timestamp = netdev_get_tx_queue(ag->dev, 0)->trans_start;
+	if (likely(time_before(jiffies, timestamp + HZ/10)))
+		return false;
+
+	if (!netif_carrier_ok(ag->dev))
+		return false;
+
+	rx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);
+	if ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)
+		return true;
+
+	tx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);
+	rx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);
+	if (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&
+	    ((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)
+		return true;
+
+	return false;
+}
+
+static int ag71xx_tx_packets(struct ag71xx *ag, bool flush)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	bool dma_stuck = false;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	int sent = 0;
+	int bytes_compl = 0;
+	int n = 0;
+
+	DBG("%s: processing TX ring\n", ag->dev->name);
+
+	while (ring->dirty + n != ring->curr) {
+		unsigned int i = (ring->dirty + n) & ring_mask;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		struct sk_buff *skb = ring->buf[i].skb;
+
+		if (!flush && !ag71xx_desc_empty(desc)) {
+			if (ag->tx_hang_workaround &&
+			    ag71xx_check_dma_stuck(ag)) {
+				schedule_delayed_work(&ag->restart_work, HZ / 2);
+				dma_stuck = true;
+			}
+			break;
+		}
+
+		if (flush)
+			desc->ctrl |= DESC_EMPTY;
+
+		n++;
+		if (!skb)
+			continue;
+
+		dev_kfree_skb_any(skb);
+		ring->buf[i].skb = NULL;
+
+		bytes_compl += ring->buf[i].len;
+
+		sent++;
+		ring->dirty += n;
+
+		while (n > 0) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+			n--;
+		}
+	}
+
+	DBG("%s: %d packets sent out\n", ag->dev->name, sent);
+
+	if (!sent)
+		return 0;
+
+	ag->dev->stats.tx_bytes += bytes_compl;
+	ag->dev->stats.tx_packets += sent;
+
+	netdev_completed_queue(ag->dev, sent, bytes_compl);
+	if ((ring->curr - ring->dirty) < (ring_size * 3) / 4)
+		netif_wake_queue(ag->dev);
+
+	if (!dma_stuck)
+		cancel_delayed_work(&ag->restart_work);
+
+	return sent;
+}
+
+static int ag71xx_rx_packets(struct ag71xx *ag, int limit)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	unsigned int pktlen_mask = ag->desc_pktlen_mask;
+	unsigned int offset = ag->rx_buf_offset;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	struct sk_buff_head queue;
+	struct sk_buff *skb;
+	int done = 0;
+
+	DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
+			dev->name, limit, ring->curr, ring->dirty);
+
+	skb_queue_head_init(&queue);
+
+	while (done < limit) {
+		unsigned int i = ring->curr & ring_mask;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		int pktlen;
+		int err = 0;
+
+		if (ag71xx_desc_empty(desc))
+			break;
+
+		if ((ring->dirty + ring_size) == ring->curr) {
+			ag71xx_assert(0);
+			break;
+		}
+
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+
+		pktlen = desc->ctrl & pktlen_mask;
+		pktlen -= ETH_FCS_LEN;
+
+		dma_unmap_single(&dev->dev, ring->buf[i].dma_addr,
+				 ag->rx_buf_size, DMA_FROM_DEVICE);
+
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += pktlen;
+
+		skb = build_skb(ring->buf[i].rx_buf, ag71xx_buffer_size(ag));
+		if (!skb) {
+			skb_free_frag(ring->buf[i].rx_buf);
+			goto next;
+		}
+
+		skb_reserve(skb, offset);
+		skb_put(skb, pktlen);
+
+		if (err) {
+			dev->stats.rx_dropped++;
+			kfree_skb(skb);
+		} else {
+			skb->dev = dev;
+			skb->ip_summed = CHECKSUM_NONE;
+			__skb_queue_tail(&queue, skb);
+		}
+
+next:
+		ring->buf[i].rx_buf = NULL;
+		done++;
+
+		ring->curr++;
+	}
+
+	ag71xx_ring_rx_refill(ag);
+
+	while ((skb = __skb_dequeue(&queue)) != NULL) {
+		skb->protocol = eth_type_trans(skb, dev);
+		netif_receive_skb(skb);
+	}
+
+	DBG("%s: rx finish, curr=%u, dirty=%u, done=%d\n",
+		dev->name, ring->curr, ring->dirty, done);
+
+	return done;
+}
+
+static int ag71xx_poll(struct napi_struct *napi, int limit)
+{
+	struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *rx_ring = &ag->rx_ring;
+	int rx_ring_size = BIT(rx_ring->order);
+	unsigned long flags;
+	u32 status;
+	int tx_done;
+	int rx_done;
+
+	tx_done = ag71xx_tx_packets(ag, false);
+
+	DBG("%s: processing RX ring\n", dev->name);
+	rx_done = ag71xx_rx_packets(ag, limit);
+
+	ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);
+
+	if (rx_ring->buf[rx_ring->dirty % rx_ring_size].rx_buf == NULL)
+		goto oom;
+
+	status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (unlikely(status & RX_STATUS_OF)) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
+		dev->stats.rx_fifo_errors++;
+
+		/* restart RX */
+		ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+	}
+
+	if (rx_done < limit) {
+		if (status & RX_STATUS_PR)
+			goto more;
+
+		status = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+		if (status & TX_STATUS_PS)
+			goto more;
+
+		DBG("%s: disable polling mode, rx=%d, tx=%d,limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+
+		napi_complete(napi);
+
+		/* enable interrupts */
+		spin_lock_irqsave(&ag->lock, flags);
+		ag71xx_int_enable(ag, AG71XX_INT_POLL);
+		spin_unlock_irqrestore(&ag->lock, flags);
+		return rx_done;
+	}
+
+more:
+	DBG("%s: stay in polling mode, rx=%d, tx=%d, limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+	return limit;
+
+oom:
+	if (netif_msg_rx_err(ag))
+		pr_info("%s: out of memory\n", dev->name);
+
+	mod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);
+	napi_complete(napi);
+	return 0;
+}
+
+static irqreturn_t ag71xx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct ag71xx *ag = netdev_priv(dev);
+	u32 status;
+
+	status = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);
+	ag71xx_dump_intr(ag, "raw", status);
+
+	if (unlikely(!status))
+		return IRQ_NONE;
+
+	if (unlikely(status & AG71XX_INT_ERR)) {
+		if (status & AG71XX_INT_TX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);
+			dev_err(&dev->dev, "TX BUS error\n");
+		}
+		if (status & AG71XX_INT_RX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);
+			dev_err(&dev->dev, "RX BUS error\n");
+		}
+	}
+
+	if (likely(status & AG71XX_INT_POLL)) {
+		ag71xx_int_disable(ag, AG71XX_INT_POLL);
+		DBG("%s: enable polling mode\n", dev->name);
+		napi_schedule(&ag->napi);
+	}
+
+	ag71xx_debugfs_update_int_stats(ag, status);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void ag71xx_netpoll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	ag71xx_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+static int ag71xx_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	dev->mtu = new_mtu;
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
+		  ag71xx_max_frame_len(dev->mtu));
+
+	return 0;
+}
+
+static const struct net_device_ops ag71xx_netdev_ops = {
+	.ndo_open		= ag71xx_open,
+	.ndo_stop		= ag71xx_stop,
+	.ndo_start_xmit		= ag71xx_hard_start_xmit,
+	.ndo_do_ioctl		= ag71xx_do_ioctl,
+	.ndo_tx_timeout		= ag71xx_tx_timeout,
+	.ndo_change_mtu		= ag71xx_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ag71xx_netpoll,
+#endif
+};
+
+static const char *ag71xx_get_phy_if_mode_name(phy_interface_t mode)
+{
+	switch (mode) {
+	case PHY_INTERFACE_MODE_MII:
+		return "MII";
+	case PHY_INTERFACE_MODE_GMII:
+		return "GMII";
+	case PHY_INTERFACE_MODE_RMII:
+		return "RMII";
+	case PHY_INTERFACE_MODE_RGMII:
+		return "RGMII";
+	case PHY_INTERFACE_MODE_SGMII:
+		return "SGMII";
+	default:
+		break;
+	}
+
+	return "unknown";
+}
+
+static void ag71xx_of_bit(struct device_node *np, const char *prop,
+			  u32 *reg, u32 mask)
+{
+	u32 val;
+
+	if (of_property_read_u32(np, prop, &val))
+		return;
+
+	if (val)
+		*reg |= mask;
+	else
+		*reg &= ~mask;
+}
+
+static void ag71xx_setup_gmac_933x(struct device_node *np, void __iomem *base)
+{
+	u32 val = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);
+
+	ag71xx_of_bit(np, "switch-phy-swap", &val, AR933X_ETH_CFG_SW_PHY_SWAP);
+	ag71xx_of_bit(np, "switch-phy-addr-swap", &val,
+		      AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);
+
+	__raw_writel(val, base + AR933X_GMAC_REG_ETH_CFG);
+}
+
+static int ag71xx_setup_gmac(struct device_node *np)
+{
+	struct device_node *np_dev;
+	void __iomem *base;
+	int err = 0;
+
+	np = of_get_child_by_name(np, "gmac-config");
+	if (!np)
+		return 0;
+
+	np_dev = of_parse_phandle(np, "device", 0);
+	if (!np_dev)
+		goto out;
+
+	base = of_iomap(np_dev, 0);
+	if (!base) {
+		pr_err("%pOF: can't map GMAC registers\n", np_dev);
+		err = -ENOMEM;
+		goto err_iomap;
+	}
+
+	if (of_device_is_compatible(np_dev, "qca,ar9330-gmac"))
+		ag71xx_setup_gmac_933x(np, base);
+
+	iounmap(base);
+
+err_iomap:
+	of_node_put(np_dev);
+out:
+	of_node_put(np);
+	return err;
+}
+
+static int ag71xx_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct net_device *dev;
+	struct resource *res;
+	struct ag71xx *ag;
+	const void *mac_addr;
+	u32 max_frame_len;
+	int tx_size, err;
+
+	if (!np)
+		return -ENODEV;
+
+	dev = alloc_etherdev(sizeof(*ag));
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	err = ag71xx_setup_gmac(np);
+	if (err)
+		return err;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	ag = netdev_priv(dev);
+	ag->pdev = pdev;
+	ag->dev = dev;
+	ag->msg_enable = netif_msg_init(ag71xx_msg_level,
+					AG71XX_DEFAULT_MSG_ENABLE);
+	spin_lock_init(&ag->lock);
+
+	ag->mac_reset = devm_reset_control_get(&pdev->dev, "mac");
+	if (IS_ERR(ag->mac_reset)) {
+		dev_err(&pdev->dev, "missing mac reset\n");
+		err = PTR_ERR(ag->mac_reset);
+		goto err_free;
+	}
+
+	ag->phy_reset = devm_reset_control_get_optional(&pdev->dev, "phy");
+
+	if (of_property_read_u32_array(np, "fifo-data", ag->fifodata, 3)) {
+		if (of_device_is_compatible(np, "qca,ar9130-eth") ||
+		    of_device_is_compatible(np, "qca,ar7100-eth")) {
+			ag->fifodata[0] = 0x0fff0000;
+			ag->fifodata[1] = 0x00001fff;
+		} else {
+			ag->fifodata[0] = 0x0010ffff;
+			ag->fifodata[1] = 0x015500aa;
+			ag->fifodata[2] = 0x01f00140;
+		}
+		if (of_device_is_compatible(np, "qca,ar9130-eth"))
+			ag->fifodata[2] = 0x00780fff;
+		else if (of_device_is_compatible(np, "qca,ar7100-eth"))
+			ag->fifodata[2] = 0x008001ff;
+	}
+
+	if (of_property_read_u32_array(np, "pll-data", ag->plldata, 3))
+		dev_dbg(&pdev->dev, "failed to read pll-data property\n");
+
+	if (of_property_read_u32_array(np, "pll-reg", ag->pllreg, 3))
+		dev_dbg(&pdev->dev, "failed to read pll-reg property\n");
+
+	ag->pllregmap = syscon_regmap_lookup_by_phandle(np, "pll-handle");
+	if (IS_ERR(ag->pllregmap)) {
+		dev_dbg(&pdev->dev, "failed to read pll-handle property\n");
+		ag->pllregmap = NULL;
+	}
+
+	ag->mac_base = devm_ioremap_nocache(&pdev->dev, res->start,
+					    res->end - res->start + 1);
+	if (!ag->mac_base) {
+		err = -ENOMEM;
+		goto err_free;
+	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res) {
+		ag->mii_base = devm_ioremap_nocache(&pdev->dev, res->start,
+					    res->end - res->start + 1);
+		if (!ag->mii_base) {
+			err = -ENOMEM;
+			goto err_free;
+		}
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	err = devm_request_irq(&pdev->dev, dev->irq, ag71xx_interrupt,
+			       0x0, dev_name(&pdev->dev), dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", dev->irq);
+		goto err_free;
+	}
+
+	dev->netdev_ops = &ag71xx_netdev_ops;
+	dev->ethtool_ops = &ag71xx_ethtool_ops;
+
+	INIT_DELAYED_WORK(&ag->restart_work, ag71xx_restart_work_func);
+
+	init_timer(&ag->oom_timer);
+	ag->oom_timer.data = (unsigned long) dev;
+	ag->oom_timer.function = ag71xx_oom_timer_handler;
+
+	tx_size = AG71XX_TX_RING_SIZE_DEFAULT;
+	ag->rx_ring.order = ag71xx_ring_size_order(AG71XX_RX_RING_SIZE_DEFAULT);
+
+	if (of_device_is_compatible(np, "qca,ar9340-eth") ||
+	    of_device_is_compatible(np, "qca,qca9530-eth") ||
+	    of_device_is_compatible(np, "qca,qca9550-eth") ||
+	    of_device_is_compatible(np, "qca,qca9560-eth"))
+		ag->desc_pktlen_mask = SZ_16K - 1;
+	else
+		ag->desc_pktlen_mask = SZ_4K - 1;
+
+	if (ag->desc_pktlen_mask == SZ_16K - 1 &&
+	    !of_device_is_compatible(np, "qca,qca9550-eth") &&
+	    !of_device_is_compatible(np, "qca,qca9560-eth"))
+		max_frame_len = ag->desc_pktlen_mask;
+	else
+		max_frame_len = 1540;
+
+	dev->min_mtu = 68;
+	dev->max_mtu = max_frame_len - ag71xx_max_frame_len(0);
+
+	if (of_device_is_compatible(np, "qca,ar7240-eth"))
+		ag->tx_hang_workaround = 1;
+
+	ag->rx_buf_offset = NET_SKB_PAD;
+	if (!of_device_is_compatible(np, "qca,ar7100-eth") &&
+	    !of_device_is_compatible(np, "qca,ar9130-eth"))
+		ag->rx_buf_offset += NET_IP_ALIGN;
+
+	if (of_device_is_compatible(np, "qca,ar7100-eth")) {
+		ag->tx_ring.desc_split = AG71XX_TX_RING_SPLIT;
+		tx_size *= AG71XX_TX_RING_DS_PER_PKT;
+	}
+	ag->tx_ring.order = ag71xx_ring_size_order(tx_size);
+
+	ag->stop_desc = dmam_alloc_coherent(&pdev->dev,
+					    sizeof(struct ag71xx_desc),
+					    &ag->stop_desc_dma, GFP_KERNEL);
+	if (!ag->stop_desc)
+		goto err_free;
+
+	ag->stop_desc->data = 0;
+	ag->stop_desc->ctrl = 0;
+	ag->stop_desc->next = (u32) ag->stop_desc_dma;
+
+	mac_addr = of_get_mac_address(np);
+	if (mac_addr)
+		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
+	if (!mac_addr || !is_valid_ether_addr(dev->dev_addr)) {
+		dev_err(&pdev->dev, "invalid MAC address, using random address\n");
+		eth_random_addr(dev->dev_addr);
+	}
+
+	ag->phy_if_mode = of_get_phy_mode(np);
+	if (ag->phy_if_mode < 0) {
+		dev_err(&pdev->dev, "missing phy-mode property in DT\n");
+		err = ag->phy_if_mode;
+		goto err_free;
+	}
+
+	netif_napi_add(dev, &ag->napi, ag71xx_poll, AG71XX_NAPI_WEIGHT);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, 0);
+	ag71xx_hw_init(ag);
+	ag71xx_mdio_init(ag);
+
+	err = ag71xx_phy_connect(ag);
+	if (err)
+		goto err_mdio_free;
+
+	err = ag71xx_debugfs_init(ag);
+	if (err)
+		goto err_phy_disconnect;
+
+	platform_set_drvdata(pdev, dev);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to register net device\n");
+		platform_set_drvdata(pdev, NULL);
+		ag71xx_debugfs_exit(ag);
+		goto err_phy_disconnect;
+	}
+
+	pr_info("%s: Atheros AG71xx at 0x%08lx, irq %d, mode:%s\n",
+		dev->name, (unsigned long) ag->mac_base, dev->irq,
+		ag71xx_get_phy_if_mode_name(ag->phy_if_mode));
+
+	return 0;
+
+err_phy_disconnect:
+	ag71xx_phy_disconnect(ag);
+err_mdio_free:
+	ag71xx_mdio_cleanup(ag);
+err_free:
+	free_netdev(dev);
+	return err;
+}
+
+static int ag71xx_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct ag71xx *ag;
+
+	if (!dev)
+		return 0;
+
+	ag = netdev_priv(dev);
+	ag71xx_debugfs_exit(ag);
+	ag71xx_phy_disconnect(ag);
+	ag71xx_mdio_cleanup(ag);
+	unregister_netdev(dev);
+	free_irq(dev->irq, dev);
+	iounmap(ag->mac_base);
+	kfree(dev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id ag71xx_match[] = {
+	{ .compatible = "qca,ar7100-eth" },
+	{ .compatible = "qca,ar7240-eth" },
+	{ .compatible = "qca,ar7241-eth" },
+	{ .compatible = "qca,ar7242-eth" },
+	{ .compatible = "qca,ar9130-eth" },
+	{ .compatible = "qca,ar9330-eth" },
+	{ .compatible = "qca,ar9340-eth" },
+	{ .compatible = "qca,qca9530-eth" },
+	{ .compatible = "qca,qca9550-eth" },
+	{ .compatible = "qca,qca9560-eth" },
+	{}
+};
+
+static struct platform_driver ag71xx_driver = {
+	.probe		= ag71xx_probe,
+	.remove		= ag71xx_remove,
+	.driver = {
+		.name	= AG71XX_DRV_NAME,
+		.of_match_table = ag71xx_match,
+	}
+};
+
+static int __init ag71xx_module_init(void)
+{
+	int ret;
+
+	ret = ag71xx_debugfs_root_init();
+	if (ret)
+		goto err_out;
+
+	ret = platform_driver_register(&ag71xx_driver);
+	if (ret)
+		goto err_debugfs_exit;
+
+	return 0;
+
+err_debugfs_exit:
+	ag71xx_debugfs_root_exit();
+err_out:
+	return ret;
+}
+
+static void __exit ag71xx_module_exit(void)
+{
+	platform_driver_unregister(&ag71xx_driver);
+	ag71xx_debugfs_root_exit();
+}
+
+module_init(ag71xx_module_init);
+module_exit(ag71xx_module_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_AUTHOR("Felix Fietkau <nbd@nbd.name>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" AG71XX_DRV_NAME);
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
new file mode 100644
index 0000000000..8c1572b181
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
@@ -0,0 +1,218 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/of_mdio.h>
+#include "ag71xx.h"
+
+#define AG71XX_MDIO_RETRY	1000
+#define AG71XX_MDIO_DELAY	5
+
+static int bus_count;
+
+static int ag71xx_mdio_wait_busy(struct ag71xx *ag)
+{
+	int i;
+
+	for (i = 0; i < AG71XX_MDIO_RETRY; i++) {
+		u32 busy;
+
+		udelay(AG71XX_MDIO_DELAY);
+
+		regmap_read(ag->mii_regmap, AG71XX_REG_MII_IND, &busy);
+		if (!busy)
+			return 0;
+
+		udelay(AG71XX_MDIO_DELAY);
+	}
+
+	pr_err("%s: MDIO operation timed out\n", ag->mii_bus->name);
+
+	return -ETIMEDOUT;
+}
+
+int ag71xx_mdio_mii_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct ag71xx *ag = bus->priv;
+	int err;
+	int ret;
+
+	err = ag71xx_mdio_wait_busy(ag);
+	if (err)
+		return 0xffff;
+
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_READ);
+
+	err = ag71xx_mdio_wait_busy(ag);
+	if (err)
+		return 0xffff;
+
+	regmap_read(ag->mii_regmap, AG71XX_REG_MII_STATUS, &ret);
+	ret &= 0xffff;
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+
+	DBG("mii_read: addr=%04x, reg=%04x, value=%04x\n", addr, reg, ret);
+
+	return ret;
+}
+
+int ag71xx_mdio_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct ag71xx *ag = bus->priv;
+
+	DBG("mii_write: addr=%04x, reg=%04x, value=%04x\n", addr, reg, val);
+
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CTRL, val);
+
+	ag71xx_mdio_wait_busy(ag);
+
+	return 0;
+}
+
+static int ar934x_mdio_clock_div(unsigned int rate)
+{
+	if (rate == 100 * 1000 * 1000)
+		return 6; /* 100 MHz clock divided by 20 => 5 MHz */
+	else if (rate == 25 * 1000 * 1000)
+		return 0; /* 25 MHz clock divided by 4 => 6.25 MHz */
+	else
+		return 3; /* 40 MHz clock divided by 8 => 5 MHz */
+}
+
+static int ag71xx_mdio_reset(struct mii_bus *bus)
+{
+	struct device_node *np = bus->dev.of_node;
+	struct ag71xx *ag = bus->priv;
+	struct device_node *np_ag = ag->pdev->dev.of_node;
+	bool builtin_switch;
+	u32 t;
+
+	builtin_switch = of_property_read_bool(np, "builtin-switch");
+
+	if (of_device_is_compatible(np_ag, "qca,ar7240-eth"))
+		t = MII_CFG_CLK_DIV_6;
+	else if (of_device_is_compatible(np_ag, "qca,ar9340-eth"))
+		t = MII_CFG_CLK_DIV_58;
+	else if (builtin_switch)
+		t = MII_CFG_CLK_DIV_10;
+	else
+		t = MII_CFG_CLK_DIV_28;
+
+	if (builtin_switch && of_device_is_compatible(np_ag, "qca,ar9340-eth")) {
+		struct clk *ref_clk = of_clk_get(np, 0);
+		int clock_rate;
+
+		if (WARN_ON_ONCE(!ref_clk))
+			clock_rate = 40 * 1000 * 1000;
+		else
+			clock_rate = clk_get_rate(ref_clk);
+
+		t = ar934x_mdio_clock_div(clock_rate);
+		clk_put(ref_clk);
+	}
+
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);
+	udelay(100);
+
+	regmap_write(ag->mii_regmap, AG71XX_REG_MII_CFG, t);
+	udelay(100);
+
+	return 0;
+}
+
+int ag71xx_mdio_init(struct ag71xx *ag)
+{
+	struct device *parent = &ag->pdev->dev;
+	struct device_node *np;
+	struct mii_bus *mii_bus;
+	bool builtin_switch;
+	int i, err;
+
+	np = of_get_child_by_name(parent->of_node, "mdio-bus");
+	if (!np)
+		return -ENODEV;
+
+	if (!of_device_is_available(np)) {
+		err = 0;
+		goto err_out;
+	}
+
+	ag->mii_regmap = syscon_regmap_lookup_by_phandle(np, "regmap");
+	if (!ag->mii_regmap)
+		return -ENOENT;
+
+	mii_bus = devm_mdiobus_alloc(parent);
+	if (!mii_bus) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	ag->mdio_reset = of_reset_control_get_exclusive(np, "mdio");
+	builtin_switch = of_property_read_bool(np, "builtin-switch");
+
+	mii_bus->name = "mdio";
+	if (builtin_switch) {
+		mii_bus->read = ar7240sw_phy_read;
+		mii_bus->write = ar7240sw_phy_write;
+	} else {
+		mii_bus->read = ag71xx_mdio_mii_read;
+		mii_bus->write = ag71xx_mdio_mii_write;
+	}
+	mii_bus->reset = ag71xx_mdio_reset;
+	mii_bus->priv = ag;
+	mii_bus->parent = parent;
+	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%s.%d", np->name, bus_count++);
+
+	if (!builtin_switch &&
+	    of_property_read_u32(np, "phy-mask", &mii_bus->phy_mask))
+		mii_bus->phy_mask = 0;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		mii_bus->irq[i] = PHY_POLL;
+
+	if (!IS_ERR(ag->mdio_reset)) {
+		reset_control_assert(ag->mdio_reset);
+		msleep(100);
+		reset_control_deassert(ag->mdio_reset);
+		msleep(200);
+	}
+
+	err = of_mdiobus_register(mii_bus, np);
+	if (err)
+		goto err_out;
+
+	ag->mii_bus = mii_bus;
+
+	if (builtin_switch)
+		ag71xx_ar7240_init(ag, np);
+
+	return 0;
+
+err_out:
+	of_node_put(np);
+	return err;
+}
+
+void ag71xx_mdio_cleanup(struct ag71xx *ag)
+{
+	if (!ag->mii_bus)
+		return;
+
+	ag71xx_ar7240_cleanup(ag);
+	mdiobus_unregister(ag->mii_bus);
+}
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
new file mode 100644
index 0000000000..f9df38d530
--- /dev/null
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
@@ -0,0 +1,92 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/of_mdio.h>
+#include "ag71xx.h"
+
+static void ag71xx_phy_link_adjust(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+	unsigned long flags;
+	int status_change = 0;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	if (phydev->link) {
+		if (ag->duplex != phydev->duplex
+		    || ag->speed != phydev->speed) {
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != ag->link)
+		status_change = 1;
+
+	ag->link = phydev->link;
+	ag->duplex = phydev->duplex;
+	ag->speed = phydev->speed;
+
+	if (status_change)
+		ag71xx_link_adjust(ag);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+int ag71xx_phy_connect(struct ag71xx *ag)
+{
+	struct device_node *np = ag->pdev->dev.of_node;
+	struct device_node *phy_node;
+	int ret;
+
+	if (of_phy_is_fixed_link(np)) {
+		ret = of_phy_register_fixed_link(np);
+		if (ret < 0) {
+			dev_err(&ag->pdev->dev,
+				"Failed to register fixed PHY link: %d\n", ret);
+			return ret;
+		}
+
+		phy_node = of_node_get(np);
+	} else {
+		phy_node = of_parse_phandle(np, "phy-handle", 0);
+	}
+
+	if (!phy_node) {
+		dev_err(&ag->pdev->dev,
+			"Could not find valid phy node\n");
+		return -ENODEV;
+	}
+
+	ag->phy_dev = of_phy_connect(ag->dev, phy_node, ag71xx_phy_link_adjust,
+				     0, ag->phy_if_mode);
+
+	of_node_put(phy_node);
+
+	if (!ag->phy_dev) {
+		dev_err(&ag->pdev->dev,
+			"Could not connect to PHY device\n");
+		return -ENODEV;
+	}
+
+	dev_info(&ag->pdev->dev, "connected to PHY at %s [uid=%08x, driver=%s]\n",
+		    phydev_name(ag->phy_dev),
+		    ag->phy_dev->phy_id, ag->phy_dev->drv->name);
+
+	return 0;
+}
+
+void ag71xx_phy_disconnect(struct ag71xx *ag)
+{
+	phy_disconnect(ag->phy_dev);
+}
diff --git a/target/linux/ath79/generic/config-default b/target/linux/ath79/generic/config-default
new file mode 100644
index 0000000000..c174c4e126
--- /dev/null
+++ b/target/linux/ath79/generic/config-default
@@ -0,0 +1,16 @@
+CONFIG_BLK_MQ_PCI=y
+CONFIG_INTEL_XWAY_PHY=y
+CONFIG_LEDS_RESET=y
+CONFIG_MTD_SPLIT_EVA_FW=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_PCI=y
+CONFIG_PCI_AR71XX=y
+CONFIG_PCI_AR724X=y
+CONFIG_PCI_DISABLE_COMMON_QUIRKS=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PHY_AR7100_USB=y
+CONFIG_PHY_AR7200_USB=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
diff --git a/target/linux/ath79/generic/profiles/00-default.mk b/target/linux/ath79/generic/profiles/00-default.mk
new file mode 100644
index 0000000000..83b39e4418
--- /dev/null
+++ b/target/linux/ath79/generic/profiles/00-default.mk
@@ -0,0 +1,16 @@
+#
+# Copyright (C) 2009 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define Profile/Default
+	NAME:=Default Profile (all drivers)
+	PRIORITY := 1
+endef
+
+define Profile/Default/Description
+	Default package set compatible with most boards.
+endef
+$(eval $(call Profile,Default))
diff --git a/target/linux/ath79/generic/target.mk b/target/linux/ath79/generic/target.mk
new file mode 100644
index 0000000000..64eb205e4d
--- /dev/null
+++ b/target/linux/ath79/generic/target.mk
@@ -0,0 +1,8 @@
+BOARDNAME:=Generic
+FEATURES += squashfs
+
+define Target/Description
+	Build firmware images for generic Atheros AR71xx/AR913x/AR934x based boards.
+endef
+
+
diff --git a/target/linux/ath79/image/Makefile b/target/linux/ath79/image/Makefile
new file mode 100644
index 0000000000..15f4c1883a
--- /dev/null
+++ b/target/linux/ath79/image/Makefile
@@ -0,0 +1,81 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/image.mk
+
+KERNEL_LOADADDR = 0x80060000
+
+DEVICE_VARS += IMAGE_SIZE LOADER_FLASH_OFFS LOADER_TYPE ATH_SOC
+
+define Build/loader-common
+	rm -rf $@.src
+	$(MAKE) -C lzma-loader \
+		PKG_BUILD_DIR="$@.src" \
+		TARGET_DIR="$(dir $@)" LOADER_NAME="$(notdir $@)" \
+		LZMA_TEXT_START=0x80a00000 LOADADDR=0x80060000 \
+		$(1) compile loader.$(LOADER_TYPE)
+	mv "$@.$(LOADER_TYPE)" "$@"
+	rm -rf $@.src
+endef
+
+define Build/loader-kernel
+	$(call Build/loader-common,LOADER_DATA="$@")
+endef
+
+define Build/loader-kernel-cmdline
+	$(call Build/loader-common,LOADER_DATA="$@")
+endef
+
+
+define Build/loader-okli-compile
+	$(call Build/loader-common,FLASH_OFFS=$(LOADER_FLASH_OFFS) FLASH_MAX=0)
+endef
+
+# Arguments: <output name> <kernel offset>
+define Build/loader-okli
+	dd if=$(KDIR)/loader-$(word 1,$(1)).$(LOADER_TYPE) bs=$(word 2,$(1)) conv=sync of="$@.new"
+	cat "$@" >> "$@.new"
+	mv "$@.new" "$@"
+endef
+
+define Build/relocate-kernel
+	rm -rf $@.relocate
+	$(CP) ../../generic/image/relocate $@.relocate
+	$(MAKE) -j1 -C $@.relocate KERNEL_ADDR=$(KERNEL_LOADADDR) CROSS_COMPILE=$(TARGET_CROSS)
+	( \
+		dd if=$@.relocate/loader.bin bs=32 conv=sync && \
+		perl -e '@s = stat("$@"); print pack("N", @s[7])' && \
+		cat "$@" \
+	) > "$@.new"
+	mv "$@.new" "$@"
+	rm -rf $@.relocate
+endef
+
+
+define Device/Default
+  ATH_SOC :=
+  DEVICE_DTS_DIR := ../dts
+  DEVICE_DTS = $$(ATH_SOC)_$(1)
+  PROFILES = Default
+  MTDPARTS :=
+  BLOCKSIZE := 64k
+  KERNEL := kernel-bin | append-dtb | lzma | uImage lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma | uImage lzma
+  COMPILE :=
+  SUPPORTED_DEVICES := $(subst _,$(comma),$(1))
+  IMAGES := sysupgrade.bin
+  IMAGE/sysupgrade.bin = append-kernel | pad-to $$$$(BLOCKSIZE) | \
+	append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+endef
+
+ifeq ($(SUBTARGET),generic)
+include ./generic.mk
+include ./generic-tp-link.mk
+include ./generic-ubnt.mk
+endif
+ifeq ($(SUBTARGET),nand)
+include ./nand.mk
+endif
+ifeq ($(SUBTARGET),tiny)
+include ./tiny-netgear.mk
+include ./tiny-tp-link.mk
+endif
+$(eval $(call BuildImage))
diff --git a/target/linux/ath79/image/common-netgear.mk b/target/linux/ath79/image/common-netgear.mk
new file mode 100644
index 0000000000..ca4e005689
--- /dev/null
+++ b/target/linux/ath79/image/common-netgear.mk
@@ -0,0 +1,22 @@
+define Build/netgear-squashfs
+	rm -rf $@.fs $@.squashfs
+	mkdir -p $@.fs/image
+	cp $@ $@.fs/image/uImage
+	$(STAGING_DIR_HOST)/bin/mksquashfs-lzma  \
+		$@.fs $@.squashfs -be \
+		-noappend -root-owned -b 65536 \
+		$(if $(SOURCE_DATE_EPOCH),-fixed-time $(SOURCE_DATE_EPOCH))
+
+	dd if=/dev/zero bs=1k count=1 >> $@.squashfs
+	mkimage \
+		-A mips -O linux -T filesystem -C none \
+		-M $(NETGEAR_KERNEL_MAGIC) \
+		-a 0xbf070000 -e 0xbf070000 \
+		-n 'MIPS $(VERSION_DIST) Linux-$(LINUX_VERSION)' \
+		-d $@.squashfs $@
+	rm -rf $@.squashfs $@.fs
+endef
+
+define Build/netgear-uImage
+	$(call Build/uImage,$(1) -M $(NETGEAR_KERNEL_MAGIC))
+endef
diff --git a/target/linux/ath79/image/common-tp-link.mk b/target/linux/ath79/image/common-tp-link.mk
new file mode 100644
index 0000000000..f816308a9d
--- /dev/null
+++ b/target/linux/ath79/image/common-tp-link.mk
@@ -0,0 +1,90 @@
+DEVICE_VARS += TPLINK_HWID TPLINK_HWREV TPLINK_FLASHLAYOUT TPLINK_HEADER_VERSION TPLINK_BOARD_NAME
+
+define rootfs_align
+$(patsubst %-256k,0x40000,$(patsubst %-128k,0x20000,$(patsubst %-64k,0x10000,$(patsubst squashfs%,0x4,$(patsubst root.%,%,$(1))))))
+endef
+
+# combine kernel and rootfs into one image
+# mktplinkfw <type> <optional extra arguments to mktplinkfw binary>
+# <type> is "sysupgrade" or "factory"
+#
+# -a align the rootfs start on an <align> bytes boundary
+# -j add jffs2 end-of-filesystem markers
+# -s strip padding from end of the image
+# -X reserve <size> bytes in the firmware image (hexval prefixed with 0x)
+define Build/mktplinkfw
+	-$(STAGING_DIR_HOST)/bin/mktplinkfw \
+		-H $(TPLINK_HWID) -W $(TPLINK_HWREV) -F $(TPLINK_FLASHLAYOUT) -N OpenWrt -V $(REVISION) \
+		-m $(TPLINK_HEADER_VERSION) \
+		-k $(IMAGE_KERNEL) \
+		-r $@ \
+		-o $@.new \
+		-j -X 0x40000 \
+		-a $(call rootfs_align,$(FILESYSTEM)) \
+		$(wordlist 2,$(words $(1)),$(1)) \
+		$(if $(findstring sysupgrade,$(word 1,$(1))),-s) && mv $@.new $@ || rm -f $@
+endef
+
+# mktplinkfw-combined
+#
+# -c combined image
+define Build/mktplinkfw-combined
+	$(STAGING_DIR_HOST)/bin/mktplinkfw \
+		-H $(TPLINK_HWID) -W $(TPLINK_HWREV) -F $(TPLINK_FLASHLAYOUT) -N OpenWrt -V $(REVISION) $(1) \
+		-m $(TPLINK_HEADER_VERSION) \
+		-k $@ \
+		-o $@.new \
+		-s -S \
+		-c
+	@mv $@.new $@
+endef
+
+define Device/tplink
+  TPLINK_HWREV := 0x1
+  TPLINK_HEADER_VERSION := 1
+  LOADER_TYPE := gz
+  KERNEL := kernel-bin | append-dtb | lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma | tplink-v1-header
+  IMAGES := sysupgrade.bin factory.bin
+  IMAGE/sysupgrade.bin := append-rootfs | mktplinkfw sysupgrade | append-metadata
+  IMAGE/factory.bin := append-rootfs | mktplinkfw factory
+endef
+
+define Device/tplink-nolzma
+  $(Device/tplink)
+  LOADER_FLASH_OFFS := 0x22000
+  COMPILE := loader-$(1).gz
+  COMPILE/loader-$(1).gz := loader-okli-compile
+  KERNEL := kernel-bin | append-dtb | lzma | uImage lzma -M 0x4f4b4c49 | loader-okli $(1) 7680
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | gzip | tplink-v1-header
+endef
+
+define Device/tplink-4m
+  $(Device/tplink-nolzma)
+  TPLINK_FLASHLAYOUT := 4M
+  IMAGE_SIZE := 3904k
+endef
+
+define Device/tplink-4mlzma
+  $(Device/tplink)
+  TPLINK_FLASHLAYOUT := 4Mlzma
+  IMAGE_SIZE := 3904k
+endef
+
+define Device/tplink-8m
+  $(Device/tplink-nolzma)
+  TPLINK_FLASHLAYOUT := 8M
+  IMAGE_SIZE := 7936k
+endef
+
+define Device/tplink-8mlzma
+$(Device/tplink)
+  TPLINK_FLASHLAYOUT := 8Mlzma
+  IMAGE_SIZE := 7936k
+endef
+
+define Device/tplink-16mlzma
+  $(Device/tplink)
+  TPLINK_FLASHLAYOUT := 16Mlzma
+  IMAGE_SIZE := 15872k
+endef
diff --git a/target/linux/ath79/image/generic-tp-link.mk b/target/linux/ath79/image/generic-tp-link.mk
new file mode 100644
index 0000000000..8cfbcd3a67
--- /dev/null
+++ b/target/linux/ath79/image/generic-tp-link.mk
@@ -0,0 +1,90 @@
+include ./common-tp-link.mk
+
+define Device/tl-archer-c7-v2
+  $(Device/tplink-16mlzma)
+  ATH_SOC := qca9558
+  DEVICE_TITLE := TP-LINK Archer C7 v2
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport kmod-ath10k ath10k-firmware-qca988x
+  TPLINK_HWID := 0xc7000002
+  SUPPORTED_DEVICES := tplink,tl-archer-c7-v2
+  IMAGES := sysupgrade.bin factory.bin factory-us.bin factory-eu.bin
+  IMAGE/factory-us.bin := append-rootfs | mktplinkfw factory -C US
+  IMAGE/factory-eu.bin := append-rootfs | mktplinkfw factory -C EU
+endef
+TARGET_DEVICES += tl-archer-c7-v2
+
+define Device/tl-wdr3600
+  $(Device/tplink-8mlzma)
+  ATH_SOC := ar9344
+  DEVICE_TITLE := TP-LINK TL-WDR3600
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x36000001
+  SUPPORTED_DEVICES := tplink,tl-wdr3600 tl-wdr3600
+endef
+TARGET_DEVICES += tl-wdr3600
+
+define Device/tl-wdr4300
+  $(Device/tl-wdr3600)
+  DEVICE_TITLE := TP-LINK TL-WDR4300
+  TPLINK_HWID := 0x43000001
+  SUPPORTED_DEVICES := tplink,tl-wdr4300 tl-wdr4300
+endef
+TARGET_DEVICES += tl-wdr4300
+
+define Device/tl-wr1043nd-v1
+  $(Device/tplink-8m)
+  ATH_SOC := ar9132
+  DEVICE_TITLE := TP-LINK TL-WR1043N/ND v1
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x10430001
+  SUPPORTED_DEVICES := tplink,tl-wr1043nd-v1 tl-wr1043nd
+endef
+TARGET_DEVICES += tl-wr1043nd-v1
+
+define Device/tl-wr1043nd-v2
+  $(Device/tplink-8mlzma)
+  ATH_SOC := qca9558
+  DEVICE_TITLE := TP-LINK TL-WR1043N/ND v2
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x10430002
+  SUPPORTED_DEVICES := tplink,tl-wr1043nd-v2 tl-wr1043nd-v2
+endef
+TARGET_DEVICES += tl-wr1043nd-v2
+
+define Device/tl-wr1043nd-v3
+  $(Device/tplink-8mlzma)
+  ATH_SOC := qca9558
+  DEVICE_TITLE := TP-LINK TL-WR1043N/ND v3
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x10430003
+  SUPPORTED_DEVICES := tplink,tl-wr1043nd-v3 tl-wr1043nd-v3
+endef
+TARGET_DEVICES += tl-wr1043nd-v3
+
+define Device/tl-wr1043nd-v4
+  $(Device/tplink)
+  ATH_SOC := qca9563
+  IMAGE_SIZE := 15552k
+  DEVICE_TITLE := TP-LINK TL-WR1043N/ND v4
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x10430004
+  TPLINK_BOARD_ID := TLWR1043NDV4
+  KERNEL := kernel-bin | append-dtb | lzma | tplink-v1-header
+  IMAGE/sysupgrade.bin := append-rootfs | tplink-safeloader sysupgrade
+  IMAGE/factory.bin := append-rootfs | tplink-safeloader factory
+  SUPPORTED_DEVICES := tplink,tl-wr1043nd-v4 tl-wr1043nd-v4
+endef
+TARGET_DEVICES += tl-wr1043nd-v4
+
+define Device/tl-wr2543-v1
+  $(Device/tplink-8mlzma)
+  ATH_SOC := ar7242
+  DEVICE_TITLE := TP-LINK TL-WR2543N/ND v1
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x25430001
+  IMAGE/sysupgrade.bin := append-rootfs | mktplinkfw sysupgrade -v 3.13.99 | \
+    append-metadata | check-size $$$$(IMAGE_SIZE)
+  IMAGE/factory.bin := append-rootfs | mktplinkfw factory -v 3.13.99
+  SUPPORTED_DEVICES := tplink,tl-wr2543-v1 tl-wr2543-v1
+endef
+TARGET_DEVICES += tl-wr2543-v1
diff --git a/target/linux/ath79/image/generic-ubnt.mk b/target/linux/ath79/image/generic-ubnt.mk
new file mode 100644
index 0000000000..900167f626
--- /dev/null
+++ b/target/linux/ath79/image/generic-ubnt.mk
@@ -0,0 +1,100 @@
+DEVICE_VARS += UBNT_BOARD UBNT_CHIP UBNT_TYPE
+
+# mkubntimage is using the kernel image direct
+# routerboard creates partitions out of the ubnt header
+define Build/mkubntimage
+	-$(STAGING_DIR_HOST)/bin/mkfwimage \
+		-B $(UBNT_BOARD) -v $(UBNT_TYPE).$(UBNT_CHIP).v6.0.0-$(VERSION_DIST)-$(REVISION) \
+		-k $(IMAGE_KERNEL) \
+		-r $@ \
+		-o $@
+endef
+
+# all UBNT XM device expect the kernel image to have 1024k while flash, when
+# booting the image, the size doesn't matter.
+define Build/mkubntimage-split
+	-[ -f $@ ] && ( \
+	dd if=$@ of=$@.old1 bs=1024k count=1; \
+	dd if=$@ of=$@.old2 bs=1024k skip=1; \
+	$(STAGING_DIR_HOST)/bin/mkfwimage \
+		-B $(UBNT_BOARD) -v $(UBNT_TYPE).$(UBNT_CHIP).v6.0.0-$(VERSION_DIST)-$(REVISION) \
+		-k $@.old1 \
+		-r $@.old2 \
+		-o $@; \
+	rm $@.old1 $@.old2 )
+endef
+
+# UBNT_BOARD e.g. one of (XS2, XS5, RS, XM)
+# UBNT_TYPE e.g. one of (BZ, XM, XW)
+# UBNT_CHIP e.g. one of (ar7240, ar933x, ar934x)
+define Device/ubnt
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2
+  IMAGE_SIZE := 7552k
+  UBNT_BOARD := XM
+  IMAGES += factory.bin
+  IMAGE/factory.bin := append-kernel | pad-to $$$$(BLOCKSIZE) | \
+	append-rootfs | pad-rootfs | check-size $$$$(IMAGE_SIZE) | mkubntimage-split
+endef
+
+define Device/ubnt-xm
+  $(Device/ubnt)
+  DEVICE_PACKAGES += kmod-usb-ohci
+  UBNT_TYPE := XM
+  UBNT_CHIP := ar7240
+  ATH_SOC := ar7241
+  KERNEL := kernel-bin | append-dtb | relocate-kernel | lzma | uImage lzma
+endef
+
+define Device/ubnt-bz
+  $(Device/ubnt)
+  UBNT_TYPE := BZ
+  UBNT_CHIP := ar7240
+  ATH_SOC := ar7241
+endef
+
+define Device/ubnt_bullet-m
+  $(Device/ubnt-xm)
+  DEVICE_TITLE := Ubiquiti Bullet-M
+  SUPPORTED_DEVICES += bullet-m
+endef
+TARGET_DEVICES += ubnt_bullet-m
+
+define Device/ubnt_rocket-m
+  $(Device/ubnt-xm)
+  DEVICE_TITLE := Ubiquiti Rocket-M
+  SUPPORTED_DEVICES += rocket-m
+endef
+TARGET_DEVICES += ubnt_rocket-m
+
+define Device/ubnt_nano-m
+  $(Device/ubnt-xm)
+  DEVICE_TITLE := Ubiquiti Nano-M
+  SUPPORTED_DEVICES += nano-m
+endef
+TARGET_DEVICES += ubnt_nano-m
+
+define Device/ubnt_unifi
+  $(Device/ubnt-bz)
+  DEVICE_TITLE := Ubiquiti UniFi
+  SUPPORTED_DEVICES += unifi
+endef
+TARGET_DEVICES += ubnt_unifi
+
+define Device/ubnt-unifiac
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2
+  DEVICE_PROFILE := UBNT
+  IMAGE_SIZE := 7744k
+  IMAGES := sysupgrade.bin
+  IMAGE/sysupgrade.bin := append-kernel | pad-to $$$$(BLOCKSIZE) | append-rootfs | pad-rootfs | check-size $$$$(IMAGE_SIZE)
+endef
+
+
+define Device/ubnt-unifiac-lite
+  $(Device/ubnt-unifiac)
+  DEVICE_TITLE := Ubiquiti UniFi AC-Lite
+  DEVICE_PACKAGES := kmod-ath10k ath10k-firmware-qca988x
+  DEVICE_PROFILE += UBNTUNIFIACLITE
+  BOARDNAME := UBNT-UF-AC-LITE
+  ATH_SOC := qca9563
+endef
+TARGET_DEVICES += ubnt-unifiac-lite
diff --git a/target/linux/ath79/image/generic.mk b/target/linux/ath79/image/generic.mk
new file mode 100644
index 0000000000..f4ed7b3412
--- /dev/null
+++ b/target/linux/ath79/image/generic.mk
@@ -0,0 +1,100 @@
+include ./common-netgear.mk
+
+define Device/avm_fritz300e
+  ATH_SOC := ar7242
+  DEVICE_TITLE := AVM FRITZ!WLAN Repeater 300E
+  KERNEL := kernel-bin | append-dtb | lzma | eva-image
+  KERNEL_INITRAMFS := $$(KERNEL)
+  IMAGE_SIZE := 15232k
+  IMAGE/sysupgrade.bin := append-kernel | pad-to 64k | \
+	append-squashfs-fakeroot-be | pad-to 256 | \
+	append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+  DEVICE_PACKAGES := fritz-tffs rssileds -swconfig
+endef
+TARGET_DEVICES += avm_fritz300e
+
+define Device/embeddedwireless_dorin
+  ATH_SOC := ar9331
+  DEVICE_TITLE := Embedded Wireless Dorin
+  DEVICE_PACKAGES := kmod-usb-chipidea2
+  IMAGE_SIZE := 16000k
+  SUPPORTED_DEVICES += ew-dorin
+endef
+TARGET_DEVICES += embeddedwireless_dorin
+
+define Device/etactica-eg200
+  ATH_SOC := ar9331
+  DEVICE_TITLE := eTactica EG200
+  DEVICE_PACKAGES := kmod-usb-chipidea2 kmod-ledtrig-oneshot \
+	kmod-usb-serial kmod-usb-serial-ftdi kmod-usb-storage  kmod-fs-ext4
+  SUPPORTED_DEVICES += etactica,eg200 rme-eg200
+endef
+TARGET_DEVICES += etactica-eg200
+
+define Device/glinet_ar150
+  ATH_SOC := ar9330
+  DEVICE_TITLE := GL.iNet GL-AR150
+  DEVICE_PACKAGES := kmod-usb-chipidea2
+  IMAGE_SIZE := 16000k
+  SUPPORTED_DEVICES += gl-ar150
+endef
+TARGET_DEVICES += glinet_ar150
+
+define Device/glinet_ar300m_nor
+  ATH_SOC := qca9533
+  DEVICE_TITLE := GL.iNet GL-AR300M
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2
+  IMAGE_SIZE := 16000k
+  SUPPORTED_DEVICES += gl-ar300m
+endef
+TARGET_DEVICES += glinet_ar300m_nor
+
+define Device/openmesh_om5p-ac-v2
+  ATH_SOC := qca9558
+  DEVICE_TITLE := OpenMesh OM5P-AC v2
+  DEVICE_PACKAGES := kmod-ath10k ath10k-firmware-qca988x om-watchdog
+  IMAGE_SIZE := 7808k
+  SUPPORTED_DEVICES += om5p-acv2
+endef
+TARGET_DEVICES += openmesh_om5p-ac-v2
+
+define Device/netgear_wndr3800
+  ATH_SOC := ar7161
+  DEVICE_TITLE := NETGEAR WNDR3800
+  NETGEAR_KERNEL_MAGIC := 0x33373031
+  KERNEL := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  NETGEAR_BOARD_ID := WNDR3800
+  NETGEAR_HW_ID := 29763654+16+128
+  IMAGE_SIZE := 15872k
+  IMAGES := sysupgrade.bin factory.img
+  IMAGE/default := append-kernel | pad-to $$$$(BLOCKSIZE) | netgear-squashfs | append-rootfs | pad-rootfs
+  IMAGE/sysupgrade.bin := $$(IMAGE/default) | append-metadata | check-size $$$$(IMAGE_SIZE)
+  IMAGE/factory.img := $$(IMAGE/default) | netgear-dni | check-size $$$$(IMAGE_SIZE)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb-ohci kmod-usb2 kmod-usb-ledtrig-usbport kmod-leds-reset
+  SUPPORTED_DEVICES += wndr3800
+endef
+TARGET_DEVICES += netgear_wndr3800
+
+define Device/buffalo_wzr-hp-g450h
+  ATH_SOC := ar7242
+  DEVICE_TITLE := Buffalo WZR-HP-G450H
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-ledtrig-usbport
+  IMAGE_SIZE := 32256k
+  SUPPORTED_DEVICES += wzr-hp-g450h
+endef
+TARGET_DEVICES += buffalo_wzr-hp-g450h
+
+define Device/phicomm-k2t
+  ATH_SOC := qca9563
+  DEVICE_TITLE := Phicomm K2T
+  KERNEL := kernel-bin | append-dtb | lzma | uImage lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma | uImage lzma
+  IMAGE_SIZE := 15744k
+  IMAGES := sysupgrade.bin
+  IMAGE/default := append-kernel | append-rootfs | pad-rootfs
+  IMAGE/sysupgrade.bin := $$(IMAGE/default) | append-metadata | check-size $$$$(IMAGE_SIZE)
+  DEVICE_PACKAGES := kmod-leds-reset kmod-ath10k ath10k-firmware-qca9888
+  SUPPORTED_DEVICES += phicomm,k2t
+endef
+TARGET_DEVICES += phicomm-k2t
diff --git a/target/linux/ath79/image/lzma-loader/Makefile b/target/linux/ath79/image/lzma-loader/Makefile
new file mode 100644
index 0000000000..738093a958
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/Makefile
@@ -0,0 +1,70 @@
+#
+# Copyright (C) 2011 OpenWrt.org
+# Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+LZMA_TEXT_START	:= 0x80a00000
+LOADADDR	:= 0x80060000
+LOADER		:= loader.bin
+LOADER_NAME	:= $(basename $(notdir $(LOADER)))
+LOADER_DATA 	:=
+TARGET_DIR	:=
+FLASH_OFFS	:=
+FLASH_MAX	:=
+BOARD		:=
+
+ifeq ($(TARGET_DIR),)
+TARGET_DIR	:= $(KDIR)
+endif
+
+LOADER_BIN	:= $(TARGET_DIR)/$(LOADER_NAME).bin
+LOADER_GZ	:= $(TARGET_DIR)/$(LOADER_NAME).gz
+LOADER_ELF	:= $(TARGET_DIR)/$(LOADER_NAME).elf
+
+PKG_NAME := lzma-loader
+PKG_BUILD_DIR := $(KDIR)/$(PKG_NAME)
+
+.PHONY : loader-compile loader.bin loader.elf loader.gz
+
+$(PKG_BUILD_DIR)/.prepared:
+	mkdir $(PKG_BUILD_DIR)
+	$(CP) ./src/* $(PKG_BUILD_DIR)/
+	touch $@
+
+loader-compile: $(PKG_BUILD_DIR)/.prepared
+	$(MAKE) -C $(PKG_BUILD_DIR) CROSS_COMPILE="$(TARGET_CROSS)" \
+		LZMA_TEXT_START=$(LZMA_TEXT_START) \
+		LOADADDR=$(LOADADDR) \
+		LOADER_DATA=$(LOADER_DATA) \
+		FLASH_OFFS=$(FLASH_OFFS) \
+		FLASH_MAX=$(FLASH_MAX) \
+		BOARD="$(BOARD)" \
+		clean all
+
+loader.gz: $(PKG_BUILD_DIR)/loader.bin
+	# Workaround for buggy bootloaders: Some devices
+	# (TP-Link TL-WR1043ND v1) don't work correctly when
+	# the uncompressed loader is too small (probably a cache
+	# invalidation issue)
+	dd if=$< bs=512K conv=sync | gzip -nc9 > $(LOADER_GZ)
+
+loader.elf: $(PKG_BUILD_DIR)/loader.elf
+	$(CP) $< $(LOADER_ELF)
+
+loader.bin: $(PKG_BUILD_DIR)/loader.bin
+	$(CP) $< $(LOADER_BIN)
+
+download:
+prepare: $(PKG_BUILD_DIR)/.prepared
+compile: loader-compile
+
+install:
+
+clean:
+	rm -rf $(PKG_BUILD_DIR)
+
diff --git a/target/linux/ath79/image/lzma-loader/src/LzmaDecode.c b/target/linux/ath79/image/lzma-loader/src/LzmaDecode.c
new file mode 100644
index 0000000000..cb8345377e
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/LzmaDecode.c
@@ -0,0 +1,584 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/LzmaDecode.h b/target/linux/ath79/image/lzma-loader/src/LzmaDecode.h
new file mode 100644
index 0000000000..2870eeb9c9
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff --git a/target/linux/ath79/image/lzma-loader/src/LzmaTypes.h b/target/linux/ath79/image/lzma-loader/src/LzmaTypes.h
new file mode 100644
index 0000000000..9c27290757
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_NO_SYSTEM_SIZE_T */
+/* You can use it, if you don't want <stddef.h> */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+#include <stddef.h>
+typedef size_t SizeT;
+#endif
+#endif
+
+#endif
diff --git a/target/linux/ath79/image/lzma-loader/src/Makefile b/target/linux/ath79/image/lzma-loader/src/Makefile
new file mode 100644
index 0000000000..7773f027a2
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/Makefile
@@ -0,0 +1,108 @@
+#
+# Makefile for the LZMA compressed kernel loader for
+# Atheros AR7XXX/AR9XXX based boards
+#
+# Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+#
+# Some parts of this file was based on the OpenWrt specific lzma-loader
+# for the BCM47xx and ADM5120 based boards:
+#	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
+#	Copyright (C) 2005 Mineharu Takahara <mtakahar@yahoo.com>
+#	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 as published
+# by the Free Software Foundation.
+#
+
+LOADADDR	:=
+LZMA_TEXT_START	:= 0x80a00000
+LOADER_DATA	:=
+BOARD		:=
+FLASH_OFFS	:=
+FLASH_MAX	:=
+
+CC		:= $(CROSS_COMPILE)gcc
+LD		:= $(CROSS_COMPILE)ld
+OBJCOPY		:= $(CROSS_COMPILE)objcopy
+OBJDUMP		:= $(CROSS_COMPILE)objdump
+
+BIN_FLAGS	:= -O binary -R .reginfo -R .note -R .comment -R .mdebug \
+		   -R .MIPS.abiflags -S
+
+CFLAGS		= -D__KERNEL__ -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
+		  -fno-strict-aliasing -fno-common -fomit-frame-pointer -G 0 \
+		  -mno-abicalls -fno-pic -ffunction-sections -pipe -mlong-calls \
+		  -fno-common -ffreestanding -fhonour-copts -nostartfiles \
+		  -mabi=32 -march=mips32r2 \
+		  -Wa,-32 -Wa,-march=mips32r2 -Wa,-mips32r2 -Wa,--trap
+CFLAGS		+= -D_LZMA_PROB32
+CFLAGS		+= -flto
+
+ASFLAGS		= $(CFLAGS) -D__ASSEMBLY__
+
+LDFLAGS		= -static -Wl,--gc-sections -Wl,-no-warn-mismatch
+LDFLAGS		+= -Wl,-e,startup -T loader.lds -Wl,-Ttext,$(LZMA_TEXT_START)
+LDFLAGS		+= -flto -fwhole-program
+
+O_FORMAT 	= $(shell $(OBJDUMP) -i | head -2 | grep elf32)
+
+OBJECTS		:= head.o loader.o cache.o board.o printf.o LzmaDecode.o
+
+ifneq ($(strip $(LOADER_DATA)),)
+OBJECTS		+= data.o
+CFLAGS		+= -DLZMA_WRAPPER=1 -DLOADADDR=$(LOADADDR)
+endif
+
+ifneq ($(strip $(KERNEL_CMDLINE)),)
+CFLAGS		+= -DCONFIG_KERNEL_CMDLINE='"$(KERNEL_CMDLINE)"'
+endif
+
+ifneq ($(strip $(FLASH_OFFS)),)
+CFLAGS		+= -DCONFIG_FLASH_OFFS=$(FLASH_OFFS)
+endif
+
+ifneq ($(strip $(FLASH_MAX)),)
+CFLAGS		+= -DCONFIG_FLASH_MAX=$(FLASH_MAX)
+endif
+
+BOARD_DEF := $(shell echo $(strip $(BOARD)) | tr a-z A-Z | tr - _)
+ifneq ($(BOARD_DEF),)
+CFLAGS		+= -DCONFIG_BOARD_$(BOARD_DEF)
+endif
+
+all: loader.elf
+
+# Don't build dependencies, this may die if $(CC) isn't gcc
+dep:
+
+install:
+
+%.o : %.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+%.o : %.S
+	$(CC) $(ASFLAGS) -c -o $@ $<
+
+data.o: $(LOADER_DATA)
+	$(LD) -r -b binary --oformat $(O_FORMAT) -T lzma-data.lds -o $@ $<
+
+loader: $(OBJECTS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJECTS)
+
+loader.bin: loader
+	$(OBJCOPY) $(BIN_FLAGS) $< $@
+
+loader2.o: loader.bin
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $@ $<
+
+loader.elf: loader2.o
+	$(LD) -z max-page-size=0x1000 -e startup -T loader2.lds -Ttext $(LOADADDR) -o $@ $<
+
+mrproper: clean
+
+clean:
+	rm -f loader *.elf *.bin *.o
+
+
+
diff --git a/target/linux/ath79/image/lzma-loader/src/ar71xx_regs.h b/target/linux/ath79/image/lzma-loader/src/ar71xx_regs.h
new file mode 100644
index 0000000000..19a4785bb4
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/ar71xx_regs.h
@@ -0,0 +1,725 @@
+/*
+ *  Atheros AR71XX/AR724X/AR913X SoC register definitions
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_AR71XX_REGS_H
+#define __ASM_MACH_AR71XX_REGS_H
+
+#define BIT(_x)			(1UL << (_x))
+
+#define AR71XX_APB_BASE		0x18000000
+#define AR71XX_GE0_BASE		0x19000000
+#define AR71XX_GE0_SIZE		0x10000
+#define AR71XX_GE1_BASE		0x1a000000
+#define AR71XX_GE1_SIZE		0x10000
+#define AR71XX_EHCI_BASE	0x1b000000
+#define AR71XX_EHCI_SIZE	0x1000
+#define AR71XX_OHCI_BASE	0x1c000000
+#define AR71XX_OHCI_SIZE	0x1000
+#define AR71XX_SPI_BASE		0x1f000000
+#define AR71XX_SPI_SIZE		0x01000000
+
+#define AR71XX_DDR_CTRL_BASE	(AR71XX_APB_BASE + 0x00000000)
+#define AR71XX_DDR_CTRL_SIZE	0x100
+#define AR71XX_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+#define AR71XX_UART_SIZE	0x100
+#define AR71XX_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
+#define AR71XX_USB_CTRL_SIZE	0x100
+#define AR71XX_GPIO_BASE        (AR71XX_APB_BASE + 0x00040000)
+#define AR71XX_GPIO_SIZE        0x100
+#define AR71XX_PLL_BASE		(AR71XX_APB_BASE + 0x00050000)
+#define AR71XX_PLL_SIZE		0x100
+#define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+#define AR71XX_RESET_SIZE	0x100
+#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
+#define AR71XX_MII_SIZE		0x100
+
+#define AR71XX_PCI_MEM_BASE	0x10000000
+#define AR71XX_PCI_MEM_SIZE	0x07000000
+
+#define AR71XX_PCI_WIN0_OFFS	0x10000000
+#define AR71XX_PCI_WIN1_OFFS	0x11000000
+#define AR71XX_PCI_WIN2_OFFS	0x12000000
+#define AR71XX_PCI_WIN3_OFFS	0x13000000
+#define AR71XX_PCI_WIN4_OFFS	0x14000000
+#define AR71XX_PCI_WIN5_OFFS	0x15000000
+#define AR71XX_PCI_WIN6_OFFS	0x16000000
+#define AR71XX_PCI_WIN7_OFFS	0x07000000
+
+#define AR71XX_PCI_CFG_BASE	\
+	(AR71XX_PCI_MEM_BASE + AR71XX_PCI_WIN7_OFFS + 0x10000)
+#define AR71XX_PCI_CFG_SIZE	0x100
+
+#define AR7240_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
+#define AR7240_USB_CTRL_SIZE	0x100
+#define AR7240_OHCI_BASE	0x1b000000
+#define AR7240_OHCI_SIZE	0x1000
+
+#define AR724X_PCI_MEM_BASE	0x10000000
+#define AR724X_PCI_MEM_SIZE	0x04000000
+
+#define AR724X_PCI_CFG_BASE	0x14000000
+#define AR724X_PCI_CFG_SIZE	0x1000
+#define AR724X_PCI_CRP_BASE	(AR71XX_APB_BASE + 0x000c0000)
+#define AR724X_PCI_CRP_SIZE	0x1000
+#define AR724X_PCI_CTRL_BASE	(AR71XX_APB_BASE + 0x000f0000)
+#define AR724X_PCI_CTRL_SIZE	0x100
+
+#define AR724X_EHCI_BASE	0x1b000000
+#define AR724X_EHCI_SIZE	0x1000
+
+#define AR913X_EHCI_BASE	0x1b000000
+#define AR913X_EHCI_SIZE	0x1000
+#define AR913X_WMAC_BASE	(AR71XX_APB_BASE + 0x000C0000)
+#define AR913X_WMAC_SIZE	0x30000
+
+#define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+#define AR933X_UART_SIZE	0x14
+#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define AR933X_GMAC_SIZE	0x04
+#define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR933X_WMAC_SIZE	0x20000
+#define AR933X_EHCI_BASE	0x1b000000
+#define AR933X_EHCI_SIZE	0x1000
+
+#define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define AR934X_GMAC_SIZE	0x14
+#define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR934X_WMAC_SIZE	0x20000
+#define AR934X_EHCI_BASE	0x1b000000
+#define AR934X_EHCI_SIZE	0x200
+
+#define QCA955X_PCI_MEM_BASE0	0x10000000
+#define QCA955X_PCI_MEM_BASE1	0x12000000
+#define QCA955X_PCI_MEM_SIZE	0x02000000
+#define QCA955X_PCI_CFG_BASE0	0x14000000
+#define QCA955X_PCI_CFG_BASE1	0x16000000
+#define QCA955X_PCI_CFG_SIZE	0x1000
+#define QCA955X_PCI_CRP_BASE0	(AR71XX_APB_BASE + 0x000c0000)
+#define QCA955X_PCI_CRP_BASE1	(AR71XX_APB_BASE + 0x00250000)
+#define QCA955X_PCI_CRP_SIZE	0x1000
+#define QCA955X_PCI_CTRL_BASE0	(AR71XX_APB_BASE + 0x000f0000)
+#define QCA955X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
+#define QCA955X_PCI_CTRL_SIZE	0x100
+
+#define QCA955X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define QCA955X_WMAC_SIZE	0x20000
+#define QCA955X_EHCI0_BASE	0x1b000000
+#define QCA955X_EHCI1_BASE	0x1b400000
+#define QCA955X_EHCI_SIZE	0x1000
+#define QCA955X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define QCA955X_GMAC_SIZE	0x40
+
+#define AR9300_OTP_BASE		0x14000
+#define AR9300_OTP_STATUS	0x15f18
+#define AR9300_OTP_STATUS_TYPE		0x7
+#define AR9300_OTP_STATUS_VALID		0x4
+#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
+#define AR9300_OTP_STATUS_SM_BUSY	0x1
+#define AR9300_OTP_READ_DATA	0x15f1c
+
+/*
+ * DDR_CTRL block
+ */
+#define AR71XX_DDR_REG_PCI_WIN0		0x7c
+#define AR71XX_DDR_REG_PCI_WIN1		0x80
+#define AR71XX_DDR_REG_PCI_WIN2		0x84
+#define AR71XX_DDR_REG_PCI_WIN3		0x88
+#define AR71XX_DDR_REG_PCI_WIN4		0x8c
+#define AR71XX_DDR_REG_PCI_WIN5		0x90
+#define AR71XX_DDR_REG_PCI_WIN6		0x94
+#define AR71XX_DDR_REG_PCI_WIN7		0x98
+#define AR71XX_DDR_REG_FLUSH_GE0	0x9c
+#define AR71XX_DDR_REG_FLUSH_GE1	0xa0
+#define AR71XX_DDR_REG_FLUSH_USB	0xa4
+#define AR71XX_DDR_REG_FLUSH_PCI	0xa8
+
+#define AR724X_DDR_REG_FLUSH_GE0	0x7c
+#define AR724X_DDR_REG_FLUSH_GE1	0x80
+#define AR724X_DDR_REG_FLUSH_USB	0x84
+#define AR724X_DDR_REG_FLUSH_PCIE	0x88
+
+#define AR913X_DDR_REG_FLUSH_GE0	0x7c
+#define AR913X_DDR_REG_FLUSH_GE1	0x80
+#define AR913X_DDR_REG_FLUSH_USB	0x84
+#define AR913X_DDR_REG_FLUSH_WMAC	0x88
+
+#define AR933X_DDR_REG_FLUSH_GE0	0x7c
+#define AR933X_DDR_REG_FLUSH_GE1	0x80
+#define AR933X_DDR_REG_FLUSH_USB	0x84
+#define AR933X_DDR_REG_FLUSH_WMAC	0x88
+
+#define AR934X_DDR_REG_FLUSH_GE0	0x9c
+#define AR934X_DDR_REG_FLUSH_GE1	0xa0
+#define AR934X_DDR_REG_FLUSH_USB	0xa4
+#define AR934X_DDR_REG_FLUSH_PCIE	0xa8
+#define AR934X_DDR_REG_FLUSH_WMAC	0xac
+
+/*
+ * PLL block
+ */
+#define AR71XX_PLL_REG_CPU_CONFIG	0x00
+#define AR71XX_PLL_REG_SEC_CONFIG	0x04
+#define AR71XX_PLL_REG_ETH0_INT_CLOCK	0x10
+#define AR71XX_PLL_REG_ETH1_INT_CLOCK	0x14
+
+#define AR71XX_PLL_DIV_SHIFT		3
+#define AR71XX_PLL_DIV_MASK		0x1f
+#define AR71XX_CPU_DIV_SHIFT		16
+#define AR71XX_CPU_DIV_MASK		0x3
+#define AR71XX_DDR_DIV_SHIFT		18
+#define AR71XX_DDR_DIV_MASK		0x3
+#define AR71XX_AHB_DIV_SHIFT		20
+#define AR71XX_AHB_DIV_MASK		0x7
+
+#define AR71XX_ETH0_PLL_SHIFT		17
+#define AR71XX_ETH1_PLL_SHIFT		19
+
+#define AR724X_PLL_REG_CPU_CONFIG	0x00
+#define AR724X_PLL_REG_PCIE_CONFIG	0x18
+
+#define AR724X_PLL_DIV_SHIFT		0
+#define AR724X_PLL_DIV_MASK		0x3ff
+#define AR724X_PLL_REF_DIV_SHIFT	10
+#define AR724X_PLL_REF_DIV_MASK		0xf
+#define AR724X_AHB_DIV_SHIFT		19
+#define AR724X_AHB_DIV_MASK		0x1
+#define AR724X_DDR_DIV_SHIFT		22
+#define AR724X_DDR_DIV_MASK		0x3
+
+#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
+
+#define AR913X_PLL_REG_CPU_CONFIG	0x00
+#define AR913X_PLL_REG_ETH_CONFIG	0x04
+#define AR913X_PLL_REG_ETH0_INT_CLOCK	0x14
+#define AR913X_PLL_REG_ETH1_INT_CLOCK	0x18
+
+#define AR913X_PLL_DIV_SHIFT		0
+#define AR913X_PLL_DIV_MASK		0x3ff
+#define AR913X_DDR_DIV_SHIFT		22
+#define AR913X_DDR_DIV_MASK		0x3
+#define AR913X_AHB_DIV_SHIFT		19
+#define AR913X_AHB_DIV_MASK		0x1
+
+#define AR913X_ETH0_PLL_SHIFT		20
+#define AR913X_ETH1_PLL_SHIFT		22
+
+#define AR933X_PLL_CPU_CONFIG_REG	0x00
+#define AR933X_PLL_CLOCK_CTRL_REG	0x08
+
+#define AR933X_PLL_CPU_CONFIG_NINT_SHIFT	10
+#define AR933X_PLL_CPU_CONFIG_NINT_MASK		0x3f
+#define AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT	16
+#define AR933X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT	23
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
+
+#define AR933X_PLL_CLOCK_CTRL_BYPASS		BIT(2)
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT	5
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT	10
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT	15
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK	0x7
+
+#define AR934X_PLL_CPU_CONFIG_REG		0x00
+#define AR934X_PLL_DDR_CONFIG_REG		0x04
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_REG		0x08
+#define AR934X_PLL_ETH_XMII_CONTROL_REG		0x2c
+
+#define AR934X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+#define AR934X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+#define AR934X_PLL_CPU_CONFIG_NINT_SHIFT	6
+#define AR934X_PLL_CPU_CONFIG_NINT_MASK		0x3f
+#define AR934X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
+#define AR934X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define AR934X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
+#define AR934X_PLL_CPU_CONFIG_OUTDIV_MASK	0x3
+
+#define AR934X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
+#define AR934X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
+#define AR934X_PLL_DDR_CONFIG_NINT_SHIFT	10
+#define AR934X_PLL_DDR_CONFIG_NINT_MASK		0x3f
+#define AR934X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
+#define AR934X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
+#define AR934X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
+#define AR934X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
+
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_PLL_BYPASS	BIT(2)
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_PLL_BYPASS	BIT(3)
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_PLL_BYPASS	BIT(4)
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_SHIFT	5
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK	0x1f
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_POST_DIV_SHIFT	10
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK	0x1f
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_POST_DIV_SHIFT	15
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK	0x1f
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPUCLK_FROM_CPUPLL	BIT(20)
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
+#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
+
+#define QCA955X_PLL_CPU_CONFIG_REG		0x00
+#define QCA955X_PLL_DDR_CONFIG_REG		0x04
+#define QCA955X_PLL_CLK_CTRL_REG		0x08
+
+#define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+#define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+#define QCA955X_PLL_CPU_CONFIG_NINT_SHIFT	6
+#define QCA955X_PLL_CPU_CONFIG_NINT_MASK	0x3f
+#define QCA955X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
+#define QCA955X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define QCA955X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
+#define QCA955X_PLL_CPU_CONFIG_OUTDIV_MASK	0x3
+
+#define QCA955X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
+#define QCA955X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
+#define QCA955X_PLL_DDR_CONFIG_NINT_SHIFT	10
+#define QCA955X_PLL_DDR_CONFIG_NINT_MASK	0x3f
+#define QCA955X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
+#define QCA955X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
+#define QCA955X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
+#define QCA955X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
+
+#define QCA955X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
+#define QCA955X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
+#define QCA955X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
+#define QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
+#define QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
+#define QCA955X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
+#define QCA955X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
+#define QCA955X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
+#define QCA955X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
+#define QCA955X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL		BIT(20)
+#define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
+#define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+
+/*
+ * USB_CONFIG block
+ */
+#define AR71XX_USB_CTRL_REG_FLADJ	0x00
+#define AR71XX_USB_CTRL_REG_CONFIG	0x04
+
+/*
+ * RESET block
+ */
+#define AR71XX_RESET_REG_TIMER			0x00
+#define AR71XX_RESET_REG_TIMER_RELOAD		0x04
+#define AR71XX_RESET_REG_WDOG_CTRL		0x08
+#define AR71XX_RESET_REG_WDOG			0x0c
+#define AR71XX_RESET_REG_MISC_INT_STATUS	0x10
+#define AR71XX_RESET_REG_MISC_INT_ENABLE	0x14
+#define AR71XX_RESET_REG_PCI_INT_STATUS		0x18
+#define AR71XX_RESET_REG_PCI_INT_ENABLE		0x1c
+#define AR71XX_RESET_REG_GLOBAL_INT_STATUS	0x20
+#define AR71XX_RESET_REG_RESET_MODULE		0x24
+#define AR71XX_RESET_REG_PERFC_CTRL		0x2c
+#define AR71XX_RESET_REG_PERFC0			0x30
+#define AR71XX_RESET_REG_PERFC1			0x34
+#define AR71XX_RESET_REG_REV_ID			0x90
+
+#define AR913X_RESET_REG_GLOBAL_INT_STATUS	0x18
+#define AR913X_RESET_REG_RESET_MODULE		0x1c
+#define AR913X_RESET_REG_PERF_CTRL		0x20
+#define AR913X_RESET_REG_PERFC0			0x24
+#define AR913X_RESET_REG_PERFC1			0x28
+
+#define AR724X_RESET_REG_RESET_MODULE		0x1c
+
+#define AR933X_RESET_REG_RESET_MODULE		0x1c
+#define AR933X_RESET_REG_BOOTSTRAP		0xac
+
+#define AR934X_RESET_REG_RESET_MODULE		0x1c
+#define AR934X_RESET_REG_BOOTSTRAP		0xb0
+#define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
+
+#define QCA955X_RESET_REG_BOOTSTRAP		0xb0
+#define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
+
+#define MISC_INT_ETHSW			BIT(12)
+#define MISC_INT_TIMER4			BIT(10)
+#define MISC_INT_TIMER3			BIT(9)
+#define MISC_INT_TIMER2			BIT(8)
+#define MISC_INT_DMA			BIT(7)
+#define MISC_INT_OHCI			BIT(6)
+#define MISC_INT_PERFC			BIT(5)
+#define MISC_INT_WDOG			BIT(4)
+#define MISC_INT_UART			BIT(3)
+#define MISC_INT_GPIO			BIT(2)
+#define MISC_INT_ERROR			BIT(1)
+#define MISC_INT_TIMER			BIT(0)
+
+#define AR71XX_RESET_EXTERNAL		BIT(28)
+#define AR71XX_RESET_FULL_CHIP		BIT(24)
+#define AR71XX_RESET_CPU_NMI		BIT(21)
+#define AR71XX_RESET_CPU_COLD		BIT(20)
+#define AR71XX_RESET_DMA		BIT(19)
+#define AR71XX_RESET_SLIC		BIT(18)
+#define AR71XX_RESET_STEREO		BIT(17)
+#define AR71XX_RESET_DDR		BIT(16)
+#define AR71XX_RESET_GE1_MAC		BIT(13)
+#define AR71XX_RESET_GE1_PHY		BIT(12)
+#define AR71XX_RESET_USBSUS_OVERRIDE	BIT(10)
+#define AR71XX_RESET_GE0_MAC		BIT(9)
+#define AR71XX_RESET_GE0_PHY		BIT(8)
+#define AR71XX_RESET_USB_OHCI_DLL	BIT(6)
+#define AR71XX_RESET_USB_HOST		BIT(5)
+#define AR71XX_RESET_USB_PHY		BIT(4)
+#define AR71XX_RESET_PCI_BUS		BIT(1)
+#define AR71XX_RESET_PCI_CORE		BIT(0)
+
+#define AR7240_RESET_USB_HOST		BIT(5)
+#define AR7240_RESET_OHCI_DLL		BIT(3)
+
+#define AR724X_RESET_GE1_MDIO		BIT(23)
+#define AR724X_RESET_GE0_MDIO		BIT(22)
+#define AR724X_RESET_PCIE_PHY_SERIAL	BIT(10)
+#define AR724X_RESET_PCIE_PHY		BIT(7)
+#define AR724X_RESET_PCIE		BIT(6)
+#define AR724X_RESET_USB_HOST		BIT(5)
+#define AR724X_RESET_USB_PHY		BIT(4)
+#define AR724X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define AR913X_RESET_AMBA2WMAC		BIT(22)
+#define AR913X_RESET_USBSUS_OVERRIDE	BIT(10)
+#define AR913X_RESET_USB_HOST		BIT(5)
+#define AR913X_RESET_USB_PHY		BIT(4)
+
+#define AR933X_RESET_GE1_MDIO		BIT(23)
+#define AR933X_RESET_GE0_MDIO		BIT(22)
+#define AR933X_RESET_GE1_MAC		BIT(13)
+#define AR933X_RESET_WMAC		BIT(11)
+#define AR933X_RESET_GE0_MAC		BIT(9)
+#define AR933X_RESET_USB_HOST		BIT(5)
+#define AR933X_RESET_USB_PHY		BIT(4)
+#define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define AR934X_RESET_HOST		BIT(31)
+#define AR934X_RESET_SLIC		BIT(30)
+#define AR934X_RESET_HDMA		BIT(29)
+#define AR934X_RESET_EXTERNAL		BIT(28)
+#define AR934X_RESET_RTC		BIT(27)
+#define AR934X_RESET_PCIE_EP_INT	BIT(26)
+#define AR934X_RESET_CHKSUM_ACC		BIT(25)
+#define AR934X_RESET_FULL_CHIP		BIT(24)
+#define AR934X_RESET_GE1_MDIO		BIT(23)
+#define AR934X_RESET_GE0_MDIO		BIT(22)
+#define AR934X_RESET_CPU_NMI		BIT(21)
+#define AR934X_RESET_CPU_COLD		BIT(20)
+#define AR934X_RESET_HOST_RESET_INT	BIT(19)
+#define AR934X_RESET_PCIE_EP		BIT(18)
+#define AR934X_RESET_UART1		BIT(17)
+#define AR934X_RESET_DDR		BIT(16)
+#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
+#define AR934X_RESET_NANDF		BIT(14)
+#define AR934X_RESET_GE1_MAC		BIT(13)
+#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
+#define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
+#define AR934X_RESET_HOST_DMA_INT	BIT(10)
+#define AR934X_RESET_GE0_MAC		BIT(9)
+#define AR934X_RESET_ETH_SWITCH		BIT(8)
+#define AR934X_RESET_PCIE_PHY		BIT(7)
+#define AR934X_RESET_PCIE		BIT(6)
+#define AR934X_RESET_USB_HOST		BIT(5)
+#define AR934X_RESET_USB_PHY		BIT(4)
+#define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
+#define AR934X_RESET_LUT		BIT(2)
+#define AR934X_RESET_MBOX		BIT(1)
+#define AR934X_RESET_I2S		BIT(0)
+
+#define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
+#define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
+#define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
+
+#define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
+#define AR934X_BOOTSTRAP_SW_OPTION7	BIT(22)
+#define AR934X_BOOTSTRAP_SW_OPTION6	BIT(21)
+#define AR934X_BOOTSTRAP_SW_OPTION5	BIT(20)
+#define AR934X_BOOTSTRAP_SW_OPTION4	BIT(19)
+#define AR934X_BOOTSTRAP_SW_OPTION3	BIT(18)
+#define AR934X_BOOTSTRAP_SW_OPTION2	BIT(17)
+#define AR934X_BOOTSTRAP_SW_OPTION1	BIT(16)
+#define AR934X_BOOTSTRAP_USB_MODE_DEVICE BIT(7)
+#define AR934X_BOOTSTRAP_PCIE_RC	BIT(6)
+#define AR934X_BOOTSTRAP_EJTAG_MODE	BIT(5)
+#define AR934X_BOOTSTRAP_REF_CLK_40	BIT(4)
+#define AR934X_BOOTSTRAP_BOOT_FROM_SPI	BIT(2)
+#define AR934X_BOOTSTRAP_SDRAM_DISABLED	BIT(1)
+#define AR934X_BOOTSTRAP_DDR1		BIT(0)
+
+#define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
+
+#define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+#define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+#define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
+#define AR934X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
+#define AR934X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
+#define AR934X_PCIE_WMAC_INT_WMAC_ALL \
+	(AR934X_PCIE_WMAC_INT_WMAC_MISC | AR934X_PCIE_WMAC_INT_WMAC_TX | \
+	 AR934X_PCIE_WMAC_INT_WMAC_RXLP | AR934X_PCIE_WMAC_INT_WMAC_RXHP)
+
+#define AR934X_PCIE_WMAC_INT_PCIE_ALL \
+	(AR934X_PCIE_WMAC_INT_PCIE_RC | AR934X_PCIE_WMAC_INT_PCIE_RC0 | \
+	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
+	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
+
+#define QCA955X_EXT_INT_WMAC_MISC		BIT(0)
+#define QCA955X_EXT_INT_WMAC_TX			BIT(1)
+#define QCA955X_EXT_INT_WMAC_RXLP		BIT(2)
+#define QCA955X_EXT_INT_WMAC_RXHP		BIT(3)
+#define QCA955X_EXT_INT_PCIE_RC1		BIT(4)
+#define QCA955X_EXT_INT_PCIE_RC1_INT0		BIT(5)
+#define QCA955X_EXT_INT_PCIE_RC1_INT1		BIT(6)
+#define QCA955X_EXT_INT_PCIE_RC1_INT2		BIT(7)
+#define QCA955X_EXT_INT_PCIE_RC1_INT3		BIT(8)
+#define QCA955X_EXT_INT_PCIE_RC2		BIT(12)
+#define QCA955X_EXT_INT_PCIE_RC2_INT0		BIT(13)
+#define QCA955X_EXT_INT_PCIE_RC2_INT1		BIT(14)
+#define QCA955X_EXT_INT_PCIE_RC2_INT2		BIT(15)
+#define QCA955X_EXT_INT_PCIE_RC2_INT3		BIT(16)
+#define QCA955X_EXT_INT_USB1			BIT(24)
+#define QCA955X_EXT_INT_USB2			BIT(28)
+
+#define QCA955X_EXT_INT_WMAC_ALL \
+	(QCA955X_EXT_INT_WMAC_MISC | QCA955X_EXT_INT_WMAC_TX | \
+	 QCA955X_EXT_INT_WMAC_RXLP | QCA955X_EXT_INT_WMAC_RXHP)
+
+#define QCA955X_EXT_INT_PCIE_RC1_ALL \
+	(QCA955X_EXT_INT_PCIE_RC1 | QCA955X_EXT_INT_PCIE_RC1_INT0 | \
+	 QCA955X_EXT_INT_PCIE_RC1_INT1 | QCA955X_EXT_INT_PCIE_RC1_INT2 | \
+	 QCA955X_EXT_INT_PCIE_RC1_INT3)
+
+#define QCA955X_EXT_INT_PCIE_RC2_ALL \
+	(QCA955X_EXT_INT_PCIE_RC2 | QCA955X_EXT_INT_PCIE_RC2_INT0 | \
+	 QCA955X_EXT_INT_PCIE_RC2_INT1 | QCA955X_EXT_INT_PCIE_RC2_INT2 | \
+	 QCA955X_EXT_INT_PCIE_RC2_INT3)
+
+#define REV_ID_MAJOR_MASK		0xfff0
+#define REV_ID_MAJOR_AR71XX		0x00a0
+#define REV_ID_MAJOR_AR913X		0x00b0
+#define REV_ID_MAJOR_AR7240		0x00c0
+#define REV_ID_MAJOR_AR7241		0x0100
+#define REV_ID_MAJOR_AR7242		0x1100
+#define REV_ID_MAJOR_AR9330		0x0110
+#define REV_ID_MAJOR_AR9331		0x1110
+#define REV_ID_MAJOR_AR9341		0x0120
+#define REV_ID_MAJOR_AR9342		0x1120
+#define REV_ID_MAJOR_AR9344		0x2120
+#define REV_ID_MAJOR_QCA9558		0x1130
+
+#define AR71XX_REV_ID_MINOR_MASK	0x3
+#define AR71XX_REV_ID_MINOR_AR7130	0x0
+#define AR71XX_REV_ID_MINOR_AR7141	0x1
+#define AR71XX_REV_ID_MINOR_AR7161	0x2
+#define AR71XX_REV_ID_REVISION_MASK	0x3
+#define AR71XX_REV_ID_REVISION_SHIFT	2
+
+#define AR913X_REV_ID_MINOR_MASK	0x3
+#define AR913X_REV_ID_MINOR_AR9130	0x0
+#define AR913X_REV_ID_MINOR_AR9132	0x1
+#define AR913X_REV_ID_REVISION_MASK	0x3
+#define AR913X_REV_ID_REVISION_SHIFT	2
+
+#define AR933X_REV_ID_REVISION_MASK	0x3
+
+#define AR724X_REV_ID_REVISION_MASK	0x3
+
+#define AR934X_REV_ID_REVISION_MASK     0xf
+
+#define AR944X_REV_ID_REVISION_MASK	0xf
+
+/*
+ * SPI block
+ */
+#define AR71XX_SPI_REG_FS	0x00	/* Function Select */
+#define AR71XX_SPI_REG_CTRL	0x04	/* SPI Control */
+#define AR71XX_SPI_REG_IOC	0x08	/* SPI I/O Control */
+#define AR71XX_SPI_REG_RDS	0x0c	/* Read Data Shift */
+
+#define AR71XX_SPI_FS_GPIO	BIT(0)	/* Enable GPIO mode */
+
+#define AR71XX_SPI_CTRL_RD	BIT(6)	/* Remap Disable */
+#define AR71XX_SPI_CTRL_DIV_MASK 0x3f
+
+#define AR71XX_SPI_IOC_DO	BIT(0)	/* Data Out pin */
+#define AR71XX_SPI_IOC_CLK	BIT(8)	/* CLK pin */
+#define AR71XX_SPI_IOC_CS(n)	BIT(16 + (n))
+#define AR71XX_SPI_IOC_CS0	AR71XX_SPI_IOC_CS(0)
+#define AR71XX_SPI_IOC_CS1	AR71XX_SPI_IOC_CS(1)
+#define AR71XX_SPI_IOC_CS2	AR71XX_SPI_IOC_CS(2)
+#define AR71XX_SPI_IOC_CS_ALL	(AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1 | \
+				 AR71XX_SPI_IOC_CS2)
+
+/*
+ * GPIO block
+ */
+#define AR71XX_GPIO_REG_OE		0x00
+#define AR71XX_GPIO_REG_IN		0x04
+#define AR71XX_GPIO_REG_OUT		0x08
+#define AR71XX_GPIO_REG_SET		0x0c
+#define AR71XX_GPIO_REG_CLEAR		0x10
+#define AR71XX_GPIO_REG_INT_MODE	0x14
+#define AR71XX_GPIO_REG_INT_TYPE	0x18
+#define AR71XX_GPIO_REG_INT_POLARITY	0x1c
+#define AR71XX_GPIO_REG_INT_PENDING	0x20
+#define AR71XX_GPIO_REG_INT_ENABLE	0x24
+#define AR71XX_GPIO_REG_FUNC		0x28
+
+#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
+#define AR934X_GPIO_REG_OUT_FUNC1	0x30
+#define AR934X_GPIO_REG_OUT_FUNC2	0x34
+#define AR934X_GPIO_REG_OUT_FUNC3	0x38
+#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
+#define AR934X_GPIO_REG_OUT_FUNC5	0x40
+#define AR934X_GPIO_REG_FUNC		0x6c
+
+#define AR71XX_GPIO_COUNT		16
+#define AR724X_GPIO_COUNT		18
+#define AR913X_GPIO_COUNT		22
+#define AR933X_GPIO_COUNT		30
+#define AR934X_GPIO_COUNT		23
+#define QCA955X_GPIO_COUNT		24
+
+#define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
+#define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
+#define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
+#define AR71XX_GPIO_FUNC_SPI_CS1_EN		BIT(12)
+#define AR71XX_GPIO_FUNC_UART_EN		BIT(8)
+#define AR71XX_GPIO_FUNC_USB_OC_EN		BIT(4)
+#define AR71XX_GPIO_FUNC_USB_CLK_EN		BIT(0)
+
+#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
+#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
+#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
+#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
+#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
+#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
+#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
+#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
+#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
+#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
+#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
+#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+
+#define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
+#define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
+#define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
+#define AR913X_GPIO_FUNC_I2S_MCKEN		BIT(19)
+#define AR913X_GPIO_FUNC_I2S1_EN		BIT(18)
+#define AR913X_GPIO_FUNC_I2S0_EN		BIT(17)
+#define AR913X_GPIO_FUNC_SLIC_EN		BIT(16)
+#define AR913X_GPIO_FUNC_UART_RTSCTS_EN		BIT(9)
+#define AR913X_GPIO_FUNC_UART_EN		BIT(8)
+#define AR913X_GPIO_FUNC_USB_CLK_EN		BIT(4)
+
+#define AR933X_GPIO_FUNC_SPDIF2TCK		BIT(31)
+#define AR933X_GPIO_FUNC_SPDIF_EN		BIT(30)
+#define AR933X_GPIO_FUNC_I2SO_22_18_EN		BIT(29)
+#define AR933X_GPIO_FUNC_I2S_MCK_EN		BIT(27)
+#define AR933X_GPIO_FUNC_I2SO_EN		BIT(26)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_DUPL	BIT(25)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_COLL	BIT(24)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_ACT	BIT(23)
+#define AR933X_GPIO_FUNC_SPI_EN			BIT(18)
+#define AR933X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
+#define AR933X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
+#define AR933X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
+#define AR933X_GPIO_FUNC_UART_EN		BIT(1)
+#define AR933X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+
+#define AR934X_GPIO_FUNC_DDR_DQOE_EN	BIT(17)
+#define AR934X_GPIO_FUNC_SPI_CS_1_EN	BIT(14)
+#define AR934X_GPIO_FUNC_SPI_CS_0_EN	BIT(13)
+
+#define AR934X_GPIO_OUT_GPIO		0x00
+
+/*
+ * MII_CTRL block
+ */
+#define AR71XX_MII_REG_MII0_CTRL	0x00
+#define AR71XX_MII_REG_MII1_CTRL	0x04
+
+#define AR71XX_MII_CTRL_IF_MASK		3
+#define AR71XX_MII_CTRL_SPEED_SHIFT	4
+#define AR71XX_MII_CTRL_SPEED_MASK	3
+#define AR71XX_MII_CTRL_SPEED_10	0
+#define AR71XX_MII_CTRL_SPEED_100	1
+#define AR71XX_MII_CTRL_SPEED_1000	2
+
+#define AR71XX_MII0_CTRL_IF_GMII	0
+#define AR71XX_MII0_CTRL_IF_MII		1
+#define AR71XX_MII0_CTRL_IF_RGMII	2
+#define AR71XX_MII0_CTRL_IF_RMII	3
+
+#define AR71XX_MII1_CTRL_IF_RGMII	0
+#define AR71XX_MII1_CTRL_IF_RMII	1
+
+/*
+ * AR933X GMAC interface
+ */
+#define AR933X_GMAC_REG_ETH_CFG		0x00
+
+#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
+#define AR933X_ETH_CFG_MII_GE0		BIT(1)
+#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
+#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
+#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
+#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
+#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
+#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
+#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
+#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
+#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
+
+/*
+ * AR934X GMAC Interface
+ */
+#define AR934X_GMAC_REG_ETH_CFG		0x00
+
+#define AR934X_ETH_CFG_RGMII_GMAC0	BIT(0)
+#define AR934X_ETH_CFG_MII_GMAC0	BIT(1)
+#define AR934X_ETH_CFG_GMII_GMAC0	BIT(2)
+#define AR934X_ETH_CFG_MII_GMAC0_MASTER	BIT(3)
+#define AR934X_ETH_CFG_MII_GMAC0_SLAVE	BIT(4)
+#define AR934X_ETH_CFG_MII_GMAC0_ERR_EN	BIT(5)
+#define AR934X_ETH_CFG_SW_ONLY_MODE	BIT(6)
+#define AR934X_ETH_CFG_SW_PHY_SWAP	BIT(7)
+#define AR934X_ETH_CFG_SW_APB_ACCESS	BIT(9)
+#define AR934X_ETH_CFG_RMII_GMAC0	BIT(10)
+#define AR933X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
+#define AR934X_ETH_CFG_RMII_GMAC0_MASTER BIT(12)
+#define AR933X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
+
+/*
+ * QCA955X GMAC Interface
+ */
+
+#define QCA955X_GMAC_REG_ETH_CFG	0x00
+
+#define QCA955X_ETH_CFG_RGMII_GMAC0	BIT(0)
+#define QCA955X_ETH_CFG_SGMII_GMAC0	BIT(6)
+
+#endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/ath79/image/lzma-loader/src/board.c b/target/linux/ath79/image/lzma-loader/src/board.c
new file mode 100644
index 0000000000..2f4dd6b1f6
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/board.c
@@ -0,0 +1,56 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <stddef.h>
+#include "config.h"
+#include "ar71xx_regs.h"
+
+#define READREG(r)	*(volatile unsigned int *)(r)
+#define WRITEREG(r,v)	*(volatile unsigned int *)(r) = v
+
+#define KSEG1ADDR(_x)	(((_x) & 0x1fffffff) | 0xa0000000)
+
+#define UART_BASE	0xb8020000
+
+#define UART_TX		0
+#define UART_LSR	5
+
+#define UART_LSR_THRE   0x20
+
+#define UART_READ(r)		READREG(UART_BASE + 4 * (r))
+#define UART_WRITE(r,v)		WRITEREG(UART_BASE + 4 * (r), (v))
+
+void board_putc(int ch)
+{
+	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
+	UART_WRITE(UART_TX, ch);
+	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
+}
+
+#ifdef CONFIG_BOARD_TL_WR1043ND_V1
+static void tlwr1043nd_init(void)
+{
+	unsigned int reg = KSEG1ADDR(AR71XX_RESET_BASE);
+	unsigned int t;
+
+	t = READREG(reg + AR913X_RESET_REG_RESET_MODULE);
+	t |= AR71XX_RESET_GE0_PHY;
+	WRITEREG(reg + AR913X_RESET_REG_RESET_MODULE, t);
+	/* flush write */
+	t = READREG(reg + AR913X_RESET_REG_RESET_MODULE);
+}
+#else
+static inline void tlwr1043nd_init(void) {}
+#endif
+
+void board_init(void)
+{
+	tlwr1043nd_init();
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/cache.c b/target/linux/ath79/image/lzma-loader/src/cache.c
new file mode 100644
index 0000000000..28cc848333
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/cache.c
@@ -0,0 +1,43 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * The cache manipulation routine has been taken from the U-Boot project.
+ *	(C) Copyright 2003
+ *	Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include "cache.h"
+#include "cacheops.h"
+#include "config.h"
+
+#define cache_op(op,addr)						\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noreorder				\n"	\
+	"	.set	mips3\n\t				\n"	\
+	"	cache	%0, %1					\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "i" (op), "R" (*(unsigned char *)(addr)))
+
+void flush_cache(unsigned long start_addr, unsigned long size)
+{
+	unsigned long lsize = CONFIG_CACHELINE_SIZE;
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		cache_op(Hit_Invalidate_I, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/cache.h b/target/linux/ath79/image/lzma-loader/src/cache.h
new file mode 100644
index 0000000000..506a235884
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/cache.h
@@ -0,0 +1,17 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#ifndef __CACHE_H
+#define __CACHE_H
+
+void flush_cache(unsigned long start_addr, unsigned long size);
+
+#endif /* __CACHE_H */
diff --git a/target/linux/ath79/image/lzma-loader/src/cacheops.h b/target/linux/ath79/image/lzma-loader/src/cacheops.h
new file mode 100644
index 0000000000..70bcad7694
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/cacheops.h
@@ -0,0 +1,85 @@
+/*
+ * Cache operations for the cache instruction.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * (C) Copyright 1996, 97, 99, 2002, 03 Ralf Baechle
+ * (C) Copyright 1999 Silicon Graphics, Inc.
+ */
+#ifndef	__ASM_CACHEOPS_H
+#define	__ASM_CACHEOPS_H
+
+/*
+ * Cache Operations available on all MIPS processors with R4000-style caches
+ */
+#define Index_Invalidate_I      0x00
+#define Index_Writeback_Inv_D   0x01
+#define Index_Load_Tag_I	0x04
+#define Index_Load_Tag_D	0x05
+#define Index_Store_Tag_I	0x08
+#define Index_Store_Tag_D	0x09
+#if defined(CONFIG_CPU_LOONGSON2)
+#define Hit_Invalidate_I	0x00
+#else
+#define Hit_Invalidate_I	0x10
+#endif
+#define Hit_Invalidate_D	0x11
+#define Hit_Writeback_Inv_D	0x15
+
+/*
+ * R4000-specific cacheops
+ */
+#define Create_Dirty_Excl_D	0x0d
+#define Fill			0x14
+#define Hit_Writeback_I		0x18
+#define Hit_Writeback_D		0x19
+
+/*
+ * R4000SC and R4400SC-specific cacheops
+ */
+#define Index_Invalidate_SI     0x02
+#define Index_Writeback_Inv_SD  0x03
+#define Index_Load_Tag_SI	0x06
+#define Index_Load_Tag_SD	0x07
+#define Index_Store_Tag_SI	0x0A
+#define Index_Store_Tag_SD	0x0B
+#define Create_Dirty_Excl_SD	0x0f
+#define Hit_Invalidate_SI	0x12
+#define Hit_Invalidate_SD	0x13
+#define Hit_Writeback_Inv_SD	0x17
+#define Hit_Writeback_SD	0x1b
+#define Hit_Set_Virtual_SI	0x1e
+#define Hit_Set_Virtual_SD	0x1f
+
+/*
+ * R5000-specific cacheops
+ */
+#define R5K_Page_Invalidate_S	0x17
+
+/*
+ * RM7000-specific cacheops
+ */
+#define Page_Invalidate_T	0x16
+
+/*
+ * R10000-specific cacheops
+ *
+ * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
+ * Most of the _S cacheops are identical to the R4000SC _SD cacheops.
+ */
+#define Index_Writeback_Inv_S	0x03
+#define Index_Load_Tag_S	0x07
+#define Index_Store_Tag_S	0x0B
+#define Hit_Invalidate_S	0x13
+#define Cache_Barrier		0x14
+#define Hit_Writeback_Inv_S	0x17
+#define Index_Load_Data_I	0x18
+#define Index_Load_Data_D	0x19
+#define Index_Load_Data_S	0x1b
+#define Index_Store_Data_I	0x1c
+#define Index_Store_Data_D	0x1d
+#define Index_Store_Data_S	0x1f
+
+#endif	/* __ASM_CACHEOPS_H */
diff --git a/target/linux/ath79/image/lzma-loader/src/config.h b/target/linux/ath79/image/lzma-loader/src/config.h
new file mode 100644
index 0000000000..287392b340
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/config.h
@@ -0,0 +1,31 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+#define CONFIG_ICACHE_SIZE	(32 * 1024)
+#define CONFIG_DCACHE_SIZE	(64 * 1024)
+#define CONFIG_CACHELINE_SIZE	32
+
+#ifndef CONFIG_FLASH_OFFS
+#define CONFIG_FLASH_OFFS	0
+#endif
+
+#ifndef CONFIG_FLASH_MAX
+#define CONFIG_FLASH_MAX	0
+#endif
+
+#ifndef CONFIG_FLASH_STEP
+#define CONFIG_FLASH_STEP	0x1000
+#endif
+
+#endif /* _CONFIG_H_ */
diff --git a/target/linux/ath79/image/lzma-loader/src/cp0regdef.h b/target/linux/ath79/image/lzma-loader/src/cp0regdef.h
new file mode 100644
index 0000000000..c1188ad8c8
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/cp0regdef.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 1994, 1995, 1996, 1997, 2000, 2001 by Ralf Baechle
+ *
+ * Copyright (C) 2001, Monta Vista Software
+ * Author: jsun@mvista.com or jsun@junsun.net
+ */
+#ifndef _cp0regdef_h_
+#define _cp0regdef_h_
+
+#define CP0_INDEX $0
+#define CP0_RANDOM $1
+#define CP0_ENTRYLO0 $2
+#define CP0_ENTRYLO1 $3
+#define CP0_CONTEXT $4
+#define CP0_PAGEMASK $5
+#define CP0_WIRED $6
+#define CP0_BADVADDR $8
+#define CP0_COUNT $9
+#define CP0_ENTRYHI $10
+#define CP0_COMPARE $11
+#define CP0_STATUS $12
+#define CP0_CAUSE $13
+#define CP0_EPC $14
+#define CP0_PRID $15
+#define CP0_CONFIG $16
+#define CP0_LLADDR $17
+#define CP0_WATCHLO $18
+#define CP0_WATCHHI $19
+#define CP0_XCONTEXT $20
+#define CP0_FRAMEMASK $21
+#define CP0_DIAGNOSTIC $22
+#define CP0_PERFORMANCE $25
+#define CP0_ECC $26
+#define CP0_CACHEERR $27
+#define CP0_TAGLO $28
+#define CP0_TAGHI $29
+#define CP0_ERROREPC $30
+
+#endif
diff --git a/target/linux/ath79/image/lzma-loader/src/head.S b/target/linux/ath79/image/lzma-loader/src/head.S
new file mode 100644
index 0000000000..d414b14d11
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/head.S
@@ -0,0 +1,134 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Some parts of this code was based on the OpenWrt specific lzma-loader
+ * for the BCM47xx and ADM5120 based boards:
+ *	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
+ *	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include "cp0regdef.h"
+#include "cacheops.h"
+#include "config.h"
+
+#define KSEG0		0x80000000
+
+	.macro	ehb
+	sll     zero, 3
+	.endm
+
+	.text
+
+LEAF(startup)
+	.set noreorder
+	.set mips32
+
+	mtc0	zero, CP0_WATCHLO	# clear watch registers
+	mtc0	zero, CP0_WATCHHI
+	mtc0	zero, CP0_CAUSE		# clear before writing status register
+
+	mfc0	t0, CP0_STATUS
+	li	t1, 0x1000001f
+	or	t0, t1
+	xori	t0, 0x1f
+	mtc0	t0, CP0_STATUS
+	ehb
+
+	/*
+	 * Some bootloaders set the 'Kseg0 coherency algorithm' to
+	 * 'Cacheable, noncoherent, write-through, no write allocate'
+	 * and this cause performance issues. Let's go and change it to
+	 * 'Cacheable, noncoherent, write-back, write allocate'
+	 */
+	mfc0	t0, CP0_CONFIG
+	li	t1, ~7			#~CONF_CM_CMASK
+	and	t0, t1
+	ori	t0, 3			#CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+	nop
+
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+	ehb
+
+	la	t0, __reloc_label	# get linked address of label
+	bal	__reloc_label		# branch and link to label to
+	nop				# get actual address
+__reloc_label:
+	subu	t0, ra, t0		# get reloc_delta
+
+	beqz	t0, __reloc_done         # if delta is 0 we are in the right place
+	nop
+
+	/* Copy our code to the right place */
+	la	t1, _code_start		# get linked address of _code_start
+	la	t2, _code_end		# get linked address of _code_end
+	addu	t0, t0, t1		# calculate actual address of _code_start
+
+__reloc_copy:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	add	t1, 4
+	blt	t1, t2, __reloc_copy
+	add	t0, 4
+
+	/* flush cache */
+	la	t0, _code_start
+	la	t1, _code_end
+
+	li	t2, ~(CONFIG_CACHELINE_SIZE - 1)
+	and	t0, t2
+	and	t1, t2
+	li	t2, CONFIG_CACHELINE_SIZE
+
+	b	__flush_check
+	nop
+
+__flush_line:
+	cache	Hit_Writeback_Inv_D, 0(t0)
+	cache	Hit_Invalidate_I, 0(t0)
+	add	t0, t2
+
+__flush_check:
+	bne	t0, t1, __flush_line
+	nop
+
+	sync
+
+__reloc_done:
+
+	/* clear bss */
+	la	t0, _bss_start
+	la	t1, _bss_end
+	b	__bss_check
+	nop
+
+__bss_fill:
+	sw	zero, 0(t0)
+	addi	t0, 4
+
+__bss_check:
+	bne	t0, t1, __bss_fill
+	nop
+
+	/* Setup new "C" stack */
+	la	sp, _stack
+
+	/* reserve stack space for a0-a3 registers */
+	subu	sp, 16
+
+	/* jump to the decompressor routine */
+	la	t0, loader_main
+	jr	t0
+	nop
+
+	.set reorder
+END(startup)
diff --git a/target/linux/ath79/image/lzma-loader/src/loader.c b/target/linux/ath79/image/lzma-loader/src/loader.c
new file mode 100644
index 0000000000..794c4b6285
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/loader.c
@@ -0,0 +1,264 @@
+/*
+ * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Some parts of this code was based on the OpenWrt specific lzma-loader
+ * for the BCM47xx and ADM5120 based boards:
+ *	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
+ *	Copyright (C) 2005 Mineharu Takahara <mtakahar@yahoo.com>
+ *	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
+ *
+ * The image_header structure has been taken from the U-Boot project.
+ *	(C) Copyright 2008 Semihalf
+ *	(C) Copyright 2000-2005
+ *	Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "config.h"
+#include "cache.h"
+#include "printf.h"
+#include "LzmaDecode.h"
+
+#define AR71XX_FLASH_START	0x1f000000
+#define AR71XX_FLASH_END	0x1fe00000
+
+#define KSEG0			0x80000000
+#define KSEG1			0xa0000000
+
+#define KSEG1ADDR(a)		((((unsigned)(a)) & 0x1fffffffU) | KSEG1)
+
+#undef LZMA_DEBUG
+
+#ifdef LZMA_DEBUG
+#  define DBG(f, a...)	printf(f, ## a)
+#else
+#  define DBG(f, a...)	do {} while (0)
+#endif
+
+#define IH_MAGIC_OKLI		0x4f4b4c49	/* 'OKLI' */
+
+#define IH_NMLEN		32	/* Image Name Length		*/
+
+typedef struct image_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number	*/
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
+	uint32_t	ih_time;	/* Image Creation Timestamp	*/
+	uint32_t	ih_size;	/* Image Data Size		*/
+	uint32_t	ih_load;	/* Data	 Load  Address		*/
+	uint32_t	ih_ep;		/* Entry Point Address		*/
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
+	uint8_t		ih_os;		/* Operating System		*/
+	uint8_t		ih_arch;	/* CPU architecture		*/
+	uint8_t		ih_type;	/* Image Type			*/
+	uint8_t		ih_comp;	/* Compression Type		*/
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
+} image_header_t;
+
+/* beyond the image end, size not known in advance */
+extern unsigned char workspace[];
+extern void board_init(void);
+
+static CLzmaDecoderState lzma_state;
+static unsigned char *lzma_data;
+static unsigned long lzma_datasize;
+static unsigned long lzma_outsize;
+static unsigned long kernel_la;
+
+#ifdef CONFIG_KERNEL_CMDLINE
+#define kernel_argc	2
+static const char kernel_cmdline[] = CONFIG_KERNEL_CMDLINE;
+static const char *const kernel_argv[] = {
+	NULL,
+	kernel_cmdline,
+	NULL,
+};
+#endif /* CONFIG_KERNEL_CMDLINE */
+
+static void halt(void)
+{
+	printf("\nSystem halted!\n");
+	for(;;);
+}
+
+static __inline__ unsigned long get_be32(void *buf)
+{
+	unsigned char *p = buf;
+
+	return (((unsigned long) p[0] << 24) +
+	        ((unsigned long) p[1] << 16) +
+	        ((unsigned long) p[2] << 8) +
+	        (unsigned long) p[3]);
+}
+
+static __inline__ unsigned char lzma_get_byte(void)
+{
+	unsigned char c;
+
+	lzma_datasize--;
+	c = *lzma_data++;
+
+	return c;
+}
+
+static int lzma_init_props(void)
+{
+	unsigned char props[LZMA_PROPERTIES_SIZE];
+	int res;
+	int i;
+
+	/* read lzma properties */
+	for (i = 0; i < LZMA_PROPERTIES_SIZE; i++)
+		props[i] = lzma_get_byte();
+
+	/* read the lower half of uncompressed size in the header */
+	lzma_outsize = ((SizeT) lzma_get_byte()) +
+		       ((SizeT) lzma_get_byte() << 8) +
+		       ((SizeT) lzma_get_byte() << 16) +
+		       ((SizeT) lzma_get_byte() << 24);
+
+	/* skip rest of the header (upper half of uncompressed size) */
+	for (i = 0; i < 4; i++)
+		lzma_get_byte();
+
+	res = LzmaDecodeProperties(&lzma_state.Properties, props,
+					LZMA_PROPERTIES_SIZE);
+	return res;
+}
+
+static int lzma_decompress(unsigned char *outStream)
+{
+	SizeT ip, op;
+	int ret;
+
+	lzma_state.Probs = (CProb *) workspace;
+
+	ret = LzmaDecode(&lzma_state, lzma_data, lzma_datasize, &ip, outStream,
+			 lzma_outsize, &op);
+
+	if (ret != LZMA_RESULT_OK) {
+		int i;
+
+		DBG("LzmaDecode error %d at %08x, osize:%d ip:%d op:%d\n",
+		    ret, lzma_data + ip, lzma_outsize, ip, op);
+
+		for (i = 0; i < 16; i++)
+			DBG("%02x ", lzma_data[ip + i]);
+
+		DBG("\n");
+	}
+
+	return ret;
+}
+
+#if (LZMA_WRAPPER)
+static void lzma_init_data(void)
+{
+	extern unsigned char _lzma_data_start[];
+	extern unsigned char _lzma_data_end[];
+
+	kernel_la = LOADADDR;
+	lzma_data = _lzma_data_start;
+	lzma_datasize = _lzma_data_end - _lzma_data_start;
+}
+#else
+static void lzma_init_data(void)
+{
+	struct image_header *hdr = NULL;
+	unsigned char *flash_base;
+	unsigned long flash_ofs;
+	unsigned long kernel_ofs;
+	unsigned long kernel_size;
+
+	flash_base = (unsigned char *) KSEG1ADDR(AR71XX_FLASH_START);
+
+	printf("Looking for OpenWrt image... ");
+
+	for (flash_ofs = CONFIG_FLASH_OFFS;
+	     flash_ofs <= (CONFIG_FLASH_OFFS + CONFIG_FLASH_MAX);
+	     flash_ofs += CONFIG_FLASH_STEP) {
+		unsigned long magic;
+		unsigned char *p;
+
+		p = flash_base + flash_ofs;
+		magic = get_be32(p);
+		if (magic == IH_MAGIC_OKLI) {
+			hdr = (struct image_header *) p;
+			break;
+		}
+	}
+
+	if (hdr == NULL) {
+		printf("not found!\n");
+		halt();
+	}
+
+	printf("found at 0x%08x\n", flash_base + flash_ofs);
+
+	kernel_ofs = sizeof(struct image_header);
+	kernel_size = get_be32(&hdr->ih_size);
+	kernel_la = get_be32(&hdr->ih_load);
+
+	lzma_data = flash_base + flash_ofs + kernel_ofs;
+	lzma_datasize = kernel_size;
+}
+#endif /* (LZMA_WRAPPER) */
+
+void loader_main(unsigned long reg_a0, unsigned long reg_a1,
+		 unsigned long reg_a2, unsigned long reg_a3)
+{
+	void (*kernel_entry) (unsigned long, unsigned long, unsigned long,
+			      unsigned long);
+	int res;
+
+	board_init();
+
+	printf("\n\nOpenWrt kernel loader for AR7XXX/AR9XXX\n");
+	printf("Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>\n");
+
+	lzma_init_data();
+
+	res = lzma_init_props();
+	if (res != LZMA_RESULT_OK) {
+		printf("Incorrect LZMA stream properties!\n");
+		halt();
+	}
+
+	printf("Decompressing kernel... ");
+
+	res = lzma_decompress((unsigned char *) kernel_la);
+	if (res != LZMA_RESULT_OK) {
+		printf("failed, ");
+		switch (res) {
+		case LZMA_RESULT_DATA_ERROR:
+			printf("data error!\n");
+			break;
+		default:
+			printf("unknown error %d!\n", res);
+		}
+		halt();
+	} else {
+		printf("done!\n");
+	}
+
+	flush_cache(kernel_la, lzma_outsize);
+
+	printf("Starting kernel at %08x...\n\n", kernel_la);
+
+#ifdef CONFIG_KERNEL_CMDLINE
+	reg_a0 = kernel_argc;
+	reg_a1 = (unsigned long) kernel_argv;
+	reg_a2 = 0;
+	reg_a3 = 0;
+#endif
+
+	kernel_entry = (void *) kernel_la;
+	kernel_entry(reg_a0, reg_a1, reg_a2, reg_a3);
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/loader.lds b/target/linux/ath79/image/lzma-loader/src/loader.lds
new file mode 100644
index 0000000000..01ff852361
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/loader.lds
@@ -0,0 +1,34 @@
+OUTPUT_ARCH(mips)
+SECTIONS {
+	.text : {
+		_code_start = .;
+		*(.text)
+		*(.text.*)
+		*(.rodata)
+		*(.rodata.*)
+		*(.data.lzma)
+	}
+
+	. = ALIGN(32);
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(32);
+	_code_end = .;
+
+	_bss_start = .;
+	.bss : {
+		*(.bss)
+		*(.bss.*)
+	}
+
+	. = ALIGN(32);
+	_bss_end = .;
+
+	. = . + 8192;
+	_stack = .;
+
+	workspace = .;
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/loader2.lds b/target/linux/ath79/image/lzma-loader/src/loader2.lds
new file mode 100644
index 0000000000..db0bb46424
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/loader2.lds
@@ -0,0 +1,10 @@
+OUTPUT_ARCH(mips)
+SECTIONS {
+	.text : {
+		startup = .;
+		*(.text)
+		*(.text.*)
+		*(.data)
+		*(.data.*)
+	}
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/lzma-data.lds b/target/linux/ath79/image/lzma-loader/src/lzma-data.lds
new file mode 100644
index 0000000000..abf756ba13
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/lzma-data.lds
@@ -0,0 +1,8 @@
+OUTPUT_ARCH(mips)
+SECTIONS {
+	.data.lzma : {
+		_lzma_data_start = .;
+		*(.data)
+		_lzma_data_end = .;
+	}
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/printf.c b/target/linux/ath79/image/lzma-loader/src/printf.c
new file mode 100644
index 0000000000..7bb5a86e18
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/printf.c
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include	"printf.h"
+
+extern void board_putc(int ch);
+
+/* this is the maximum width for a variable */
+#define		LP_MAX_BUF	256
+
+/* macros */
+#define		IsDigit(x)	( ((x) >= '0') && ((x) <= '9') )
+#define		Ctod(x)		( (x) - '0')
+
+/* forward declaration */
+static int PrintChar(char *, char, int, int);
+static int PrintString(char *, char *, int, int);
+static int PrintNum(char *, unsigned long, int, int, int, int, char, int);
+
+/* private variable */
+static const char theFatalMsg[] = "fatal error in lp_Print!";
+
+/* -*-
+ * A low level printf() function.
+ */
+static void
+lp_Print(void (*output)(void *, char *, int),
+	 void * arg,
+	 char *fmt,
+	 va_list ap)
+{
+
+#define 	OUTPUT(arg, s, l)  \
+  { if (((l) < 0) || ((l) > LP_MAX_BUF)) { \
+       (*output)(arg, (char*)theFatalMsg, sizeof(theFatalMsg)-1); for(;;); \
+    } else { \
+      (*output)(arg, s, l); \
+    } \
+  }
+
+    char buf[LP_MAX_BUF];
+
+    char c;
+    char *s;
+    long int num;
+
+    int longFlag;
+    int negFlag;
+    int width;
+    int prec;
+    int ladjust;
+    char padc;
+
+    int length;
+
+    for(;;) {
+	{
+	    /* scan for the next '%' */
+	    char *fmtStart = fmt;
+	    while ( (*fmt != '\0') && (*fmt != '%')) {
+		fmt ++;
+	    }
+
+	    /* flush the string found so far */
+	    OUTPUT(arg, fmtStart, fmt-fmtStart);
+
+	    /* are we hitting the end? */
+	    if (*fmt == '\0') break;
+	}
+
+	/* we found a '%' */
+	fmt ++;
+
+	/* check for long */
+	if (*fmt == 'l') {
+	    longFlag = 1;
+	    fmt ++;
+	} else {
+	    longFlag = 0;
+	}
+
+	/* check for other prefixes */
+	width = 0;
+	prec = -1;
+	ladjust = 0;
+	padc = ' ';
+
+	if (*fmt == '-') {
+	    ladjust = 1;
+	    fmt ++;
+	}
+
+	if (*fmt == '0') {
+	    padc = '0';
+	    fmt++;
+	}
+
+	if (IsDigit(*fmt)) {
+	    while (IsDigit(*fmt)) {
+		width = 10 * width + Ctod(*fmt++);
+	    }
+	}
+
+	if (*fmt == '.') {
+	    fmt ++;
+	    if (IsDigit(*fmt)) {
+		prec = 0;
+		while (IsDigit(*fmt)) {
+		    prec = prec*10 + Ctod(*fmt++);
+		}
+	    }
+	}
+
+
+	/* check format flag */
+	negFlag = 0;
+	switch (*fmt) {
+	 case 'b':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    length = PrintNum(buf, num, 2, 0, width, ladjust, padc, 0);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'd':
+	 case 'D':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    if (num < 0) {
+		num = - num;
+		negFlag = 1;
+	    }
+	    length = PrintNum(buf, num, 10, negFlag, width, ladjust, padc, 0);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'o':
+	 case 'O':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    length = PrintNum(buf, num, 8, 0, width, ladjust, padc, 0);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'u':
+	 case 'U':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    length = PrintNum(buf, num, 10, 0, width, ladjust, padc, 0);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'x':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    length = PrintNum(buf, num, 16, 0, width, ladjust, padc, 0);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'X':
+	    if (longFlag) {
+		num = va_arg(ap, long int);
+	    } else {
+		num = va_arg(ap, int);
+	    }
+	    length = PrintNum(buf, num, 16, 0, width, ladjust, padc, 1);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 'c':
+	    c = (char)va_arg(ap, int);
+	    length = PrintChar(buf, c, width, ladjust);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case 's':
+	    s = (char*)va_arg(ap, char *);
+	    length = PrintString(buf, s, width, ladjust);
+	    OUTPUT(arg, buf, length);
+	    break;
+
+	 case '\0':
+	    fmt --;
+	    break;
+
+	 default:
+	    /* output this char as it is */
+	    OUTPUT(arg, fmt, 1);
+	}	/* switch (*fmt) */
+
+	fmt ++;
+    }		/* for(;;) */
+
+    /* special termination call */
+    OUTPUT(arg, "\0", 1);
+}
+
+
+/* --------------- local help functions --------------------- */
+static int
+PrintChar(char * buf, char c, int length, int ladjust)
+{
+    int i;
+
+    if (length < 1) length = 1;
+    if (ladjust) {
+	*buf = c;
+	for (i=1; i< length; i++) buf[i] = ' ';
+    } else {
+	for (i=0; i< length-1; i++) buf[i] = ' ';
+	buf[length - 1] = c;
+    }
+    return length;
+}
+
+static int
+PrintString(char * buf, char* s, int length, int ladjust)
+{
+    int i;
+    int len=0;
+    char* s1 = s;
+    while (*s1++) len++;
+    if (length < len) length = len;
+
+    if (ladjust) {
+	for (i=0; i< len; i++) buf[i] = s[i];
+	for (i=len; i< length; i++) buf[i] = ' ';
+    } else {
+	for (i=0; i< length-len; i++) buf[i] = ' ';
+	for (i=length-len; i < length; i++) buf[i] = s[i-length+len];
+    }
+    return length;
+}
+
+static int
+PrintNum(char * buf, unsigned long u, int base, int negFlag,
+	 int length, int ladjust, char padc, int upcase)
+{
+    /* algorithm :
+     *  1. prints the number from left to right in reverse form.
+     *  2. fill the remaining spaces with padc if length is longer than
+     *     the actual length
+     *     TRICKY : if left adjusted, no "0" padding.
+     *		    if negtive, insert  "0" padding between "0" and number.
+     *  3. if (!ladjust) we reverse the whole string including paddings
+     *  4. otherwise we only reverse the actual string representing the num.
+     */
+
+    int actualLength =0;
+    char *p = buf;
+    int i;
+
+    do {
+	int tmp = u %base;
+	if (tmp <= 9) {
+	    *p++ = '0' + tmp;
+	} else if (upcase) {
+	    *p++ = 'A' + tmp - 10;
+	} else {
+	    *p++ = 'a' + tmp - 10;
+	}
+	u /= base;
+    } while (u != 0);
+
+    if (negFlag) {
+	*p++ = '-';
+    }
+
+    /* figure out actual length and adjust the maximum length */
+    actualLength = p - buf;
+    if (length < actualLength) length = actualLength;
+
+    /* add padding */
+    if (ladjust) {
+	padc = ' ';
+    }
+    if (negFlag && !ladjust && (padc == '0')) {
+	for (i = actualLength-1; i< length-1; i++) buf[i] = padc;
+	buf[length -1] = '-';
+    } else {
+	for (i = actualLength; i< length; i++) buf[i] = padc;
+    }
+
+
+    /* prepare to reverse the string */
+    {
+	int begin = 0;
+	int end;
+	if (ladjust) {
+	    end = actualLength - 1;
+	} else {
+	    end = length -1;
+	}
+
+	while (end > begin) {
+	    char tmp = buf[begin];
+	    buf[begin] = buf[end];
+	    buf[end] = tmp;
+	    begin ++;
+	    end --;
+	}
+    }
+
+    /* adjust the string pointer */
+    return length;
+}
+
+static void printf_output(void *arg, char *s, int l)
+{
+    int i;
+
+    // special termination call
+    if ((l==1) && (s[0] == '\0')) return;
+
+    for (i=0; i< l; i++) {
+	board_putc(s[i]);
+	if (s[i] == '\n') board_putc('\r');
+    }
+}
+
+void printf(char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    lp_Print(printf_output, 0, fmt, ap);
+    va_end(ap);
+}
diff --git a/target/linux/ath79/image/lzma-loader/src/printf.h b/target/linux/ath79/image/lzma-loader/src/printf.h
new file mode 100644
index 0000000000..9b1c1df232
--- /dev/null
+++ b/target/linux/ath79/image/lzma-loader/src/printf.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _printf_h_
+#define _printf_h_
+
+#include <stdarg.h>
+void printf(char *fmt, ...);
+
+#endif /* _printf_h_ */
diff --git a/target/linux/ath79/image/nand.mk b/target/linux/ath79/image/nand.mk
new file mode 100644
index 0000000000..979afd2b2b
--- /dev/null
+++ b/target/linux/ath79/image/nand.mk
@@ -0,0 +1,13 @@
+define Device/glinet_ar300m_nand
+  ATH_SOC := qca9533
+  DEVICE_TITLE := GL-AR300M (NAND)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb-storage kmod-usb-ledtrig-usbport
+  KERNEL_SIZE := 2048k
+  BLOCKSIZE := 128k
+  PAGESIZE := 2048
+  VID_HDR_OFFSET := 512
+  IMAGES := factory.ubi sysupgrade.tar
+  IMAGE/sysupgrade.tar := sysupgrade-tar
+  IMAGE/factory.ubi := append-kernel | pad-to $$$$(KERNEL_SIZE) | append-ubi
+endef
+TARGET_DEVICES += glinet_ar300m_nand
diff --git a/target/linux/ath79/image/tiny-netgear.mk b/target/linux/ath79/image/tiny-netgear.mk
new file mode 100644
index 0000000000..48d14e9e2e
--- /dev/null
+++ b/target/linux/ath79/image/tiny-netgear.mk
@@ -0,0 +1,36 @@
+include ./common-netgear.mk
+
+
+define Device/netgear_wnr612-v2
+  ATH_SOC := ar7240
+  DEVICE_TITLE := Netgear WNR612v2
+  DEVICE_DTS := ar7240_netgear_wnr612-v2
+  NETGEAR_KERNEL_MAGIC := 0x32303631
+  KERNEL := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  NETGEAR_BOARD_ID := REALWNR612V2
+  IMAGE_SIZE := 3904k
+  IMAGES := sysupgrade.bin factory.img
+  IMAGE/default := append-kernel | pad-to $$$$(BLOCKSIZE) | netgear-squashfs | append-rootfs | pad-rootfs
+  IMAGE/sysupgrade.bin := $$(IMAGE/default) | append-metadata | check-size $$$$(IMAGE_SIZE)
+  IMAGE/factory.img := $$(IMAGE/default) | netgear-dni | check-size $$$$(IMAGE_SIZE)
+  SUPPORTED_DEVICES := netgear,wnr612-v2 wnr612-v2
+endef
+TARGET_DEVICES += netgear_wnr612-v2
+
+define Device/n150r
+  ATH_SOC := ar7240
+  DEVICE_TITLE := ON Network N150R
+  DEVICE_DTS := ar7240_on_n150r
+  NETGEAR_KERNEL_MAGIC := 0x32303631
+  KERNEL := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma -d20 | netgear-uImage lzma
+  NETGEAR_BOARD_ID := N150R
+  IMAGE_SIZE := 3904k
+  IMAGES := sysupgrade.bin factory.img
+  IMAGE/default := append-kernel | pad-to $$$$(BLOCKSIZE) | netgear-squashfs | append-rootfs | pad-rootfs
+  IMAGE/sysupgrade.bin := $$(IMAGE/default) | append-metadata | check-size $$$$(IMAGE_SIZE)
+  IMAGE/factory.img := $$(IMAGE/default) | netgear-dni | check-size $$$$(IMAGE_SIZE)
+  SUPPORTED_DEVICES := on,n150r n150r
+endef
+TARGET_DEVICES += n150r
diff --git a/target/linux/ath79/image/tiny-tp-link.mk b/target/linux/ath79/image/tiny-tp-link.mk
new file mode 100644
index 0000000000..1dfed48dba
--- /dev/null
+++ b/target/linux/ath79/image/tiny-tp-link.mk
@@ -0,0 +1,41 @@
+include ./common-tp-link.mk
+
+
+define Device/tl-mr10u
+  $(Device/tplink-4mlzma)
+  ATH_SOC := ar9331
+  DEVICE_TITLE := TP-Link TL-MR10U
+  DEVICE_PACKAGES := kmod-usb-chipidea2
+  TPLINK_HWID := 0x00100101
+  SUPPORTED_DEVICES := tplink,tl-mr10u tl-mr10u
+endef
+TARGET_DEVICES += tl-mr10u
+
+define Device/tl-mr3020-v1
+  $(Device/tplink-4mlzma)
+  ATH_SOC := ar9331
+  DEVICE_TITLE := TP-LINK TL-MR3020 v1
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb-chipidea2 kmod-usb-ledtrig-usbport
+  TPLINK_HWID := 0x30200001
+  SUPPORTED_DEVICES := tplink,tl-mr3020-v1 tl-mr3020-v1
+endef
+TARGET_DEVICES += tl-mr3020-v1
+
+define Device/tl-wr703n
+  $(Device/tplink-4mlzma)
+  ATH_SOC := ar9331
+  DEVICE_TITLE := TP-Link TL-WR703N
+  DEVICE_PACKAGES := kmod-usb-chipidea2
+  TPLINK_HWID := 0x07030101
+  SUPPORTED_DEVICES := tplink,tl-wr703n tl-wr703n
+endef
+TARGET_DEVICES += tl-wr703n
+
+define Device/tl-wr740n-v2
+  $(Device/tplink-4m)
+  ATH_SOC := ar7240
+  DEVICE_TITLE := TP-Link TL-WR740N/ND v2
+  TPLINK_HWID := 0x07400001
+  SUPPORTED_DEVICES := tplink,tl-wr740n-v2 tl-wr740n-v2
+endef
+TARGET_DEVICES += tl-wr740n-v2
diff --git a/target/linux/ath79/modules.mk b/target/linux/ath79/modules.mk
new file mode 100644
index 0000000000..946440dd61
--- /dev/null
+++ b/target/linux/ath79/modules.mk
@@ -0,0 +1,16 @@
+LEDS_MENU:=LED modules
+
+define KernelPackage/leds-reset
+  SUBMENU:=$(LEDS_MENU)
+  TITLE:=reset controller LED support
+  DEPENDS:= @TARGET_ath79
+  KCONFIG:=CONFIG_LEDS_RESET=m
+  FILES:=$(LINUX_DIR)/drivers/leds/leds-reset.ko
+  AUTOLOAD:=$(call AutoLoad,60,leds-reset,1)
+endef
+
+define KernelPackage/leds-reset/description
+ Kernel module for LEDs on reset lines
+endef
+
+$(eval $(call KernelPackage,leds-reset))
diff --git a/target/linux/ath79/nand/config-default b/target/linux/ath79/nand/config-default
new file mode 100644
index 0000000000..738c29c9b1
--- /dev/null
+++ b/target/linux/ath79/nand/config-default
@@ -0,0 +1,14 @@
+CONFIG_BCH=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_BCH=y
+CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND_ECC_BCH=y
+CONFIG_MTD_SPINAND_MT29F=y
+CONFIG_MTD_SPINAND_ONDIEECC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+# CONFIG_UBIFS_FS is not set
diff --git a/target/linux/ath79/nand/profiles/00-default.mk b/target/linux/ath79/nand/profiles/00-default.mk
new file mode 100644
index 0000000000..06ab790389
--- /dev/null
+++ b/target/linux/ath79/nand/profiles/00-default.mk
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2009 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define Profile/Default
+	NAME:=Default Profile
+	PACKAGES:= \
+		kmod-usb-core kmod-usb-ohci kmod-usb2 kmod-usb-ledtrig-usbport
+	PRIORITY := 1
+endef
+
+define Profile/Default/Description
+	Default package set compatible with most boards.
+endef
+$(eval $(call Profile,Default))
diff --git a/target/linux/ath79/nand/target.mk b/target/linux/ath79/nand/target.mk
new file mode 100644
index 0000000000..a53603d27b
--- /dev/null
+++ b/target/linux/ath79/nand/target.mk
@@ -0,0 +1,7 @@
+BOARDNAME := Generic devices with NAND flash
+FEATURES += squashfs nand rtc
+
+define Target/Description
+	Build firmware for Atheros AR71xx/AR913x based boards with
+	NAND flash, e.g. Netgear WNDR4300.
+endef
diff --git a/target/linux/ath79/patches-4.14/0001-tty-serial-drop-QCA-pecific-SoC-symbols.patch b/target/linux/ath79/patches-4.14/0001-tty-serial-drop-QCA-pecific-SoC-symbols.patch
new file mode 100644
index 0000000000..6c4b907e22
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0001-tty-serial-drop-QCA-pecific-SoC-symbols.patch
@@ -0,0 +1,21 @@
+From 58812f6d0f1e11b03ed266038ed3b7274ab6f121 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:26:32 +0100
+Subject: [PATCH 01/27] tty: serial: drop QCA pecific SoC symbols
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/tty/serial/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/tty/serial/Kconfig
++++ b/drivers/tty/serial/Kconfig
+@@ -1463,7 +1463,7 @@ config SERIAL_XILINX_PS_UART_CONSOLE
+ 
+ config SERIAL_AR933X
+ 	tristate "AR933X serial port support"
+-	depends on HAVE_CLK && SOC_AR933X
++	depends on HAVE_CLK && ATH79
+ 	select SERIAL_CORE
+ 	help
+ 	  If you have an Atheros AR933X SOC based board and want to use the
diff --git a/target/linux/ath79/patches-4.14/0002-watchdog-ath79-fix-maximum-timeout.patch b/target/linux/ath79/patches-4.14/0002-watchdog-ath79-fix-maximum-timeout.patch
new file mode 100644
index 0000000000..36234d8d83
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0002-watchdog-ath79-fix-maximum-timeout.patch
@@ -0,0 +1,32 @@
+From 5f5c9858af167f842ee8df053920b98387a71af1 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Mon, 5 Mar 2018 11:41:25 +0100
+Subject: [PATCH 02/27] watchdog: ath79: fix maximum timeout
+
+If the userland tries to set a timeout higher than the max_timeout,
+then we should fallback to max_timeout.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/watchdog/ath79_wdt.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/drivers/watchdog/ath79_wdt.c
++++ b/drivers/watchdog/ath79_wdt.c
+@@ -115,10 +115,14 @@ static inline void ath79_wdt_disable(voi
+ 
+ static int ath79_wdt_set_timeout(int val)
+ {
+-	if (val < 1 || val > max_timeout)
++	if (val < 1)
+ 		return -EINVAL;
+ 
+-	timeout = val;
++	if (val > max_timeout)
++		timeout = max_timeout;
++	else
++		timeout = val;
++
+ 	ath79_wdt_keepalive();
+ 
+ 	return 0;
diff --git a/target/linux/ath79/patches-4.14/0003-leds-add-reset-controller-based-driver.patch b/target/linux/ath79/patches-4.14/0003-leds-add-reset-controller-based-driver.patch
new file mode 100644
index 0000000000..d15c77a8dd
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0003-leds-add-reset-controller-based-driver.patch
@@ -0,0 +1,186 @@
+From ecbd9c87f073f097d9fe56390353e64e963e866a Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:03:03 +0100
+Subject: [PATCH 03/27] leds: add reset-controller based driver
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/leds/Kconfig      |  11 ++++
+ drivers/leds/Makefile     |   1 +
+ drivers/leds/leds-reset.c | 137 ++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 149 insertions(+)
+ create mode 100644 drivers/leds/leds-reset.c
+
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -696,6 +696,17 @@ config LEDS_NIC78BX
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called leds-nic78bx.
+ 
++config LEDS_RESET
++	tristate "LED support for reset-controller API"
++	depends on LEDS_CLASS
++	depends on RESET_CONTROLLER
++	help
++	  This option enables support for LEDs connected to pins driven by reset
++	  controllers. Yes, DNI actual built HW like that.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called leds-reset.
++
+ comment "LED Triggers"
+ source "drivers/leds/trigger/Kconfig"
+ 
+--- /dev/null
++++ b/drivers/leds/leds-reset.c
+@@ -0,0 +1,140 @@
++/*
++ * Copyright (C) 2018 John Crispin <john@phrozen.org>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ */
++#include <linux/err.h>
++#include <linux/reset.h>
++#include <linux/kernel.h>
++#include <linux/leds.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++
++struct reset_led_data {
++	struct led_classdev cdev;
++	struct reset_control *rst;
++};
++
++static inline struct reset_led_data *
++			cdev_to_reset_led_data(struct led_classdev *led_cdev)
++{
++	return container_of(led_cdev, struct reset_led_data, cdev);
++}
++
++static void reset_led_set(struct led_classdev *led_cdev,
++	enum led_brightness value)
++{
++	struct reset_led_data *led_dat = cdev_to_reset_led_data(led_cdev);
++
++	if (value == LED_OFF)
++		reset_control_assert(led_dat->rst);
++	else
++		reset_control_deassert(led_dat->rst);
++}
++
++struct reset_leds_priv {
++	int num_leds;
++	struct reset_led_data leds[];
++};
++
++static inline int sizeof_reset_leds_priv(int num_leds)
++{
++	return sizeof(struct reset_leds_priv) +
++		(sizeof(struct reset_led_data) * num_leds);
++}
++
++static struct reset_leds_priv *reset_leds_create(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct fwnode_handle *child;
++	struct reset_leds_priv *priv;
++	int count, ret;
++
++	count = device_get_child_node_count(dev);
++	if (!count)
++		return ERR_PTR(-ENODEV);
++
++	priv = devm_kzalloc(dev, sizeof_reset_leds_priv(count), GFP_KERNEL);
++	if (!priv)
++		return ERR_PTR(-ENOMEM);
++
++	device_for_each_child_node(dev, child) {
++		struct reset_led_data *led = &priv->leds[priv->num_leds];
++		struct device_node *np = to_of_node(child);
++
++		ret = fwnode_property_read_string(child, "label", &led->cdev.name);
++		if (!led->cdev.name) {
++			fwnode_handle_put(child);
++			return ERR_PTR(-EINVAL);
++		}
++		led->rst = __of_reset_control_get(np, NULL, 0, 0, 0);
++		if (IS_ERR(led->rst))
++			return ERR_PTR(-EINVAL);
++
++		fwnode_property_read_string(child, "linux,default-trigger",
++						&led->cdev.default_trigger);
++
++		led->cdev.brightness_set = reset_led_set;
++		ret = devm_of_led_classdev_register(&pdev->dev, np, &led->cdev);
++		if (ret < 0)
++			return ERR_PTR(ret);
++		led->cdev.dev->of_node = np;
++		priv->num_leds++;
++	}
++
++	return priv;
++}
++
++static const struct of_device_id of_reset_leds_match[] = {
++	{ .compatible = "reset-leds", },
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, of_reset_leds_match);
++
++static int reset_led_probe(struct platform_device *pdev)
++{
++	struct reset_leds_priv *priv;
++
++	priv = reset_leds_create(pdev);
++	if (IS_ERR(priv))
++		return PTR_ERR(priv);
++
++	platform_set_drvdata(pdev, priv);
++
++	return 0;
++}
++
++static void reset_led_shutdown(struct platform_device *pdev)
++{
++	struct reset_leds_priv *priv = platform_get_drvdata(pdev);
++	int i;
++
++	for (i = 0; i < priv->num_leds; i++) {
++		struct reset_led_data *led = &priv->leds[i];
++
++		if (!(led->cdev.flags & LED_RETAIN_AT_SHUTDOWN))
++			reset_led_set(&led->cdev, LED_OFF);
++	}
++}
++
++static struct platform_driver reset_led_driver = {
++	.probe		= reset_led_probe,
++	.shutdown	= reset_led_shutdown,
++	.driver		= {
++		.name	= "leds-reset",
++		.of_match_table = of_reset_leds_match,
++	},
++};
++
++module_platform_driver(reset_led_driver);
++
++MODULE_AUTHOR("John Crispin <john@phrozen.org>");
++MODULE_DESCRIPTION("reset controller LED driver");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:leds-reset");
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -73,6 +73,7 @@ obj-$(CONFIG_LEDS_PM8058)		+= leds-pm805
+ obj-$(CONFIG_LEDS_MLXCPLD)		+= leds-mlxcpld.o
+ obj-$(CONFIG_LEDS_NIC78BX)		+= leds-nic78bx.o
+ obj-$(CONFIG_LEDS_MT6323)		+= leds-mt6323.o
++obj-$(CONFIG_LEDS_RESET)		+= leds-reset.o
+ 
+ # LED SPI Drivers
+ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
diff --git a/target/linux/ath79/patches-4.14/0004-phy-add-ath79-usb-phys.patch b/target/linux/ath79/patches-4.14/0004-phy-add-ath79-usb-phys.patch
new file mode 100644
index 0000000000..6280baf913
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0004-phy-add-ath79-usb-phys.patch
@@ -0,0 +1,320 @@
+From 08c9d6ceef01893678a5d2e8a15517c745417f21 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:04:05 +0100
+Subject: [PATCH 04/27] phy: add ath79 usb phys
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/phy/Kconfig          |  16 ++++++
+ drivers/phy/Makefile         |   2 +
+ drivers/phy/phy-ar7100-usb.c | 124 +++++++++++++++++++++++++++++++++++++++++++
+ drivers/phy/phy-ar7200-usb.c | 108 +++++++++++++++++++++++++++++++++++++
+ 4 files changed, 250 insertions(+)
+ create mode 100644 drivers/phy/phy-ar7100-usb.c
+ create mode 100644 drivers/phy/phy-ar7200-usb.c
+
+--- a/drivers/phy/Kconfig
++++ b/drivers/phy/Kconfig
+@@ -15,6 +15,22 @@ config GENERIC_PHY
+ 	  phy users can obtain reference to the PHY. All the users of this
+ 	  framework should select this config.
+ 
++config PHY_AR7100_USB
++	tristate "Atheros AR7100 USB PHY driver"
++	depends on ATH79 || COMPILE_TEST
++	default y if USB_EHCI_HCD_PLATFORM
++	select PHY_SIMPLE
++	help
++	  Enable this to support the USB PHY on Atheros AR7100 SoCs.
++
++config PHY_AR7200_USB
++	tristate "Atheros AR7200 USB PHY driver"
++	depends on ATH79 || COMPILE_TEST
++	default y if USB_EHCI_HCD_PLATFORM
++	select PHY_SIMPLE
++	help
++	  Enable this to support the USB PHY on Atheros AR7200 SoCs.
++
+ config PHY_LPC18XX_USB_OTG
+ 	tristate "NXP LPC18xx/43xx SoC USB OTG PHY driver"
+ 	depends on OF && (ARCH_LPC18XX || COMPILE_TEST)
+--- a/drivers/phy/Makefile
++++ b/drivers/phy/Makefile
+@@ -4,6 +4,8 @@
+ #
+ 
+ obj-$(CONFIG_GENERIC_PHY)		+= phy-core.o
++obj-$(CONFIG_PHY_AR7100_USB)		+= phy-ar7100-usb.o
++obj-$(CONFIG_PHY_AR7200_USB)		+= phy-ar7200-usb.o
+ obj-$(CONFIG_PHY_LPC18XX_USB_OTG)	+= phy-lpc18xx-usb-otg.o
+ obj-$(CONFIG_PHY_XGENE)			+= phy-xgene.o
+ obj-$(CONFIG_PHY_PISTACHIO_USB)		+= phy-pistachio-usb.o
+--- /dev/null
++++ b/drivers/phy/phy-ar7100-usb.c
+@@ -0,0 +1,140 @@
++/*
++ * Copyright (C) 2018 John Crispin <john@phrozen.org>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/phy/phy.h>
++#include <linux/delay.h>
++#include <linux/reset.h>
++#include <linux/of_gpio.h>
++
++#include <asm/mach-ath79/ath79.h>
++#include <asm/mach-ath79/ar71xx_regs.h>
++
++struct ar7100_usb_phy {
++	struct reset_control	*rst_phy;
++	struct reset_control	*rst_host;
++	struct reset_control	*rst_ohci_dll;
++	void __iomem		*io_base;
++	struct phy		*phy;
++	int			gpio;
++};
++
++static int ar7100_usb_phy_power_off(struct phy *phy)
++{
++	struct ar7100_usb_phy *priv = phy_get_drvdata(phy);
++	int err = 0;
++
++	err |= reset_control_assert(priv->rst_host);
++	err |= reset_control_assert(priv->rst_phy);
++	err |= reset_control_assert(priv->rst_ohci_dll);
++
++	return err;
++}
++
++static int ar7100_usb_phy_power_on(struct phy *phy)
++{
++	struct ar7100_usb_phy *priv = phy_get_drvdata(phy);
++	int err = 0;
++
++	err |= ar7100_usb_phy_power_off(phy);
++	mdelay(100);
++	err |= reset_control_deassert(priv->rst_ohci_dll);
++	err |= reset_control_deassert(priv->rst_phy);
++	err |= reset_control_deassert(priv->rst_host);
++	mdelay(500);
++	iowrite32(0xf0000, priv->io_base + AR71XX_USB_CTRL_REG_CONFIG);
++	iowrite32(0x20c00, priv->io_base + AR71XX_USB_CTRL_REG_FLADJ);
++
++	return err;
++}
++
++static const struct phy_ops ar7100_usb_phy_ops = {
++	.power_on	= ar7100_usb_phy_power_on,
++	.power_off	= ar7100_usb_phy_power_off,
++	.owner		= THIS_MODULE,
++};
++
++static int ar7100_usb_phy_probe(struct platform_device *pdev)
++{
++	struct phy_provider *phy_provider;
++	struct resource *res;
++	struct ar7100_usb_phy *priv;
++
++	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	priv->io_base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(priv->io_base))
++		return PTR_ERR(priv->io_base);
++
++	priv->rst_phy = devm_reset_control_get(&pdev->dev, "usb-phy");
++	if (IS_ERR(priv->rst_phy)) {
++		dev_err(&pdev->dev, "phy reset is missing\n");
++		return PTR_ERR(priv->rst_phy);
++	}
++
++	priv->rst_host = devm_reset_control_get(&pdev->dev, "usb-host");
++	if (IS_ERR(priv->rst_host)) {
++		dev_err(&pdev->dev, "host reset is missing\n");
++		return PTR_ERR(priv->rst_host);
++	}
++
++	priv->rst_ohci_dll = devm_reset_control_get(&pdev->dev, "usb-ohci-dll");
++	if (IS_ERR(priv->rst_ohci_dll)) {
++		dev_err(&pdev->dev, "ohci-dll reset is missing\n");
++		return PTR_ERR(priv->rst_host);
++	}
++
++	priv->phy = devm_phy_create(&pdev->dev, NULL, &ar7100_usb_phy_ops);
++	if (IS_ERR(priv->phy)) {
++		dev_err(&pdev->dev, "failed to create PHY\n");
++		return PTR_ERR(priv->phy);
++	}
++
++	priv->gpio = of_get_gpio(pdev->dev.of_node, 0);
++	if (priv->gpio >= 0) {
++		int ret = devm_gpio_request(&pdev->dev, priv->gpio, dev_name(&pdev->dev));
++
++		if (ret) {
++			dev_err(&pdev->dev, "failed to request gpio\n");
++			return ret;
++		}
++		gpio_export_with_name(priv->gpio, 0, dev_name(&pdev->dev));
++		gpio_set_value(priv->gpio, 1);
++	}
++
++	phy_set_drvdata(priv->phy, priv);
++
++	phy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);
++
++
++	return PTR_ERR_OR_ZERO(phy_provider);
++}
++
++static const struct of_device_id ar7100_usb_phy_of_match[] = {
++	{ .compatible = "qca,ar7100-usb-phy" },
++	{}
++};
++MODULE_DEVICE_TABLE(of, ar7100_usb_phy_of_match);
++
++static struct platform_driver ar7100_usb_phy_driver = {
++	.probe	= ar7100_usb_phy_probe,
++	.driver = {
++		.of_match_table	= ar7100_usb_phy_of_match,
++		.name		= "ar7100-usb-phy",
++	}
++};
++module_platform_driver(ar7100_usb_phy_driver);
++
++MODULE_DESCRIPTION("ATH79 USB PHY driver");
++MODULE_AUTHOR("Alban Bedel <albeu@free.fr>");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/phy/phy-ar7200-usb.c
+@@ -0,0 +1,123 @@
++/*
++ * Copyright (C) 2015 Alban Bedel <albeu@free.fr>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/phy/phy.h>
++#include <linux/reset.h>
++#include <linux/of_gpio.h>
++
++struct ar7200_usb_phy {
++	struct reset_control	*rst_phy;
++	struct reset_control	*suspend_override;
++	struct phy		*phy;
++	int			gpio;
++};
++
++static int ar7200_usb_phy_power_on(struct phy *phy)
++{
++	struct ar7200_usb_phy *priv = phy_get_drvdata(phy);
++	int err = 0;
++
++	if (priv->rst_phy)
++		err = reset_control_deassert(priv->rst_phy);
++	if (!err && priv->suspend_override)
++		err = reset_control_assert(priv->suspend_override);
++	if (err && priv->rst_phy)
++		err = reset_control_assert(priv->rst_phy);
++
++	return err;
++}
++
++static int ar7200_usb_phy_power_off(struct phy *phy)
++{
++	struct ar7200_usb_phy *priv = phy_get_drvdata(phy);
++	int err = 0;
++
++	if (priv->suspend_override)
++		err = reset_control_deassert(priv->suspend_override);
++	if (priv->rst_phy)
++		err |= reset_control_assert(priv->rst_phy);
++
++	return err;
++}
++
++static const struct phy_ops ar7200_usb_phy_ops = {
++	.power_on	= ar7200_usb_phy_power_on,
++	.power_off	= ar7200_usb_phy_power_off,
++	.owner		= THIS_MODULE,
++};
++
++static int ar7200_usb_phy_probe(struct platform_device *pdev)
++{
++	struct phy_provider *phy_provider;
++	struct ar7200_usb_phy *priv;
++
++	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	priv->rst_phy = devm_reset_control_get(&pdev->dev, "usb-phy");
++	if (IS_ERR(priv->rst_phy)) {
++		dev_err(&pdev->dev, "phy reset is missing\n");
++		return PTR_ERR(priv->rst_phy);
++	}
++
++	priv->suspend_override = devm_reset_control_get_optional(
++		&pdev->dev, "usb-suspend-override");
++	if (IS_ERR(priv->suspend_override)) {
++		if (PTR_ERR(priv->suspend_override) == -ENOENT)
++			priv->suspend_override = NULL;
++		else
++			return PTR_ERR(priv->suspend_override);
++	}
++
++	priv->phy = devm_phy_create(&pdev->dev, NULL, &ar7200_usb_phy_ops);
++	if (IS_ERR(priv->phy)) {
++		dev_err(&pdev->dev, "failed to create PHY\n");
++		return PTR_ERR(priv->phy);
++	}
++
++	priv->gpio = of_get_gpio(pdev->dev.of_node, 0);
++	if (priv->gpio >= 0) {
++		int ret = devm_gpio_request(&pdev->dev, priv->gpio, dev_name(&pdev->dev));
++
++		if (ret) {
++			dev_err(&pdev->dev, "failed to request gpio\n");
++			return ret;
++		}
++		gpio_export_with_name(priv->gpio, 0, dev_name(&pdev->dev));
++		gpio_set_value(priv->gpio, 1);
++	}
++
++	phy_set_drvdata(priv->phy, priv);
++
++	phy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);
++
++	return PTR_ERR_OR_ZERO(phy_provider);
++}
++
++static const struct of_device_id ar7200_usb_phy_of_match[] = {
++	{ .compatible = "qca,ar7200-usb-phy" },
++	{}
++};
++MODULE_DEVICE_TABLE(of, ar7200_usb_phy_of_match);
++
++static struct platform_driver ar7200_usb_phy_driver = {
++	.probe	= ar7200_usb_phy_probe,
++	.driver = {
++		.of_match_table	= ar7200_usb_phy_of_match,
++		.name		= "ar7200-usb-phy",
++	}
++};
++module_platform_driver(ar7200_usb_phy_driver);
++
++MODULE_DESCRIPTION("ATH79 USB PHY driver");
++MODULE_AUTHOR("Alban Bedel <albeu@free.fr>");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/ath79/patches-4.14/0005-usb-add-more-OF-quirk-properties.patch b/target/linux/ath79/patches-4.14/0005-usb-add-more-OF-quirk-properties.patch
new file mode 100644
index 0000000000..ec1bc3f7f7
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0005-usb-add-more-OF-quirk-properties.patch
@@ -0,0 +1,24 @@
+From 2201818e5bd33f389beceb3943fdfcf5a698fc5b Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:01:43 +0100
+Subject: [PATCH 05/27] usb: add more OF/quirk properties
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/usb/host/ehci-platform.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/usb/host/ehci-platform.c
++++ b/drivers/usb/host/ehci-platform.c
+@@ -187,6 +187,11 @@ static int ehci_platform_probe(struct pl
+ 	ehci = hcd_to_ehci(hcd);
+ 
+ 	if (pdata == &ehci_platform_defaults && dev->dev.of_node) {
++		of_property_read_u32(dev->dev.of_node, "caps-offset", &pdata->caps_offset);
++
++		if (of_property_read_bool(dev->dev.of_node, "has-synopsys-hc-bug"))
++			pdata->has_synopsys_hc_bug = 1;
++
+ 		if (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))
+ 			ehci->big_endian_mmio = 1;
+ 
diff --git a/target/linux/ath79/patches-4.14/0006-usb-drop-deprecated-symbols.patch b/target/linux/ath79/patches-4.14/0006-usb-drop-deprecated-symbols.patch
new file mode 100644
index 0000000000..a97fab71f4
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0006-usb-drop-deprecated-symbols.patch
@@ -0,0 +1,51 @@
+From bd17da5b6297e0e52b787049292d076ad415362a Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:04:54 +0100
+Subject: [PATCH 06/27] usb: drop deprecated symbols
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/usb/host/Kconfig | 25 -------------------------
+ 1 file changed, 25 deletions(-)
+
+--- a/drivers/usb/host/Kconfig
++++ b/drivers/usb/host/Kconfig
+@@ -297,19 +297,6 @@ config USB_CNS3XXX_EHCI
+ 	  It is needed for high-speed (480Mbit/sec) USB 2.0 device
+ 	  support.
+ 
+-config USB_EHCI_ATH79
+-	bool "EHCI support for AR7XXX/AR9XXX SoCs (DEPRECATED)"
+-	depends on (SOC_AR71XX || SOC_AR724X || SOC_AR913X || SOC_AR933X)
+-	select USB_EHCI_ROOT_HUB_TT
+-	select USB_EHCI_HCD_PLATFORM
+-	default y
+-	---help---
+-	  This option is deprecated now and the driver was removed, use
+-	  USB_EHCI_HCD_PLATFORM instead.
+-
+-	  Enables support for the built-in EHCI controller present
+-	  on the Atheros AR7XXX/AR9XXX SoCs.
+-
+ config USB_EHCI_HCD_PLATFORM
+ 	tristate "Generic EHCI driver for a platform device"
+ 	default n
+@@ -493,18 +480,6 @@ config USB_OHCI_HCD_DAVINCI
+ 	  controller. This driver cannot currently be a loadable
+ 	  module because it lacks a proper PHY abstraction.
+ 
+-config USB_OHCI_ATH79
+-	bool "USB OHCI support for the Atheros AR71XX/AR7240 SoCs (DEPRECATED)"
+-	depends on (SOC_AR71XX || SOC_AR724X)
+-	select USB_OHCI_HCD_PLATFORM
+-	default y
+-	help
+-	  This option is deprecated now and the driver was removed, use
+-	  USB_OHCI_HCD_PLATFORM instead.
+-
+-	  Enables support for the built-in OHCI controller present on the
+-	  Atheros AR71XX/AR7240 SoCs.
+-
+ config USB_OHCI_HCD_PPC_OF_BE
+ 	bool "OHCI support for OF platform bus (big endian)"
+ 	depends on PPC
diff --git a/target/linux/ath79/patches-4.14/0007-irqchip-irq-ath79-intc-add-irq-cascade-driver-for-QC.patch b/target/linux/ath79/patches-4.14/0007-irqchip-irq-ath79-intc-add-irq-cascade-driver-for-QC.patch
new file mode 100644
index 0000000000..ae3e6c068d
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0007-irqchip-irq-ath79-intc-add-irq-cascade-driver-for-QC.patch
@@ -0,0 +1,168 @@
+From cb376159800b9b44be76949c3aee89eb06d29faa Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:55:13 +0100
+Subject: [PATCH 07/27] irqchip/irq-ath79-intc: add irq cascade driver for
+ QCA9556 SoCs
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/irqchip/Makefile         |   1 +
+ drivers/irqchip/irq-ath79-intc.c | 104 +++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 105 insertions(+)
+ create mode 100644 drivers/irqchip/irq-ath79-intc.c
+
+--- a/drivers/irqchip/Makefile
++++ b/drivers/irqchip/Makefile
+@@ -3,6 +3,7 @@ obj-$(CONFIG_IRQCHIP)			+= irqchip.o
+ 
+ obj-$(CONFIG_ALPINE_MSI)		+= irq-alpine-msi.o
+ obj-$(CONFIG_ATH79)			+= irq-ath79-cpu.o
++obj-$(CONFIG_ATH79)			+= irq-ath79-intc.o
+ obj-$(CONFIG_ATH79)			+= irq-ath79-misc.o
+ obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2835.o
+ obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2836.o
+--- /dev/null
++++ b/drivers/irqchip/irq-ath79-intc.c
+@@ -0,0 +1,142 @@
++/*
++ *  Atheros AR71xx/AR724x/AR913x specific interrupt handling
++ *
++ *  Copyright (C) 2018 John Crispin <john@phrozen.org>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#include <linux/interrupt.h>
++#include <linux/irqchip.h>
++#include <linux/of.h>
++#include <linux/of_irq.h>
++#include <linux/irqdomain.h>
++
++#include <asm/irq_cpu.h>
++#include <asm/mach-ath79/ath79.h>
++#include <asm/mach-ath79/ar71xx_regs.h>
++
++#define ATH79_MAX_INTC_CASCADE	3
++
++struct ath79_intc {
++	struct irq_chip chip;
++	u32 irq;
++	u32 pending_mask;
++	u32 int_status;
++	u32 irq_mask[ATH79_MAX_INTC_CASCADE];
++	u32 irq_wb_chan[ATH79_MAX_INTC_CASCADE];
++};
++
++static void ath79_intc_irq_handler(struct irq_desc *desc)
++{
++	struct irq_domain *domain = irq_desc_get_handler_data(desc);
++	struct ath79_intc *intc = domain->host_data;
++	u32 pending;
++
++	pending = ath79_reset_rr(intc->int_status);
++	pending &= intc->pending_mask;
++
++	if (pending) {
++		int i;
++
++		for (i = 0; i < domain->hwirq_max; i++)
++			if (pending & intc->irq_mask[i]) {
++				if (intc->irq_wb_chan[i] != 0xffffffff)
++					ath79_ddr_wb_flush(intc->irq_wb_chan[i]);
++				generic_handle_irq(irq_find_mapping(domain, i));
++			}
++	} else {
++		spurious_interrupt();
++	}
++}
++
++static void ath79_intc_irq_enable(struct irq_data *d)
++{
++	struct ath79_intc *intc = d->domain->host_data;
++	enable_irq(intc->irq);
++}
++
++static void ath79_intc_irq_disable(struct irq_data *d)
++{
++	struct ath79_intc *intc = d->domain->host_data;
++	disable_irq(intc->irq);
++}
++
++static int ath79_intc_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
++{
++	struct ath79_intc *intc = d->host_data;
++
++	irq_set_chip_and_handler(irq, &intc->chip, handle_level_irq);
++
++	return 0;
++}
++
++static const struct irq_domain_ops ath79_irq_domain_ops = {
++	.xlate = irq_domain_xlate_onecell,
++	.map = ath79_intc_map,
++};
++
++static int __init ath79_intc_of_init(
++	struct device_node *node, struct device_node *parent)
++{
++	struct irq_domain *domain;
++	struct ath79_intc *intc;
++	int cnt, cntwb, i, err;
++
++	cnt = of_property_count_u32_elems(node, "qca,pending-bits");
++	if (cnt > ATH79_MAX_INTC_CASCADE)
++		panic("Too many INTC pending bits\n");
++
++	intc = kzalloc(sizeof(*intc), GFP_KERNEL);
++	if (!intc)
++		panic("Failed to allocate INTC memory\n");
++	intc->chip = dummy_irq_chip;
++	intc->chip.name = "INTC";
++	intc->chip.irq_disable = ath79_intc_irq_disable;
++	intc->chip.irq_enable = ath79_intc_irq_enable;
++
++	if (of_property_read_u32(node, "qca,int-status-addr", &intc->int_status) < 0) {
++		panic("Missing address of interrupt status register\n");
++	}
++
++	of_property_read_u32_array(node, "qca,pending-bits", intc->irq_mask, cnt);
++	for (i = 0; i < cnt; i++) {
++		intc->pending_mask |= intc->irq_mask[i];
++		intc->irq_wb_chan[i] = 0xffffffff;
++	}
++
++	cntwb = of_count_phandle_with_args(
++		node, "qca,ddr-wb-channels", "#qca,ddr-wb-channel-cells");
++
++	for (i = 0; i < cntwb; i++) {
++		struct of_phandle_args args;
++		u32 irq = i;
++
++		of_property_read_u32_index(
++			node, "qca,ddr-wb-channel-interrupts", i, &irq);
++		if (irq >= ATH79_MAX_INTC_CASCADE)
++			continue;
++
++		err = of_parse_phandle_with_args(
++			node, "qca,ddr-wb-channels",
++			"#qca,ddr-wb-channel-cells",
++			i, &args);
++		if (err)
++			return err;
++
++		intc->irq_wb_chan[irq] = args.args[0];
++	}
++
++	intc->irq = irq_of_parse_and_map(node, 0);
++	if (!intc->irq)
++		panic("Failed to get INTC IRQ");
++
++	domain = irq_domain_add_linear(node, cnt, &ath79_irq_domain_ops, intc);
++	irq_set_chained_handler_and_data(intc->irq, ath79_intc_irq_handler, domain);
++
++	return 0;
++}
++IRQCHIP_DECLARE(ath79_intc, "qca,ar9340-intc",
++		ath79_intc_of_init);
diff --git a/target/linux/ath79/patches-4.14/0008-irqchip-irq-ath79-cpu-drop-OF-init-helper.patch b/target/linux/ath79/patches-4.14/0008-irqchip-irq-ath79-cpu-drop-OF-init-helper.patch
new file mode 100644
index 0000000000..84e066e2a6
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0008-irqchip-irq-ath79-cpu-drop-OF-init-helper.patch
@@ -0,0 +1,23 @@
+From f711421eb5f6f790f1ebc09a13ae4aed8ba5f67b Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:58:19 +0100
+Subject: [PATCH 08/27] irqchip/irq-ath79-cpu: drop !OF init helper
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ drivers/irqchip/irq-ath79-cpu.c | 7 -------
+ 1 file changed, 7 deletions(-)
+
+--- a/drivers/irqchip/irq-ath79-cpu.c
++++ b/drivers/irqchip/irq-ath79-cpu.c
+@@ -88,10 +88,3 @@ static int __init ar79_cpu_intc_of_init(
+ }
+ IRQCHIP_DECLARE(ar79_cpu_intc, "qca,ar7100-cpu-intc",
+ 		ar79_cpu_intc_of_init);
+-
+-void __init ath79_cpu_irq_init(unsigned irq_wb_chan2, unsigned irq_wb_chan3)
+-{
+-	irq_wb_chan[2] = irq_wb_chan2;
+-	irq_wb_chan[3] = irq_wb_chan3;
+-	mips_cpu_irq_init();
+-}
diff --git a/target/linux/ath79/patches-4.14/0009-MIPS-ath79-add-lots-of-missing-registers.patch b/target/linux/ath79/patches-4.14/0009-MIPS-ath79-add-lots-of-missing-registers.patch
new file mode 100644
index 0000000000..d1755394fa
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0009-MIPS-ath79-add-lots-of-missing-registers.patch
@@ -0,0 +1,971 @@
+From 3ea2bff4ed3ce74dc4303aa20f5e906e78352f6b Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:06:10 +0100
+Subject: [PATCH 09/27] MIPS: ath79: add lots of missing registers
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/include/asm/mach-ath79/ar71xx_regs.h | 773 ++++++++++++++++++++++++-
+ 1 file changed, 771 insertions(+), 2 deletions(-)
+
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -20,6 +20,10 @@
+ #include <linux/bitops.h>
+ 
+ #define AR71XX_APB_BASE		0x18000000
++#define AR71XX_GE0_BASE		0x19000000
++#define AR71XX_GE0_SIZE		0x10000
++#define AR71XX_GE1_BASE		0x1a000000
++#define AR71XX_GE1_SIZE		0x10000
+ #define AR71XX_EHCI_BASE	0x1b000000
+ #define AR71XX_EHCI_SIZE	0x1000
+ #define AR71XX_OHCI_BASE	0x1c000000
+@@ -39,6 +43,8 @@
+ #define AR71XX_PLL_SIZE		0x100
+ #define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+ #define AR71XX_RESET_SIZE	0x100
++#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
++#define AR71XX_MII_SIZE		0x100
+ 
+ #define AR71XX_PCI_MEM_BASE	0x10000000
+ #define AR71XX_PCI_MEM_SIZE	0x07000000
+@@ -81,18 +87,39 @@
+ 
+ #define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+ #define AR933X_UART_SIZE	0x14
++#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define AR933X_GMAC_SIZE	0x04
+ #define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define AR933X_WMAC_SIZE	0x20000
+ #define AR933X_EHCI_BASE	0x1b000000
+ #define AR933X_EHCI_SIZE	0x1000
+ 
++#define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define AR934X_GMAC_SIZE	0x14
+ #define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define AR934X_WMAC_SIZE	0x20000
+ #define AR934X_EHCI_BASE	0x1b000000
+ #define AR934X_EHCI_SIZE	0x200
++#define AR934X_NFC_BASE		0x1b000200
++#define AR934X_NFC_SIZE		0xb8
+ #define AR934X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
+ #define AR934X_SRIF_SIZE	0x1000
+ 
++#define QCA953X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA953X_GMAC_SIZE	0x14
++#define QCA953X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
++#define QCA953X_WMAC_SIZE	0x20000
++#define QCA953X_EHCI_BASE	0x1b000000
++#define QCA953X_EHCI_SIZE	0x200
++#define QCA953X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
++#define QCA953X_SRIF_SIZE	0x1000
++
++#define QCA953X_PCI_CFG_BASE0	0x14000000
++#define QCA953X_PCI_CTRL_BASE0	(AR71XX_APB_BASE + 0x000f0000)
++#define QCA953X_PCI_CRP_BASE0	(AR71XX_APB_BASE + 0x000c0000)
++#define QCA953X_PCI_MEM_BASE0	0x10000000
++#define QCA953X_PCI_MEM_SIZE	0x02000000
++
+ #define QCA955X_PCI_MEM_BASE0	0x10000000
+ #define QCA955X_PCI_MEM_BASE1	0x12000000
+ #define QCA955X_PCI_MEM_SIZE	0x02000000
+@@ -106,11 +133,72 @@
+ #define QCA955X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
+ #define QCA955X_PCI_CTRL_SIZE	0x100
+ 
++#define QCA955X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA955X_GMAC_SIZE	0x40
+ #define QCA955X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define QCA955X_WMAC_SIZE	0x20000
+ #define QCA955X_EHCI0_BASE	0x1b000000
+ #define QCA955X_EHCI1_BASE	0x1b400000
+ #define QCA955X_EHCI_SIZE	0x1000
++#define QCA955X_NFC_BASE	0x1b800200
++#define QCA955X_NFC_SIZE	0xb8
++
++#define QCA956X_PCI_MEM_BASE1	0x12000000
++#define QCA956X_PCI_MEM_SIZE	0x02000000
++#define QCA956X_PCI_CFG_BASE1	0x16000000
++#define QCA956X_PCI_CFG_SIZE	0x1000
++#define QCA956X_PCI_CRP_BASE1	(AR71XX_APB_BASE + 0x00250000)
++#define QCA956X_PCI_CRP_SIZE	0x1000
++#define QCA956X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
++#define QCA956X_PCI_CTRL_SIZE	0x100
++
++#define QCA956X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
++#define QCA956X_WMAC_SIZE	0x20000
++#define QCA956X_EHCI0_BASE	0x1b000000
++#define QCA956X_EHCI1_BASE	0x1b400000
++#define QCA956X_EHCI_SIZE	0x200
++#define QCA956X_GMAC_SGMII_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA956X_GMAC_SGMII_SIZE	0x64
++#define QCA956X_PLL_BASE	(AR71XX_APB_BASE + 0x00050000)
++#define QCA956X_PLL_SIZE	0x50
++#define QCA956X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA956X_GMAC_SIZE	0x64
++
++/*
++ * Hidden Registers
++ */
++#define QCA956X_MAC_CFG_BASE		0xb9000000
++#define QCA956X_MAC_CFG_SIZE		0x64
++
++#define QCA956X_MAC_CFG1_REG		0x00
++#define QCA956X_MAC_CFG1_SOFT_RST	BIT(31)
++#define QCA956X_MAC_CFG1_RX_RST		BIT(19)
++#define QCA956X_MAC_CFG1_TX_RST		BIT(18)
++#define QCA956X_MAC_CFG1_LOOPBACK	BIT(8)
++#define QCA956X_MAC_CFG1_RX_EN		BIT(2)
++#define QCA956X_MAC_CFG1_TX_EN		BIT(0)
++
++#define QCA956X_MAC_CFG2_REG		0x04
++#define QCA956X_MAC_CFG2_IF_1000	BIT(9)
++#define QCA956X_MAC_CFG2_IF_10_100	BIT(8)
++#define QCA956X_MAC_CFG2_HUGE_FRAME_EN	BIT(5)
++#define QCA956X_MAC_CFG2_LEN_CHECK	BIT(4)
++#define QCA956X_MAC_CFG2_PAD_CRC_EN	BIT(2)
++#define QCA956X_MAC_CFG2_FDX		BIT(0)
++
++#define QCA956X_MAC_MII_MGMT_CFG_REG	0x20
++#define QCA956X_MGMT_CFG_CLK_DIV_20	0x07
++
++#define QCA956X_MAC_FIFO_CFG0_REG	0x48
++#define QCA956X_MAC_FIFO_CFG1_REG	0x4c
++#define QCA956X_MAC_FIFO_CFG2_REG	0x50
++#define QCA956X_MAC_FIFO_CFG3_REG	0x54
++#define QCA956X_MAC_FIFO_CFG4_REG	0x58
++#define QCA956X_MAC_FIFO_CFG5_REG	0x5c
++
++#define QCA956X_DAM_RESET_OFFSET	0xb90001bc
++#define QCA956X_DAM_RESET_SIZE		0x4
++#define QCA956X_INLINE_CHKSUM_ENG	BIT(27)
+ 
+ /*
+  * DDR_CTRL block
+@@ -149,6 +237,12 @@
+ #define AR934X_DDR_REG_FLUSH_PCIE	0xa8
+ #define AR934X_DDR_REG_FLUSH_WMAC	0xac
+ 
++#define QCA953X_DDR_REG_FLUSH_GE0	0x9c
++#define QCA953X_DDR_REG_FLUSH_GE1	0xa0
++#define QCA953X_DDR_REG_FLUSH_USB	0xa4
++#define QCA953X_DDR_REG_FLUSH_PCIE	0xa8
++#define QCA953X_DDR_REG_FLUSH_WMAC	0xac
++
+ /*
+  * PLL block
+  */
+@@ -166,9 +260,15 @@
+ #define AR71XX_AHB_DIV_SHIFT		20
+ #define AR71XX_AHB_DIV_MASK		0x7
+ 
++#define AR71XX_ETH0_PLL_SHIFT		17
++#define AR71XX_ETH1_PLL_SHIFT		19
++
+ #define AR724X_PLL_REG_CPU_CONFIG	0x00
+ #define AR724X_PLL_REG_PCIE_CONFIG	0x10
+ 
++#define AR724X_PLL_REG_PCIE_CONFIG_PPL_BYPASS	BIT(16)
++#define AR724X_PLL_REG_PCIE_CONFIG_PPL_RESET	BIT(25)
++
+ #define AR724X_PLL_FB_SHIFT		0
+ #define AR724X_PLL_FB_MASK		0x3ff
+ #define AR724X_PLL_REF_DIV_SHIFT	10
+@@ -178,6 +278,8 @@
+ #define AR724X_DDR_DIV_SHIFT		22
+ #define AR724X_DDR_DIV_MASK		0x3
+ 
++#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
++
+ #define AR913X_PLL_REG_CPU_CONFIG	0x00
+ #define AR913X_PLL_REG_ETH_CONFIG	0x04
+ #define AR913X_PLL_REG_ETH0_INT_CLOCK	0x14
+@@ -190,6 +292,9 @@
+ #define AR913X_AHB_DIV_SHIFT		19
+ #define AR913X_AHB_DIV_MASK		0x1
+ 
++#define AR913X_ETH0_PLL_SHIFT		20
++#define AR913X_ETH1_PLL_SHIFT		22
++
+ #define AR933X_PLL_CPU_CONFIG_REG	0x00
+ #define AR933X_PLL_CLOCK_CTRL_REG	0x08
+ 
+@@ -211,6 +316,8 @@
+ #define AR934X_PLL_CPU_CONFIG_REG		0x00
+ #define AR934X_PLL_DDR_CONFIG_REG		0x04
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_REG		0x08
++#define AR934X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
++#define AR934X_PLL_ETH_XMII_CONTROL_REG		0x2c
+ 
+ #define AR934X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+ #define AR934X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+@@ -243,9 +350,52 @@
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
+ 
++#define AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL	BIT(6)
++
++#define QCA953X_PLL_CPU_CONFIG_REG		0x00
++#define QCA953X_PLL_DDR_CONFIG_REG		0x04
++#define QCA953X_PLL_CLK_CTRL_REG		0x08
++#define QCA953X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
++#define QCA953X_PLL_ETH_XMII_CONTROL_REG	0x2c
++#define QCA953X_PLL_ETH_SGMII_CONTROL_REG	0x48
++
++#define QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
++#define QCA953X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
++#define QCA953X_PLL_CPU_CONFIG_NINT_SHIFT	6
++#define QCA953X_PLL_CPU_CONFIG_NINT_MASK	0x3f
++#define QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
++#define QCA953X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
++#define QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
++#define QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
++
++#define QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
++#define QCA953X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
++#define QCA953X_PLL_DDR_CONFIG_NINT_SHIFT	10
++#define QCA953X_PLL_DDR_CONFIG_NINT_MASK	0x3f
++#define QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
++#define QCA953X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
++#define QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
++#define QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
++
++#define QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
++#define QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
++#define QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
++#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
++#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
++#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
++#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL		BIT(20)
++#define QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
++#define QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
++
+ #define QCA955X_PLL_CPU_CONFIG_REG		0x00
+ #define QCA955X_PLL_DDR_CONFIG_REG		0x04
+ #define QCA955X_PLL_CLK_CTRL_REG		0x08
++#define QCA955X_PLL_ETH_XMII_CONTROL_REG	0x28
++#define QCA955X_PLL_ETH_SGMII_CONTROL_REG	0x48
++#define QCA955X_PLL_ETH_SGMII_SERDES_REG	0x4c
+ 
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+@@ -278,6 +428,81 @@
+ #define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
+ #define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+ 
++#define QCA955X_PLL_ETH_SGMII_SERDES_LOCK_DETECT	BIT(2)
++#define QCA955X_PLL_ETH_SGMII_SERDES_PLL_REFCLK		BIT(1)
++#define QCA955X_PLL_ETH_SGMII_SERDES_EN_PLL		BIT(0)
++
++#define QCA956X_PLL_CPU_CONFIG_REG			0x00
++#define QCA956X_PLL_CPU_CONFIG1_REG			0x04
++#define QCA956X_PLL_DDR_CONFIG_REG			0x08
++#define QCA956X_PLL_DDR_CONFIG1_REG			0x0c
++#define QCA956X_PLL_CLK_CTRL_REG			0x10
++#define QCA956X_PLL_SWITCH_CLOCK_CONTROL_REG		0x28
++#define QCA956X_PLL_ETH_XMII_CONTROL_REG		0x30
++#define QCA956X_PLL_ETH_SGMII_SERDES_REG		0x4c
++
++#define QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT		12
++#define QCA956X_PLL_CPU_CONFIG_REFDIV_MASK		0x1f
++#define QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT		19
++#define QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK		0x7
++
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT		0
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK		0x1f
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT		5
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK		0x1fff
++#define QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT		18
++#define QCA956X_PLL_CPU_CONFIG1_NINT_MASK		0x1ff
++
++#define QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT		16
++#define QCA956X_PLL_DDR_CONFIG_REFDIV_MASK		0x1f
++#define QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT		23
++#define QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK		0x7
++
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT		0
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK		0x1f
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT		5
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK		0x1fff
++#define QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT		18
++#define QCA956X_PLL_DDR_CONFIG1_NINT_MASK		0x1ff
++
++#define QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
++#define QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
++#define QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
++#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
++#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
++#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
++#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL	BIT(20)
++#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL	BIT(21)
++#define QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
++
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_I2C_CLK_SELB		BIT(5)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1		BIT(6)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_UART1_CLK_SEL		BIT(7)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SHIFT 8
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK	 0xf
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_EN_PLL_TOP		BIT(12)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2		BIT(13)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1		BIT(14)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2		BIT(15)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE	BIT(16)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_EEE_ENABLE		BIT(17)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL		BIT(18)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_SWITCHCLK_SEL		BIT(19)
++
++#define QCA956X_PLL_ETH_XMII_TX_INVERT			BIT(1)
++#define QCA956X_PLL_ETH_XMII_GIGE			BIT(25)
++#define QCA956X_PLL_ETH_XMII_RX_DELAY_SHIFT		28
++#define QCA956X_PLL_ETH_XMII_RX_DELAY_MASK		0x3
++#define QCA956X_PLL_ETH_XMII_TX_DELAY_SHIFT		26
++#define QCA956X_PLL_ETH_XMII_TX_DELAY_MASK		3
++
++#define QCA956X_PLL_ETH_SGMII_SERDES_LOCK_DETECT		BIT(2)
++#define QCA956X_PLL_ETH_SGMII_SERDES_PLL_REFCLK			BIT(1)
++#define QCA956X_PLL_ETH_SGMII_SERDES_EN_PLL			BIT(0)
++
+ /*
+  * USB_CONFIG block
+  */
+@@ -317,10 +542,19 @@
+ #define AR934X_RESET_REG_BOOTSTRAP		0xb0
+ #define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
+ 
++#define QCA953X_RESET_REG_RESET_MODULE		0x1c
++#define QCA953X_RESET_REG_BOOTSTRAP		0xb0
++#define QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
++
+ #define QCA955X_RESET_REG_RESET_MODULE		0x1c
+ #define QCA955X_RESET_REG_BOOTSTRAP		0xb0
+ #define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
+ 
++#define QCA956X_RESET_REG_RESET_MODULE		0x1c
++#define QCA956X_RESET_REG_BOOTSTRAP		0xb0
++#define QCA956X_RESET_REG_EXT_INT_STATUS	0xac
++
++#define MISC_INT_MIPS_SI_TIMERINT_MASK	BIT(28)
+ #define MISC_INT_ETHSW			BIT(12)
+ #define MISC_INT_TIMER4			BIT(10)
+ #define MISC_INT_TIMER3			BIT(9)
+@@ -370,16 +604,123 @@
+ #define AR913X_RESET_USB_HOST		BIT(5)
+ #define AR913X_RESET_USB_PHY		BIT(4)
+ 
++#define AR933X_RESET_GE1_MDIO		BIT(23)
++#define AR933X_RESET_GE0_MDIO		BIT(22)
++#define AR933X_RESET_GE1_MAC		BIT(13)
+ #define AR933X_RESET_WMAC		BIT(11)
++#define AR933X_RESET_GE0_MAC		BIT(9)
+ #define AR933X_RESET_USB_HOST		BIT(5)
+ #define AR933X_RESET_USB_PHY		BIT(4)
+ #define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
+ 
++#define AR934X_RESET_HOST		BIT(31)
++#define AR934X_RESET_SLIC		BIT(30)
++#define AR934X_RESET_HDMA		BIT(29)
++#define AR934X_RESET_EXTERNAL		BIT(28)
++#define AR934X_RESET_RTC		BIT(27)
++#define AR934X_RESET_PCIE_EP_INT	BIT(26)
++#define AR934X_RESET_CHKSUM_ACC		BIT(25)
++#define AR934X_RESET_FULL_CHIP		BIT(24)
++#define AR934X_RESET_GE1_MDIO		BIT(23)
++#define AR934X_RESET_GE0_MDIO		BIT(22)
++#define AR934X_RESET_CPU_NMI		BIT(21)
++#define AR934X_RESET_CPU_COLD		BIT(20)
++#define AR934X_RESET_HOST_RESET_INT	BIT(19)
++#define AR934X_RESET_PCIE_EP		BIT(18)
++#define AR934X_RESET_UART1		BIT(17)
++#define AR934X_RESET_DDR		BIT(16)
++#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define AR934X_RESET_NANDF		BIT(14)
++#define AR934X_RESET_GE1_MAC		BIT(13)
++#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
+ #define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
++#define AR934X_RESET_HOST_DMA_INT	BIT(10)
++#define AR934X_RESET_GE0_MAC		BIT(9)
++#define AR934X_RESET_ETH_SWITCH		BIT(8)
++#define AR934X_RESET_PCIE_PHY		BIT(7)
++#define AR934X_RESET_PCIE		BIT(6)
+ #define AR934X_RESET_USB_HOST		BIT(5)
+ #define AR934X_RESET_USB_PHY		BIT(4)
+ #define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
++#define AR934X_RESET_LUT		BIT(2)
++#define AR934X_RESET_MBOX		BIT(1)
++#define AR934X_RESET_I2S		BIT(0)
++
++#define QCA953X_RESET_USB_EXT_PWR	BIT(29)
++#define QCA953X_RESET_EXTERNAL		BIT(28)
++#define QCA953X_RESET_RTC		BIT(27)
++#define QCA953X_RESET_FULL_CHIP		BIT(24)
++#define QCA953X_RESET_GE1_MDIO		BIT(23)
++#define QCA953X_RESET_GE0_MDIO		BIT(22)
++#define QCA953X_RESET_CPU_NMI		BIT(21)
++#define QCA953X_RESET_CPU_COLD		BIT(20)
++#define QCA953X_RESET_DDR		BIT(16)
++#define QCA953X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define QCA953X_RESET_GE1_MAC		BIT(13)
++#define QCA953X_RESET_ETH_SWITCH_ANALOG	BIT(12)
++#define QCA953X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA953X_RESET_GE0_MAC		BIT(9)
++#define QCA953X_RESET_ETH_SWITCH	BIT(8)
++#define QCA953X_RESET_PCIE_PHY		BIT(7)
++#define QCA953X_RESET_PCIE		BIT(6)
++#define QCA953X_RESET_USB_HOST		BIT(5)
++#define QCA953X_RESET_USB_PHY		BIT(4)
++#define QCA953X_RESET_USBSUS_OVERRIDE	BIT(3)
++
++#define QCA955X_RESET_HOST		BIT(31)
++#define QCA955X_RESET_SLIC		BIT(30)
++#define QCA955X_RESET_HDMA		BIT(29)
++#define QCA955X_RESET_EXTERNAL		BIT(28)
++#define QCA955X_RESET_RTC		BIT(27)
++#define QCA955X_RESET_PCIE_EP_INT	BIT(26)
++#define QCA955X_RESET_CHKSUM_ACC	BIT(25)
++#define QCA955X_RESET_FULL_CHIP		BIT(24)
++#define QCA955X_RESET_GE1_MDIO		BIT(23)
++#define QCA955X_RESET_GE0_MDIO		BIT(22)
++#define QCA955X_RESET_CPU_NMI		BIT(21)
++#define QCA955X_RESET_CPU_COLD		BIT(20)
++#define QCA955X_RESET_HOST_RESET_INT	BIT(19)
++#define QCA955X_RESET_PCIE_EP		BIT(18)
++#define QCA955X_RESET_UART1		BIT(17)
++#define QCA955X_RESET_DDR		BIT(16)
++#define QCA955X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define QCA955X_RESET_NANDF		BIT(14)
++#define QCA955X_RESET_GE1_MAC		BIT(13)
++#define QCA955X_RESET_SGMII_ANALOG	BIT(12)
++#define QCA955X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA955X_RESET_HOST_DMA_INT	BIT(10)
++#define QCA955X_RESET_GE0_MAC		BIT(9)
++#define QCA955X_RESET_SGMII		BIT(8)
++#define QCA955X_RESET_PCIE_PHY		BIT(7)
++#define QCA955X_RESET_PCIE		BIT(6)
++#define QCA955X_RESET_USB_HOST		BIT(5)
++#define QCA955X_RESET_USB_PHY		BIT(4)
++#define QCA955X_RESET_USBSUS_OVERRIDE	BIT(3)
++#define QCA955X_RESET_LUT		BIT(2)
++#define QCA955X_RESET_MBOX		BIT(1)
++#define QCA955X_RESET_I2S		BIT(0)
++
++#define QCA956X_RESET_EXTERNAL		BIT(28)
++#define QCA956X_RESET_FULL_CHIP		BIT(24)
++#define QCA956X_RESET_GE1_MDIO		BIT(23)
++#define QCA956X_RESET_GE0_MDIO		BIT(22)
++#define QCA956X_RESET_CPU_NMI		BIT(21)
++#define QCA956X_RESET_CPU_COLD		BIT(20)
++#define QCA956X_RESET_DMA		BIT(19)
++#define QCA956X_RESET_DDR		BIT(16)
++#define QCA956X_RESET_GE1_MAC		BIT(13)
++#define QCA956X_RESET_SGMII_ANALOG	BIT(12)
++#define QCA956X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA956X_RESET_GE0_MAC		BIT(9)
++#define QCA956X_RESET_SGMII		BIT(8)
++#define QCA956X_RESET_USB_HOST		BIT(5)
++#define QCA956X_RESET_USB_PHY		BIT(4)
++#define QCA956X_RESET_USBSUS_OVERRIDE	BIT(3)
++#define QCA956X_RESET_SWITCH_ANALOG	BIT(2)
++#define QCA956X_RESET_SWITCH		BIT(0)
+ 
++#define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
++#define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
+ #define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
+ 
+ #define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
+@@ -398,8 +739,17 @@
+ #define AR934X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
+ #define AR934X_BOOTSTRAP_DDR1		BIT(0)
+ 
++#define QCA953X_BOOTSTRAP_SW_OPTION2	BIT(12)
++#define QCA953X_BOOTSTRAP_SW_OPTION1	BIT(11)
++#define QCA953X_BOOTSTRAP_EJTAG_MODE	BIT(5)
++#define QCA953X_BOOTSTRAP_REF_CLK_40	BIT(4)
++#define QCA953X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
++#define QCA953X_BOOTSTRAP_DDR1		BIT(0)
++
+ #define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
+ 
++#define QCA956X_BOOTSTRAP_REF_CLK_40	BIT(2)
++
+ #define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+ #define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+ #define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
+@@ -418,6 +768,24 @@
+ 	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
+ 	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
+ 
++#define QCA953X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
++#define QCA953X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
++#define QCA953X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
++#define QCA953X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
++#define QCA953X_PCIE_WMAC_INT_WMAC_ALL \
++	(QCA953X_PCIE_WMAC_INT_WMAC_MISC | QCA953X_PCIE_WMAC_INT_WMAC_TX | \
++	 QCA953X_PCIE_WMAC_INT_WMAC_RXLP | QCA953X_PCIE_WMAC_INT_WMAC_RXHP)
++
++#define QCA953X_PCIE_WMAC_INT_PCIE_ALL \
++	(QCA953X_PCIE_WMAC_INT_PCIE_RC | QCA953X_PCIE_WMAC_INT_PCIE_RC0 | \
++	 QCA953X_PCIE_WMAC_INT_PCIE_RC1 | QCA953X_PCIE_WMAC_INT_PCIE_RC2 | \
++	 QCA953X_PCIE_WMAC_INT_PCIE_RC3)
++
+ #define QCA955X_EXT_INT_WMAC_MISC		BIT(0)
+ #define QCA955X_EXT_INT_WMAC_TX			BIT(1)
+ #define QCA955X_EXT_INT_WMAC_RXLP		BIT(2)
+@@ -449,6 +817,37 @@
+ 	 QCA955X_EXT_INT_PCIE_RC2_INT1 | QCA955X_EXT_INT_PCIE_RC2_INT2 | \
+ 	 QCA955X_EXT_INT_PCIE_RC2_INT3)
+ 
++#define QCA956X_EXT_INT_WMAC_MISC		BIT(0)
++#define QCA956X_EXT_INT_WMAC_TX			BIT(1)
++#define QCA956X_EXT_INT_WMAC_RXLP		BIT(2)
++#define QCA956X_EXT_INT_WMAC_RXHP		BIT(3)
++#define QCA956X_EXT_INT_PCIE_RC1		BIT(4)
++#define QCA956X_EXT_INT_PCIE_RC1_INT0		BIT(5)
++#define QCA956X_EXT_INT_PCIE_RC1_INT1		BIT(6)
++#define QCA956X_EXT_INT_PCIE_RC1_INT2		BIT(7)
++#define QCA956X_EXT_INT_PCIE_RC1_INT3		BIT(8)
++#define QCA956X_EXT_INT_PCIE_RC2		BIT(12)
++#define QCA956X_EXT_INT_PCIE_RC2_INT0		BIT(13)
++#define QCA956X_EXT_INT_PCIE_RC2_INT1		BIT(14)
++#define QCA956X_EXT_INT_PCIE_RC2_INT2		BIT(15)
++#define QCA956X_EXT_INT_PCIE_RC2_INT3		BIT(16)
++#define QCA956X_EXT_INT_USB1			BIT(24)
++#define QCA956X_EXT_INT_USB2			BIT(28)
++
++#define QCA956X_EXT_INT_WMAC_ALL \
++	(QCA956X_EXT_INT_WMAC_MISC | QCA956X_EXT_INT_WMAC_TX | \
++	 QCA956X_EXT_INT_WMAC_RXLP | QCA956X_EXT_INT_WMAC_RXHP)
++
++#define QCA956X_EXT_INT_PCIE_RC1_ALL \
++	(QCA956X_EXT_INT_PCIE_RC1 | QCA956X_EXT_INT_PCIE_RC1_INT0 | \
++	 QCA956X_EXT_INT_PCIE_RC1_INT1 | QCA956X_EXT_INT_PCIE_RC1_INT2 | \
++	 QCA956X_EXT_INT_PCIE_RC1_INT3)
++
++#define QCA956X_EXT_INT_PCIE_RC2_ALL \
++	(QCA956X_EXT_INT_PCIE_RC2 | QCA956X_EXT_INT_PCIE_RC2_INT0 | \
++	 QCA956X_EXT_INT_PCIE_RC2_INT1 | QCA956X_EXT_INT_PCIE_RC2_INT2 | \
++	 QCA956X_EXT_INT_PCIE_RC2_INT3)
++
+ #define REV_ID_MAJOR_MASK		0xfff0
+ #define REV_ID_MAJOR_AR71XX		0x00a0
+ #define REV_ID_MAJOR_AR913X		0x00b0
+@@ -460,8 +859,12 @@
+ #define REV_ID_MAJOR_AR9341		0x0120
+ #define REV_ID_MAJOR_AR9342		0x1120
+ #define REV_ID_MAJOR_AR9344		0x2120
++#define REV_ID_MAJOR_QCA9533		0x0140
++#define REV_ID_MAJOR_QCA9533_V2		0x0160
+ #define REV_ID_MAJOR_QCA9556		0x0130
+ #define REV_ID_MAJOR_QCA9558		0x1130
++#define REV_ID_MAJOR_TP9343		0x0150
++#define REV_ID_MAJOR_QCA956X		0x1150
+ 
+ #define AR71XX_REV_ID_MINOR_MASK	0x3
+ #define AR71XX_REV_ID_MINOR_AR7130	0x0
+@@ -482,8 +885,12 @@
+ 
+ #define AR934X_REV_ID_REVISION_MASK	0xf
+ 
++#define QCA953X_REV_ID_REVISION_MASK	0xf
++
+ #define QCA955X_REV_ID_REVISION_MASK	0xf
+ 
++#define QCA956X_REV_ID_REVISION_MASK	0xf
++
+ /*
+  * SPI block
+  */
+@@ -521,15 +928,63 @@
+ #define AR71XX_GPIO_REG_INT_ENABLE	0x24
+ #define AR71XX_GPIO_REG_FUNC		0x28
+ 
++#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
++#define AR934X_GPIO_REG_OUT_FUNC1	0x30
++#define AR934X_GPIO_REG_OUT_FUNC2	0x34
++#define AR934X_GPIO_REG_OUT_FUNC3	0x38
++#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
++#define AR934X_GPIO_REG_OUT_FUNC5	0x40
+ #define AR934X_GPIO_REG_FUNC		0x6c
+ 
++#define QCA953X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA953X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA953X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA953X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA953X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA953X_GPIO_REG_IN_ENABLE0	0x44
++#define QCA953X_GPIO_REG_FUNC		0x6c
++
++#define QCA953X_GPIO_OUT_MUX_SPI_CS1		10
++#define QCA953X_GPIO_OUT_MUX_SPI_CS2		11
++#define QCA953X_GPIO_OUT_MUX_SPI_CS0		9
++#define QCA953X_GPIO_OUT_MUX_SPI_CLK		8
++#define QCA953X_GPIO_OUT_MUX_SPI_MOSI		12
++#define QCA953X_GPIO_OUT_MUX_LED_LINK1		41
++#define QCA953X_GPIO_OUT_MUX_LED_LINK2		42
++#define QCA953X_GPIO_OUT_MUX_LED_LINK3		43
++#define QCA953X_GPIO_OUT_MUX_LED_LINK4		44
++#define QCA953X_GPIO_OUT_MUX_LED_LINK5		45
++
++#define QCA955X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA955X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA955X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA955X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA955X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA955X_GPIO_REG_OUT_FUNC5	0x40
++#define QCA955X_GPIO_REG_FUNC		0x6c
++
++#define QCA956X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA956X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA956X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA956X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA956X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA956X_GPIO_REG_OUT_FUNC5	0x40
++#define QCA956X_GPIO_REG_IN_ENABLE0	0x44
++#define QCA956X_GPIO_REG_IN_ENABLE3	0x50
++#define QCA956X_GPIO_REG_FUNC		0x6c
++
++#define QCA956X_GPIO_OUT_MUX_GE0_MDO	32
++#define QCA956X_GPIO_OUT_MUX_GE0_MDC	33
++
+ #define AR71XX_GPIO_COUNT		16
+ #define AR7240_GPIO_COUNT		18
+ #define AR7241_GPIO_COUNT		20
+ #define AR913X_GPIO_COUNT		22
+ #define AR933X_GPIO_COUNT		30
+ #define AR934X_GPIO_COUNT		23
++#define QCA953X_GPIO_COUNT		18
+ #define QCA955X_GPIO_COUNT		24
++#define QCA956X_GPIO_COUNT		23
+ 
+ /*
+  * SRIF block
+@@ -552,4 +1007,318 @@
+ #define AR934X_SRIF_DPLL2_OUTDIV_SHIFT	13
+ #define AR934X_SRIF_DPLL2_OUTDIV_MASK	0x7
+ 
++#define QCA953X_SRIF_CPU_DPLL1_REG	0x1c0
++#define QCA953X_SRIF_CPU_DPLL2_REG	0x1c4
++#define QCA953X_SRIF_CPU_DPLL3_REG	0x1c8
++
++#define QCA953X_SRIF_DDR_DPLL1_REG	0x240
++#define QCA953X_SRIF_DDR_DPLL2_REG	0x244
++#define QCA953X_SRIF_DDR_DPLL3_REG	0x248
++
++#define QCA953X_SRIF_DPLL1_REFDIV_SHIFT	27
++#define QCA953X_SRIF_DPLL1_REFDIV_MASK	0x1f
++#define QCA953X_SRIF_DPLL1_NINT_SHIFT	18
++#define QCA953X_SRIF_DPLL1_NINT_MASK	0x1ff
++#define QCA953X_SRIF_DPLL1_NFRAC_MASK	0x0003ffff
++
++#define QCA953X_SRIF_DPLL2_LOCAL_PLL	BIT(30)
++#define QCA953X_SRIF_DPLL2_OUTDIV_SHIFT	13
++#define QCA953X_SRIF_DPLL2_OUTDIV_MASK	0x7
++
++#define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
++#define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
++#define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
++#define AR71XX_GPIO_FUNC_SPI_CS1_EN		BIT(12)
++#define AR71XX_GPIO_FUNC_UART_EN		BIT(8)
++#define AR71XX_GPIO_FUNC_USB_OC_EN		BIT(4)
++#define AR71XX_GPIO_FUNC_USB_CLK_EN		BIT(0)
++
++#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
++#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
++#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
++#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
++#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
++#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
++#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
++#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
++#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
++#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
++#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
++#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
++
++#define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
++#define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
++#define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
++#define AR913X_GPIO_FUNC_I2S_MCKEN		BIT(19)
++#define AR913X_GPIO_FUNC_I2S1_EN		BIT(18)
++#define AR913X_GPIO_FUNC_I2S0_EN		BIT(17)
++#define AR913X_GPIO_FUNC_SLIC_EN		BIT(16)
++#define AR913X_GPIO_FUNC_UART_RTSCTS_EN		BIT(9)
++#define AR913X_GPIO_FUNC_UART_EN		BIT(8)
++#define AR913X_GPIO_FUNC_USB_CLK_EN		BIT(4)
++
++#define AR933X_GPIO_FUNC_SPDIF2TCK		BIT(31)
++#define AR933X_GPIO_FUNC_SPDIF_EN		BIT(30)
++#define AR933X_GPIO_FUNC_I2SO_22_18_EN		BIT(29)
++#define AR933X_GPIO_FUNC_I2S_MCK_EN		BIT(27)
++#define AR933X_GPIO_FUNC_I2SO_EN		BIT(26)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_DUPL	BIT(25)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_COLL	BIT(24)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_ACT	BIT(23)
++#define AR933X_GPIO_FUNC_SPI_EN			BIT(18)
++#define AR933X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
++#define AR933X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
++#define AR933X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
++#define AR933X_GPIO_FUNC_UART_EN		BIT(1)
++#define AR933X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
++
++#define AR934X_GPIO_FUNC_CLK_OBS7_EN		BIT(9)
++#define AR934X_GPIO_FUNC_CLK_OBS6_EN		BIT(8)
++#define AR934X_GPIO_FUNC_CLK_OBS5_EN		BIT(7)
++#define AR934X_GPIO_FUNC_CLK_OBS4_EN		BIT(6)
++#define AR934X_GPIO_FUNC_CLK_OBS3_EN		BIT(5)
++#define AR934X_GPIO_FUNC_CLK_OBS2_EN		BIT(4)
++#define AR934X_GPIO_FUNC_CLK_OBS1_EN		BIT(3)
++#define AR934X_GPIO_FUNC_CLK_OBS0_EN		BIT(2)
++#define AR934X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
++
++#define AR934X_GPIO_OUT_GPIO		0
++#define AR934X_GPIO_OUT_SPI_CS1	7
++#define AR934X_GPIO_OUT_LED_LINK0	41
++#define AR934X_GPIO_OUT_LED_LINK1	42
++#define AR934X_GPIO_OUT_LED_LINK2	43
++#define AR934X_GPIO_OUT_LED_LINK3	44
++#define AR934X_GPIO_OUT_LED_LINK4	45
++#define AR934X_GPIO_OUT_EXT_LNA0	46
++#define AR934X_GPIO_OUT_EXT_LNA1	47
++
++#define QCA955X_GPIO_FUNC_CLK_OBS7_EN		BIT(9)
++#define QCA955X_GPIO_FUNC_CLK_OBS6_EN		BIT(8)
++#define QCA955X_GPIO_FUNC_CLK_OBS5_EN		BIT(7)
++#define QCA955X_GPIO_FUNC_CLK_OBS4_EN		BIT(6)
++#define QCA955X_GPIO_FUNC_CLK_OBS3_EN		BIT(5)
++#define QCA955X_GPIO_FUNC_CLK_OBS2_EN		BIT(4)
++#define QCA955X_GPIO_FUNC_CLK_OBS1_EN		BIT(3)
++#define QCA955X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
++
++#define QCA955X_GPIO_OUT_GPIO		0
++#define QCA955X_MII_EXT_MDI		1
++#define QCA955X_SLIC_DATA_OUT		3
++#define QCA955X_SLIC_PCM_FS		4
++#define QCA955X_SLIC_PCM_CLK		5
++#define QCA955X_SPI_CLK			8
++#define QCA955X_SPI_CS_0		9
++#define QCA955X_SPI_CS_1		10
++#define QCA955X_SPI_CS_2		11
++#define QCA955X_SPI_MISO		12
++#define QCA955X_I2S_CLK			13
++#define QCA955X_I2S_WS			14
++#define QCA955X_I2S_SD			15
++#define QCA955X_I2S_MCK			16
++#define QCA955X_SPDIF_OUT		17
++#define QCA955X_UART1_TD		18
++#define QCA955X_UART1_RTS		19
++#define QCA955X_UART1_RD		20
++#define QCA955X_UART1_CTS		21
++#define QCA955X_UART0_SOUT		22
++#define QCA955X_SPDIF2_OUT		23
++#define QCA955X_LED_SGMII_SPEED0	24
++#define QCA955X_LED_SGMII_SPEED1	25
++#define QCA955X_LED_SGMII_DUPLEX	26
++#define QCA955X_LED_SGMII_LINK_UP	27
++#define QCA955X_SGMII_SPEED0_INVERT	28
++#define QCA955X_SGMII_SPEED1_INVERT	29
++#define QCA955X_SGMII_DUPLEX_INVERT	30
++#define QCA955X_SGMII_LINK_UP_INVERT	31
++#define QCA955X_GE1_MII_MDO		32
++#define QCA955X_GE1_MII_MDC		33
++#define QCA955X_SWCOM2			38
++#define QCA955X_SWCOM3			39
++#define QCA955X_MAC2_GPIO		40
++#define QCA955X_MAC3_GPIO		41
++#define QCA955X_ATT_LED			42
++#define QCA955X_PWR_LED			43
++#define QCA955X_TX_FRAME		44
++#define QCA955X_RX_CLEAR_EXTERNAL	45
++#define QCA955X_LED_NETWORK_EN		46
++#define QCA955X_LED_POWER_EN		47
++#define QCA955X_WMAC_GLUE_WOW		68
++#define QCA955X_RX_CLEAR_EXTENSION	70
++#define QCA955X_CP_NAND_CS1		73
++#define QCA955X_USB_SUSPEND		74
++#define QCA955X_ETH_TX_ERR		75
++#define QCA955X_DDR_DQ_OE		76
++#define QCA955X_CLKREQ_N_EP		77
++#define QCA955X_CLKREQ_N_RC		78
++#define QCA955X_CLK_OBS0		79
++#define QCA955X_CLK_OBS1		80
++#define QCA955X_CLK_OBS2		81
++#define QCA955X_CLK_OBS3		82
++#define QCA955X_CLK_OBS4		83
++#define QCA955X_CLK_OBS5		84
++
++/*
++ * MII_CTRL block
++ */
++#define AR71XX_MII_REG_MII0_CTRL	0x00
++#define AR71XX_MII_REG_MII1_CTRL	0x04
++
++#define AR71XX_MII_CTRL_IF_MASK		3
++#define AR71XX_MII_CTRL_SPEED_SHIFT	4
++#define AR71XX_MII_CTRL_SPEED_MASK	3
++#define AR71XX_MII_CTRL_SPEED_10	0
++#define AR71XX_MII_CTRL_SPEED_100	1
++#define AR71XX_MII_CTRL_SPEED_1000	2
++
++#define AR71XX_MII0_CTRL_IF_GMII	0
++#define AR71XX_MII0_CTRL_IF_MII		1
++#define AR71XX_MII0_CTRL_IF_RGMII	2
++#define AR71XX_MII0_CTRL_IF_RMII	3
++
++#define AR71XX_MII1_CTRL_IF_RGMII	0
++#define AR71XX_MII1_CTRL_IF_RMII	1
++
++/*
++ * AR933X GMAC interface
++ */
++#define AR933X_GMAC_REG_ETH_CFG		0x00
++
++#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
++#define AR933X_ETH_CFG_MII_GE0		BIT(1)
++#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
++#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
++#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
++#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
++#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
++#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
++#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
++#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
++#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
++
++/*
++ * AR934X GMAC Interface
++ */
++#define AR934X_GMAC_REG_ETH_CFG		0x00
++
++#define AR934X_ETH_CFG_RGMII_GMAC0	BIT(0)
++#define AR934X_ETH_CFG_MII_GMAC0	BIT(1)
++#define AR934X_ETH_CFG_GMII_GMAC0	BIT(2)
++#define AR934X_ETH_CFG_MII_GMAC0_MASTER	BIT(3)
++#define AR934X_ETH_CFG_MII_GMAC0_SLAVE	BIT(4)
++#define AR934X_ETH_CFG_MII_GMAC0_ERR_EN	BIT(5)
++#define AR934X_ETH_CFG_SW_ONLY_MODE	BIT(6)
++#define AR934X_ETH_CFG_SW_PHY_SWAP	BIT(7)
++#define AR934X_ETH_CFG_SW_APB_ACCESS	BIT(9)
++#define AR934X_ETH_CFG_RMII_GMAC0	BIT(10)
++#define AR933X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
++#define AR934X_ETH_CFG_RMII_GMAC0_MASTER BIT(12)
++#define AR933X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++#define AR934X_ETH_CFG_RXD_DELAY        BIT(14)
++#define AR934X_ETH_CFG_RXD_DELAY_MASK   0x3
++#define AR934X_ETH_CFG_RXD_DELAY_SHIFT  14
++#define AR934X_ETH_CFG_RDV_DELAY        BIT(16)
++#define AR934X_ETH_CFG_RDV_DELAY_MASK   0x3
++#define AR934X_ETH_CFG_RDV_DELAY_SHIFT  16
++
++/*
++ * QCA953X GMAC Interface
++ */
++#define QCA953X_GMAC_REG_ETH_CFG		0x00
++
++#define QCA953X_ETH_CFG_SW_ONLY_MODE		BIT(6)
++#define QCA953X_ETH_CFG_SW_PHY_SWAP		BIT(7)
++#define QCA953X_ETH_CFG_SW_APB_ACCESS		BIT(9)
++#define QCA953X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++
++/*
++ * QCA955X GMAC Interface
++ */
++
++#define QCA955X_GMAC_REG_ETH_CFG	0x00
++#define QCA955X_GMAC_REG_SGMII_SERDES	0x18
++
++#define QCA955X_ETH_CFG_RGMII_EN	BIT(0)
++#define QCA955X_ETH_CFG_MII_GE0		BIT(1)
++#define QCA955X_ETH_CFG_GMII_GE0	BIT(2)
++#define QCA955X_ETH_CFG_MII_GE0_MASTER	BIT(3)
++#define QCA955X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
++#define QCA955X_ETH_CFG_GE0_ERR_EN	BIT(5)
++#define QCA955X_ETH_CFG_GE0_SGMII	BIT(6)
++#define QCA955X_ETH_CFG_RMII_GE0	BIT(10)
++#define QCA955X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
++#define QCA955X_ETH_CFG_RMII_GE0_MASTER	BIT(12)
++#define QCA955X_ETH_CFG_RXD_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_RXD_DELAY_SHIFT	14
++#define QCA955X_ETH_CFG_RDV_DELAY	BIT(16)
++#define QCA955X_ETH_CFG_RDV_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_RDV_DELAY_SHIFT	16
++#define QCA955X_ETH_CFG_TXD_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_TXD_DELAY_SHIFT	18
++#define QCA955X_ETH_CFG_TXE_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_TXE_DELAY_SHIFT	20
++
++#define QCA955X_SGMII_SERDES_LOCK_DETECT_STATUS	BIT(15)
++#define QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT 23
++#define QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK 0xf
++/*
++ * QCA956X GMAC Interface
++ */
++
++#define QCA956X_GMAC_REG_ETH_CFG	0x00
++#define QCA956X_GMAC_REG_SGMII_RESET	0x14
++#define QCA956X_GMAC_REG_SGMII_SERDES	0x18
++#define QCA956X_GMAC_REG_MR_AN_CONTROL	0x1c
++#define QCA956X_GMAC_REG_SGMII_CONFIG	0x34
++#define QCA956X_GMAC_REG_SGMII_DEBUG	0x58
++
++#define QCA956X_ETH_CFG_RGMII_EN		BIT(0)
++#define QCA956X_ETH_CFG_GE0_SGMII		BIT(6)
++#define QCA956X_ETH_CFG_SW_ONLY_MODE		BIT(7)
++#define QCA956X_ETH_CFG_SW_PHY_SWAP		BIT(8)
++#define QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(9)
++#define QCA956X_ETH_CFG_SW_APB_ACCESS		BIT(10)
++#define QCA956X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++#define QCA956X_ETH_CFG_RXD_DELAY_MASK		0x3
++#define QCA956X_ETH_CFG_RXD_DELAY_SHIFT		14
++#define QCA956X_ETH_CFG_RDV_DELAY_MASK		0x3
++#define QCA956X_ETH_CFG_RDV_DELAY_SHIFT		16
++
++#define QCA956X_SGMII_RESET_RX_CLK_N_RESET	0x0
++#define QCA956X_SGMII_RESET_RX_CLK_N		BIT(0)
++#define QCA956X_SGMII_RESET_TX_CLK_N		BIT(1)
++#define QCA956X_SGMII_RESET_RX_125M_N		BIT(2)
++#define QCA956X_SGMII_RESET_TX_125M_N		BIT(3)
++#define QCA956X_SGMII_RESET_HW_RX_125M_N	BIT(4)
++
++#define QCA956X_SGMII_SERDES_CDR_BW_MASK	0x3
++#define QCA956X_SGMII_SERDES_CDR_BW_SHIFT	1
++#define QCA956X_SGMII_SERDES_TX_DR_CTRL_MASK	0x7
++#define QCA956X_SGMII_SERDES_TX_DR_CTRL_SHIFT	4
++#define QCA956X_SGMII_SERDES_PLL_BW		BIT(8)
++#define QCA956X_SGMII_SERDES_VCO_FAST		BIT(9)
++#define QCA956X_SGMII_SERDES_VCO_SLOW		BIT(10)
++#define QCA956X_SGMII_SERDES_LOCK_DETECT_STATUS	BIT(15)
++#define QCA956X_SGMII_SERDES_EN_SIGNAL_DETECT	BIT(16)
++#define QCA956X_SGMII_SERDES_FIBER_SDO		BIT(17)
++#define QCA956X_SGMII_SERDES_RES_CALIBRATION_SHIFT 23
++#define QCA956X_SGMII_SERDES_RES_CALIBRATION_MASK 0xf
++#define QCA956X_SGMII_SERDES_VCO_REG_SHIFT	27
++#define QCA956X_SGMII_SERDES_VCO_REG_MASK	0xf
++
++#define QCA956X_MR_AN_CONTROL_AN_ENABLE		BIT(12)
++#define QCA956X_MR_AN_CONTROL_PHY_RESET		BIT(15)
++
++#define QCA956X_SGMII_CONFIG_MODE_CTRL_SHIFT	0
++#define QCA956X_SGMII_CONFIG_MODE_CTRL_MASK	0x7
++
+ #endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/ath79/patches-4.14/0010-MIPS-ath79-select-the-PINCTRL-subsystem.patch b/target/linux/ath79/patches-4.14/0010-MIPS-ath79-select-the-PINCTRL-subsystem.patch
new file mode 100644
index 0000000000..cd3f96c3f3
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0010-MIPS-ath79-select-the-PINCTRL-subsystem.patch
@@ -0,0 +1,20 @@
+From f3d5027255ef0752ed12b65c3bf7eb363fc3c096 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:00:55 +0100
+Subject: [PATCH 10/27] MIPS: ath79: select the PINCTRL subsystem
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/Kconfig | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -191,6 +191,7 @@ config ATH79
+ 	select CSRC_R4K
+ 	select DMA_NONCOHERENT
+ 	select GPIOLIB
++	select PINCTRL
+ 	select HAVE_CLK
+ 	select COMMON_CLK
+ 	select CLKDEV_LOOKUP
diff --git a/target/linux/ath79/patches-4.14/0011-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch b/target/linux/ath79/patches-4.14/0011-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
new file mode 100644
index 0000000000..85ee24c208
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0011-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
@@ -0,0 +1,27 @@
+From 54204ef3edbb1aa2390cabba61fe185a12cc39f0 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 08:35:44 +0100
+Subject: [PATCH 11/27] MIPS: ath79: fix register address in
+ ath79_ddr_wb_flush()
+
+ath79_ddr_wb_flush_base has the type void __iomem *, so register offsets
+need to be a multiple of 4.
+
+Cc: Alban Bedel <albeu@free.fr>
+Fixes: 24b0e3e84fbf ("MIPS: ath79: Improve the DDR controller interface")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/mips/ath79/common.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -58,7 +58,7 @@ EXPORT_SYMBOL_GPL(ath79_ddr_ctrl_init);
+ 
+ void ath79_ddr_wb_flush(u32 reg)
+ {
+-	void __iomem *flush_reg = ath79_ddr_wb_flush_base + reg;
++	void __iomem *flush_reg = ath79_ddr_wb_flush_base + (reg * 4);
+ 
+ 	/* Flush the DDR write buffer. */
+ 	__raw_writel(0x1, flush_reg);
diff --git a/target/linux/ath79/patches-4.14/0012-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch b/target/linux/ath79/patches-4.14/0012-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
new file mode 100644
index 0000000000..2b744ee94f
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0012-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
@@ -0,0 +1,42 @@
+From ac3a5ee699f3baa7654c93a3ffda46be82443344 Mon Sep 17 00:00:00 2001
+From: Markos Chandras <markos.chandras@imgtec.com>
+Date: Wed, 21 Aug 2013 11:47:22 +0100
+Subject: [PATCH 12/27] MIPS: ath79: Avoid using unitialized 'reg' variable
+
+Fixes the following build error:
+arch/mips/include/asm/mach-ath79/ath79.h:139:20: error: 'reg' may be used
+uninitialized in this function [-Werror=maybe-uninitialized]
+arch/mips/ath79/common.c:62:6: note: 'reg' was declared here
+In file included from arch/mips/ath79/common.c:20:0:
+arch/mips/ath79/common.c: In function 'ath79_device_reset_clear':
+arch/mips/include/asm/mach-ath79/ath79.h:139:20:
+error: 'reg' may be used uninitialized in this function
+[-Werror=maybe-uninitialized]
+arch/mips/ath79/common.c:90:6: note: 'reg' was declared here
+
+Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
+Acked-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ arch/mips/ath79/common.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -106,7 +106,7 @@ void ath79_device_reset_set(u32 mask)
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+-		BUG();
++		panic("Reset register not defined for this SOC");
+ 
+ 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
+ 	t = ath79_reset_rr(reg);
+@@ -134,7 +134,7 @@ void ath79_device_reset_clear(u32 mask)
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+-		BUG();
++		panic("Reset register not defined for this SOC");
+ 
+ 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
+ 	t = ath79_reset_rr(reg);
diff --git a/target/linux/ath79/patches-4.14/0013-MIPS-ath79-fix-system-restart.patch b/target/linux/ath79/patches-4.14/0013-MIPS-ath79-fix-system-restart.patch
new file mode 100644
index 0000000000..969636128f
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0013-MIPS-ath79-fix-system-restart.patch
@@ -0,0 +1,32 @@
+From 11562939754b8f877562d9a137854022eb521716 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 5 Mar 2018 11:33:54 +0100
+Subject: [PATCH 13/27] MIPS: ath79: fix system restart
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/ath79/setup.c                  | 1 +
+ arch/mips/include/asm/mach-ath79/ath79.h | 1 +
+ 2 files changed, 2 insertions(+)
+
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -40,6 +40,7 @@ static char ath79_sys_type[ATH79_SYS_TYP
+ 
+ static void ath79_restart(char *command)
+ {
++	local_irq_disable();
+ 	ath79_device_reset_set(AR71XX_RESET_FULL_CHIP);
+ 	for (;;)
+ 		if (cpu_wait)
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -134,6 +134,7 @@ static inline u32 ath79_pll_rr(unsigned
+ static inline void ath79_reset_wr(unsigned reg, u32 val)
+ {
+ 	__raw_writel(val, ath79_reset_base + reg);
++	(void) __raw_readl(ath79_reset_base + reg); /* flush */
+ }
+ 
+ static inline u32 ath79_reset_rr(unsigned reg)
diff --git a/target/linux/ath79/patches-4.14/0014-MIPS-ath79-finetune-cpu-overrides.patch b/target/linux/ath79/patches-4.14/0014-MIPS-ath79-finetune-cpu-overrides.patch
new file mode 100644
index 0000000000..e390e584f6
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0014-MIPS-ath79-finetune-cpu-overrides.patch
@@ -0,0 +1,38 @@
+From 5a8496923bafc4350f51b26964fdc3252a09fd79 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 5 Mar 2018 11:35:29 +0100
+Subject: [PATCH 14/27] MIPS: ath79: finetune cpu-overrides
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h
++++ b/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h
+@@ -36,6 +36,7 @@
+ #define cpu_has_mdmx		0
+ #define cpu_has_mips3d		0
+ #define cpu_has_smartmips	0
++#define cpu_has_rixi		0
+ 
+ #define cpu_has_mips32r1	1
+ #define cpu_has_mips32r2	1
+@@ -43,6 +44,7 @@
+ #define cpu_has_mips64r2	0
+ 
+ #define cpu_has_mipsmt		0
++#define cpu_has_userlocal	0
+ 
+ #define cpu_has_64bits		0
+ #define cpu_has_64bit_zero_reg	0
+@@ -51,5 +53,9 @@
+ 
+ #define cpu_dcache_line_size()	32
+ #define cpu_icache_line_size()	32
++#define cpu_has_vtag_icache	0
++#define cpu_has_dc_aliases	1
++#define cpu_has_ic_fills_f_dc	0
++#define cpu_has_pindexed_dcache	0
+ 
+ #endif /* __ASM_MACH_ATH79_CPU_FEATURE_OVERRIDES_H */
diff --git a/target/linux/ath79/patches-4.14/0015-MIPS-ath79-enable-uart-during-early_prink.patch b/target/linux/ath79/patches-4.14/0015-MIPS-ath79-enable-uart-during-early_prink.patch
new file mode 100644
index 0000000000..5826d01764
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0015-MIPS-ath79-enable-uart-during-early_prink.patch
@@ -0,0 +1,71 @@
+From b14f8260724abec6c82970085dece6a143d3a0db Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <juhosg@openwrt.org>
+Date: Mon, 5 Mar 2018 11:38:21 +0100
+Subject: [PATCH 15/27] MIPS: ath79: enable uart during early_prink
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ arch/mips/ath79/early_printk.c | 44 +++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 43 insertions(+), 1 deletion(-)
+
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -58,6 +58,46 @@ static void prom_putchar_dummy(unsigned
+ 	/* nothing to do */
+ }
+ 
++static void prom_enable_uart(u32 id)
++{
++	void __iomem *gpio_base;
++	u32 uart_en;
++	u32 t;
++
++	switch (id) {
++	case REV_ID_MAJOR_AR71XX:
++		uart_en = AR71XX_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR7240:
++	case REV_ID_MAJOR_AR7241:
++	case REV_ID_MAJOR_AR7242:
++		uart_en = AR724X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR913X:
++		uart_en = AR913X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR9330:
++	case REV_ID_MAJOR_AR9331:
++		uart_en = AR933X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR9341:
++	case REV_ID_MAJOR_AR9342:
++	case REV_ID_MAJOR_AR9344:
++		/* TODO */
++	default:
++		return;
++	}
++
++	gpio_base = (void __iomem *)(KSEG1ADDR(AR71XX_GPIO_BASE));
++	t = __raw_readl(gpio_base + AR71XX_GPIO_REG_FUNC);
++	t |= uart_en;
++	__raw_writel(t, gpio_base + AR71XX_GPIO_REG_FUNC);
++}
++
+ static void prom_putchar_init(void)
+ {
+ 	void __iomem *base;
+@@ -88,8 +128,10 @@ static void prom_putchar_init(void)
+ 
+ 	default:
+ 		_prom_putchar = prom_putchar_dummy;
+-		break;
++		return;
+ 	}
++
++	prom_enable_uart(id);
+ }
+ 
+ void prom_putchar(unsigned char ch)
diff --git a/target/linux/ath79/patches-4.14/0016-MIPS-ath79-add-support-for-QCA953x-SoC.patch b/target/linux/ath79/patches-4.14/0016-MIPS-ath79-add-support-for-QCA953x-SoC.patch
new file mode 100644
index 0000000000..0432a23d14
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0016-MIPS-ath79-add-support-for-QCA953x-SoC.patch
@@ -0,0 +1,331 @@
+From cff23ba486e3c5d17c4d7e446f5eddead855c101 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 08:45:55 +0100
+Subject: [PATCH 16/27] MIPS: ath79: add support for QCA953x SoC
+
+Note that the clock calculation looks very similar to the QCA955x, but the
+meaning of the bits CPUCLK_FROM_CPUPLL and DDRCLK_FROM_DDRPLL is reversed.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+---
+ arch/mips/ath79/Kconfig                  |  6 ++-
+ arch/mips/ath79/clock.c                  | 87 ++++++++++++++++++++++++++++++++
+ arch/mips/ath79/common.c                 |  4 ++
+ arch/mips/ath79/dev-common.c             |  4 ++
+ arch/mips/ath79/early_printk.c           |  2 +
+ arch/mips/ath79/irq.c                    | 33 +++++++++++-
+ arch/mips/ath79/setup.c                  | 21 ++++++--
+ arch/mips/include/asm/mach-ath79/ath79.h | 11 ++++
+ 8 files changed, 162 insertions(+), 6 deletions(-)
+
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -94,6 +94,10 @@ config SOC_AR934X
+ 	select PCI_AR724X if PCI
+ 	def_bool n
+ 
++config SOC_QCA953X
++	select USB_ARCH_HAS_EHCI
++	def_bool n
++
+ config SOC_QCA955X
+ 	select HW_HAS_PCI
+ 	select PCI_AR724X if PCI
+@@ -115,7 +119,7 @@ config ATH79_DEV_USB
+ 	def_bool n
+ 
+ config ATH79_DEV_WMAC
+-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA955X)
++	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
+ 	def_bool n
+ 
+ endif
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -355,6 +355,91 @@ static void __init ar934x_clocks_init(vo
+ 	iounmap(dpll_base);
+ }
+ 
++static void __init qca953x_clocks_init(void)
++{
++	unsigned long ref_rate;
++	unsigned long cpu_rate;
++	unsigned long ddr_rate;
++	unsigned long ahb_rate;
++	u32 pll, out_div, ref_div, nint, frac, clk_ctrl, postdiv;
++	u32 cpu_pll, ddr_pll;
++	u32 bootstrap;
++
++	bootstrap = ath79_reset_rr(QCA953X_RESET_REG_BOOTSTRAP);
++	if (bootstrap &	QCA953X_BOOTSTRAP_REF_CLK_40)
++		ref_rate = 40 * 1000 * 1000;
++	else
++		ref_rate = 25 * 1000 * 1000;
++
++	pll = ath79_pll_rr(QCA953X_PLL_CPU_CONFIG_REG);
++	out_div = (pll >> QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
++		  QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
++		  QCA953X_PLL_CPU_CONFIG_REFDIV_MASK;
++	nint = (pll >> QCA953X_PLL_CPU_CONFIG_NINT_SHIFT) &
++	       QCA953X_PLL_CPU_CONFIG_NINT_MASK;
++	frac = (pll >> QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT) &
++	       QCA953X_PLL_CPU_CONFIG_NFRAC_MASK;
++
++	cpu_pll = nint * ref_rate / ref_div;
++	cpu_pll += frac * (ref_rate >> 6) / ref_div;
++	cpu_pll /= (1 << out_div);
++
++	pll = ath79_pll_rr(QCA953X_PLL_DDR_CONFIG_REG);
++	out_div = (pll >> QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
++		  QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
++		  QCA953X_PLL_DDR_CONFIG_REFDIV_MASK;
++	nint = (pll >> QCA953X_PLL_DDR_CONFIG_NINT_SHIFT) &
++	       QCA953X_PLL_DDR_CONFIG_NINT_MASK;
++	frac = (pll >> QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT) &
++	       QCA953X_PLL_DDR_CONFIG_NFRAC_MASK;
++
++	ddr_pll = nint * ref_rate / ref_div;
++	ddr_pll += frac * (ref_rate >> 6) / (ref_div << 4);
++	ddr_pll /= (1 << out_div);
++
++	clk_ctrl = ath79_pll_rr(QCA953X_PLL_CLK_CTRL_REG);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
++		cpu_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL)
++		cpu_rate = cpu_pll / (postdiv + 1);
++	else
++		cpu_rate = ddr_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
++		ddr_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL)
++		ddr_rate = ddr_pll / (postdiv + 1);
++	else
++		ddr_rate = cpu_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
++		ahb_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
++		ahb_rate = ddr_pll / (postdiv + 1);
++	else
++		ahb_rate = cpu_pll / (postdiv + 1);
++
++	ath79_add_sys_clkdev("ref", ref_rate);
++	ath79_add_sys_clkdev("cpu", cpu_rate);
++	ath79_add_sys_clkdev("ddr", ddr_rate);
++	ath79_add_sys_clkdev("ahb", ahb_rate);
++
++	clk_add_alias("wdt", NULL, "ref", NULL);
++	clk_add_alias("uart", NULL, "ref", NULL);
++}
++
+ static void __init qca955x_clocks_init(void)
+ {
+ 	unsigned long ref_rate;
+@@ -450,6 +535,8 @@ void __init ath79_clocks_init(void)
+ 		ar933x_clocks_init();
+ 	else if (soc_is_ar934x())
+ 		ar934x_clocks_init();
++	else if (soc_is_qca953x())
++		qca953x_clocks_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_clocks_init();
+ 	else
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -103,6 +103,8 @@ void ath79_device_reset_set(u32 mask)
+ 		reg = AR933X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_ar934x())
+ 		reg = AR934X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca953x())
++		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+@@ -131,6 +133,8 @@ void ath79_device_reset_clear(u32 mask)
+ 		reg = AR933X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_ar934x())
+ 		reg = AR934X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca953x())
++		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -85,6 +85,7 @@ void __init ath79_register_uart(void)
+ 	    soc_is_ar724x() ||
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar934x() ||
++	    soc_is_qca953x() ||
+ 	    soc_is_qca955x()) {
+ 		ath79_uart_data[0].uartclk = uart_clk_rate;
+ 		platform_device_register(&ath79_uart_device);
+@@ -148,6 +149,9 @@ void __init ath79_gpio_init(void)
+ 	} else if (soc_is_ar934x()) {
+ 		ath79_gpio_pdata.ngpios = AR934X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
++	} else if (soc_is_qca953x()) {
++		ath79_gpio_pdata.ngpios = QCA953X_GPIO_COUNT;
++		ath79_gpio_pdata.oe_inverted = 1;
+ 	} else if (soc_is_qca955x()) {
+ 		ath79_gpio_pdata.ngpios = QCA955X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -116,6 +116,8 @@ static void prom_putchar_init(void)
+ 	case REV_ID_MAJOR_AR9341:
+ 	case REV_ID_MAJOR_AR9342:
+ 	case REV_ID_MAJOR_AR9344:
++	case REV_ID_MAJOR_QCA9533:
++	case REV_ID_MAJOR_QCA9533_V2:
+ 	case REV_ID_MAJOR_QCA9556:
+ 	case REV_ID_MAJOR_QCA9558:
+ 		_prom_putchar = prom_putchar_ar71xx;
+--- a/arch/mips/ath79/irq.c
++++ b/arch/mips/ath79/irq.c
+@@ -56,6 +56,34 @@ static void ar934x_ip2_irq_init(void)
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), ar934x_ip2_irq_dispatch);
+ }
+ 
++static void qca953x_ip2_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS);
++
++	if (status & QCA953X_PCIE_WMAC_INT_PCIE_ALL) {
++		ath79_ddr_wb_flush(3);
++		generic_handle_irq(ATH79_IP2_IRQ(0));
++	} else if (status & QCA953X_PCIE_WMAC_INT_WMAC_ALL) {
++		ath79_ddr_wb_flush(4);
++		generic_handle_irq(ATH79_IP2_IRQ(1));
++	} else {
++		spurious_interrupt();
++	}
++}
++
++static void qca953x_irq_init(void)
++{
++	int i;
++
++	for (i = ATH79_IP2_IRQ_BASE;
++	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca953x_ip2_irq_dispatch);
++}
++
+ static void qca955x_ip2_irq_dispatch(struct irq_desc *desc)
+ {
+ 	u32 status;
+@@ -143,7 +171,7 @@ void __init arch_init_irq(void)
+ 	    soc_is_ar913x() || soc_is_ar933x()) {
+ 		irq_wb_chan2 = 3;
+ 		irq_wb_chan3 = 2;
+-	} else if (soc_is_ar934x()) {
++	} else if (soc_is_ar934x() || soc_is_qca953x()) {
+ 		irq_wb_chan3 = 2;
+ 	}
+ 
+@@ -154,6 +182,7 @@ void __init arch_init_irq(void)
+ 	else if (soc_is_ar724x() ||
+ 		 soc_is_ar933x() ||
+ 		 soc_is_ar934x() ||
++		 soc_is_qca953x() ||
+ 		 soc_is_qca955x())
+ 		misc_is_ar71xx = false;
+ 	else
+@@ -164,6 +193,8 @@ void __init arch_init_irq(void)
+ 
+ 	if (soc_is_ar934x())
+ 		ar934x_ip2_irq_init();
++	else if (soc_is_qca953x())
++		qca953x_irq_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_irq_init();
+ }
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -60,6 +60,7 @@ static void __init ath79_detect_sys_type
+ 	u32 major;
+ 	u32 minor;
+ 	u32 rev = 0;
++	u32 ver = 1;
+ 
+ 	id = ath79_reset_rr(AR71XX_RESET_REG_REV_ID);
+ 	major = id & REV_ID_MAJOR_MASK;
+@@ -152,6 +153,17 @@ static void __init ath79_detect_sys_type
+ 		rev = id & AR934X_REV_ID_REVISION_MASK;
+ 		break;
+ 
++	case REV_ID_MAJOR_QCA9533_V2:
++		ver = 2;
++		ath79_soc_rev = 2;
++		/* drop through */
++
++	case REV_ID_MAJOR_QCA9533:
++		ath79_soc = ATH79_SOC_QCA9533;
++		chip = "9533";
++		rev = id & QCA953X_REV_ID_REVISION_MASK;
++		break;
++
+ 	case REV_ID_MAJOR_QCA9556:
+ 		ath79_soc = ATH79_SOC_QCA9556;
+ 		chip = "9556";
+@@ -168,11 +180,12 @@ static void __init ath79_detect_sys_type
+ 		panic("ath79: unknown SoC, id:0x%08x", id);
+ 	}
+ 
+-	ath79_soc_rev = rev;
++	if (ver == 1)
++		ath79_soc_rev = rev;
+ 
+-	if (soc_is_qca955x())
+-		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s rev %u",
+-			chip, rev);
++	if (soc_is_qca953x() || soc_is_qca955x())
++		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s ver %u rev %u",
++			chip, ver, rev);
+ 	else
+ 		sprintf(ath79_sys_type, "Atheros AR%s rev %u", chip, rev);
+ 	pr_info("SoC: %s\n", ath79_sys_type);
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -32,6 +32,7 @@ enum ath79_soc_type {
+ 	ATH79_SOC_AR9341,
+ 	ATH79_SOC_AR9342,
+ 	ATH79_SOC_AR9344,
++	ATH79_SOC_QCA9533,
+ 	ATH79_SOC_QCA9556,
+ 	ATH79_SOC_QCA9558,
+ };
+@@ -100,6 +101,16 @@ static inline int soc_is_ar934x(void)
+ 	return soc_is_ar9341() || soc_is_ar9342() || soc_is_ar9344();
+ }
+ 
++static inline int soc_is_qca9533(void)
++{
++	return ath79_soc == ATH79_SOC_QCA9533;
++}
++
++static inline int soc_is_qca953x(void)
++{
++	return soc_is_qca9533();
++}
++
+ static inline int soc_is_qca9556(void)
+ {
+ 	return ath79_soc == ATH79_SOC_QCA9556;
diff --git a/target/linux/ath79/patches-4.14/0017-MIPS-ath79-add-support-for-qca956x-soc.patch b/target/linux/ath79/patches-4.14/0017-MIPS-ath79-add-support-for-qca956x-soc.patch
new file mode 100644
index 0000000000..294fb32a17
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0017-MIPS-ath79-add-support-for-qca956x-soc.patch
@@ -0,0 +1,410 @@
+From 6aeb24b9508bbe91f89cd4eb21d0d7582d971146 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <hackpascal@gmail.com>
+Date: Tue, 6 Mar 2018 08:48:31 +0100
+Subject: [PATCH 17/27] MIPS: ath79: add support for qca956x soc
+
+This patch adds soc support for QCA9561 and TP9343.
+TP9343 is a reduced version of QCA9561, which can be found in TP-LINK routers in China.
+The qca956x_wmac has not yet been supported by ath9k.
+
+tested on TL-WDR6500 and TL-WR882N v1 (Chinese version)
+
+Signed-off-by: Weijie Gao <hackpascal@gmail.com>
+---
+ arch/mips/ath79/Kconfig                  |  2 +-
+ arch/mips/ath79/clock.c                  | 96 ++++++++++++++++++++++++++++++++
+ arch/mips/ath79/common.c                 |  4 ++
+ arch/mips/ath79/dev-common.c             |  7 ++-
+ arch/mips/ath79/early_printk.c           |  2 +
+ arch/mips/ath79/irq.c                    | 87 ++++++++++++++++++++++++++++-
+ arch/mips/ath79/pci.c                    | 12 ++++
+ arch/mips/ath79/setup.c                  | 17 +++++-
+ arch/mips/include/asm/mach-ath79/ath79.h | 22 ++++++++
+ 9 files changed, 245 insertions(+), 4 deletions(-)
+
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -119,7 +119,7 @@ config ATH79_DEV_USB
+ 	def_bool n
+ 
+ config ATH79_DEV_WMAC
+-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
++	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X || SOC_QCA956X)
+ 	def_bool n
+ 
+ endif
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -525,6 +525,100 @@ static void __init qca955x_clocks_init(v
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
++static void __init qca956x_clocks_init(void)
++{
++	unsigned long ref_rate;
++	unsigned long cpu_rate;
++	unsigned long ddr_rate;
++	unsigned long ahb_rate;
++	u32 pll, out_div, ref_div, nint, hfrac, lfrac, clk_ctrl, postdiv;
++	u32 cpu_pll, ddr_pll;
++	u32 bootstrap;
++
++	bootstrap = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
++	if (bootstrap &	QCA956X_BOOTSTRAP_REF_CLK_40)
++		ref_rate = 40 * 1000 * 1000;
++	else
++		ref_rate = 25 * 1000 * 1000;
++
++	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG_REG);
++	out_div = (pll >> QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
++		  QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
++		  QCA956X_PLL_CPU_CONFIG_REFDIV_MASK;
++
++	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG1_REG);
++	nint = (pll >> QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NINT_MASK;
++	hfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK;
++	lfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK;
++
++	cpu_pll = nint * ref_rate / ref_div;
++	cpu_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
++	cpu_pll += (hfrac >> 13) * ref_rate / ref_div;
++	cpu_pll /= (1 << out_div);
++
++	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG_REG);
++	out_div = (pll >> QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
++		  QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
++		  QCA956X_PLL_DDR_CONFIG_REFDIV_MASK;
++	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG1_REG);
++	nint = (pll >> QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NINT_MASK;
++	hfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK;
++	lfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK;
++
++	ddr_pll = nint * ref_rate / ref_div;
++	ddr_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
++	ddr_pll += (hfrac >> 13) * ref_rate / ref_div;
++	ddr_pll /= (1 << out_div);
++
++	clk_ctrl = ath79_pll_rr(QCA956X_PLL_CLK_CTRL_REG);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
++		cpu_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL)
++		cpu_rate = ddr_pll / (postdiv + 1);
++	else
++		cpu_rate = cpu_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
++		ddr_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL)
++		ddr_rate = cpu_pll / (postdiv + 1);
++	else
++		ddr_rate = ddr_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
++		ahb_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
++		ahb_rate = ddr_pll / (postdiv + 1);
++	else
++		ahb_rate = cpu_pll / (postdiv + 1);
++
++	ath79_add_sys_clkdev("ref", ref_rate);
++	ath79_add_sys_clkdev("cpu", cpu_rate);
++	ath79_add_sys_clkdev("ddr", ddr_rate);
++	ath79_add_sys_clkdev("ahb", ahb_rate);
++
++	clk_add_alias("wdt", NULL, "ref", NULL);
++	clk_add_alias("uart", NULL, "ref", NULL);
++}
++
+ void __init ath79_clocks_init(void)
+ {
+ 	if (soc_is_ar71xx())
+@@ -539,6 +633,8 @@ void __init ath79_clocks_init(void)
+ 		qca953x_clocks_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_clocks_init();
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		qca956x_clocks_init();
+ 	else
+ 		BUG();
+ }
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -107,6 +107,8 @@ void ath79_device_reset_set(u32 mask)
+ 		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		reg = QCA956X_RESET_REG_RESET_MODULE;
+ 	else
+ 		panic("Reset register not defined for this SOC");
+ 
+@@ -137,6 +139,8 @@ void ath79_device_reset_clear(u32 mask)
+ 		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		reg = QCA956X_RESET_REG_RESET_MODULE;
+ 	else
+ 		panic("Reset register not defined for this SOC");
+ 
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -86,7 +86,9 @@ void __init ath79_register_uart(void)
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar934x() ||
+ 	    soc_is_qca953x() ||
+-	    soc_is_qca955x()) {
++	    soc_is_qca955x() ||
++	    soc_is_qca956x() ||
++	    soc_is_tp9343()) {
+ 		ath79_uart_data[0].uartclk = uart_clk_rate;
+ 		platform_device_register(&ath79_uart_device);
+ 	} else if (soc_is_ar933x()) {
+@@ -155,6 +157,9 @@ void __init ath79_gpio_init(void)
+ 	} else if (soc_is_qca955x()) {
+ 		ath79_gpio_pdata.ngpios = QCA955X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
++	} else if (soc_is_qca956x() || soc_is_tp9343()) {
++		ath79_gpio_pdata.ngpios = QCA956X_GPIO_COUNT;
++		ath79_gpio_pdata.oe_inverted = 1;
+ 	} else {
+ 		BUG();
+ 	}
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -120,6 +120,8 @@ static void prom_putchar_init(void)
+ 	case REV_ID_MAJOR_QCA9533_V2:
+ 	case REV_ID_MAJOR_QCA9556:
+ 	case REV_ID_MAJOR_QCA9558:
++	case REV_ID_MAJOR_TP9343:
++	case REV_ID_MAJOR_QCA956X:
+ 		_prom_putchar = prom_putchar_ar71xx;
+ 		break;
+ 
+--- a/arch/mips/ath79/irq.c
++++ b/arch/mips/ath79/irq.c
+@@ -156,6 +156,87 @@ static void qca955x_irq_init(void)
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca955x_ip3_irq_dispatch);
+ }
+ 
++static void qca956x_ip2_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
++	status &= QCA956X_EXT_INT_PCIE_RC1_ALL | QCA956X_EXT_INT_WMAC_ALL;
++
++	if (status == 0) {
++		spurious_interrupt();
++		return;
++	}
++
++	if (status & QCA956X_EXT_INT_PCIE_RC1_ALL) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP2_IRQ(0));
++	}
++
++	if (status & QCA956X_EXT_INT_WMAC_ALL) {
++		/* TODO: flsuh DDR? */
++		generic_handle_irq(ATH79_IP2_IRQ(1));
++	}
++}
++
++static void qca956x_ip3_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
++	status &= QCA956X_EXT_INT_PCIE_RC2_ALL |
++		  QCA956X_EXT_INT_USB1 | QCA956X_EXT_INT_USB2;
++
++	if (status == 0) {
++		spurious_interrupt();
++		return;
++	}
++
++	if (status & QCA956X_EXT_INT_USB1) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(0));
++	}
++
++	if (status & QCA956X_EXT_INT_USB2) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(1));
++	}
++
++	if (status & QCA956X_EXT_INT_PCIE_RC2_ALL) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(2));
++	}
++}
++
++static void qca956x_enable_timer_cb(void) {
++	u32 misc;
++
++	misc = ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
++	misc |= MISC_INT_MIPS_SI_TIMERINT_MASK;
++	ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_ENABLE, misc);
++}
++
++static void qca956x_irq_init(void)
++{
++	int i;
++
++	for (i = ATH79_IP2_IRQ_BASE;
++	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca956x_ip2_irq_dispatch);
++
++	for (i = ATH79_IP3_IRQ_BASE;
++	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca956x_ip3_irq_dispatch);
++
++	/* QCA956x timer init workaround has to be applied right before setting
++	 * up the clock. Else, there will be no jiffies */
++	late_time_init = &qca956x_enable_timer_cb;
++}
++
+ void __init arch_init_irq(void)
+ {
+ 	unsigned irq_wb_chan2 = -1;
+@@ -183,7 +264,9 @@ void __init arch_init_irq(void)
+ 		 soc_is_ar933x() ||
+ 		 soc_is_ar934x() ||
+ 		 soc_is_qca953x() ||
+-		 soc_is_qca955x())
++		 soc_is_qca955x() ||
++		 soc_is_qca956x() ||
++		 soc_is_tp9343())
+ 		misc_is_ar71xx = false;
+ 	else
+ 		BUG();
+@@ -197,4 +280,6 @@ void __init arch_init_irq(void)
+ 		qca953x_irq_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_irq_init();
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		qca956x_irq_init();
+ }
+--- a/arch/mips/ath79/pci.c
++++ b/arch/mips/ath79/pci.c
+@@ -82,6 +82,9 @@ int pcibios_map_irq(const struct pci_dev
+ 		} else if (soc_is_qca955x()) {
+ 			ath79_pci_irq_map = qca955x_pci_irq_map;
+ 			ath79_pci_nr_irqs = ARRAY_SIZE(qca955x_pci_irq_map);
++		} else if (soc_is_qca956x()) {
++			ath79_pci_irq_map = qca956x_pci_irq_map;
++			ath79_pci_nr_irqs = ARRAY_SIZE(qca956x_pci_irq_map);
+ 		} else {
+ 			pr_crit("pci %s: invalid irq map\n",
+ 				pci_name((struct pci_dev *) dev));
+@@ -261,6 +264,15 @@ int __init ath79_register_pci(void)
+ 						 QCA955X_PCI_MEM_SIZE,
+ 						 1,
+ 						 ATH79_IP3_IRQ(2));
++	} else if (soc_is_qca956x()) {
++		pdev = ath79_register_pci_ar724x(0,
++						 QCA956X_PCI_CFG_BASE1,
++						 QCA956X_PCI_CTRL_BASE1,
++						 QCA956X_PCI_CRP_BASE1,
++						 QCA956X_PCI_MEM_BASE1,
++						 QCA956X_PCI_MEM_SIZE,
++						 1,
++						 ATH79_IP3_IRQ(2));
+ 	} else {
+ 		/* No PCI support */
+ 		return -ENODEV;
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -176,6 +176,18 @@ static void __init ath79_detect_sys_type
+ 		rev = id & QCA955X_REV_ID_REVISION_MASK;
+ 		break;
+ 
++	case REV_ID_MAJOR_QCA956X:
++		ath79_soc = ATH79_SOC_QCA956X;
++		chip = "956X";
++		rev = id & QCA956X_REV_ID_REVISION_MASK;
++		break;
++
++	case REV_ID_MAJOR_TP9343:
++		ath79_soc = ATH79_SOC_TP9343;
++		chip = "9343";
++		rev = id & QCA956X_REV_ID_REVISION_MASK;
++		break;
++
+ 	default:
+ 		panic("ath79: unknown SoC, id:0x%08x", id);
+ 	}
+@@ -183,9 +195,12 @@ static void __init ath79_detect_sys_type
+ 	if (ver == 1)
+ 		ath79_soc_rev = rev;
+ 
+-	if (soc_is_qca953x() || soc_is_qca955x())
++	if (soc_is_qca953x() || soc_is_qca955x() || soc_is_qca956x())
+ 		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s ver %u rev %u",
+ 			chip, ver, rev);
++	else if (soc_is_tp9343())
++		sprintf(ath79_sys_type, "Qualcomm Atheros TP%s rev %u",
++			chip, rev);
+ 	else
+ 		sprintf(ath79_sys_type, "Atheros AR%s rev %u", chip, rev);
+ 	pr_info("SoC: %s\n", ath79_sys_type);
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -35,6 +35,8 @@ enum ath79_soc_type {
+ 	ATH79_SOC_QCA9533,
+ 	ATH79_SOC_QCA9556,
+ 	ATH79_SOC_QCA9558,
++	ATH79_SOC_TP9343,
++	ATH79_SOC_QCA956X,
+ };
+ 
+ extern enum ath79_soc_type ath79_soc;
+@@ -126,6 +128,26 @@ static inline int soc_is_qca955x(void)
+ 	return soc_is_qca9556() || soc_is_qca9558();
+ }
+ 
++static inline int soc_is_tp9343(void)
++{
++	return ath79_soc == ATH79_SOC_TP9343;
++}
++
++static inline int soc_is_qca9561(void)
++{
++	return ath79_soc == ATH79_SOC_QCA956X;
++}
++
++static inline int soc_is_qca9563(void)
++{
++	return ath79_soc == ATH79_SOC_QCA956X;
++}
++
++static inline int soc_is_qca956x(void)
++{
++	return soc_is_qca9561() || soc_is_qca9563();
++}
++
+ void ath79_ddr_wb_flush(unsigned int reg);
+ void ath79_ddr_set_pci_windows(void);
+ 
diff --git a/target/linux/ath79/patches-4.14/0019-MIPS-ath79-get-PCIe-controller-out-of-reset.patch b/target/linux/ath79/patches-4.14/0019-MIPS-ath79-get-PCIe-controller-out-of-reset.patch
new file mode 100644
index 0000000000..f435e9bc1c
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0019-MIPS-ath79-get-PCIe-controller-out-of-reset.patch
@@ -0,0 +1,100 @@
+From 308c2ef9c4f1be2e1cee699042671eb973b51803 Mon Sep 17 00:00:00 2001
+From: Mathias Kresin <dev@kresin.me>
+Date: Tue, 6 Mar 2018 08:37:43 +0100
+Subject: [PATCH 19/27] MIPS: ath79: get PCIe controller out of reset
+
+The ar724x pci driver expects the PCIe controller to be brought out of
+reset by the bootloader.
+
+At least the AVM Fritz 300E bootloader doesn't take care of releasing
+the different PCIe controller related resets which causes an endless
+hang as soon as either the PCIE Reset register (0x180f0018) or the PCI
+Application Control register (0x180f0000) is read from.
+
+Do the full "PCIE Root Complex Initialization Sequence" if the PCIe
+host controller is still in reset during probing.
+
+The QCA u-boot sleeps 10ms after the PCIE Application Control bit is
+set to ready. It has been shown that 10ms might not be enough time if
+PCIe should be used right after setting the bit. During my tests it
+took up to 20ms till the link was up. Giving the link up to 100ms
+should work for all cases.
+
+Signed-off-by: Mathias Kresin <dev@kresin.me>
+---
+ arch/mips/pci/pci-ar724x.c | 42 ++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 42 insertions(+)
+
+--- a/arch/mips/pci/pci-ar724x.c
++++ b/arch/mips/pci/pci-ar724x.c
+@@ -12,14 +12,18 @@
+ #include <linux/irq.h>
+ #include <linux/pci.h>
+ #include <linux/init.h>
++#include <linux/delay.h>
+ #include <linux/platform_device.h>
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ 
++#define AR724X_PCI_REG_APP		0x00
+ #define AR724X_PCI_REG_RESET		0x18
+ #define AR724X_PCI_REG_INT_STATUS	0x4c
+ #define AR724X_PCI_REG_INT_MASK		0x50
+ 
++#define AR724X_PCI_APP_LTSSM_ENABLE	BIT(0)
++
+ #define AR724X_PCI_RESET_LINK_UP	BIT(0)
+ 
+ #define AR724X_PCI_INT_DEV0		BIT(14)
+@@ -325,6 +329,37 @@ static void ar724x_pci_irq_init(struct a
+ 					 apc);
+ }
+ 
++static void ar724x_pci_hw_init(struct ar724x_pci_controller *apc)
++{
++	u32 ppl, app;
++	int wait = 0;
++
++	/* deassert PCIe host controller and PCIe PHY reset */
++	ath79_device_reset_clear(AR724X_RESET_PCIE);
++	ath79_device_reset_clear(AR724X_RESET_PCIE_PHY);
++
++	/* remove the reset of the PCIE PLL */
++	ppl = ath79_pll_rr(AR724X_PLL_REG_PCIE_CONFIG);
++	ppl &= ~AR724X_PLL_REG_PCIE_CONFIG_PPL_RESET;
++	ath79_pll_wr(AR724X_PLL_REG_PCIE_CONFIG, ppl);
++
++	/* deassert bypass for the PCIE PLL */
++	ppl = ath79_pll_rr(AR724X_PLL_REG_PCIE_CONFIG);
++	ppl &= ~AR724X_PLL_REG_PCIE_CONFIG_PPL_BYPASS;
++	ath79_pll_wr(AR724X_PLL_REG_PCIE_CONFIG, ppl);
++
++	/* set PCIE Application Control to ready */
++	app = __raw_readl(apc->ctrl_base + AR724X_PCI_REG_APP);
++	app |= AR724X_PCI_APP_LTSSM_ENABLE;
++	__raw_writel(app, apc->ctrl_base + AR724X_PCI_REG_APP);
++
++	/* wait up to 100ms for PHY link up */
++	do {
++		mdelay(10);
++		wait++;
++	} while (wait < 10 && !ar724x_pci_check_link(apc));
++}
++
+ static int ar724x_pci_probe(struct platform_device *pdev)
+ {
+ 	struct ar724x_pci_controller *apc;
+@@ -383,6 +418,13 @@ static int ar724x_pci_probe(struct platf
+ 	apc->pci_controller.io_resource = &apc->io_res;
+ 	apc->pci_controller.mem_resource = &apc->mem_res;
+ 
++	/*
++	 * Do the full PCIE Root Complex Initialization Sequence if the PCIe
++	 * host controller is in reset.
++	 */
++	if (ath79_reset_rr(AR724X_RESET_REG_RESET_MODULE) & AR724X_RESET_PCIE)
++		ar724x_pci_hw_init(apc);
++
+ 	apc->link_up = ar724x_pci_check_link(apc);
+ 	if (!apc->link_up)
+ 		dev_warn(&pdev->dev, "PCIe link is down\n");
diff --git a/target/linux/ath79/patches-4.14/0020-MIPS-ath79-turn-pci-ar71xx-driver-into-a-pure-OF-dri.patch b/target/linux/ath79/patches-4.14/0020-MIPS-ath79-turn-pci-ar71xx-driver-into-a-pure-OF-dri.patch
new file mode 100644
index 0000000000..2d9ddf4a2c
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0020-MIPS-ath79-turn-pci-ar71xx-driver-into-a-pure-OF-dri.patch
@@ -0,0 +1,197 @@
+From cc5a306038b7956b5736a70696dddaaf3792df76 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:22:49 +0100
+Subject: [PATCH 20/27] MIPS: ath79: turn pci-ar71xx driver into a pure OF
+ driver
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/pci/pci-ar71xx.c | 81 +++++++++++++++++++++++-----------------------
+ 1 file changed, 40 insertions(+), 41 deletions(-)
+
+--- a/arch/mips/pci/pci-ar71xx.c
++++ b/arch/mips/pci/pci-ar71xx.c
+@@ -18,8 +18,11 @@
+ #include <linux/pci.h>
+ #include <linux/pci_regs.h>
+ #include <linux/interrupt.h>
++#include <linux/irqchip/chained_irq.h>
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
++#include <linux/of_irq.h>
++#include <linux/of_pci.h>
+ 
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ #include <asm/mach-ath79/ath79.h>
+@@ -49,12 +52,13 @@
+ #define AR71XX_PCI_IRQ_COUNT		5
+ 
+ struct ar71xx_pci_controller {
++	struct device_node *np;
+ 	void __iomem *cfg_base;
+ 	int irq;
+-	int irq_base;
+ 	struct pci_controller pci_ctrl;
+ 	struct resource io_res;
+ 	struct resource mem_res;
++	struct irq_domain *domain;
+ };
+ 
+ /* Byte lane enable bits */
+@@ -228,29 +232,30 @@ static struct pci_ops ar71xx_pci_ops = {
+ 
+ static void ar71xx_pci_irq_handler(struct irq_desc *desc)
+ {
+-	struct ar71xx_pci_controller *apc;
+ 	void __iomem *base = ath79_reset_base;
++	struct irq_chip *chip = irq_desc_get_chip(desc);
++	struct ar71xx_pci_controller *apc = irq_desc_get_handler_data(desc);
+ 	u32 pending;
+ 
+-	apc = irq_desc_get_handler_data(desc);
+-
++	chained_irq_enter(chip, desc);
+ 	pending = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_STATUS) &
+ 		  __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+ 
+ 	if (pending & AR71XX_PCI_INT_DEV0)
+-		generic_handle_irq(apc->irq_base + 0);
++		generic_handle_irq(irq_linear_revmap(apc->domain, 1));
+ 
+ 	else if (pending & AR71XX_PCI_INT_DEV1)
+-		generic_handle_irq(apc->irq_base + 1);
++		generic_handle_irq(irq_linear_revmap(apc->domain, 2));
+ 
+ 	else if (pending & AR71XX_PCI_INT_DEV2)
+-		generic_handle_irq(apc->irq_base + 2);
++		generic_handle_irq(irq_linear_revmap(apc->domain, 3));
+ 
+ 	else if (pending & AR71XX_PCI_INT_CORE)
+-		generic_handle_irq(apc->irq_base + 4);
++		generic_handle_irq(irq_linear_revmap(apc->domain, 4));
+ 
+ 	else
+ 		spurious_interrupt();
++	chained_irq_exit(chip, desc);
+ }
+ 
+ static void ar71xx_pci_irq_unmask(struct irq_data *d)
+@@ -261,7 +266,7 @@ static void ar71xx_pci_irq_unmask(struct
+ 	u32 t;
+ 
+ 	apc = irq_data_get_irq_chip_data(d);
+-	irq = d->irq - apc->irq_base;
++	irq = irq_linear_revmap(apc->domain, d->irq);
+ 
+ 	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+ 	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+@@ -278,7 +283,7 @@ static void ar71xx_pci_irq_mask(struct i
+ 	u32 t;
+ 
+ 	apc = irq_data_get_irq_chip_data(d);
+-	irq = d->irq - apc->irq_base;
++	irq = irq_linear_revmap(apc->domain, d->irq);
+ 
+ 	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+ 	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+@@ -294,24 +299,30 @@ static struct irq_chip ar71xx_pci_irq_ch
+ 	.irq_mask_ack	= ar71xx_pci_irq_mask,
+ };
+ 
++static int ar71xx_pci_irq_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
++{
++	struct ar71xx_pci_controller *apc = d->host_data;
++
++	irq_set_chip_and_handler(irq, &ar71xx_pci_irq_chip, handle_level_irq);
++	irq_set_chip_data(irq, apc);
++
++	return 0;
++}
++
++static const struct irq_domain_ops ar71xx_pci_domain_ops = {
++	.xlate = irq_domain_xlate_onecell,
++	.map = ar71xx_pci_irq_map,
++};
++
+ static void ar71xx_pci_irq_init(struct ar71xx_pci_controller *apc)
+ {
+ 	void __iomem *base = ath79_reset_base;
+-	int i;
+ 
+ 	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+ 	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_STATUS);
+ 
+-	BUILD_BUG_ON(ATH79_PCI_IRQ_COUNT < AR71XX_PCI_IRQ_COUNT);
+-
+-	apc->irq_base = ATH79_PCI_IRQ_BASE;
+-	for (i = apc->irq_base;
+-	     i < apc->irq_base + AR71XX_PCI_IRQ_COUNT; i++) {
+-		irq_set_chip_and_handler(i, &ar71xx_pci_irq_chip,
+-					 handle_level_irq);
+-		irq_set_chip_data(i, apc);
+-	}
+-
++	apc->domain = irq_domain_add_linear(apc->np, AR71XX_PCI_IRQ_COUNT,
++					    &ar71xx_pci_domain_ops, apc);
+ 	irq_set_chained_handler_and_data(apc->irq, ar71xx_pci_irq_handler,
+ 					 apc);
+ }
+@@ -328,6 +339,11 @@ static void ar71xx_pci_reset(void)
+ 	mdelay(100);
+ }
+ 
++static const struct of_device_id ar71xx_pci_ids[] = {
++	{ .compatible = "qca,ar7100-pci" },
++	{},
++};
++
+ static int ar71xx_pci_probe(struct platform_device *pdev)
+ {
+ 	struct ar71xx_pci_controller *apc;
+@@ -348,26 +364,6 @@ static int ar71xx_pci_probe(struct platf
+ 	if (apc->irq < 0)
+ 		return -EINVAL;
+ 
+-	res = platform_get_resource_byname(pdev, IORESOURCE_IO, "io_base");
+-	if (!res)
+-		return -EINVAL;
+-
+-	apc->io_res.parent = res;
+-	apc->io_res.name = "PCI IO space";
+-	apc->io_res.start = res->start;
+-	apc->io_res.end = res->end;
+-	apc->io_res.flags = IORESOURCE_IO;
+-
+-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem_base");
+-	if (!res)
+-		return -EINVAL;
+-
+-	apc->mem_res.parent = res;
+-	apc->mem_res.name = "PCI memory space";
+-	apc->mem_res.start = res->start;
+-	apc->mem_res.end = res->end;
+-	apc->mem_res.flags = IORESOURCE_MEM;
+-
+ 	ar71xx_pci_reset();
+ 
+ 	/* setup COMMAND register */
+@@ -380,9 +376,11 @@ static int ar71xx_pci_probe(struct platf
+ 
+ 	ar71xx_pci_irq_init(apc);
+ 
++	apc->np = pdev->dev.of_node;
+ 	apc->pci_ctrl.pci_ops = &ar71xx_pci_ops;
+ 	apc->pci_ctrl.mem_resource = &apc->mem_res;
+ 	apc->pci_ctrl.io_resource = &apc->io_res;
++	pci_load_of_ranges(&apc->pci_ctrl, pdev->dev.of_node);
+ 
+ 	register_pci_controller(&apc->pci_ctrl);
+ 
+@@ -393,6 +391,7 @@ static struct platform_driver ar71xx_pci
+ 	.probe = ar71xx_pci_probe,
+ 	.driver = {
+ 		.name = "ar71xx-pci",
++		.of_match_table = of_match_ptr(ar71xx_pci_ids),
+ 	},
+ };
+ 
diff --git a/target/linux/ath79/patches-4.14/0021-MIPS-ath79-turn-pci-ar724x-driver-into-a-pure-OF-dri.patch b/target/linux/ath79/patches-4.14/0021-MIPS-ath79-turn-pci-ar724x-driver-into-a-pure-OF-dri.patch
new file mode 100644
index 0000000000..d5ebeb87ae
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0021-MIPS-ath79-turn-pci-ar724x-driver-into-a-pure-OF-dri.patch
@@ -0,0 +1,199 @@
+From 0e7f36bfd68401e8c42933e7f770f270497bb9a8 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:23:25 +0100
+Subject: [PATCH 21/27] MIPS: ath79: turn pci-ar724x driver into a pure OF
+ driver
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/pci/pci-ar724x.c | 86 +++++++++++++++++++++-------------------------
+ 1 file changed, 40 insertions(+), 46 deletions(-)
+
+--- a/arch/mips/pci/pci-ar724x.c
++++ b/arch/mips/pci/pci-ar724x.c
+@@ -14,8 +14,11 @@
+ #include <linux/init.h>
+ #include <linux/delay.h>
+ #include <linux/platform_device.h>
++#include <linux/irqchip/chained_irq.h>
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
++#include <linux/of_irq.h>
++#include <linux/of_pci.h>
+ 
+ #define AR724X_PCI_REG_APP		0x00
+ #define AR724X_PCI_REG_RESET		0x18
+@@ -45,17 +48,20 @@ struct ar724x_pci_controller {
+ 	void __iomem *crp_base;
+ 
+ 	int irq;
+-	int irq_base;
+ 
+ 	bool link_up;
+ 	bool bar0_is_cached;
+ 	u32  bar0_value;
+ 
++	struct device_node *np;
+ 	struct pci_controller pci_controller;
++	struct irq_domain *domain;
+ 	struct resource io_res;
+ 	struct resource mem_res;
+ };
+ 
++static struct irq_chip ar724x_pci_irq_chip;
++
+ static inline bool ar724x_pci_check_link(struct ar724x_pci_controller *apc)
+ {
+ 	u32 reset;
+@@ -231,35 +237,31 @@ static struct pci_ops ar724x_pci_ops = {
+ 
+ static void ar724x_pci_irq_handler(struct irq_desc *desc)
+ {
+-	struct ar724x_pci_controller *apc;
+-	void __iomem *base;
++	struct irq_chip *chip = irq_desc_get_chip(desc);
++	struct ar724x_pci_controller *apc = irq_desc_get_handler_data(desc);
+ 	u32 pending;
+ 
+-	apc = irq_desc_get_handler_data(desc);
+-	base = apc->ctrl_base;
+-
+-	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &
+-		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
++	chained_irq_enter(chip, desc);
++	pending = __raw_readl(apc->ctrl_base + AR724X_PCI_REG_INT_STATUS) &
++		  __raw_readl(apc->ctrl_base + AR724X_PCI_REG_INT_MASK);
+ 
+ 	if (pending & AR724X_PCI_INT_DEV0)
+-		generic_handle_irq(apc->irq_base + 0);
+-
++		generic_handle_irq(irq_linear_revmap(apc->domain, 1));
+ 	else
+ 		spurious_interrupt();
++	chained_irq_exit(chip, desc);
+ }
+ 
+ static void ar724x_pci_irq_unmask(struct irq_data *d)
+ {
+ 	struct ar724x_pci_controller *apc;
+ 	void __iomem *base;
+-	int offset;
+ 	u32 t;
+ 
+ 	apc = irq_data_get_irq_chip_data(d);
+ 	base = apc->ctrl_base;
+-	offset = apc->irq_base - d->irq;
+ 
+-	switch (offset) {
++	switch (irq_linear_revmap(apc->domain, d->irq)) {
+ 	case 0:
+ 		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+ 		__raw_writel(t | AR724X_PCI_INT_DEV0,
+@@ -273,14 +275,12 @@ static void ar724x_pci_irq_mask(struct i
+ {
+ 	struct ar724x_pci_controller *apc;
+ 	void __iomem *base;
+-	int offset;
+ 	u32 t;
+ 
+ 	apc = irq_data_get_irq_chip_data(d);
+ 	base = apc->ctrl_base;
+-	offset = apc->irq_base - d->irq;
+ 
+-	switch (offset) {
++	switch (irq_linear_revmap(apc->domain, d->irq)) {
+ 	case 0:
+ 		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+ 		__raw_writel(t & ~AR724X_PCI_INT_DEV0,
+@@ -305,26 +305,32 @@ static struct irq_chip ar724x_pci_irq_ch
+ 	.irq_mask_ack	= ar724x_pci_irq_mask,
+ };
+ 
++static int ar724x_pci_irq_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
++{
++	struct ar724x_pci_controller *apc = d->host_data;
++
++	irq_set_chip_and_handler(irq, &ar724x_pci_irq_chip, handle_level_irq);
++	irq_set_chip_data(irq, apc);
++
++	return 0;
++}
++
++static const struct irq_domain_ops ar724x_pci_domain_ops = {
++	.xlate = irq_domain_xlate_onecell,
++	.map = ar724x_pci_irq_map,
++};
++
+ static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc,
+ 				int id)
+ {
+ 	void __iomem *base;
+-	int i;
+ 
+ 	base = apc->ctrl_base;
+ 
+ 	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
+ 	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
+ 
+-	apc->irq_base = ATH79_PCI_IRQ_BASE + (id * AR724X_PCI_IRQ_COUNT);
+-
+-	for (i = apc->irq_base;
+-	     i < apc->irq_base + AR724X_PCI_IRQ_COUNT; i++) {
+-		irq_set_chip_and_handler(i, &ar724x_pci_irq_chip,
+-					 handle_level_irq);
+-		irq_set_chip_data(i, apc);
+-	}
+-
++	apc->domain = irq_domain_add_linear(apc->np, 2, &ar724x_pci_domain_ops, apc);
+ 	irq_set_chained_handler_and_data(apc->irq, ar724x_pci_irq_handler,
+ 					 apc);
+ }
+@@ -394,29 +400,11 @@ static int ar724x_pci_probe(struct platf
+ 	if (apc->irq < 0)
+ 		return -EINVAL;
+ 
+-	res = platform_get_resource_byname(pdev, IORESOURCE_IO, "io_base");
+-	if (!res)
+-		return -EINVAL;
+-
+-	apc->io_res.parent = res;
+-	apc->io_res.name = "PCI IO space";
+-	apc->io_res.start = res->start;
+-	apc->io_res.end = res->end;
+-	apc->io_res.flags = IORESOURCE_IO;
+-
+-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem_base");
+-	if (!res)
+-		return -EINVAL;
+-
+-	apc->mem_res.parent = res;
+-	apc->mem_res.name = "PCI memory space";
+-	apc->mem_res.start = res->start;
+-	apc->mem_res.end = res->end;
+-	apc->mem_res.flags = IORESOURCE_MEM;
+-
++	apc->np = pdev->dev.of_node;
+ 	apc->pci_controller.pci_ops = &ar724x_pci_ops;
+ 	apc->pci_controller.io_resource = &apc->io_res;
+ 	apc->pci_controller.mem_resource = &apc->mem_res;
++	pci_load_of_ranges(&apc->pci_controller, pdev->dev.of_node);
+ 
+ 	/*
+ 	 * Do the full PCIE Root Complex Initialization Sequence if the PCIe
+@@ -438,10 +426,16 @@ static int ar724x_pci_probe(struct platf
+ 	return 0;
+ }
+ 
++static const struct of_device_id ar724x_pci_ids[] = {
++	{ .compatible = "qcom,ar7240-pci" },
++	{},
++};
++
+ static struct platform_driver ar724x_pci_driver = {
+ 	.probe = ar724x_pci_probe,
+ 	.driver = {
+ 		.name = "ar724x-pci",
++		.of_match_table = of_match_ptr(ar724x_pci_ids),
+ 	},
+ };
+ 
diff --git a/target/linux/ath79/patches-4.14/0022-MIPS-ath79-drop-pci.c.patch b/target/linux/ath79/patches-4.14/0022-MIPS-ath79-drop-pci.c.patch
new file mode 100644
index 0000000000..58ed122c68
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0022-MIPS-ath79-drop-pci.c.patch
@@ -0,0 +1,350 @@
+From f4128f3224df2309262ef8d1275d928717ebefd0 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:21:46 +0100
+Subject: [PATCH 22/27] MIPS: ath79: drop pci.c
+
+This patch drops pci.c fromt he ath79 folder and moves the the pcibios
+callbacks to a new fixup file.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/ath79/Makefile    |   1 -
+ arch/mips/ath79/pci.c       | 285 --------------------------------------------
+ arch/mips/pci/Makefile      |   1 +
+ arch/mips/pci/fixup-ath79.c |  21 ++++
+ 4 files changed, 22 insertions(+), 286 deletions(-)
+ delete mode 100644 arch/mips/ath79/pci.c
+ create mode 100644 arch/mips/pci/fixup-ath79.c
+
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -11,7 +11,6 @@
+ obj-y	:= prom.o setup.o irq.o common.o clock.o
+ 
+ obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+-obj-$(CONFIG_PCI)			+= pci.o
+ 
+ #
+ # Devices
+--- a/arch/mips/ath79/pci.c
++++ /dev/null
+@@ -1,285 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X specific PCI setup code
+- *
+- *  Copyright (C) 2011 Ren Bolldorf <xsecute@googlemail.com>
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  Parts of this file are based on Atheros' 2.6.15 BSP
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/init.h>
+-#include <linux/pci.h>
+-#include <linux/resource.h>
+-#include <linux/platform_device.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include <asm/mach-ath79/ath79.h>
+-#include <asm/mach-ath79/irq.h>
+-#include "pci.h"
+-
+-static int (*ath79_pci_plat_dev_init)(struct pci_dev *dev);
+-static const struct ath79_pci_irq *ath79_pci_irq_map;
+-static unsigned ath79_pci_nr_irqs;
+-
+-static const struct ath79_pci_irq ar71xx_pci_irq_map[] = {
+-	{
+-		.slot	= 17,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(0),
+-	}, {
+-		.slot	= 18,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(1),
+-	}, {
+-		.slot	= 19,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(2),
+-	}
+-};
+-
+-static const struct ath79_pci_irq ar724x_pci_irq_map[] = {
+-	{
+-		.slot	= 0,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(0),
+-	}
+-};
+-
+-static const struct ath79_pci_irq qca955x_pci_irq_map[] = {
+-	{
+-		.bus	= 0,
+-		.slot	= 0,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(0),
+-	},
+-	{
+-		.bus	= 1,
+-		.slot	= 0,
+-		.pin	= 1,
+-		.irq	= ATH79_PCI_IRQ(1),
+-	},
+-};
+-
+-int pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+-{
+-	int irq = -1;
+-	int i;
+-
+-	if (ath79_pci_nr_irqs == 0 ||
+-	    ath79_pci_irq_map == NULL) {
+-		if (soc_is_ar71xx()) {
+-			ath79_pci_irq_map = ar71xx_pci_irq_map;
+-			ath79_pci_nr_irqs = ARRAY_SIZE(ar71xx_pci_irq_map);
+-		} else if (soc_is_ar724x() ||
+-			   soc_is_ar9342() ||
+-			   soc_is_ar9344()) {
+-			ath79_pci_irq_map = ar724x_pci_irq_map;
+-			ath79_pci_nr_irqs = ARRAY_SIZE(ar724x_pci_irq_map);
+-		} else if (soc_is_qca955x()) {
+-			ath79_pci_irq_map = qca955x_pci_irq_map;
+-			ath79_pci_nr_irqs = ARRAY_SIZE(qca955x_pci_irq_map);
+-		} else if (soc_is_qca956x()) {
+-			ath79_pci_irq_map = qca956x_pci_irq_map;
+-			ath79_pci_nr_irqs = ARRAY_SIZE(qca956x_pci_irq_map);
+-		} else {
+-			pr_crit("pci %s: invalid irq map\n",
+-				pci_name((struct pci_dev *) dev));
+-			return irq;
+-		}
+-	}
+-
+-	for (i = 0; i < ath79_pci_nr_irqs; i++) {
+-		const struct ath79_pci_irq *entry;
+-
+-		entry = &ath79_pci_irq_map[i];
+-		if (entry->bus == dev->bus->number &&
+-		    entry->slot == slot &&
+-		    entry->pin == pin) {
+-			irq = entry->irq;
+-			break;
+-		}
+-	}
+-
+-	if (irq < 0)
+-		pr_crit("pci %s: no irq found for pin %u\n",
+-			pci_name((struct pci_dev *) dev), pin);
+-	else
+-		pr_info("pci %s: using irq %d for pin %u\n",
+-			pci_name((struct pci_dev *) dev), irq, pin);
+-
+-	return irq;
+-}
+-
+-int pcibios_plat_dev_init(struct pci_dev *dev)
+-{
+-	if (ath79_pci_plat_dev_init)
+-		return ath79_pci_plat_dev_init(dev);
+-
+-	return 0;
+-}
+-
+-void __init ath79_pci_set_irq_map(unsigned nr_irqs,
+-				  const struct ath79_pci_irq *map)
+-{
+-	ath79_pci_nr_irqs = nr_irqs;
+-	ath79_pci_irq_map = map;
+-}
+-
+-void __init ath79_pci_set_plat_dev_init(int (*func)(struct pci_dev *dev))
+-{
+-	ath79_pci_plat_dev_init = func;
+-}
+-
+-static struct platform_device *
+-ath79_register_pci_ar71xx(void)
+-{
+-	struct platform_device *pdev;
+-	struct resource res[4];
+-
+-	memset(res, 0, sizeof(res));
+-
+-	res[0].name = "cfg_base";
+-	res[0].flags = IORESOURCE_MEM;
+-	res[0].start = AR71XX_PCI_CFG_BASE;
+-	res[0].end = AR71XX_PCI_CFG_BASE + AR71XX_PCI_CFG_SIZE - 1;
+-
+-	res[1].flags = IORESOURCE_IRQ;
+-	res[1].start = ATH79_CPU_IRQ(2);
+-	res[1].end = ATH79_CPU_IRQ(2);
+-
+-	res[2].name = "io_base";
+-	res[2].flags = IORESOURCE_IO;
+-	res[2].start = 0;
+-	res[2].end = 0;
+-
+-	res[3].name = "mem_base";
+-	res[3].flags = IORESOURCE_MEM;
+-	res[3].start = AR71XX_PCI_MEM_BASE;
+-	res[3].end = AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1;
+-
+-	pdev = platform_device_register_simple("ar71xx-pci", -1,
+-					       res, ARRAY_SIZE(res));
+-	return pdev;
+-}
+-
+-static struct platform_device *
+-ath79_register_pci_ar724x(int id,
+-			  unsigned long cfg_base,
+-			  unsigned long ctrl_base,
+-			  unsigned long crp_base,
+-			  unsigned long mem_base,
+-			  unsigned long mem_size,
+-			  unsigned long io_base,
+-			  int irq)
+-{
+-	struct platform_device *pdev;
+-	struct resource res[6];
+-
+-	memset(res, 0, sizeof(res));
+-
+-	res[0].name = "cfg_base";
+-	res[0].flags = IORESOURCE_MEM;
+-	res[0].start = cfg_base;
+-	res[0].end = cfg_base + AR724X_PCI_CFG_SIZE - 1;
+-
+-	res[1].name = "ctrl_base";
+-	res[1].flags = IORESOURCE_MEM;
+-	res[1].start = ctrl_base;
+-	res[1].end = ctrl_base + AR724X_PCI_CTRL_SIZE - 1;
+-
+-	res[2].flags = IORESOURCE_IRQ;
+-	res[2].start = irq;
+-	res[2].end = irq;
+-
+-	res[3].name = "mem_base";
+-	res[3].flags = IORESOURCE_MEM;
+-	res[3].start = mem_base;
+-	res[3].end = mem_base + mem_size - 1;
+-
+-	res[4].name = "io_base";
+-	res[4].flags = IORESOURCE_IO;
+-	res[4].start = io_base;
+-	res[4].end = io_base;
+-
+-	res[5].name = "crp_base";
+-	res[5].flags = IORESOURCE_MEM;
+-	res[5].start = crp_base;
+-	res[5].end = crp_base + AR724X_PCI_CRP_SIZE - 1;
+-
+-	pdev = platform_device_register_simple("ar724x-pci", id,
+-					       res, ARRAY_SIZE(res));
+-	return pdev;
+-}
+-
+-int __init ath79_register_pci(void)
+-{
+-	struct platform_device *pdev = NULL;
+-
+-	if (soc_is_ar71xx()) {
+-		pdev = ath79_register_pci_ar71xx();
+-	} else if (soc_is_ar724x()) {
+-		pdev = ath79_register_pci_ar724x(-1,
+-						 AR724X_PCI_CFG_BASE,
+-						 AR724X_PCI_CTRL_BASE,
+-						 AR724X_PCI_CRP_BASE,
+-						 AR724X_PCI_MEM_BASE,
+-						 AR724X_PCI_MEM_SIZE,
+-						 0,
+-						 ATH79_CPU_IRQ(2));
+-	} else if (soc_is_ar9342() ||
+-		   soc_is_ar9344()) {
+-		u32 bootstrap;
+-
+-		bootstrap = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+-		if ((bootstrap & AR934X_BOOTSTRAP_PCIE_RC) == 0)
+-			return -ENODEV;
+-
+-		pdev = ath79_register_pci_ar724x(-1,
+-						 AR724X_PCI_CFG_BASE,
+-						 AR724X_PCI_CTRL_BASE,
+-						 AR724X_PCI_CRP_BASE,
+-						 AR724X_PCI_MEM_BASE,
+-						 AR724X_PCI_MEM_SIZE,
+-						 0,
+-						 ATH79_IP2_IRQ(0));
+-	} else if (soc_is_qca9558()) {
+-		pdev = ath79_register_pci_ar724x(0,
+-						 QCA955X_PCI_CFG_BASE0,
+-						 QCA955X_PCI_CTRL_BASE0,
+-						 QCA955X_PCI_CRP_BASE0,
+-						 QCA955X_PCI_MEM_BASE0,
+-						 QCA955X_PCI_MEM_SIZE,
+-						 0,
+-						 ATH79_IP2_IRQ(0));
+-
+-		pdev = ath79_register_pci_ar724x(1,
+-						 QCA955X_PCI_CFG_BASE1,
+-						 QCA955X_PCI_CTRL_BASE1,
+-						 QCA955X_PCI_CRP_BASE1,
+-						 QCA955X_PCI_MEM_BASE1,
+-						 QCA955X_PCI_MEM_SIZE,
+-						 1,
+-						 ATH79_IP3_IRQ(2));
+-	} else if (soc_is_qca956x()) {
+-		pdev = ath79_register_pci_ar724x(0,
+-						 QCA956X_PCI_CFG_BASE1,
+-						 QCA956X_PCI_CTRL_BASE1,
+-						 QCA956X_PCI_CRP_BASE1,
+-						 QCA956X_PCI_MEM_BASE1,
+-						 QCA956X_PCI_MEM_SIZE,
+-						 1,
+-						 ATH79_IP3_IRQ(2));
+-	} else {
+-		/* No PCI support */
+-		return -ENODEV;
+-	}
+-
+-	if (!pdev)
+-		pr_err("unable to register PCI controller device\n");
+-
+-	return pdev ? 0 : -ENODEV;
+-}
+--- a/arch/mips/pci/Makefile
++++ b/arch/mips/pci/Makefile
+@@ -29,6 +29,7 @@ obj-$(CONFIG_MIPS_PCI_VIRTIO)	+= pci-vir
+ #
+ # These are still pretty much in the old state, watch, go blind.
+ #
++obj-$(CONFIG_ATH79)		+= fixup-ath79.o
+ obj-$(CONFIG_LASAT)		+= pci-lasat.o
+ obj-$(CONFIG_MIPS_COBALT)	+= fixup-cobalt.o
+ obj-$(CONFIG_LEMOTE_FULOONG2E)	+= fixup-fuloong2e.o ops-loongson2.o
+--- /dev/null
++++ b/arch/mips/pci/fixup-ath79.c
+@@ -0,0 +1,21 @@
++/*
++ *  Copyright (C) 2018 John Crispin <john@phrozen.org>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#include <linux/pci.h>
++//#include <linux/of_irq.h>
++#include <linux/of_pci.h>
++
++int pcibios_plat_dev_init(struct pci_dev *dev)
++{
++	return PCIBIOS_SUCCESSFUL;
++}
++
++int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
++{
++	return of_irq_parse_and_map_pci(dev, slot, pin);
++}
diff --git a/target/linux/ath79/patches-4.14/0023-MIPS-ath79-drop-mach-files.patch b/target/linux/ath79/patches-4.14/0023-MIPS-ath79-drop-mach-files.patch
new file mode 100644
index 0000000000..2d9a9bc971
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0023-MIPS-ath79-drop-mach-files.patch
@@ -0,0 +1,742 @@
+From 6e38a86d50dba5cc1da9bfd07969d76dd3ac2dda Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:28:13 +0100
+Subject: [PATCH 23/27] MIPS: ath79: drop mach files
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/ath79/Kconfig        |  73 -------------------
+ arch/mips/ath79/Makefile       |  10 ---
+ arch/mips/ath79/mach-ap121.c   |  92 ------------------------
+ arch/mips/ath79/mach-ap136.c   | 156 -----------------------------------------
+ arch/mips/ath79/mach-ap81.c    | 100 --------------------------
+ arch/mips/ath79/mach-db120.c   | 136 -----------------------------------
+ arch/mips/ath79/mach-pb44.c    | 128 ---------------------------------
+ arch/mips/ath79/mach-ubnt-xm.c | 126 ---------------------------------
+ 8 files changed, 821 deletions(-)
+ delete mode 100644 arch/mips/ath79/mach-ap121.c
+ delete mode 100644 arch/mips/ath79/mach-ap136.c
+ delete mode 100644 arch/mips/ath79/mach-ap81.c
+ delete mode 100644 arch/mips/ath79/mach-db120.c
+ delete mode 100644 arch/mips/ath79/mach-pb44.c
+ delete mode 100644 arch/mips/ath79/mach-ubnt-xm.c
+
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -1,79 +1,6 @@
+ # SPDX-License-Identifier: GPL-2.0
+ if ATH79
+ 
+-menu "Atheros AR71XX/AR724X/AR913X machine selection"
+-
+-config ATH79_MACH_AP121
+-	bool "Atheros AP121 reference board"
+-	select SOC_AR933X
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	select ATH79_DEV_USB
+-	select ATH79_DEV_WMAC
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Atheros AP121 reference board.
+-
+-config ATH79_MACH_AP136
+-	bool "Atheros AP136 reference board"
+-	select SOC_QCA955X
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	select ATH79_DEV_USB
+-	select ATH79_DEV_WMAC
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Atheros AP136 reference board.
+-
+-config ATH79_MACH_AP81
+-	bool "Atheros AP81 reference board"
+-	select SOC_AR913X
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	select ATH79_DEV_USB
+-	select ATH79_DEV_WMAC
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Atheros AP81 reference board.
+-
+-config ATH79_MACH_DB120
+-	bool "Atheros DB120 reference board"
+-	select SOC_AR934X
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	select ATH79_DEV_USB
+-	select ATH79_DEV_WMAC
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Atheros DB120 reference board.
+-
+-config ATH79_MACH_PB44
+-	bool "Atheros PB44 reference board"
+-	select SOC_AR71XX
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	select ATH79_DEV_USB
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Atheros PB44 reference board.
+-
+-config ATH79_MACH_UBNT_XM
+-	bool "Ubiquiti Networks XM (rev 1.0) board"
+-	select SOC_AR724X
+-	select ATH79_DEV_GPIO_BUTTONS
+-	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
+-	help
+-	  Say 'Y' here if you want your kernel to support the
+-	  Ubiquiti Networks XM (rev 1.0) board.
+-
+-endmenu
+-
+ config SOC_AR71XX
+ 	select HW_HAS_PCI
+ 	def_bool n
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -21,13 +21,3 @@ obj-$(CONFIG_ATH79_DEV_LEDS_GPIO)	+= dev
+ obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
+ obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
+ obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+-
+-#
+-# Machines
+-#
+-obj-$(CONFIG_ATH79_MACH_AP121)		+= mach-ap121.o
+-obj-$(CONFIG_ATH79_MACH_AP136)		+= mach-ap136.o
+-obj-$(CONFIG_ATH79_MACH_AP81)		+= mach-ap81.o
+-obj-$(CONFIG_ATH79_MACH_DB120)		+= mach-db120.o
+-obj-$(CONFIG_ATH79_MACH_PB44)		+= mach-pb44.o
+-obj-$(CONFIG_ATH79_MACH_UBNT_XM)	+= mach-ubnt-xm.o
+--- a/arch/mips/ath79/mach-ap121.c
++++ /dev/null
+@@ -1,92 +0,0 @@
+-/*
+- *  Atheros AP121 board support
+- *
+- *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include "machtypes.h"
+-#include "dev-gpio-buttons.h"
+-#include "dev-leds-gpio.h"
+-#include "dev-spi.h"
+-#include "dev-usb.h"
+-#include "dev-wmac.h"
+-
+-#define AP121_GPIO_LED_WLAN		0
+-#define AP121_GPIO_LED_USB		1
+-
+-#define AP121_GPIO_BTN_JUMPSTART	11
+-#define AP121_GPIO_BTN_RESET		12
+-
+-#define AP121_KEYS_POLL_INTERVAL	20	/* msecs */
+-#define AP121_KEYS_DEBOUNCE_INTERVAL	(3 * AP121_KEYS_POLL_INTERVAL)
+-
+-#define AP121_CAL_DATA_ADDR	0x1fff1000
+-
+-static struct gpio_led ap121_leds_gpio[] __initdata = {
+-	{
+-		.name		= "ap121:green:usb",
+-		.gpio		= AP121_GPIO_LED_USB,
+-		.active_low	= 0,
+-	},
+-	{
+-		.name		= "ap121:green:wlan",
+-		.gpio		= AP121_GPIO_LED_WLAN,
+-		.active_low	= 0,
+-	},
+-};
+-
+-static struct gpio_keys_button ap121_gpio_keys[] __initdata = {
+-	{
+-		.desc		= "jumpstart button",
+-		.type		= EV_KEY,
+-		.code		= KEY_WPS_BUTTON,
+-		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP121_GPIO_BTN_JUMPSTART,
+-		.active_low	= 1,
+-	},
+-	{
+-		.desc		= "reset button",
+-		.type		= EV_KEY,
+-		.code		= KEY_RESTART,
+-		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP121_GPIO_BTN_RESET,
+-		.active_low	= 1,
+-	}
+-};
+-
+-static struct spi_board_info ap121_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "mx25l1606e",
+-	}
+-};
+-
+-static struct ath79_spi_platform_data ap121_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect = 1,
+-};
+-
+-static void __init ap121_setup(void)
+-{
+-	u8 *cal_data = (u8 *) KSEG1ADDR(AP121_CAL_DATA_ADDR);
+-
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121_leds_gpio),
+-				 ap121_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(ap121_gpio_keys),
+-					ap121_gpio_keys);
+-
+-	ath79_register_spi(&ap121_spi_data, ap121_spi_info,
+-			   ARRAY_SIZE(ap121_spi_info));
+-	ath79_register_usb();
+-	ath79_register_wmac(cal_data);
+-}
+-
+-MIPS_MACHINE(ATH79_MACH_AP121, "AP121", "Atheros AP121 reference board",
+-	     ap121_setup);
+--- a/arch/mips/ath79/mach-ap136.c
++++ /dev/null
+@@ -1,156 +0,0 @@
+-/*
+- * Qualcomm Atheros AP136 reference board support
+- *
+- * Copyright (c) 2012 Qualcomm Atheros
+- * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+- *
+- */
+-
+-#include <linux/pci.h>
+-#include <linux/ath9k_platform.h>
+-
+-#include "machtypes.h"
+-#include "dev-gpio-buttons.h"
+-#include "dev-leds-gpio.h"
+-#include "dev-spi.h"
+-#include "dev-usb.h"
+-#include "dev-wmac.h"
+-#include "pci.h"
+-
+-#define AP136_GPIO_LED_STATUS_RED	14
+-#define AP136_GPIO_LED_STATUS_GREEN	19
+-#define AP136_GPIO_LED_USB		4
+-#define AP136_GPIO_LED_WLAN_2G		13
+-#define AP136_GPIO_LED_WLAN_5G		12
+-#define AP136_GPIO_LED_WPS_RED		15
+-#define AP136_GPIO_LED_WPS_GREEN	20
+-
+-#define AP136_GPIO_BTN_WPS		16
+-#define AP136_GPIO_BTN_RFKILL		21
+-
+-#define AP136_KEYS_POLL_INTERVAL	20	/* msecs */
+-#define AP136_KEYS_DEBOUNCE_INTERVAL	(3 * AP136_KEYS_POLL_INTERVAL)
+-
+-#define AP136_WMAC_CALDATA_OFFSET 0x1000
+-#define AP136_PCIE_CALDATA_OFFSET 0x5000
+-
+-static struct gpio_led ap136_leds_gpio[] __initdata = {
+-	{
+-		.name		= "qca:green:status",
+-		.gpio		= AP136_GPIO_LED_STATUS_GREEN,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "qca:red:status",
+-		.gpio		= AP136_GPIO_LED_STATUS_RED,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "qca:green:wps",
+-		.gpio		= AP136_GPIO_LED_WPS_GREEN,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "qca:red:wps",
+-		.gpio		= AP136_GPIO_LED_WPS_RED,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "qca:red:wlan-2g",
+-		.gpio		= AP136_GPIO_LED_WLAN_2G,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "qca:red:usb",
+-		.gpio		= AP136_GPIO_LED_USB,
+-		.active_low	= 1,
+-	}
+-};
+-
+-static struct gpio_keys_button ap136_gpio_keys[] __initdata = {
+-	{
+-		.desc		= "WPS button",
+-		.type		= EV_KEY,
+-		.code		= KEY_WPS_BUTTON,
+-		.debounce_interval = AP136_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP136_GPIO_BTN_WPS,
+-		.active_low	= 1,
+-	},
+-	{
+-		.desc		= "RFKILL button",
+-		.type		= EV_KEY,
+-		.code		= KEY_RFKILL,
+-		.debounce_interval = AP136_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP136_GPIO_BTN_RFKILL,
+-		.active_low	= 1,
+-	},
+-};
+-
+-static struct spi_board_info ap136_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "mx25l6405d",
+-	}
+-};
+-
+-static struct ath79_spi_platform_data ap136_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect	= 1,
+-};
+-
+-#ifdef CONFIG_PCI
+-static struct ath9k_platform_data ap136_ath9k_data;
+-
+-static int ap136_pci_plat_dev_init(struct pci_dev *dev)
+-{
+-	if (dev->bus->number == 1 && (PCI_SLOT(dev->devfn)) == 0)
+-		dev->dev.platform_data = &ap136_ath9k_data;
+-
+-	return 0;
+-}
+-
+-static void __init ap136_pci_init(u8 *eeprom)
+-{
+-	memcpy(ap136_ath9k_data.eeprom_data, eeprom,
+-	       sizeof(ap136_ath9k_data.eeprom_data));
+-
+-	ath79_pci_set_plat_dev_init(ap136_pci_plat_dev_init);
+-	ath79_register_pci();
+-}
+-#else
+-static inline void ap136_pci_init(u8 *eeprom) {}
+-#endif /* CONFIG_PCI */
+-
+-static void __init ap136_setup(void)
+-{
+-	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+-
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
+-				 ap136_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(ap136_gpio_keys),
+-					ap136_gpio_keys);
+-	ath79_register_spi(&ap136_spi_data, ap136_spi_info,
+-			   ARRAY_SIZE(ap136_spi_info));
+-	ath79_register_usb();
+-	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET);
+-	ap136_pci_init(art + AP136_PCIE_CALDATA_OFFSET);
+-}
+-
+-MIPS_MACHINE(ATH79_MACH_AP136_010, "AP136-010",
+-	     "Atheros AP136-010 reference board",
+-	     ap136_setup);
+--- a/arch/mips/ath79/mach-ap81.c
++++ /dev/null
+@@ -1,100 +0,0 @@
+-/*
+- *  Atheros AP81 board support
+- *
+- *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include "machtypes.h"
+-#include "dev-wmac.h"
+-#include "dev-gpio-buttons.h"
+-#include "dev-leds-gpio.h"
+-#include "dev-spi.h"
+-#include "dev-usb.h"
+-
+-#define AP81_GPIO_LED_STATUS	1
+-#define AP81_GPIO_LED_AOSS	3
+-#define AP81_GPIO_LED_WLAN	6
+-#define AP81_GPIO_LED_POWER	14
+-
+-#define AP81_GPIO_BTN_SW4	12
+-#define AP81_GPIO_BTN_SW1	21
+-
+-#define AP81_KEYS_POLL_INTERVAL		20	/* msecs */
+-#define AP81_KEYS_DEBOUNCE_INTERVAL	(3 * AP81_KEYS_POLL_INTERVAL)
+-
+-#define AP81_CAL_DATA_ADDR	0x1fff1000
+-
+-static struct gpio_led ap81_leds_gpio[] __initdata = {
+-	{
+-		.name		= "ap81:green:status",
+-		.gpio		= AP81_GPIO_LED_STATUS,
+-		.active_low	= 1,
+-	}, {
+-		.name		= "ap81:amber:aoss",
+-		.gpio		= AP81_GPIO_LED_AOSS,
+-		.active_low	= 1,
+-	}, {
+-		.name		= "ap81:green:wlan",
+-		.gpio		= AP81_GPIO_LED_WLAN,
+-		.active_low	= 1,
+-	}, {
+-		.name		= "ap81:green:power",
+-		.gpio		= AP81_GPIO_LED_POWER,
+-		.active_low	= 1,
+-	}
+-};
+-
+-static struct gpio_keys_button ap81_gpio_keys[] __initdata = {
+-	{
+-		.desc		= "sw1",
+-		.type		= EV_KEY,
+-		.code		= BTN_0,
+-		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP81_GPIO_BTN_SW1,
+-		.active_low	= 1,
+-	} , {
+-		.desc		= "sw4",
+-		.type		= EV_KEY,
+-		.code		= BTN_1,
+-		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= AP81_GPIO_BTN_SW4,
+-		.active_low	= 1,
+-	}
+-};
+-
+-static struct spi_board_info ap81_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "m25p64",
+-	}
+-};
+-
+-static struct ath79_spi_platform_data ap81_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect = 1,
+-};
+-
+-static void __init ap81_setup(void)
+-{
+-	u8 *cal_data = (u8 *) KSEG1ADDR(AP81_CAL_DATA_ADDR);
+-
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap81_leds_gpio),
+-				 ap81_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, AP81_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(ap81_gpio_keys),
+-					ap81_gpio_keys);
+-	ath79_register_spi(&ap81_spi_data, ap81_spi_info,
+-			   ARRAY_SIZE(ap81_spi_info));
+-	ath79_register_wmac(cal_data);
+-	ath79_register_usb();
+-}
+-
+-MIPS_MACHINE(ATH79_MACH_AP81, "AP81", "Atheros AP81 reference board",
+-	     ap81_setup);
+--- a/arch/mips/ath79/mach-db120.c
++++ /dev/null
+@@ -1,136 +0,0 @@
+-/*
+- * Atheros DB120 reference board support
+- *
+- * Copyright (c) 2011 Qualcomm Atheros
+- * Copyright (c) 2011 Gabor Juhos <juhosg@openwrt.org>
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+- *
+- */
+-
+-#include <linux/pci.h>
+-#include <linux/ath9k_platform.h>
+-
+-#include "machtypes.h"
+-#include "dev-gpio-buttons.h"
+-#include "dev-leds-gpio.h"
+-#include "dev-spi.h"
+-#include "dev-usb.h"
+-#include "dev-wmac.h"
+-#include "pci.h"
+-
+-#define DB120_GPIO_LED_WLAN_5G		12
+-#define DB120_GPIO_LED_WLAN_2G		13
+-#define DB120_GPIO_LED_STATUS		14
+-#define DB120_GPIO_LED_WPS		15
+-
+-#define DB120_GPIO_BTN_WPS		16
+-
+-#define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
+-#define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
+-
+-#define DB120_WMAC_CALDATA_OFFSET 0x1000
+-#define DB120_PCIE_CALDATA_OFFSET 0x5000
+-
+-static struct gpio_led db120_leds_gpio[] __initdata = {
+-	{
+-		.name		= "db120:green:status",
+-		.gpio		= DB120_GPIO_LED_STATUS,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "db120:green:wps",
+-		.gpio		= DB120_GPIO_LED_WPS,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "db120:green:wlan-5g",
+-		.gpio		= DB120_GPIO_LED_WLAN_5G,
+-		.active_low	= 1,
+-	},
+-	{
+-		.name		= "db120:green:wlan-2g",
+-		.gpio		= DB120_GPIO_LED_WLAN_2G,
+-		.active_low	= 1,
+-	},
+-};
+-
+-static struct gpio_keys_button db120_gpio_keys[] __initdata = {
+-	{
+-		.desc		= "WPS button",
+-		.type		= EV_KEY,
+-		.code		= KEY_WPS_BUTTON,
+-		.debounce_interval = DB120_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= DB120_GPIO_BTN_WPS,
+-		.active_low	= 1,
+-	},
+-};
+-
+-static struct spi_board_info db120_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "s25sl064a",
+-	}
+-};
+-
+-static struct ath79_spi_platform_data db120_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect = 1,
+-};
+-
+-#ifdef CONFIG_PCI
+-static struct ath9k_platform_data db120_ath9k_data;
+-
+-static int db120_pci_plat_dev_init(struct pci_dev *dev)
+-{
+-	switch (PCI_SLOT(dev->devfn)) {
+-	case 0:
+-		dev->dev.platform_data = &db120_ath9k_data;
+-		break;
+-	}
+-
+-	return 0;
+-}
+-
+-static void __init db120_pci_init(u8 *eeprom)
+-{
+-	memcpy(db120_ath9k_data.eeprom_data, eeprom,
+-	       sizeof(db120_ath9k_data.eeprom_data));
+-
+-	ath79_pci_set_plat_dev_init(db120_pci_plat_dev_init);
+-	ath79_register_pci();
+-}
+-#else
+-static inline void db120_pci_init(u8 *eeprom) {}
+-#endif /* CONFIG_PCI */
+-
+-static void __init db120_setup(void)
+-{
+-	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+-
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
+-				 db120_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(db120_gpio_keys),
+-					db120_gpio_keys);
+-	ath79_register_spi(&db120_spi_data, db120_spi_info,
+-			   ARRAY_SIZE(db120_spi_info));
+-	ath79_register_usb();
+-	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET);
+-	db120_pci_init(art + DB120_PCIE_CALDATA_OFFSET);
+-}
+-
+-MIPS_MACHINE(ATH79_MACH_DB120, "DB120", "Atheros DB120 reference board",
+-	     db120_setup);
+--- a/arch/mips/ath79/mach-pb44.c
++++ /dev/null
+@@ -1,122 +0,0 @@
+-/*
+- *  Atheros PB44 reference board support
+- *
+- *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/init.h>
+-#include <linux/platform_device.h>
+-#include <linux/i2c.h>
+-#include <linux/i2c-gpio.h>
+-#include <linux/platform_data/pcf857x.h>
+-
+-#include "machtypes.h"
+-#include "dev-gpio-buttons.h"
+-#include "dev-leds-gpio.h"
+-#include "dev-spi.h"
+-#include "dev-usb.h"
+-#include "pci.h"
+-
+-#define PB44_GPIO_I2C_SCL	0
+-#define PB44_GPIO_I2C_SDA	1
+-
+-#define PB44_GPIO_EXP_BASE	16
+-#define PB44_GPIO_SW_RESET	(PB44_GPIO_EXP_BASE + 6)
+-#define PB44_GPIO_SW_JUMP	(PB44_GPIO_EXP_BASE + 8)
+-#define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + 9)
+-#define PB44_GPIO_LED_JUMP2	(PB44_GPIO_EXP_BASE + 10)
+-
+-#define PB44_KEYS_POLL_INTERVAL		20	/* msecs */
+-#define PB44_KEYS_DEBOUNCE_INTERVAL	(3 * PB44_KEYS_POLL_INTERVAL)
+-
+-static struct i2c_gpio_platform_data pb44_i2c_gpio_data = {
+-	.sda_pin	= PB44_GPIO_I2C_SDA,
+-	.scl_pin	= PB44_GPIO_I2C_SCL,
+-};
+-
+-static struct platform_device pb44_i2c_gpio_device = {
+-	.name		= "i2c-gpio",
+-	.id		= 0,
+-	.dev = {
+-		.platform_data	= &pb44_i2c_gpio_data,
+-	}
+-};
+-
+-static struct pcf857x_platform_data pb44_pcf857x_data = {
+-	.gpio_base	= PB44_GPIO_EXP_BASE,
+-};
+-
+-static struct i2c_board_info pb44_i2c_board_info[] __initdata = {
+-	{
+-		I2C_BOARD_INFO("pcf8575", 0x20),
+-		.platform_data	= &pb44_pcf857x_data,
+-	},
+-};
+-
+-static struct gpio_led pb44_leds_gpio[] __initdata = {
+-	{
+-		.name		= "pb44:amber:jump1",
+-		.gpio		= PB44_GPIO_LED_JUMP1,
+-		.active_low	= 1,
+-	}, {
+-		.name		= "pb44:green:jump2",
+-		.gpio		= PB44_GPIO_LED_JUMP2,
+-		.active_low	= 1,
+-	},
+-};
+-
+-static struct gpio_keys_button pb44_gpio_keys[] __initdata = {
+-	{
+-		.desc		= "soft_reset",
+-		.type		= EV_KEY,
+-		.code		= KEY_RESTART,
+-		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= PB44_GPIO_SW_RESET,
+-		.active_low	= 1,
+-	} , {
+-		.desc		= "jumpstart",
+-		.type		= EV_KEY,
+-		.code		= KEY_WPS_BUTTON,
+-		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
+-		.gpio		= PB44_GPIO_SW_JUMP,
+-		.active_low	= 1,
+-	}
+-};
+-
+-static struct spi_board_info pb44_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "m25p64",
+-	},
+-};
+-
+-static struct ath79_spi_platform_data pb44_spi_data = {
+-	.bus_num		= 0,
+-	.num_chipselect		= 1,
+-};
+-
+-static void __init pb44_init(void)
+-{
+-	i2c_register_board_info(0, pb44_i2c_board_info,
+-				ARRAY_SIZE(pb44_i2c_board_info));
+-	platform_device_register(&pb44_i2c_gpio_device);
+-
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(pb44_leds_gpio),
+-				 pb44_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, PB44_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(pb44_gpio_keys),
+-					pb44_gpio_keys);
+-	ath79_register_spi(&pb44_spi_data, pb44_spi_info,
+-			   ARRAY_SIZE(pb44_spi_info));
+-	ath79_register_usb();
+-	ath79_register_pci();
+-}
+-
+-MIPS_MACHINE(ATH79_MACH_PB44, "PB44", "Atheros PB44 reference board",
+-	     pb44_init);
diff --git a/target/linux/ath79/patches-4.14/0024-GPIO-add-named-gpio-exports.patch b/target/linux/ath79/patches-4.14/0024-GPIO-add-named-gpio-exports.patch
new file mode 100644
index 0000000000..0c1bc73926
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0024-GPIO-add-named-gpio-exports.patch
@@ -0,0 +1,166 @@
+From 4267880319bc1a2270d352e0ded6d6386242a7ef Mon Sep 17 00:00:00 2001
+From: John Crispin <blogic@openwrt.org>
+Date: Tue, 12 Aug 2014 20:49:27 +0200
+Subject: [PATCH 24/53] GPIO: add named gpio exports
+
+Signed-off-by: John Crispin <blogic@openwrt.org>
+---
+ drivers/gpio/gpiolib-of.c     |   68 +++++++++++++++++++++++++++++++++++++++++
+ drivers/gpio/gpiolib-sysfs.c  |   10 +++++-
+ include/asm-generic/gpio.h    |    6 ++++
+ include/linux/gpio/consumer.h |    8 +++++
+ 4 files changed, 91 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpio/gpiolib-of.c
++++ b/drivers/gpio/gpiolib-of.c
+@@ -23,6 +23,8 @@
+ #include <linux/pinctrl/pinctrl.h>
+ #include <linux/slab.h>
+ #include <linux/gpio/machine.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
+ 
+ #include "gpiolib.h"
+ 
+@@ -506,3 +508,69 @@ void of_gpiochip_remove(struct gpio_chip
+ 	gpiochip_remove_pin_ranges(chip);
+ 	of_node_put(chip->of_node);
+ }
++
++static struct of_device_id gpio_export_ids[] = {
++	{ .compatible = "gpio-export" },
++	{ /* sentinel */ }
++};
++
++static int __init of_gpio_export_probe(struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node;
++	struct device_node *cnp;
++	u32 val;
++	int nb = 0;
++
++	for_each_child_of_node(np, cnp) {
++		const char *name = NULL;
++		int gpio;
++		bool dmc;
++		int max_gpio = 1;
++		int i;
++
++		of_property_read_string(cnp, "gpio-export,name", &name);
++
++		if (!name)
++			max_gpio = of_gpio_count(cnp);
++
++		for (i = 0; i < max_gpio; i++) {
++			unsigned flags = 0;
++			enum of_gpio_flags of_flags;
++
++			gpio = of_get_gpio_flags(cnp, i, &of_flags);
++
++			if (of_flags == OF_GPIO_ACTIVE_LOW)
++				flags |= GPIOF_ACTIVE_LOW;
++
++			if (!of_property_read_u32(cnp, "gpio-export,output", &val))
++				flags |= val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
++			else
++				flags |= GPIOF_IN;
++
++			if (devm_gpio_request_one(&pdev->dev, gpio, flags, name ? name : of_node_full_name(np)))
++				continue;
++
++			dmc = of_property_read_bool(cnp, "gpio-export,direction_may_change");
++			gpio_export_with_name(gpio, dmc, name);
++			nb++;
++		}
++	}
++
++	dev_info(&pdev->dev, "%d gpio(s) exported\n", nb);
++
++	return 0;
++}
++
++static struct platform_driver gpio_export_driver = {
++	.driver		= {
++		.name		= "gpio-export",
++		.owner	= THIS_MODULE,
++		.of_match_table	= of_match_ptr(gpio_export_ids),
++	},
++};
++
++static int __init of_gpio_export_init(void)
++{
++	return platform_driver_probe(&gpio_export_driver, of_gpio_export_probe);
++}
++device_initcall(of_gpio_export_init);
+--- a/drivers/gpio/gpiolib-sysfs.c
++++ b/drivers/gpio/gpiolib-sysfs.c
+@@ -553,7 +553,7 @@ static struct class gpio_class = {
+  *
+  * Returns zero on success, else an error.
+  */
+-int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
++int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name)
+ {
+ 	struct gpio_chip	*chip;
+ 	struct gpio_device	*gdev;
+@@ -615,6 +615,8 @@ int gpiod_export(struct gpio_desc *desc,
+ 	offset = gpio_chip_hwgpio(desc);
+ 	if (chip->names && chip->names[offset])
+ 		ioname = chip->names[offset];
++	if (name)
++		ioname = name;
+ 
+ 	dev = device_create_with_groups(&gpio_class, &gdev->dev,
+ 					MKDEV(0, 0), data, gpio_groups,
+@@ -636,6 +638,12 @@ err_unlock:
+ 	gpiod_dbg(desc, "%s: status %d\n", __func__, status);
+ 	return status;
+ }
++EXPORT_SYMBOL_GPL(__gpiod_export);
++
++int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
++{
++	return __gpiod_export(desc, direction_may_change, NULL);
++}
+ EXPORT_SYMBOL_GPL(gpiod_export);
+ 
+ static int match_export(struct device *dev, const void *desc)
+--- a/include/asm-generic/gpio.h
++++ b/include/asm-generic/gpio.h
+@@ -127,6 +127,12 @@ static inline int gpio_export(unsigned g
+ 	return gpiod_export(gpio_to_desc(gpio), direction_may_change);
+ }
+ 
++int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
++static inline int gpio_export_with_name(unsigned gpio, bool direction_may_change, const char *name)
++{
++	return __gpiod_export(gpio_to_desc(gpio), direction_may_change, name);
++}
++
+ static inline int gpio_export_link(struct device *dev, const char *name,
+ 				   unsigned gpio)
+ {
+--- a/include/linux/gpio/consumer.h
++++ b/include/linux/gpio/consumer.h
+@@ -451,6 +451,7 @@ struct gpio_desc *devm_fwnode_get_gpiod_
+ 
+ #if IS_ENABLED(CONFIG_GPIOLIB) && IS_ENABLED(CONFIG_GPIO_SYSFS)
+ 
++int _gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
+ int gpiod_export(struct gpio_desc *desc, bool direction_may_change);
+ int gpiod_export_link(struct device *dev, const char *name,
+ 		      struct gpio_desc *desc);
+@@ -458,6 +459,13 @@ void gpiod_unexport(struct gpio_desc *de
+ 
+ #else  /* CONFIG_GPIOLIB && CONFIG_GPIO_SYSFS */
+ 
++static inline int _gpiod_export(struct gpio_desc *desc,
++			       bool direction_may_change,
++			       const char *name)
++{
++	return -ENOSYS;
++}
++
+ static inline int gpiod_export(struct gpio_desc *desc,
+ 			       bool direction_may_change)
+ {
diff --git a/target/linux/ath79/patches-4.14/0024-MIPS-ath79-drop-pdata-helpers.patch b/target/linux/ath79/patches-4.14/0024-MIPS-ath79-drop-pdata-helpers.patch
new file mode 100644
index 0000000000..8c4956ec34
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0024-MIPS-ath79-drop-pdata-helpers.patch
@@ -0,0 +1,922 @@
+From c038250c16cdefd6d74ad61309ba84973eceb630 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:29:46 +0100
+Subject: [PATCH 24/27] MIPS: ath79: drop pdata helpers
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/ath79/dev-common.c       | 168 -------------------------
+ arch/mips/ath79/dev-common.h       |  18 ---
+ arch/mips/ath79/dev-gpio-buttons.c |  56 ---------
+ arch/mips/ath79/dev-gpio-buttons.h |  23 ----
+ arch/mips/ath79/dev-leds-gpio.c    |  54 ---------
+ arch/mips/ath79/dev-leds-gpio.h    |  21 ----
+ arch/mips/ath79/dev-spi.c          |  38 ------
+ arch/mips/ath79/dev-spi.h          |  22 ----
+ arch/mips/ath79/dev-usb.c          | 242 -------------------------------------
+ arch/mips/ath79/dev-usb.h          |  17 ---
+ arch/mips/ath79/dev-wmac.c         | 155 ------------------------
+ arch/mips/ath79/dev-wmac.h         |  17 ---
+ arch/mips/ath79/setup.c            |   5 -
+ 13 files changed, 836 deletions(-)
+ delete mode 100644 arch/mips/ath79/dev-common.c
+ delete mode 100644 arch/mips/ath79/dev-common.h
+ delete mode 100644 arch/mips/ath79/dev-gpio-buttons.c
+ delete mode 100644 arch/mips/ath79/dev-gpio-buttons.h
+ delete mode 100644 arch/mips/ath79/dev-leds-gpio.c
+ delete mode 100644 arch/mips/ath79/dev-leds-gpio.h
+ delete mode 100644 arch/mips/ath79/dev-spi.c
+ delete mode 100644 arch/mips/ath79/dev-spi.h
+ delete mode 100644 arch/mips/ath79/dev-usb.c
+ delete mode 100644 arch/mips/ath79/dev-usb.h
+ delete mode 100644 arch/mips/ath79/dev-wmac.c
+ delete mode 100644 arch/mips/ath79/dev-wmac.h
+
+--- a/arch/mips/ath79/dev-common.c
++++ /dev/null
+@@ -1,168 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X common devices
+- *
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  Parts of this file are based on Atheros' 2.6.15 BSP
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/kernel.h>
+-#include <linux/init.h>
+-#include <linux/platform_device.h>
+-#include <linux/platform_data/gpio-ath79.h>
+-#include <linux/serial_8250.h>
+-#include <linux/clk.h>
+-#include <linux/err.h>
+-
+-#include <asm/mach-ath79/ath79.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include "common.h"
+-#include "dev-common.h"
+-
+-static struct resource ath79_uart_resources[] = {
+-	{
+-		.start	= AR71XX_UART_BASE,
+-		.end	= AR71XX_UART_BASE + AR71XX_UART_SIZE - 1,
+-		.flags	= IORESOURCE_MEM,
+-	},
+-};
+-
+-#define AR71XX_UART_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP)
+-static struct plat_serial8250_port ath79_uart_data[] = {
+-	{
+-		.mapbase	= AR71XX_UART_BASE,
+-		.irq		= ATH79_MISC_IRQ(3),
+-		.flags		= AR71XX_UART_FLAGS,
+-		.iotype		= UPIO_MEM32,
+-		.regshift	= 2,
+-	}, {
+-		/* terminating entry */
+-	}
+-};
+-
+-static struct platform_device ath79_uart_device = {
+-	.name		= "serial8250",
+-	.id		= PLAT8250_DEV_PLATFORM,
+-	.resource	= ath79_uart_resources,
+-	.num_resources	= ARRAY_SIZE(ath79_uart_resources),
+-	.dev = {
+-		.platform_data	= ath79_uart_data
+-	},
+-};
+-
+-static struct resource ar933x_uart_resources[] = {
+-	{
+-		.start	= AR933X_UART_BASE,
+-		.end	= AR933X_UART_BASE + AR71XX_UART_SIZE - 1,
+-		.flags	= IORESOURCE_MEM,
+-	},
+-	{
+-		.start	= ATH79_MISC_IRQ(3),
+-		.end	= ATH79_MISC_IRQ(3),
+-		.flags	= IORESOURCE_IRQ,
+-	},
+-};
+-
+-static struct platform_device ar933x_uart_device = {
+-	.name		= "ar933x-uart",
+-	.id		= -1,
+-	.resource	= ar933x_uart_resources,
+-	.num_resources	= ARRAY_SIZE(ar933x_uart_resources),
+-};
+-
+-void __init ath79_register_uart(void)
+-{
+-	unsigned long uart_clk_rate;
+-
+-	uart_clk_rate = ath79_get_sys_clk_rate("uart");
+-
+-	if (soc_is_ar71xx() ||
+-	    soc_is_ar724x() ||
+-	    soc_is_ar913x() ||
+-	    soc_is_ar934x() ||
+-	    soc_is_qca953x() ||
+-	    soc_is_qca955x() ||
+-	    soc_is_qca956x() ||
+-	    soc_is_tp9343()) {
+-		ath79_uart_data[0].uartclk = uart_clk_rate;
+-		platform_device_register(&ath79_uart_device);
+-	} else if (soc_is_ar933x()) {
+-		platform_device_register(&ar933x_uart_device);
+-	} else {
+-		BUG();
+-	}
+-}
+-
+-void __init ath79_register_wdt(void)
+-{
+-	struct resource res;
+-
+-	memset(&res, 0, sizeof(res));
+-
+-	res.flags = IORESOURCE_MEM;
+-	res.start = AR71XX_RESET_BASE + AR71XX_RESET_REG_WDOG_CTRL;
+-	res.end = res.start + 0x8 - 1;
+-
+-	platform_device_register_simple("ath79-wdt", -1, &res, 1);
+-}
+-
+-static struct ath79_gpio_platform_data ath79_gpio_pdata;
+-
+-static struct resource ath79_gpio_resources[] = {
+-	{
+-		.flags = IORESOURCE_MEM,
+-		.start = AR71XX_GPIO_BASE,
+-		.end = AR71XX_GPIO_BASE + AR71XX_GPIO_SIZE - 1,
+-	},
+-	{
+-		.start	= ATH79_MISC_IRQ(2),
+-		.end	= ATH79_MISC_IRQ(2),
+-		.flags	= IORESOURCE_IRQ,
+-	},
+-};
+-
+-static struct platform_device ath79_gpio_device = {
+-	.name		= "ath79-gpio",
+-	.id		= -1,
+-	.resource	= ath79_gpio_resources,
+-	.num_resources	= ARRAY_SIZE(ath79_gpio_resources),
+-	.dev = {
+-		.platform_data	= &ath79_gpio_pdata
+-	},
+-};
+-
+-void __init ath79_gpio_init(void)
+-{
+-	if (soc_is_ar71xx()) {
+-		ath79_gpio_pdata.ngpios = AR71XX_GPIO_COUNT;
+-	} else if (soc_is_ar7240()) {
+-		ath79_gpio_pdata.ngpios = AR7240_GPIO_COUNT;
+-	} else if (soc_is_ar7241() || soc_is_ar7242()) {
+-		ath79_gpio_pdata.ngpios = AR7241_GPIO_COUNT;
+-	} else if (soc_is_ar913x()) {
+-		ath79_gpio_pdata.ngpios = AR913X_GPIO_COUNT;
+-	} else if (soc_is_ar933x()) {
+-		ath79_gpio_pdata.ngpios = AR933X_GPIO_COUNT;
+-	} else if (soc_is_ar934x()) {
+-		ath79_gpio_pdata.ngpios = AR934X_GPIO_COUNT;
+-		ath79_gpio_pdata.oe_inverted = 1;
+-	} else if (soc_is_qca953x()) {
+-		ath79_gpio_pdata.ngpios = QCA953X_GPIO_COUNT;
+-		ath79_gpio_pdata.oe_inverted = 1;
+-	} else if (soc_is_qca955x()) {
+-		ath79_gpio_pdata.ngpios = QCA955X_GPIO_COUNT;
+-		ath79_gpio_pdata.oe_inverted = 1;
+-	} else if (soc_is_qca956x() || soc_is_tp9343()) {
+-		ath79_gpio_pdata.ngpios = QCA956X_GPIO_COUNT;
+-		ath79_gpio_pdata.oe_inverted = 1;
+-	} else {
+-		BUG();
+-	}
+-
+-	platform_device_register(&ath79_gpio_device);
+-}
+--- a/arch/mips/ath79/dev-common.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X common devices
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_COMMON_H
+-#define _ATH79_DEV_COMMON_H
+-
+-void ath79_register_uart(void);
+-void ath79_register_wdt(void);
+-
+-#endif /* _ATH79_DEV_COMMON_H */
+--- a/arch/mips/ath79/dev-gpio-buttons.c
++++ /dev/null
+@@ -1,56 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X GPIO button support
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include "linux/init.h"
+-#include "linux/slab.h"
+-#include <linux/platform_device.h>
+-
+-#include "dev-gpio-buttons.h"
+-
+-void __init ath79_register_gpio_keys_polled(int id,
+-					    unsigned poll_interval,
+-					    unsigned nbuttons,
+-					    struct gpio_keys_button *buttons)
+-{
+-	struct platform_device *pdev;
+-	struct gpio_keys_platform_data pdata;
+-	struct gpio_keys_button *p;
+-	int err;
+-
+-	p = kmemdup(buttons, nbuttons * sizeof(*p), GFP_KERNEL);
+-	if (!p)
+-		return;
+-
+-	pdev = platform_device_alloc("gpio-keys-polled", id);
+-	if (!pdev)
+-		goto err_free_buttons;
+-
+-	memset(&pdata, 0, sizeof(pdata));
+-	pdata.poll_interval = poll_interval;
+-	pdata.nbuttons = nbuttons;
+-	pdata.buttons = p;
+-
+-	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+-	if (err)
+-		goto err_put_pdev;
+-
+-	err = platform_device_add(pdev);
+-	if (err)
+-		goto err_put_pdev;
+-
+-	return;
+-
+-err_put_pdev:
+-	platform_device_put(pdev);
+-
+-err_free_buttons:
+-	kfree(p);
+-}
+--- a/arch/mips/ath79/dev-gpio-buttons.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X GPIO button support
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_GPIO_BUTTONS_H
+-#define _ATH79_DEV_GPIO_BUTTONS_H
+-
+-#include <linux/input.h>
+-#include <linux/gpio_keys.h>
+-
+-void ath79_register_gpio_keys_polled(int id,
+-				     unsigned poll_interval,
+-				     unsigned nbuttons,
+-				     struct gpio_keys_button *buttons);
+-
+-#endif /* _ATH79_DEV_GPIO_BUTTONS_H */
+--- a/arch/mips/ath79/dev-leds-gpio.c
++++ /dev/null
+@@ -1,54 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X common GPIO LEDs support
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/init.h>
+-#include <linux/slab.h>
+-#include <linux/platform_device.h>
+-
+-#include "dev-leds-gpio.h"
+-
+-void __init ath79_register_leds_gpio(int id,
+-				     unsigned num_leds,
+-				     struct gpio_led *leds)
+-{
+-	struct platform_device *pdev;
+-	struct gpio_led_platform_data pdata;
+-	struct gpio_led *p;
+-	int err;
+-
+-	p = kmemdup(leds, num_leds * sizeof(*p), GFP_KERNEL);
+-	if (!p)
+-		return;
+-
+-	pdev = platform_device_alloc("leds-gpio", id);
+-	if (!pdev)
+-		goto err_free_leds;
+-
+-	memset(&pdata, 0, sizeof(pdata));
+-	pdata.num_leds = num_leds;
+-	pdata.leds = p;
+-
+-	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+-	if (err)
+-		goto err_put_pdev;
+-
+-	err = platform_device_add(pdev);
+-	if (err)
+-		goto err_put_pdev;
+-
+-	return;
+-
+-err_put_pdev:
+-	platform_device_put(pdev);
+-
+-err_free_leds:
+-	kfree(p);
+-}
+--- a/arch/mips/ath79/dev-leds-gpio.h
++++ /dev/null
+@@ -1,21 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X common GPIO LEDs support
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_LEDS_GPIO_H
+-#define _ATH79_DEV_LEDS_GPIO_H
+-
+-#include <linux/leds.h>
+-
+-void ath79_register_leds_gpio(int id,
+-			      unsigned num_leds,
+-			      struct gpio_led *leds);
+-
+-#endif /* _ATH79_DEV_LEDS_GPIO_H */
+--- a/arch/mips/ath79/dev-spi.c
++++ /dev/null
+@@ -1,38 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X SPI controller device
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/platform_device.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include "dev-spi.h"
+-
+-static struct resource ath79_spi_resources[] = {
+-	{
+-		.start	= AR71XX_SPI_BASE,
+-		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+-		.flags	= IORESOURCE_MEM,
+-	},
+-};
+-
+-static struct platform_device ath79_spi_device = {
+-	.name		= "ath79-spi",
+-	.id		= -1,
+-	.resource	= ath79_spi_resources,
+-	.num_resources	= ARRAY_SIZE(ath79_spi_resources),
+-};
+-
+-void __init ath79_register_spi(struct ath79_spi_platform_data *pdata,
+-			       struct spi_board_info const *info,
+-			       unsigned n)
+-{
+-	spi_register_board_info(info, n);
+-	ath79_spi_device.dev.platform_data = pdata;
+-	platform_device_register(&ath79_spi_device);
+-}
+--- a/arch/mips/ath79/dev-spi.h
++++ /dev/null
+@@ -1,22 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X SPI controller device
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_SPI_H
+-#define _ATH79_DEV_SPI_H
+-
+-#include <linux/spi/spi.h>
+-#include <asm/mach-ath79/ath79_spi_platform.h>
+-
+-void ath79_register_spi(struct ath79_spi_platform_data *pdata,
+-			 struct spi_board_info const *info,
+-			 unsigned n);
+-
+-#endif /* _ATH79_DEV_SPI_H */
+--- a/arch/mips/ath79/dev-usb.c
++++ /dev/null
+@@ -1,242 +0,0 @@
+-/*
+- *  Atheros AR7XXX/AR9XXX USB Host Controller device
+- *
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  Parts of this file are based on Atheros' 2.6.15 BSP
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/kernel.h>
+-#include <linux/init.h>
+-#include <linux/delay.h>
+-#include <linux/irq.h>
+-#include <linux/dma-mapping.h>
+-#include <linux/platform_device.h>
+-#include <linux/usb/ehci_pdriver.h>
+-#include <linux/usb/ohci_pdriver.h>
+-
+-#include <asm/mach-ath79/ath79.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include "common.h"
+-#include "dev-usb.h"
+-
+-static u64 ath79_usb_dmamask = DMA_BIT_MASK(32);
+-
+-static struct usb_ohci_pdata ath79_ohci_pdata = {
+-};
+-
+-static struct usb_ehci_pdata ath79_ehci_pdata_v1 = {
+-	.has_synopsys_hc_bug	= 1,
+-};
+-
+-static struct usb_ehci_pdata ath79_ehci_pdata_v2 = {
+-	.caps_offset		= 0x100,
+-	.has_tt			= 1,
+-};
+-
+-static void __init ath79_usb_register(const char *name, int id,
+-				      unsigned long base, unsigned long size,
+-				      int irq, const void *data,
+-				      size_t data_size)
+-{
+-	struct resource res[2];
+-	struct platform_device *pdev;
+-
+-	memset(res, 0, sizeof(res));
+-
+-	res[0].flags = IORESOURCE_MEM;
+-	res[0].start = base;
+-	res[0].end = base + size - 1;
+-
+-	res[1].flags = IORESOURCE_IRQ;
+-	res[1].start = irq;
+-	res[1].end = irq;
+-
+-	pdev = platform_device_register_resndata(NULL, name, id,
+-						 res, ARRAY_SIZE(res),
+-						 data, data_size);
+-
+-	if (IS_ERR(pdev)) {
+-		pr_err("ath79: unable to register USB at %08lx, err=%d\n",
+-		       base, (int) PTR_ERR(pdev));
+-		return;
+-	}
+-
+-	pdev->dev.dma_mask = &ath79_usb_dmamask;
+-	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+-}
+-
+-#define AR71XX_USB_RESET_MASK	(AR71XX_RESET_USB_HOST | \
+-				 AR71XX_RESET_USB_PHY | \
+-				 AR71XX_RESET_USB_OHCI_DLL)
+-
+-static void __init ath79_usb_setup(void)
+-{
+-	void __iomem *usb_ctrl_base;
+-
+-	ath79_device_reset_set(AR71XX_USB_RESET_MASK);
+-	mdelay(1000);
+-	ath79_device_reset_clear(AR71XX_USB_RESET_MASK);
+-
+-	usb_ctrl_base = ioremap(AR71XX_USB_CTRL_BASE, AR71XX_USB_CTRL_SIZE);
+-
+-	/* Turning on the Buff and Desc swap bits */
+-	__raw_writel(0xf0000, usb_ctrl_base + AR71XX_USB_CTRL_REG_CONFIG);
+-
+-	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+-	__raw_writel(0x20c00, usb_ctrl_base + AR71XX_USB_CTRL_REG_FLADJ);
+-
+-	iounmap(usb_ctrl_base);
+-
+-	mdelay(900);
+-
+-	ath79_usb_register("ohci-platform", -1,
+-			   AR71XX_OHCI_BASE, AR71XX_OHCI_SIZE,
+-			   ATH79_MISC_IRQ(6),
+-			   &ath79_ohci_pdata, sizeof(ath79_ohci_pdata));
+-
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR71XX_EHCI_BASE, AR71XX_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v1, sizeof(ath79_ehci_pdata_v1));
+-}
+-
+-static void __init ar7240_usb_setup(void)
+-{
+-	void __iomem *usb_ctrl_base;
+-
+-	ath79_device_reset_clear(AR7240_RESET_OHCI_DLL);
+-	ath79_device_reset_set(AR7240_RESET_USB_HOST);
+-
+-	mdelay(1000);
+-
+-	ath79_device_reset_set(AR7240_RESET_OHCI_DLL);
+-	ath79_device_reset_clear(AR7240_RESET_USB_HOST);
+-
+-	usb_ctrl_base = ioremap(AR7240_USB_CTRL_BASE, AR7240_USB_CTRL_SIZE);
+-
+-	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+-	__raw_writel(0x3, usb_ctrl_base + AR71XX_USB_CTRL_REG_FLADJ);
+-
+-	iounmap(usb_ctrl_base);
+-
+-	ath79_usb_register("ohci-platform", -1,
+-			   AR7240_OHCI_BASE, AR7240_OHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ohci_pdata, sizeof(ath79_ohci_pdata));
+-}
+-
+-static void __init ar724x_usb_setup(void)
+-{
+-	ath79_device_reset_set(AR724X_RESET_USBSUS_OVERRIDE);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR724X_RESET_USB_HOST);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR724X_RESET_USB_PHY);
+-	mdelay(10);
+-
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR724X_EHCI_BASE, AR724X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-}
+-
+-static void __init ar913x_usb_setup(void)
+-{
+-	ath79_device_reset_set(AR913X_RESET_USBSUS_OVERRIDE);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR913X_RESET_USB_HOST);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR913X_RESET_USB_PHY);
+-	mdelay(10);
+-
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR913X_EHCI_BASE, AR913X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-}
+-
+-static void __init ar933x_usb_setup(void)
+-{
+-	ath79_device_reset_set(AR933X_RESET_USBSUS_OVERRIDE);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR933X_RESET_USB_HOST);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR933X_RESET_USB_PHY);
+-	mdelay(10);
+-
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR933X_EHCI_BASE, AR933X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-}
+-
+-static void __init ar934x_usb_setup(void)
+-{
+-	u32 bootstrap;
+-
+-	bootstrap = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+-	if (bootstrap & AR934X_BOOTSTRAP_USB_MODE_DEVICE)
+-		return;
+-
+-	ath79_device_reset_set(AR934X_RESET_USBSUS_OVERRIDE);
+-	udelay(1000);
+-
+-	ath79_device_reset_clear(AR934X_RESET_USB_PHY);
+-	udelay(1000);
+-
+-	ath79_device_reset_clear(AR934X_RESET_USB_PHY_ANALOG);
+-	udelay(1000);
+-
+-	ath79_device_reset_clear(AR934X_RESET_USB_HOST);
+-	udelay(1000);
+-
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-}
+-
+-static void __init qca955x_usb_setup(void)
+-{
+-	ath79_usb_register("ehci-platform", 0,
+-			   QCA955X_EHCI0_BASE, QCA955X_EHCI_SIZE,
+-			   ATH79_IP3_IRQ(0),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-
+-	ath79_usb_register("ehci-platform", 1,
+-			   QCA955X_EHCI1_BASE, QCA955X_EHCI_SIZE,
+-			   ATH79_IP3_IRQ(1),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+-}
+-
+-void __init ath79_register_usb(void)
+-{
+-	if (soc_is_ar71xx())
+-		ath79_usb_setup();
+-	else if (soc_is_ar7240())
+-		ar7240_usb_setup();
+-	else if (soc_is_ar7241() || soc_is_ar7242())
+-		ar724x_usb_setup();
+-	else if (soc_is_ar913x())
+-		ar913x_usb_setup();
+-	else if (soc_is_ar933x())
+-		ar933x_usb_setup();
+-	else if (soc_is_ar934x())
+-		ar934x_usb_setup();
+-	else if (soc_is_qca955x())
+-		qca955x_usb_setup();
+-	else
+-		BUG();
+-}
+--- a/arch/mips/ath79/dev-usb.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X USB Host Controller support
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_USB_H
+-#define _ATH79_DEV_USB_H
+-
+-void ath79_register_usb(void);
+-
+-#endif /* _ATH79_DEV_USB_H */
+--- a/arch/mips/ath79/dev-wmac.c
++++ /dev/null
+@@ -1,155 +0,0 @@
+-/*
+- *  Atheros AR913X/AR933X SoC built-in WMAC device support
+- *
+- *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  Parts of this file are based on Atheros 2.6.15/2.6.31 BSP
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/init.h>
+-#include <linux/delay.h>
+-#include <linux/irq.h>
+-#include <linux/platform_device.h>
+-#include <linux/ath9k_platform.h>
+-
+-#include <asm/mach-ath79/ath79.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include "dev-wmac.h"
+-
+-static struct ath9k_platform_data ath79_wmac_data;
+-
+-static struct resource ath79_wmac_resources[] = {
+-	{
+-		/* .start and .end fields are filled dynamically */
+-		.flags	= IORESOURCE_MEM,
+-	}, {
+-		/* .start and .end fields are filled dynamically */
+-		.flags	= IORESOURCE_IRQ,
+-	},
+-};
+-
+-static struct platform_device ath79_wmac_device = {
+-	.name		= "ath9k",
+-	.id		= -1,
+-	.resource	= ath79_wmac_resources,
+-	.num_resources	= ARRAY_SIZE(ath79_wmac_resources),
+-	.dev = {
+-		.platform_data = &ath79_wmac_data,
+-	},
+-};
+-
+-static void __init ar913x_wmac_setup(void)
+-{
+-	/* reset the WMAC */
+-	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
+-	mdelay(10);
+-
+-	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
+-	mdelay(10);
+-
+-	ath79_wmac_resources[0].start = AR913X_WMAC_BASE;
+-	ath79_wmac_resources[0].end = AR913X_WMAC_BASE + AR913X_WMAC_SIZE - 1;
+-	ath79_wmac_resources[1].start = ATH79_CPU_IRQ(2);
+-	ath79_wmac_resources[1].end = ATH79_CPU_IRQ(2);
+-}
+-
+-
+-static int ar933x_wmac_reset(void)
+-{
+-	ath79_device_reset_set(AR933X_RESET_WMAC);
+-	ath79_device_reset_clear(AR933X_RESET_WMAC);
+-
+-	return 0;
+-}
+-
+-static int ar933x_r1_get_wmac_revision(void)
+-{
+-	return ath79_soc_rev;
+-}
+-
+-static void __init ar933x_wmac_setup(void)
+-{
+-	u32 t;
+-
+-	ar933x_wmac_reset();
+-
+-	ath79_wmac_device.name = "ar933x_wmac";
+-
+-	ath79_wmac_resources[0].start = AR933X_WMAC_BASE;
+-	ath79_wmac_resources[0].end = AR933X_WMAC_BASE + AR933X_WMAC_SIZE - 1;
+-	ath79_wmac_resources[1].start = ATH79_CPU_IRQ(2);
+-	ath79_wmac_resources[1].end = ATH79_CPU_IRQ(2);
+-
+-	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+-	if (t & AR933X_BOOTSTRAP_REF_CLK_40)
+-		ath79_wmac_data.is_clk_25mhz = false;
+-	else
+-		ath79_wmac_data.is_clk_25mhz = true;
+-
+-	if (ath79_soc_rev == 1)
+-		ath79_wmac_data.get_mac_revision = ar933x_r1_get_wmac_revision;
+-
+-	ath79_wmac_data.external_reset = ar933x_wmac_reset;
+-}
+-
+-static void ar934x_wmac_setup(void)
+-{
+-	u32 t;
+-
+-	ath79_wmac_device.name = "ar934x_wmac";
+-
+-	ath79_wmac_resources[0].start = AR934X_WMAC_BASE;
+-	ath79_wmac_resources[0].end = AR934X_WMAC_BASE + AR934X_WMAC_SIZE - 1;
+-	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
+-	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
+-
+-	t = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+-	if (t & AR934X_BOOTSTRAP_REF_CLK_40)
+-		ath79_wmac_data.is_clk_25mhz = false;
+-	else
+-		ath79_wmac_data.is_clk_25mhz = true;
+-}
+-
+-static void qca955x_wmac_setup(void)
+-{
+-	u32 t;
+-
+-	ath79_wmac_device.name = "qca955x_wmac";
+-
+-	ath79_wmac_resources[0].start = QCA955X_WMAC_BASE;
+-	ath79_wmac_resources[0].end = QCA955X_WMAC_BASE + QCA955X_WMAC_SIZE - 1;
+-	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
+-	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
+-
+-	t = ath79_reset_rr(QCA955X_RESET_REG_BOOTSTRAP);
+-	if (t & QCA955X_BOOTSTRAP_REF_CLK_40)
+-		ath79_wmac_data.is_clk_25mhz = false;
+-	else
+-		ath79_wmac_data.is_clk_25mhz = true;
+-}
+-
+-void __init ath79_register_wmac(u8 *cal_data)
+-{
+-	if (soc_is_ar913x())
+-		ar913x_wmac_setup();
+-	else if (soc_is_ar933x())
+-		ar933x_wmac_setup();
+-	else if (soc_is_ar934x())
+-		ar934x_wmac_setup();
+-	else if (soc_is_qca955x())
+-		qca955x_wmac_setup();
+-	else
+-		BUG();
+-
+-	if (cal_data)
+-		memcpy(ath79_wmac_data.eeprom_data, cal_data,
+-		       sizeof(ath79_wmac_data.eeprom_data));
+-
+-	platform_device_register(&ath79_wmac_device);
+-}
+--- a/arch/mips/ath79/dev-wmac.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-/*
+- *  Atheros AR913X/AR933X SoC built-in WMAC device support
+- *
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_DEV_WMAC_H
+-#define _ATH79_DEV_WMAC_H
+-
+-void ath79_register_wmac(u8 *cal_data);
+-
+-#endif /* _ATH79_DEV_WMAC_H */
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -31,7 +31,6 @@
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ #include "common.h"
+-#include "dev-common.h"
+ #include "machtypes.h"
+ 
+ #define ATH79_SYS_TYPE_LEN	64
+@@ -316,10 +315,6 @@ static int __init ath79_setup(void)
+ 	if  (mips_machtype == ATH79_MACH_GENERIC_OF)
+ 		return 0;
+ 
+-	ath79_gpio_init();
+-	ath79_register_uart();
+-	ath79_register_wdt();
+-
+ 	mips_machine_setup();
+ 
+ 	return 0;
diff --git a/target/linux/ath79/patches-4.14/0025-MIPS-ath79-drop-irq.c.patch b/target/linux/ath79/patches-4.14/0025-MIPS-ath79-drop-irq.c.patch
new file mode 100644
index 0000000000..95b29455f0
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0025-MIPS-ath79-drop-irq.c.patch
@@ -0,0 +1,336 @@
+From 08b9cad7da5d981d595fe6d76e9675f85e23e688 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:57:15 +0100
+Subject: [PATCH 25/27] MIPS: ath79: drop irq.c
+
+all IRQ init code will flow via OF based irq chips.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/ath79/Makefile |   2 +-
+ arch/mips/ath79/irq.c    | 285 -----------------------------------------------
+ arch/mips/ath79/setup.c  |   6 +
+ 3 files changed, 7 insertions(+), 286 deletions(-)
+ delete mode 100644 arch/mips/ath79/irq.c
+
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -8,7 +8,7 @@
+ # under the terms of the GNU General Public License version 2 as published
+ # by the Free Software Foundation.
+ 
+-obj-y	:= prom.o setup.o irq.o common.o clock.o
++obj-y	:= prom.o setup.o common.o clock.o
+ 
+ obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+ 
+--- a/arch/mips/ath79/irq.c
++++ /dev/null
+@@ -1,285 +0,0 @@
+-/*
+- *  Atheros AR71xx/AR724x/AR913x specific interrupt handling
+- *
+- *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+- *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  Parts of this file are based on Atheros' 2.6.15/2.6.31 BSP
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#include <linux/kernel.h>
+-#include <linux/init.h>
+-#include <linux/interrupt.h>
+-#include <linux/irqchip.h>
+-#include <linux/of_irq.h>
+-
+-#include <asm/irq_cpu.h>
+-#include <asm/mipsregs.h>
+-
+-#include <asm/mach-ath79/ath79.h>
+-#include <asm/mach-ath79/ar71xx_regs.h>
+-#include "common.h"
+-#include "machtypes.h"
+-
+-
+-static void ar934x_ip2_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(AR934X_RESET_REG_PCIE_WMAC_INT_STATUS);
+-
+-	if (status & AR934X_PCIE_WMAC_INT_PCIE_ALL) {
+-		ath79_ddr_wb_flush(3);
+-		generic_handle_irq(ATH79_IP2_IRQ(0));
+-	} else if (status & AR934X_PCIE_WMAC_INT_WMAC_ALL) {
+-		ath79_ddr_wb_flush(4);
+-		generic_handle_irq(ATH79_IP2_IRQ(1));
+-	} else {
+-		spurious_interrupt();
+-	}
+-}
+-
+-static void ar934x_ip2_irq_init(void)
+-{
+-	int i;
+-
+-	for (i = ATH79_IP2_IRQ_BASE;
+-	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(2), ar934x_ip2_irq_dispatch);
+-}
+-
+-static void qca953x_ip2_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS);
+-
+-	if (status & QCA953X_PCIE_WMAC_INT_PCIE_ALL) {
+-		ath79_ddr_wb_flush(3);
+-		generic_handle_irq(ATH79_IP2_IRQ(0));
+-	} else if (status & QCA953X_PCIE_WMAC_INT_WMAC_ALL) {
+-		ath79_ddr_wb_flush(4);
+-		generic_handle_irq(ATH79_IP2_IRQ(1));
+-	} else {
+-		spurious_interrupt();
+-	}
+-}
+-
+-static void qca953x_irq_init(void)
+-{
+-	int i;
+-
+-	for (i = ATH79_IP2_IRQ_BASE;
+-	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca953x_ip2_irq_dispatch);
+-}
+-
+-static void qca955x_ip2_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(QCA955X_RESET_REG_EXT_INT_STATUS);
+-	status &= QCA955X_EXT_INT_PCIE_RC1_ALL | QCA955X_EXT_INT_WMAC_ALL;
+-
+-	if (status == 0) {
+-		spurious_interrupt();
+-		return;
+-	}
+-
+-	if (status & QCA955X_EXT_INT_PCIE_RC1_ALL) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP2_IRQ(0));
+-	}
+-
+-	if (status & QCA955X_EXT_INT_WMAC_ALL) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP2_IRQ(1));
+-	}
+-}
+-
+-static void qca955x_ip3_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(QCA955X_RESET_REG_EXT_INT_STATUS);
+-	status &= QCA955X_EXT_INT_PCIE_RC2_ALL |
+-		  QCA955X_EXT_INT_USB1 |
+-		  QCA955X_EXT_INT_USB2;
+-
+-	if (status == 0) {
+-		spurious_interrupt();
+-		return;
+-	}
+-
+-	if (status & QCA955X_EXT_INT_USB1) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(0));
+-	}
+-
+-	if (status & QCA955X_EXT_INT_USB2) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(1));
+-	}
+-
+-	if (status & QCA955X_EXT_INT_PCIE_RC2_ALL) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(2));
+-	}
+-}
+-
+-static void qca955x_irq_init(void)
+-{
+-	int i;
+-
+-	for (i = ATH79_IP2_IRQ_BASE;
+-	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca955x_ip2_irq_dispatch);
+-
+-	for (i = ATH79_IP3_IRQ_BASE;
+-	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca955x_ip3_irq_dispatch);
+-}
+-
+-static void qca956x_ip2_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
+-	status &= QCA956X_EXT_INT_PCIE_RC1_ALL | QCA956X_EXT_INT_WMAC_ALL;
+-
+-	if (status == 0) {
+-		spurious_interrupt();
+-		return;
+-	}
+-
+-	if (status & QCA956X_EXT_INT_PCIE_RC1_ALL) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP2_IRQ(0));
+-	}
+-
+-	if (status & QCA956X_EXT_INT_WMAC_ALL) {
+-		/* TODO: flsuh DDR? */
+-		generic_handle_irq(ATH79_IP2_IRQ(1));
+-	}
+-}
+-
+-static void qca956x_ip3_irq_dispatch(struct irq_desc *desc)
+-{
+-	u32 status;
+-
+-	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
+-	status &= QCA956X_EXT_INT_PCIE_RC2_ALL |
+-		  QCA956X_EXT_INT_USB1 | QCA956X_EXT_INT_USB2;
+-
+-	if (status == 0) {
+-		spurious_interrupt();
+-		return;
+-	}
+-
+-	if (status & QCA956X_EXT_INT_USB1) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(0));
+-	}
+-
+-	if (status & QCA956X_EXT_INT_USB2) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(1));
+-	}
+-
+-	if (status & QCA956X_EXT_INT_PCIE_RC2_ALL) {
+-		/* TODO: flush DDR? */
+-		generic_handle_irq(ATH79_IP3_IRQ(2));
+-	}
+-}
+-
+-static void qca956x_enable_timer_cb(void) {
+-	u32 misc;
+-
+-	misc = ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
+-	misc |= MISC_INT_MIPS_SI_TIMERINT_MASK;
+-	ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_ENABLE, misc);
+-}
+-
+-static void qca956x_irq_init(void)
+-{
+-	int i;
+-
+-	for (i = ATH79_IP2_IRQ_BASE;
+-	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca956x_ip2_irq_dispatch);
+-
+-	for (i = ATH79_IP3_IRQ_BASE;
+-	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
+-
+-	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca956x_ip3_irq_dispatch);
+-
+-	/* QCA956x timer init workaround has to be applied right before setting
+-	 * up the clock. Else, there will be no jiffies */
+-	late_time_init = &qca956x_enable_timer_cb;
+-}
+-
+-void __init arch_init_irq(void)
+-{
+-	unsigned irq_wb_chan2 = -1;
+-	unsigned irq_wb_chan3 = -1;
+-	bool misc_is_ar71xx;
+-
+-	if (mips_machtype == ATH79_MACH_GENERIC_OF) {
+-		irqchip_init();
+-		return;
+-	}
+-
+-	if (soc_is_ar71xx() || soc_is_ar724x() ||
+-	    soc_is_ar913x() || soc_is_ar933x()) {
+-		irq_wb_chan2 = 3;
+-		irq_wb_chan3 = 2;
+-	} else if (soc_is_ar934x() || soc_is_qca953x()) {
+-		irq_wb_chan3 = 2;
+-	}
+-
+-	ath79_cpu_irq_init(irq_wb_chan2, irq_wb_chan3);
+-
+-	if (soc_is_ar71xx() || soc_is_ar913x())
+-		misc_is_ar71xx = true;
+-	else if (soc_is_ar724x() ||
+-		 soc_is_ar933x() ||
+-		 soc_is_ar934x() ||
+-		 soc_is_qca953x() ||
+-		 soc_is_qca955x() ||
+-		 soc_is_qca956x() ||
+-		 soc_is_tp9343())
+-		misc_is_ar71xx = false;
+-	else
+-		BUG();
+-	ath79_misc_irq_init(
+-		ath79_reset_base + AR71XX_RESET_REG_MISC_INT_STATUS,
+-		ATH79_CPU_IRQ(6), ATH79_MISC_IRQ_BASE, misc_is_ar71xx);
+-
+-	if (soc_is_ar934x())
+-		ar934x_ip2_irq_init();
+-	else if (soc_is_qca953x())
+-		qca953x_irq_init();
+-	else if (soc_is_qca955x())
+-		qca955x_irq_init();
+-	else if (soc_is_qca956x() || soc_is_tp9343())
+-		qca956x_irq_init();
+-}
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -19,6 +19,7 @@
+ #include <linux/clk.h>
+ #include <linux/clk-provider.h>
+ #include <linux/of_fdt.h>
++#include <linux/irqchip.h>
+ 
+ #include <asm/bootinfo.h>
+ #include <asm/idle.h>
+@@ -310,6 +311,11 @@ void __init plat_time_init(void)
+ 	mips_hpt_frequency = cpu_clk_rate / 2;
+ }
+ 
++void __init arch_init_irq(void)
++{
++	irqchip_init();
++}
++
+ static int __init ath79_setup(void)
+ {
+ 	if  (mips_machtype == ATH79_MACH_GENERIC_OF)
diff --git a/target/linux/ath79/patches-4.14/0026-MIPS-ath79-sanitize-Kconfig-symbols.patch b/target/linux/ath79/patches-4.14/0026-MIPS-ath79-sanitize-Kconfig-symbols.patch
new file mode 100644
index 0000000000..f9906516d9
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0026-MIPS-ath79-sanitize-Kconfig-symbols.patch
@@ -0,0 +1,111 @@
+From deda44895d289a72a235359fc21f8a62ea44dc1c Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 09:33:26 +0100
+Subject: [PATCH 26/27] MIPS: ath79: sanitize Kconfig symbols
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/Kconfig        |  2 ++
+ arch/mips/ath79/Kconfig  | 48 +++++-------------------------------------------
+ arch/mips/ath79/Makefile | 10 ----------
+ arch/mips/pci/Makefile   |  2 +-
+ 4 files changed, 8 insertions(+), 54 deletions(-)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -203,6 +203,8 @@ config ATH79
+ 	select SYS_SUPPORTS_BIG_ENDIAN
+ 	select SYS_SUPPORTS_MIPS16
+ 	select SYS_SUPPORTS_ZBOOT_UART_PROM
++	select HW_HAS_PCI
++	select USB_ARCH_HAS_EHCI
+ 	select USE_OF
+ 	help
+ 	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -1,52 +1,14 @@
+ # SPDX-License-Identifier: GPL-2.0
+ if ATH79
+ 
+-config SOC_AR71XX
+-	select HW_HAS_PCI
+-	def_bool n
+-
+-config SOC_AR724X
+-	select HW_HAS_PCI
+-	select PCI_AR724X if PCI
+-	def_bool n
+-
+-config SOC_AR913X
+-	def_bool n
+-
+-config SOC_AR933X
+-	def_bool n
+-
+-config SOC_AR934X
+-	select HW_HAS_PCI
+-	select PCI_AR724X if PCI
+-	def_bool n
+-
+-config SOC_QCA953X
+-	select USB_ARCH_HAS_EHCI
+-	def_bool n
+-
+-config SOC_QCA955X
+-	select HW_HAS_PCI
+-	select PCI_AR724X if PCI
++config PCI_AR71XX
++	bool "PCI support for AR7100 type SoCs"
++	depends on PCI
+ 	def_bool n
+ 
+ config PCI_AR724X
+-	def_bool n
+-
+-config ATH79_DEV_GPIO_BUTTONS
+-	def_bool n
+-
+-config ATH79_DEV_LEDS_GPIO
+-	def_bool n
+-
+-config ATH79_DEV_SPI
+-	def_bool n
+-
+-config ATH79_DEV_USB
+-	def_bool n
+-
+-config ATH79_DEV_WMAC
+-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X || SOC_QCA956X)
++	bool "PCI support for AR724x type SoCs"
++	depends on PCI
+ 	def_bool n
+ 
+ endif
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -11,13 +11,3 @@
+ obj-y	:= prom.o setup.o common.o clock.o
+ 
+ obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+-
+-#
+-# Devices
+-#
+-obj-y					+= dev-common.o
+-obj-$(CONFIG_ATH79_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
+-obj-$(CONFIG_ATH79_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
+-obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
+-obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
+-obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+--- a/arch/mips/pci/Makefile
++++ b/arch/mips/pci/Makefile
+@@ -23,7 +23,7 @@ obj-$(CONFIG_BCM63XX)		+= pci-bcm63xx.o
+ 					ops-bcm63xx.o
+ obj-$(CONFIG_MIPS_ALCHEMY)	+= pci-alchemy.o
+ obj-$(CONFIG_PCI_AR2315)	+= pci-ar2315.o
+-obj-$(CONFIG_SOC_AR71XX)	+= pci-ar71xx.o
++obj-$(CONFIG_PCI_AR71XX)	+= pci-ar71xx.o
+ obj-$(CONFIG_PCI_AR724X)	+= pci-ar724x.o
+ obj-$(CONFIG_MIPS_PCI_VIRTIO)	+= pci-virtio-guest.o
+ #
diff --git a/target/linux/ath79/patches-4.14/0027-MIPS-ath79-drop-mips_machine-support.patch b/target/linux/ath79/patches-4.14/0027-MIPS-ath79-drop-mips_machine-support.patch
new file mode 100644
index 0000000000..cde3bae674
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0027-MIPS-ath79-drop-mips_machine-support.patch
@@ -0,0 +1,172 @@
+From e03edbc8e68063b3fca7457fa048d8abe0045f1f Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Tue, 6 Mar 2018 10:15:54 +0100
+Subject: [PATCH 27/27] MIPS: ath79: drop mips_machine support
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ arch/mips/Kconfig           |  1 -
+ arch/mips/ath79/machtypes.h | 28 -----------------
+ arch/mips/ath79/setup.c     | 74 ++++++---------------------------------------
+ 3 files changed, 10 insertions(+), 93 deletions(-)
+ delete mode 100644 arch/mips/ath79/machtypes.h
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -196,7 +196,6 @@ config ATH79
+ 	select COMMON_CLK
+ 	select CLKDEV_LOOKUP
+ 	select IRQ_MIPS_CPU
+-	select MIPS_MACHINE
+ 	select SYS_HAS_CPU_MIPS32_R2
+ 	select SYS_HAS_EARLY_PRINTK
+ 	select SYS_SUPPORTS_32BIT_KERNEL
+--- a/arch/mips/ath79/machtypes.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-/*
+- *  Atheros AR71XX/AR724X/AR913X machine type definitions
+- *
+- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+- *
+- *  This program is free software; you can redistribute it and/or modify it
+- *  under the terms of the GNU General Public License version 2 as published
+- *  by the Free Software Foundation.
+- */
+-
+-#ifndef _ATH79_MACHTYPE_H
+-#define _ATH79_MACHTYPE_H
+-
+-#include <asm/mips_machine.h>
+-
+-enum ath79_mach_type {
+-	ATH79_MACH_GENERIC_OF = -1,	/* Device tree board */
+-	ATH79_MACH_GENERIC = 0,
+-	ATH79_MACH_AP121,		/* Atheros AP121 reference board */
+-	ATH79_MACH_AP136_010,		/* Atheros AP136-010 reference board */
+-	ATH79_MACH_AP81,		/* Atheros AP81 reference board */
+-	ATH79_MACH_DB120,		/* Atheros DB120 reference board */
+-	ATH79_MACH_PB44,		/* Atheros PB44 reference board */
+-	ATH79_MACH_UBNT_XM,		/* Ubiquiti Networks XM board rev 1.0 */
+-};
+-
+-#endif /* _ATH79_MACHTYPE_H */
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -32,7 +32,6 @@
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ #include "common.h"
+-#include "machtypes.h"
+ 
+ #define ATH79_SYS_TYPE_LEN	64
+ 
+@@ -235,25 +234,21 @@ void __init plat_mem_setup(void)
+ 	else if (fw_passed_dtb)
+ 		__dt_setup_arch((void *)KSEG0ADDR(fw_passed_dtb));
+ 
+-	if (mips_machtype != ATH79_MACH_GENERIC_OF) {
+-		ath79_reset_base = ioremap_nocache(AR71XX_RESET_BASE,
+-						   AR71XX_RESET_SIZE);
+-		ath79_pll_base = ioremap_nocache(AR71XX_PLL_BASE,
+-						 AR71XX_PLL_SIZE);
+-		ath79_detect_sys_type();
+-		ath79_ddr_ctrl_init();
++	ath79_reset_base = ioremap_nocache(AR71XX_RESET_BASE,
++					   AR71XX_RESET_SIZE);
++	ath79_pll_base = ioremap_nocache(AR71XX_PLL_BASE,
++					 AR71XX_PLL_SIZE);
++	ath79_detect_sys_type();
++	ath79_ddr_ctrl_init();
+ 
+-		detect_memory_region(0, ATH79_MEM_SIZE_MIN, ATH79_MEM_SIZE_MAX);
+-
+-		/* OF machines should use the reset driver */
+-		_machine_restart = ath79_restart;
+-	}
++	detect_memory_region(0, ATH79_MEM_SIZE_MIN, ATH79_MEM_SIZE_MAX);
+ 
++	_machine_restart = ath79_restart;
+ 	_machine_halt = ath79_halt;
+ 	pm_power_off = ath79_halt;
+ }
+ 
+-static void __init ath79_of_plat_time_init(void)
++void __init plat_time_init(void)
+ {
+ 	struct device_node *np;
+ 	struct clk *clk;
+@@ -283,62 +278,12 @@ static void __init ath79_of_plat_time_in
+ 	clk_put(clk);
+ }
+ 
+-void __init plat_time_init(void)
+-{
+-	unsigned long cpu_clk_rate;
+-	unsigned long ahb_clk_rate;
+-	unsigned long ddr_clk_rate;
+-	unsigned long ref_clk_rate;
+-
+-	if (IS_ENABLED(CONFIG_OF) && mips_machtype == ATH79_MACH_GENERIC_OF) {
+-		ath79_of_plat_time_init();
+-		return;
+-	}
+-
+-	ath79_clocks_init();
+-
+-	cpu_clk_rate = ath79_get_sys_clk_rate("cpu");
+-	ahb_clk_rate = ath79_get_sys_clk_rate("ahb");
+-	ddr_clk_rate = ath79_get_sys_clk_rate("ddr");
+-	ref_clk_rate = ath79_get_sys_clk_rate("ref");
+-
+-	pr_info("Clocks: CPU:%lu.%03luMHz, DDR:%lu.%03luMHz, AHB:%lu.%03luMHz, Ref:%lu.%03luMHz\n",
+-		cpu_clk_rate / 1000000, (cpu_clk_rate / 1000) % 1000,
+-		ddr_clk_rate / 1000000, (ddr_clk_rate / 1000) % 1000,
+-		ahb_clk_rate / 1000000, (ahb_clk_rate / 1000) % 1000,
+-		ref_clk_rate / 1000000, (ref_clk_rate / 1000) % 1000);
+-
+-	mips_hpt_frequency = cpu_clk_rate / 2;
+-}
+-
+ void __init arch_init_irq(void)
+ {
+ 	irqchip_init();
+ }
+ 
+-static int __init ath79_setup(void)
+-{
+-	if  (mips_machtype == ATH79_MACH_GENERIC_OF)
+-		return 0;
+-
+-	mips_machine_setup();
+-
+-	return 0;
+-}
+-
+-arch_initcall(ath79_setup);
+-
+ void __init device_tree_init(void)
+ {
+ 	unflatten_and_copy_device_tree();
+ }
+-
+-MIPS_MACHINE(ATH79_MACH_GENERIC,
+-	     "Generic",
+-	     "Generic AR71XX/AR724X/AR913X based board",
+-	     NULL);
+-
+-MIPS_MACHINE(ATH79_MACH_GENERIC_OF,
+-	     "DTB",
+-	     "Generic AR71XX/AR724X/AR913X based board (DT)",
+-	     NULL);
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -26,7 +26,6 @@
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ #include "common.h"
+-#include "machtypes.h"
+ 
+ #define AR71XX_BASE_FREQ	40000000
+ #define AR724X_BASE_FREQ	40000000
diff --git a/target/linux/ath79/patches-4.14/0028-MIPS-ath79-add-helpers-for-setting-clocks-and-expose.patch b/target/linux/ath79/patches-4.14/0028-MIPS-ath79-add-helpers-for-setting-clocks-and-expose.patch
new file mode 100644
index 0000000000..15f6b1f8ce
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0028-MIPS-ath79-add-helpers-for-setting-clocks-and-expose.patch
@@ -0,0 +1,238 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:19:26 +0100
+Subject: [PATCH] MIPS: ath79: add helpers for setting clocks and expose
+ the ref clock
+
+Preparation for transitioning legacy the legacy clock setup code over
+to OF.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -36,20 +36,46 @@ static struct clk_onecell_data clk_data
+ 	.clk_num = ARRAY_SIZE(clks),
+ };
+ 
+-static struct clk *__init ath79_add_sys_clkdev(
+-	const char *id, unsigned long rate)
++static const char * const clk_names[ATH79_CLK_END] = {
++	[ATH79_CLK_CPU] = "cpu",
++	[ATH79_CLK_DDR] = "ddr",
++	[ATH79_CLK_AHB] = "ahb",
++	[ATH79_CLK_REF] = "ref",
++};
++
++static const char * __init ath79_clk_name(int type)
+ {
+-	struct clk *clk;
+-	int err;
++	BUG_ON(type >= ARRAY_SIZE(clk_names) || !clk_names[type]);
++	return clk_names[type];
++}
+ 
+-	clk = clk_register_fixed_rate(NULL, id, NULL, 0, rate);
++static void __init __ath79_set_clk(int type, const char *name, struct clk *clk)
++{
+ 	if (IS_ERR(clk))
+-		panic("failed to allocate %s clock structure", id);
++		panic("failed to allocate %s clock structure", clk_names[type]);
+ 
+-	err = clk_register_clkdev(clk, id, NULL);
+-	if (err)
+-		panic("unable to register %s clock device", id);
++	clks[type] = clk;
++	clk_register_clkdev(clk, name, NULL);
++}
+ 
++static struct clk * __init ath79_set_clk(int type, unsigned long rate)
++{
++	const char *name = ath79_clk_name(type);
++	struct clk *clk;
++
++	clk = clk_register_fixed_rate(NULL, name, NULL, 0, rate);
++	__ath79_set_clk(type, name, clk);
++	return clk;
++}
++
++static struct clk * __init ath79_set_ff_clk(int type, const char *parent,
++					    unsigned int mult, unsigned int div)
++{
++	const char *name = ath79_clk_name(type);
++	struct clk *clk;
++
++	clk = clk_register_fixed_factor(NULL, name, parent, 0, mult, div);
++	__ath79_set_clk(type, name, clk);
+ 	return clk;
+ }
+ 
+@@ -79,27 +105,15 @@ static void __init ar71xx_clocks_init(vo
+ 	div = (((pll >> AR71XX_AHB_DIV_SHIFT) & AR71XX_AHB_DIV_MASK) + 1) * 2;
+ 	ahb_rate = cpu_rate / div;
+ 
+-	ath79_add_sys_clkdev("ref", ref_rate);
+-	clks[ATH79_CLK_CPU] = ath79_add_sys_clkdev("cpu", cpu_rate);
+-	clks[ATH79_CLK_DDR] = ath79_add_sys_clkdev("ddr", ddr_rate);
+-	clks[ATH79_CLK_AHB] = ath79_add_sys_clkdev("ahb", ahb_rate);
++	ath79_set_clk(ATH79_CLK_REF, ref_rate);
++	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
++	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
++	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+ 	clk_add_alias("wdt", NULL, "ahb", NULL);
+ 	clk_add_alias("uart", NULL, "ahb", NULL);
+ }
+ 
+-static struct clk * __init ath79_reg_ffclk(const char *name,
+-		const char *parent_name, unsigned int mult, unsigned int div)
+-{
+-	struct clk *clk;
+-
+-	clk = clk_register_fixed_factor(NULL, name, parent_name, 0, mult, div);
+-	if (IS_ERR(clk))
+-		panic("failed to allocate %s clock structure", name);
+-
+-	return clk;
+-}
+-
+ static void __init ar724x_clk_init(struct clk *ref_clk, void __iomem *pll_base)
+ {
+ 	u32 pll;
+@@ -113,24 +127,19 @@ static void __init ar724x_clk_init(struc
+ 	ddr_div = ((pll >> AR724X_DDR_DIV_SHIFT) & AR724X_DDR_DIV_MASK) + 1;
+ 	ahb_div = (((pll >> AR724X_AHB_DIV_SHIFT) & AR724X_AHB_DIV_MASK) + 1) * 2;
+ 
+-	clks[ATH79_CLK_CPU] = ath79_reg_ffclk("cpu", "ref", mult, div);
+-	clks[ATH79_CLK_DDR] = ath79_reg_ffclk("ddr", "ref", mult, div * ddr_div);
+-	clks[ATH79_CLK_AHB] = ath79_reg_ffclk("ahb", "ref", mult, div * ahb_div);
++	ath79_set_ff_clk(ATH79_CLK_CPU, "ref", mult, div);
++	ath79_set_ff_clk(ATH79_CLK_DDR, "ref", mult, div * ddr_div);
++	ath79_set_ff_clk(ATH79_CLK_AHB, "ref", mult, div * ahb_div);
+ }
+ 
+ static void __init ar724x_clocks_init(void)
+ {
+ 	struct clk *ref_clk;
+ 
+-	ref_clk = ath79_add_sys_clkdev("ref", AR724X_BASE_FREQ);
++	ref_clk = ath79_set_clk(ATH79_CLK_REF, AR724X_BASE_FREQ);
+ 
+ 	ar724x_clk_init(ref_clk, ath79_pll_base);
+ 
+-	/* just make happy plat_time_init() from arch/mips/ath79/setup.c */
+-	clk_register_clkdev(clks[ATH79_CLK_CPU], "cpu", NULL);
+-	clk_register_clkdev(clks[ATH79_CLK_DDR], "ddr", NULL);
+-	clk_register_clkdev(clks[ATH79_CLK_AHB], "ahb", NULL);
+-
+ 	clk_add_alias("wdt", NULL, "ahb", NULL);
+ 	clk_add_alias("uart", NULL, "ahb", NULL);
+ }
+@@ -185,12 +194,12 @@ static void __init ar9330_clk_init(struc
+ 		     AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK) + 1;
+ 	}
+ 
+-	clks[ATH79_CLK_CPU] = ath79_reg_ffclk("cpu", "ref",
+-					ninit_mul, ref_div * out_div * cpu_div);
+-	clks[ATH79_CLK_DDR] = ath79_reg_ffclk("ddr", "ref",
+-					ninit_mul, ref_div * out_div * ddr_div);
+-	clks[ATH79_CLK_AHB] = ath79_reg_ffclk("ahb", "ref",
+-					ninit_mul, ref_div * out_div * ahb_div);
++	ath79_set_ff_clk(ATH79_CLK_CPU, "ref", ninit_mul,
++			 ref_div * out_div * cpu_div);
++	ath79_set_ff_clk(ATH79_CLK_DDR, "ref", ninit_mul,
++			 ref_div * out_div * ddr_div);
++	ath79_set_ff_clk(ATH79_CLK_AHB, "ref", ninit_mul,
++			 ref_div * out_div * ahb_div);
+ }
+ 
+ static void __init ar933x_clocks_init(void)
+@@ -205,15 +214,10 @@ static void __init ar933x_clocks_init(vo
+ 	else
+ 		ref_rate = (25 * 1000 * 1000);
+ 
+-	ref_clk = ath79_add_sys_clkdev("ref", ref_rate);
++	ref_clk = ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 
+ 	ar9330_clk_init(ref_clk, ath79_pll_base);
+ 
+-	/* just make happy plat_time_init() from arch/mips/ath79/setup.c */
+-	clk_register_clkdev(clks[ATH79_CLK_CPU], "cpu", NULL);
+-	clk_register_clkdev(clks[ATH79_CLK_DDR], "ddr", NULL);
+-	clk_register_clkdev(clks[ATH79_CLK_AHB], "ahb", NULL);
+-
+ 	clk_add_alias("wdt", NULL, "ahb", NULL);
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+@@ -343,10 +347,10 @@ static void __init ar934x_clocks_init(vo
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_add_sys_clkdev("ref", ref_rate);
+-	clks[ATH79_CLK_CPU] = ath79_add_sys_clkdev("cpu", cpu_rate);
+-	clks[ATH79_CLK_DDR] = ath79_add_sys_clkdev("ddr", ddr_rate);
+-	clks[ATH79_CLK_AHB] = ath79_add_sys_clkdev("ahb", ahb_rate);
++	ath79_set_clk(ATH79_CLK_REF, ref_rate);
++	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
++	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
++	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+ 	clk_add_alias("wdt", NULL, "ref", NULL);
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+@@ -430,10 +434,10 @@ static void __init qca953x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_add_sys_clkdev("ref", ref_rate);
+-	ath79_add_sys_clkdev("cpu", cpu_rate);
+-	ath79_add_sys_clkdev("ddr", ddr_rate);
+-	ath79_add_sys_clkdev("ahb", ahb_rate);
++	ath79_set_clk(ATH79_CLK_REF, ref_rate);
++	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
++	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
++	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+ 	clk_add_alias("wdt", NULL, "ref", NULL);
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+@@ -515,10 +519,10 @@ static void __init qca955x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_add_sys_clkdev("ref", ref_rate);
+-	clks[ATH79_CLK_CPU] = ath79_add_sys_clkdev("cpu", cpu_rate);
+-	clks[ATH79_CLK_DDR] = ath79_add_sys_clkdev("ddr", ddr_rate);
+-	clks[ATH79_CLK_AHB] = ath79_add_sys_clkdev("ahb", ahb_rate);
++	ath79_set_clk(ATH79_CLK_REF, ref_rate);
++	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
++	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
++	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+ 	clk_add_alias("wdt", NULL, "ref", NULL);
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+@@ -609,10 +613,10 @@ static void __init qca956x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_add_sys_clkdev("ref", ref_rate);
+-	ath79_add_sys_clkdev("cpu", cpu_rate);
+-	ath79_add_sys_clkdev("ddr", ddr_rate);
+-	ath79_add_sys_clkdev("ahb", ahb_rate);
++	ath79_set_clk(ATH79_CLK_REF, ref_rate);
++	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
++	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
++	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+ 	clk_add_alias("wdt", NULL, "ref", NULL);
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+--- a/include/dt-bindings/clock/ath79-clk.h
++++ b/include/dt-bindings/clock/ath79-clk.h
+@@ -13,7 +13,8 @@
+ #define ATH79_CLK_CPU		0
+ #define ATH79_CLK_DDR		1
+ #define ATH79_CLK_AHB		2
++#define ATH79_CLK_REF		3
+ 
+-#define ATH79_CLK_END		3
++#define ATH79_CLK_END		4
+ 
+ #endif /* __DT_BINDINGS_ATH79_CLK_H */
diff --git a/target/linux/ath79/patches-4.14/0029-MIPS-ath79-move-legacy-wdt-and-uart-clock-aliases-ou.patch b/target/linux/ath79/patches-4.14/0029-MIPS-ath79-move-legacy-wdt-and-uart-clock-aliases-ou.patch
new file mode 100644
index 0000000000..07e750a96c
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0029-MIPS-ath79-move-legacy-wdt-and-uart-clock-aliases-ou.patch
@@ -0,0 +1,110 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:22:43 +0100
+Subject: [PATCH] MIPS: ath79: move legacy "wdt" and "uart" clock aliases
+ out of soc init
+
+Preparation for reusing functions for DT
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -109,9 +109,6 @@ static void __init ar71xx_clocks_init(vo
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+-
+-	clk_add_alias("wdt", NULL, "ahb", NULL);
+-	clk_add_alias("uart", NULL, "ahb", NULL);
+ }
+ 
+ static void __init ar724x_clk_init(struct clk *ref_clk, void __iomem *pll_base)
+@@ -139,9 +136,6 @@ static void __init ar724x_clocks_init(vo
+ 	ref_clk = ath79_set_clk(ATH79_CLK_REF, AR724X_BASE_FREQ);
+ 
+ 	ar724x_clk_init(ref_clk, ath79_pll_base);
+-
+-	clk_add_alias("wdt", NULL, "ahb", NULL);
+-	clk_add_alias("uart", NULL, "ahb", NULL);
+ }
+ 
+ static void __init ar9330_clk_init(struct clk *ref_clk, void __iomem *pll_base)
+@@ -217,9 +211,6 @@ static void __init ar933x_clocks_init(vo
+ 	ref_clk = ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 
+ 	ar9330_clk_init(ref_clk, ath79_pll_base);
+-
+-	clk_add_alias("wdt", NULL, "ahb", NULL);
+-	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
+ static u32 __init ar934x_get_pll_freq(u32 ref, u32 ref_div, u32 nint, u32 nfrac,
+@@ -352,9 +343,6 @@ static void __init ar934x_clocks_init(vo
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
+-	clk_add_alias("wdt", NULL, "ref", NULL);
+-	clk_add_alias("uart", NULL, "ref", NULL);
+-
+ 	iounmap(dpll_base);
+ }
+ 
+@@ -438,9 +426,6 @@ static void __init qca953x_clocks_init(v
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+-
+-	clk_add_alias("wdt", NULL, "ref", NULL);
+-	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
+ static void __init qca955x_clocks_init(void)
+@@ -523,9 +508,6 @@ static void __init qca955x_clocks_init(v
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+-
+-	clk_add_alias("wdt", NULL, "ref", NULL);
+-	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
+ static void __init qca956x_clocks_init(void)
+@@ -617,13 +599,13 @@ static void __init qca956x_clocks_init(v
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+-
+-	clk_add_alias("wdt", NULL, "ref", NULL);
+-	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
+ void __init ath79_clocks_init(void)
+ {
++	const char *wdt;
++	const char *uart;
++
+ 	if (soc_is_ar71xx())
+ 		ar71xx_clocks_init();
+ 	else if (soc_is_ar724x() || soc_is_ar913x())
+@@ -640,6 +622,20 @@ void __init ath79_clocks_init(void)
+ 		qca956x_clocks_init();
+ 	else
+ 		BUG();
++
++	if (soc_is_ar71xx() || soc_is_ar724x() || soc_is_ar913x()) {
++		wdt = "ahb";
++		uart = "ahb";
++	} else if (soc_is_ar933x()) {
++		wdt = "ahb";
++		uart = "ref";
++	} else {
++		wdt = "ref";
++		uart = "ref";
++	}
++
++	clk_add_alias("wdt", NULL, wdt, NULL);
++	clk_add_alias("uart", NULL, uart, NULL);
+ }
+ 
+ unsigned long __init
diff --git a/target/linux/ath79/patches-4.14/0030-MIPS-ath79-pass-PLL-base-to-clock-init-functions.patch b/target/linux/ath79/patches-4.14/0030-MIPS-ath79-pass-PLL-base-to-clock-init-functions.patch
new file mode 100644
index 0000000000..d326880d84
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0030-MIPS-ath79-pass-PLL-base-to-clock-init-functions.patch
@@ -0,0 +1,238 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:23:20 +0100
+Subject: [PATCH] MIPS: ath79: pass PLL base to clock init functions
+
+Preparation for passing the mapped base via DT
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -79,7 +79,7 @@ static struct clk * __init ath79_set_ff_
+ 	return clk;
+ }
+ 
+-static void __init ar71xx_clocks_init(void)
++static void __init ar71xx_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+ 	unsigned long cpu_rate;
+@@ -91,7 +91,7 @@ static void __init ar71xx_clocks_init(vo
+ 
+ 	ref_rate = AR71XX_BASE_FREQ;
+ 
+-	pll = ath79_pll_rr(AR71XX_PLL_REG_CPU_CONFIG);
++	pll = __raw_readl(pll_base + AR71XX_PLL_REG_CPU_CONFIG);
+ 
+ 	div = ((pll >> AR71XX_PLL_FB_SHIFT) & AR71XX_PLL_FB_MASK) + 1;
+ 	freq = div * ref_rate;
+@@ -129,13 +129,13 @@ static void __init ar724x_clk_init(struc
+ 	ath79_set_ff_clk(ATH79_CLK_AHB, "ref", mult, div * ahb_div);
+ }
+ 
+-static void __init ar724x_clocks_init(void)
++static void __init ar724x_clocks_init(void __iomem *pll_base)
+ {
+ 	struct clk *ref_clk;
+ 
+ 	ref_clk = ath79_set_clk(ATH79_CLK_REF, AR724X_BASE_FREQ);
+ 
+-	ar724x_clk_init(ref_clk, ath79_pll_base);
++	ar724x_clk_init(ref_clk, pll_base);
+ }
+ 
+ static void __init ar9330_clk_init(struct clk *ref_clk, void __iomem *pll_base)
+@@ -196,7 +196,7 @@ static void __init ar9330_clk_init(struc
+ 			 ref_div * out_div * ahb_div);
+ }
+ 
+-static void __init ar933x_clocks_init(void)
++static void __init ar933x_clocks_init(void __iomem *pll_base)
+ {
+ 	struct clk *ref_clk;
+ 	unsigned long ref_rate;
+@@ -233,7 +233,7 @@ static u32 __init ar934x_get_pll_freq(u3
+ 	return ret;
+ }
+ 
+-static void __init ar934x_clocks_init(void)
++static void __init ar934x_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+ 	unsigned long cpu_rate;
+@@ -264,7 +264,7 @@ static void __init ar934x_clocks_init(vo
+ 			  AR934X_SRIF_DPLL1_REFDIV_MASK;
+ 		frac = 1 << 18;
+ 	} else {
+-		pll = ath79_pll_rr(AR934X_PLL_CPU_CONFIG_REG);
++		pll = __raw_readl(pll_base + AR934X_PLL_CPU_CONFIG_REG);
+ 		out_div = (pll >> AR934X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 			AR934X_PLL_CPU_CONFIG_OUTDIV_MASK;
+ 		ref_div = (pll >> AR934X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+@@ -291,7 +291,7 @@ static void __init ar934x_clocks_init(vo
+ 			  AR934X_SRIF_DPLL1_REFDIV_MASK;
+ 		frac = 1 << 18;
+ 	} else {
+-		pll = ath79_pll_rr(AR934X_PLL_DDR_CONFIG_REG);
++		pll = __raw_readl(pll_base + AR934X_PLL_DDR_CONFIG_REG);
+ 		out_div = (pll >> AR934X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+ 			  AR934X_PLL_DDR_CONFIG_OUTDIV_MASK;
+ 		ref_div = (pll >> AR934X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+@@ -306,7 +306,7 @@ static void __init ar934x_clocks_init(vo
+ 	ddr_pll = ar934x_get_pll_freq(ref_rate, ref_div, nint,
+ 				      nfrac, frac, out_div);
+ 
+-	clk_ctrl = ath79_pll_rr(AR934X_PLL_CPU_DDR_CLK_CTRL_REG);
++	clk_ctrl = __raw_readl(pll_base + AR934X_PLL_CPU_DDR_CLK_CTRL_REG);
+ 
+ 	postdiv = (clk_ctrl >> AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+ 		  AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK;
+@@ -346,7 +346,7 @@ static void __init ar934x_clocks_init(vo
+ 	iounmap(dpll_base);
+ }
+ 
+-static void __init qca953x_clocks_init(void)
++static void __init qca953x_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+ 	unsigned long cpu_rate;
+@@ -362,7 +362,7 @@ static void __init qca953x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
+-	pll = ath79_pll_rr(QCA953X_PLL_CPU_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA953X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+@@ -376,7 +376,7 @@ static void __init qca953x_clocks_init(v
+ 	cpu_pll += frac * (ref_rate >> 6) / ref_div;
+ 	cpu_pll /= (1 << out_div);
+ 
+-	pll = ath79_pll_rr(QCA953X_PLL_DDR_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA953X_PLL_DDR_CONFIG_REG);
+ 	out_div = (pll >> QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+@@ -390,7 +390,7 @@ static void __init qca953x_clocks_init(v
+ 	ddr_pll += frac * (ref_rate >> 6) / (ref_div << 4);
+ 	ddr_pll /= (1 << out_div);
+ 
+-	clk_ctrl = ath79_pll_rr(QCA953X_PLL_CLK_CTRL_REG);
++	clk_ctrl = __raw_readl(pll_base + QCA953X_PLL_CLK_CTRL_REG);
+ 
+ 	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+ 		  QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
+@@ -428,7 +428,7 @@ static void __init qca953x_clocks_init(v
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ }
+ 
+-static void __init qca955x_clocks_init(void)
++static void __init qca955x_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+ 	unsigned long cpu_rate;
+@@ -444,7 +444,7 @@ static void __init qca955x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
+-	pll = ath79_pll_rr(QCA955X_PLL_CPU_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA955X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA955X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA955X_PLL_CPU_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA955X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+@@ -458,7 +458,7 @@ static void __init qca955x_clocks_init(v
+ 	cpu_pll += frac * ref_rate / (ref_div * (1 << 6));
+ 	cpu_pll /= (1 << out_div);
+ 
+-	pll = ath79_pll_rr(QCA955X_PLL_DDR_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA955X_PLL_DDR_CONFIG_REG);
+ 	out_div = (pll >> QCA955X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA955X_PLL_DDR_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA955X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+@@ -472,7 +472,7 @@ static void __init qca955x_clocks_init(v
+ 	ddr_pll += frac * ref_rate / (ref_div * (1 << 10));
+ 	ddr_pll /= (1 << out_div);
+ 
+-	clk_ctrl = ath79_pll_rr(QCA955X_PLL_CLK_CTRL_REG);
++	clk_ctrl = __raw_readl(pll_base + QCA955X_PLL_CLK_CTRL_REG);
+ 
+ 	postdiv = (clk_ctrl >> QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+ 		  QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
+@@ -510,7 +510,7 @@ static void __init qca955x_clocks_init(v
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ }
+ 
+-static void __init qca956x_clocks_init(void)
++static void __init qca956x_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+ 	unsigned long cpu_rate;
+@@ -526,13 +526,13 @@ static void __init qca956x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
+-	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA956X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+ 		  QCA956X_PLL_CPU_CONFIG_REFDIV_MASK;
+ 
+-	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG1_REG);
++	pll = __raw_readl(pll_base + QCA956X_PLL_CPU_CONFIG1_REG);
+ 	nint = (pll >> QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT) &
+ 	       QCA956X_PLL_CPU_CONFIG1_NINT_MASK;
+ 	hfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT) &
+@@ -545,12 +545,12 @@ static void __init qca956x_clocks_init(v
+ 	cpu_pll += (hfrac >> 13) * ref_rate / ref_div;
+ 	cpu_pll /= (1 << out_div);
+ 
+-	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG_REG);
++	pll = __raw_readl(pll_base + QCA956X_PLL_DDR_CONFIG_REG);
+ 	out_div = (pll >> QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK;
+ 	ref_div = (pll >> QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+ 		  QCA956X_PLL_DDR_CONFIG_REFDIV_MASK;
+-	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG1_REG);
++	pll = __raw_readl(pll_base + QCA956X_PLL_DDR_CONFIG1_REG);
+ 	nint = (pll >> QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT) &
+ 	       QCA956X_PLL_DDR_CONFIG1_NINT_MASK;
+ 	hfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT) &
+@@ -563,7 +563,7 @@ static void __init qca956x_clocks_init(v
+ 	ddr_pll += (hfrac >> 13) * ref_rate / ref_div;
+ 	ddr_pll /= (1 << out_div);
+ 
+-	clk_ctrl = ath79_pll_rr(QCA956X_PLL_CLK_CTRL_REG);
++	clk_ctrl = __raw_readl(pll_base + QCA956X_PLL_CLK_CTRL_REG);
+ 
+ 	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+ 		  QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
+@@ -607,19 +607,19 @@ void __init ath79_clocks_init(void)
+ 	const char *uart;
+ 
+ 	if (soc_is_ar71xx())
+-		ar71xx_clocks_init();
++		ar71xx_clocks_init(ath79_pll_base);
+ 	else if (soc_is_ar724x() || soc_is_ar913x())
+-		ar724x_clocks_init();
++		ar724x_clocks_init(ath79_pll_base);
+ 	else if (soc_is_ar933x())
+-		ar933x_clocks_init();
++		ar933x_clocks_init(ath79_pll_base);
+ 	else if (soc_is_ar934x())
+-		ar934x_clocks_init();
++		ar934x_clocks_init(ath79_pll_base);
+ 	else if (soc_is_qca953x())
+-		qca953x_clocks_init();
++		qca953x_clocks_init(ath79_pll_base);
+ 	else if (soc_is_qca955x())
+-		qca955x_clocks_init();
++		qca955x_clocks_init(ath79_pll_base);
+ 	else if (soc_is_qca956x() || soc_is_tp9343())
+-		qca956x_clocks_init();
++		qca956x_clocks_init(ath79_pll_base);
+ 	else
+ 		BUG();
+ 
diff --git a/target/linux/ath79/patches-4.14/0031-MIPS-ath79-make-specifying-the-reference-clock-in-DT.patch b/target/linux/ath79/patches-4.14/0031-MIPS-ath79-make-specifying-the-reference-clock-in-DT.patch
new file mode 100644
index 0000000000..9cadc02d3d
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0031-MIPS-ath79-make-specifying-the-reference-clock-in-DT.patch
@@ -0,0 +1,225 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:24:07 +0100
+Subject: [PATCH] MIPS: ath79: make specifying the reference clock in DT
+ optional
+
+It can be autodetected for many SoCs using the strapping options.
+If the clock is specified in DT, the autodetected value is ignored
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -79,6 +79,18 @@ static struct clk * __init ath79_set_ff_
+ 	return clk;
+ }
+ 
++static unsigned long __init ath79_setup_ref_clk(unsigned long rate)
++{
++	struct clk *clk = clks[ATH79_CLK_REF];
++
++	if (clk)
++		rate = clk_get_rate(clk);
++	else
++		clk = ath79_set_clk(ATH79_CLK_REF, rate);
++
++	return rate;
++}
++
+ static void __init ar71xx_clocks_init(void __iomem *pll_base)
+ {
+ 	unsigned long ref_rate;
+@@ -89,7 +101,7 @@ static void __init ar71xx_clocks_init(vo
+ 	u32 freq;
+ 	u32 div;
+ 
+-	ref_rate = AR71XX_BASE_FREQ;
++	ref_rate = ath79_setup_ref_clk(AR71XX_BASE_FREQ);
+ 
+ 	pll = __raw_readl(pll_base + AR71XX_PLL_REG_CPU_CONFIG);
+ 
+@@ -105,16 +117,17 @@ static void __init ar71xx_clocks_init(vo
+ 	div = (((pll >> AR71XX_AHB_DIV_SHIFT) & AR71XX_AHB_DIV_MASK) + 1) * 2;
+ 	ahb_rate = cpu_rate / div;
+ 
+-	ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ }
+ 
+-static void __init ar724x_clk_init(struct clk *ref_clk, void __iomem *pll_base)
++static void __init ar724x_clocks_init(void __iomem *pll_base)
+ {
+-	u32 pll;
+ 	u32 mult, div, ddr_div, ahb_div;
++	u32 pll;
++
++	ath79_setup_ref_clk(AR71XX_BASE_FREQ);
+ 
+ 	pll = __raw_readl(pll_base + AR724X_PLL_REG_CPU_CONFIG);
+ 
+@@ -129,17 +142,9 @@ static void __init ar724x_clk_init(struc
+ 	ath79_set_ff_clk(ATH79_CLK_AHB, "ref", mult, div * ahb_div);
+ }
+ 
+-static void __init ar724x_clocks_init(void __iomem *pll_base)
+-{
+-	struct clk *ref_clk;
+-
+-	ref_clk = ath79_set_clk(ATH79_CLK_REF, AR724X_BASE_FREQ);
+-
+-	ar724x_clk_init(ref_clk, pll_base);
+-}
+-
+-static void __init ar9330_clk_init(struct clk *ref_clk, void __iomem *pll_base)
++static void __init ar933x_clocks_init(void __iomem *pll_base)
+ {
++	unsigned long ref_rate;
+ 	u32 clock_ctrl;
+ 	u32 ref_div;
+ 	u32 ninit_mul;
+@@ -148,6 +153,15 @@ static void __init ar9330_clk_init(struc
+ 	u32 cpu_div;
+ 	u32 ddr_div;
+ 	u32 ahb_div;
++	u32 t;
++
++	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
++	if (t & AR933X_BOOTSTRAP_REF_CLK_40)
++		ref_rate = (40 * 1000 * 1000);
++	else
++		ref_rate = (25 * 1000 * 1000);
++
++	ath79_setup_ref_clk(ref_rate);
+ 
+ 	clock_ctrl = __raw_readl(pll_base + AR933X_PLL_CLOCK_CTRL_REG);
+ 	if (clock_ctrl & AR933X_PLL_CLOCK_CTRL_BYPASS) {
+@@ -196,23 +210,6 @@ static void __init ar9330_clk_init(struc
+ 			 ref_div * out_div * ahb_div);
+ }
+ 
+-static void __init ar933x_clocks_init(void __iomem *pll_base)
+-{
+-	struct clk *ref_clk;
+-	unsigned long ref_rate;
+-	u32 t;
+-
+-	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+-	if (t & AR933X_BOOTSTRAP_REF_CLK_40)
+-		ref_rate = (40 * 1000 * 1000);
+-	else
+-		ref_rate = (25 * 1000 * 1000);
+-
+-	ref_clk = ath79_set_clk(ATH79_CLK_REF, ref_rate);
+-
+-	ar9330_clk_init(ref_clk, ath79_pll_base);
+-}
+-
+ static u32 __init ar934x_get_pll_freq(u32 ref, u32 ref_div, u32 nint, u32 nfrac,
+ 				      u32 frac, u32 out_div)
+ {
+@@ -252,6 +249,8 @@ static void __init ar934x_clocks_init(vo
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
++	ref_rate = ath79_setup_ref_clk(ref_rate);
++
+ 	pll = __raw_readl(dpll_base + AR934X_SRIF_CPU_DPLL2_REG);
+ 	if (pll & AR934X_SRIF_DPLL2_LOCAL_PLL) {
+ 		out_div = (pll >> AR934X_SRIF_DPLL2_OUTDIV_SHIFT) &
+@@ -338,7 +337,6 @@ static void __init ar934x_clocks_init(vo
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+@@ -362,6 +360,8 @@ static void __init qca953x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
++	ref_rate = ath79_setup_ref_clk(ref_rate);
++
+ 	pll = __raw_readl(pll_base + QCA953X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK;
+@@ -422,7 +422,6 @@ static void __init qca953x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+@@ -444,6 +443,8 @@ static void __init qca955x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
++	ref_rate = ath79_setup_ref_clk(ref_rate);
++
+ 	pll = __raw_readl(pll_base + QCA955X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA955X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA955X_PLL_CPU_CONFIG_OUTDIV_MASK;
+@@ -504,7 +505,6 @@ static void __init qca955x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+@@ -526,6 +526,8 @@ static void __init qca956x_clocks_init(v
+ 	else
+ 		ref_rate = 25 * 1000 * 1000;
+ 
++	ref_rate = ath79_setup_ref_clk(ref_rate);
++
+ 	pll = __raw_readl(pll_base + QCA956X_PLL_CPU_CONFIG_REG);
+ 	out_div = (pll >> QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+ 		  QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK;
+@@ -595,7 +597,6 @@ static void __init qca956x_clocks_init(v
+ 	else
+ 		ahb_rate = cpu_pll / (postdiv + 1);
+ 
+-	ath79_set_clk(ATH79_CLK_REF, ref_rate);
+ 	ath79_set_clk(ATH79_CLK_CPU, cpu_rate);
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+@@ -671,10 +672,8 @@ static void __init ath79_clocks_init_dt_
+ 	void __iomem *pll_base;
+ 
+ 	ref_clk = of_clk_get(np, 0);
+-	if (IS_ERR(ref_clk)) {
+-		pr_err("%pOF: of_clk_get failed\n", np);
+-		goto err;
+-	}
++	if (!IS_ERR(ref_clk))
++		clks[ATH79_CLK_REF] = ref_clk;
+ 
+ 	pll_base = of_iomap(np, 0);
+ 	if (!pll_base) {
+@@ -683,9 +682,9 @@ static void __init ath79_clocks_init_dt_
+ 	}
+ 
+ 	if (of_device_is_compatible(np, "qca,ar9130-pll"))
+-		ar724x_clk_init(ref_clk, pll_base);
++		ar724x_clocks_init(pll_base);
+ 	else if (of_device_is_compatible(np, "qca,ar9330-pll"))
+-		ar9330_clk_init(ref_clk, pll_base);
++		ar933x_clocks_init(pll_base);
+ 	else {
+ 		pr_err("%pOF: could not find any appropriate clk_init()\n", np);
+ 		goto err_iounmap;
+@@ -703,9 +702,6 @@ err_iounmap:
+ 
+ err_clk:
+ 	clk_put(ref_clk);
+-
+-err:
+-	return;
+ }
+ CLK_OF_DECLARE(ar9130_clk, "qca,ar9130-pll", ath79_clocks_init_dt_ng);
+ CLK_OF_DECLARE(ar9330_clk, "qca,ar9330-pll", ath79_clocks_init_dt_ng);
diff --git a/target/linux/ath79/patches-4.14/0032-MIPS-ath79-support-setting-up-clock-via-DT-on-all-So.patch b/target/linux/ath79/patches-4.14/0032-MIPS-ath79-support-setting-up-clock-via-DT-on-all-So.patch
new file mode 100644
index 0000000000..35c6ea7dbb
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0032-MIPS-ath79-support-setting-up-clock-via-DT-on-all-So.patch
@@ -0,0 +1,73 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:26:27 +0100
+Subject: [PATCH] MIPS: ath79: support setting up clock via DT on all SoC
+ types
+
+Use the same functions as the legacy code
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -658,16 +658,6 @@ ath79_get_sys_clk_rate(const char *id)
+ #ifdef CONFIG_OF
+ static void __init ath79_clocks_init_dt(struct device_node *np)
+ {
+-	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+-}
+-
+-CLK_OF_DECLARE(ar7100, "qca,ar7100-pll", ath79_clocks_init_dt);
+-CLK_OF_DECLARE(ar7240, "qca,ar7240-pll", ath79_clocks_init_dt);
+-CLK_OF_DECLARE(ar9340, "qca,ar9340-pll", ath79_clocks_init_dt);
+-CLK_OF_DECLARE(ar9550, "qca,qca9550-pll", ath79_clocks_init_dt);
+-
+-static void __init ath79_clocks_init_dt_ng(struct device_node *np)
+-{
+ 	struct clk *ref_clk;
+ 	void __iomem *pll_base;
+ 
+@@ -681,14 +671,21 @@ static void __init ath79_clocks_init_dt_
+ 		goto err_clk;
+ 	}
+ 
+-	if (of_device_is_compatible(np, "qca,ar9130-pll"))
++	if (of_device_is_compatible(np, "qca,ar7100-pll"))
++		ar71xx_clocks_init(pll_base);
++	else if (of_device_is_compatible(np, "qca,ar7240-pll") ||
++		 of_device_is_compatible(np, "qca,ar9130-pll"))
+ 		ar724x_clocks_init(pll_base);
+ 	else if (of_device_is_compatible(np, "qca,ar9330-pll"))
+ 		ar933x_clocks_init(pll_base);
+-	else {
+-		pr_err("%pOF: could not find any appropriate clk_init()\n", np);
+-		goto err_iounmap;
+-	}
++	else if (of_device_is_compatible(np, "qca,ar9340-pll"))
++		ar934x_clocks_init(pll_base);
++	else if (of_device_is_compatible(np, "qca,qca9530-pll"))
++		qca953x_clocks_init(pll_base);
++	else if (of_device_is_compatible(np, "qca,qca9550-pll"))
++		qca955x_clocks_init(pll_base);
++	else if (of_device_is_compatible(np, "qca,qca9560-pll"))
++		qca956x_clocks_init(pll_base);
+ 
+ 	if (of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data)) {
+ 		pr_err("%pOF: could not register clk provider\n", np);
+@@ -703,6 +700,14 @@ err_iounmap:
+ err_clk:
+ 	clk_put(ref_clk);
+ }
+-CLK_OF_DECLARE(ar9130_clk, "qca,ar9130-pll", ath79_clocks_init_dt_ng);
+-CLK_OF_DECLARE(ar9330_clk, "qca,ar9330-pll", ath79_clocks_init_dt_ng);
++
++CLK_OF_DECLARE(ar7100_clk, "qca,ar7100-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar7240_clk, "qca,ar7240-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9130_clk, "qca,ar9130-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9330_clk, "qca,ar9330-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9340_clk, "qca,ar9340-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9530_clk, "qca,qca9530-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9550_clk, "qca,qca9550-pll", ath79_clocks_init_dt);
++CLK_OF_DECLARE(ar9560_clk, "qca,qca9560-pll", ath79_clocks_init_dt);
++
+ #endif
diff --git a/target/linux/ath79/patches-4.14/0033-MIPS-ath79-export-switch-MDIO-reference-clock.patch b/target/linux/ath79/patches-4.14/0033-MIPS-ath79-export-switch-MDIO-reference-clock.patch
new file mode 100644
index 0000000000..6530344ce3
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0033-MIPS-ath79-export-switch-MDIO-reference-clock.patch
@@ -0,0 +1,54 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 6 Mar 2018 13:27:28 +0100
+Subject: [PATCH] MIPS: ath79: export switch MDIO reference clock
+
+On AR934x, the MDIO reference clock can be configured to a fixed 100 MHz
+clock. If that feature is not used, it defaults to the main reference clock,
+like on all other SoC.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -41,6 +41,7 @@ static const char * const clk_names[ATH7
+ 	[ATH79_CLK_DDR] = "ddr",
+ 	[ATH79_CLK_AHB] = "ahb",
+ 	[ATH79_CLK_REF] = "ref",
++	[ATH79_CLK_MDIO] = "mdio",
+ };
+ 
+ static const char * __init ath79_clk_name(int type)
+@@ -341,6 +342,10 @@ static void __init ar934x_clocks_init(vo
+ 	ath79_set_clk(ATH79_CLK_DDR, ddr_rate);
+ 	ath79_set_clk(ATH79_CLK_AHB, ahb_rate);
+ 
++	clk_ctrl = __raw_readl(pll_base + AR934X_PLL_SWITCH_CLOCK_CONTROL_REG);
++	if (clk_ctrl & AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL)
++		ath79_set_clk(ATH79_CLK_MDIO, 100 * 1000 * 1000);
++
+ 	iounmap(dpll_base);
+ }
+ 
+@@ -687,6 +692,9 @@ static void __init ath79_clocks_init_dt(
+ 	else if (of_device_is_compatible(np, "qca,qca9560-pll"))
+ 		qca956x_clocks_init(pll_base);
+ 
++	if (!clks[ATH79_CLK_MDIO])
++		clks[ATH79_CLK_MDIO] = clks[ATH79_CLK_REF];
++
+ 	if (of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data)) {
+ 		pr_err("%pOF: could not register clk provider\n", np);
+ 		goto err_iounmap;
+--- a/include/dt-bindings/clock/ath79-clk.h
++++ b/include/dt-bindings/clock/ath79-clk.h
+@@ -14,7 +14,8 @@
+ #define ATH79_CLK_DDR		1
+ #define ATH79_CLK_AHB		2
+ #define ATH79_CLK_REF		3
++#define ATH79_CLK_MDIO		4
+ 
+-#define ATH79_CLK_END		4
++#define ATH79_CLK_END		5
+ 
+ #endif /* __DT_BINDINGS_ATH79_CLK_H */
diff --git a/target/linux/ath79/patches-4.14/0034-MIPS-ath79-ath9k-exports.patch b/target/linux/ath79/patches-4.14/0034-MIPS-ath79-ath9k-exports.patch
new file mode 100644
index 0000000000..6eec142c74
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0034-MIPS-ath79-ath9k-exports.patch
@@ -0,0 +1,27 @@
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -34,11 +34,13 @@ EXPORT_SYMBOL_GPL(ath79_ddr_freq);
+ 
+ enum ath79_soc_type ath79_soc;
+ unsigned int ath79_soc_rev;
++EXPORT_SYMBOL_GPL(ath79_soc_rev);
+ 
+ void __iomem *ath79_pll_base;
+ void __iomem *ath79_reset_base;
+ EXPORT_SYMBOL_GPL(ath79_reset_base);
+-static void __iomem *ath79_ddr_base;
++void __iomem *ath79_ddr_base;
++EXPORT_SYMBOL_GPL(ath79_ddr_base);
+ static void __iomem *ath79_ddr_wb_flush_base;
+ static void __iomem *ath79_ddr_pci_win_base;
+ 
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -152,6 +152,7 @@ void ath79_ddr_wb_flush(unsigned int reg
+ void ath79_ddr_set_pci_windows(void);
+ 
+ extern void __iomem *ath79_pll_base;
++extern void __iomem *ath79_ddr_base;
+ extern void __iomem *ath79_reset_base;
+ 
+ static inline void ath79_pll_wr(unsigned reg, u32 val)
diff --git a/target/linux/ath79/patches-4.14/0035-MIPS-ath79-fix-QCA956x-boot.patch b/target/linux/ath79/patches-4.14/0035-MIPS-ath79-fix-QCA956x-boot.patch
new file mode 100644
index 0000000000..c3dd676d4d
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/0035-MIPS-ath79-fix-QCA956x-boot.patch
@@ -0,0 +1,17 @@
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -525,6 +525,14 @@ static void __init qca956x_clocks_init(v
+ 	u32 cpu_pll, ddr_pll;
+ 	u32 bootstrap;
+ 
++	/* QCA956x timer init workaround has to be applied right before setting
++	* up the clock. Else, there will be no jiffies */
++	u32 misc;
++
++	misc = ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
++	misc |= MISC_INT_MIPS_SI_TIMERINT_MASK;
++	ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_ENABLE, misc);
++
+ 	bootstrap = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
+ 	if (bootstrap &	QCA956X_BOOTSTRAP_REF_CLK_40)
+ 		ref_rate = 40 * 1000 * 1000;
diff --git a/target/linux/ath79/patches-4.14/004-register_gpio_driver_earlier.patch b/target/linux/ath79/patches-4.14/004-register_gpio_driver_earlier.patch
new file mode 100644
index 0000000000..cc30e2d91e
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/004-register_gpio_driver_earlier.patch
@@ -0,0 +1,18 @@
+HACK: register the GPIO driver earlier to ensure that gpio_request calls
+from mach files succeed.
+
+--- a/drivers/gpio/gpio-ath79.c
++++ b/drivers/gpio/gpio-ath79.c
+@@ -322,7 +322,11 @@ static struct platform_driver ath79_gpio
+ 	.remove = ath79_gpio_remove,
+ };
+ 
+-module_platform_driver(ath79_gpio_driver);
++static int __init ath79_gpio_init(void)
++{
++	return platform_driver_register(&ath79_gpio_driver);
++}
++postcore_initcall(ath79_gpio_init);
+ 
+ MODULE_DESCRIPTION("Atheros AR71XX/AR724X/AR913X GPIO API support");
+ MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ath79/patches-4.14/405-mtd-tp-link-partition-parser.patch b/target/linux/ath79/patches-4.14/405-mtd-tp-link-partition-parser.patch
new file mode 100644
index 0000000000..846b7f0a0c
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/405-mtd-tp-link-partition-parser.patch
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -194,6 +194,12 @@ config MTD_MYLOADER_PARTS
+ 	  You will still need the parsing functions to be called by the driver
+ 	  for your particular device. It won't happen automatically.
+ 
++config MTD_TPLINK_PARTS
++	tristate "TP-Link AR7XXX/AR9XXX partitioning support"
++	depends on ATH79
++	---help---
++	  TBD.
++
+ comment "User Modules And Translation Layers"
+ 
+ #
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -18,6 +18,7 @@ obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63
+ obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
+ obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
+ obj-y				+= parsers/
++obj-$(CONFIG_MTD_TPLINK_PARTS)	+= tplinkpart.o
+ 
+ # 'Users' - code which presents functionality to userspace.
+ obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
diff --git a/target/linux/ath79/patches-4.14/420-net-ar71xx_mac_driver.patch b/target/linux/ath79/patches-4.14/420-net-ar71xx_mac_driver.patch
new file mode 100644
index 0000000000..6377db0ac2
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/420-net-ar71xx_mac_driver.patch
@@ -0,0 +1,28 @@
+--- a/drivers/net/ethernet/atheros/Kconfig
++++ b/drivers/net/ethernet/atheros/Kconfig
+@@ -5,7 +5,7 @@
+ config NET_VENDOR_ATHEROS
+ 	bool "Atheros devices"
+ 	default y
+-	depends on PCI
++	depends on (PCI || ATH79)
+ 	---help---
+ 	  If you have a network (Ethernet) card belonging to this class, say Y.
+ 
+@@ -78,4 +78,6 @@ config ALX
+ 	  To compile this driver as a module, choose M here.  The module
+ 	  will be called alx.
+ 
++source drivers/net/ethernet/atheros/ag71xx/Kconfig
++
+ endif # NET_VENDOR_ATHEROS
+--- a/drivers/net/ethernet/atheros/Makefile
++++ b/drivers/net/ethernet/atheros/Makefile
+@@ -3,6 +3,7 @@
+ # Makefile for the Atheros network device drivers.
+ #
+ 
++obj-$(CONFIG_AG71XX) += ag71xx/
+ obj-$(CONFIG_ATL1) += atlx/
+ obj-$(CONFIG_ATL2) += atlx/
+ obj-$(CONFIG_ATL1E) += atl1e/
diff --git a/target/linux/ath79/patches-4.14/430-drivers-link-spi-before-mtd.patch b/target/linux/ath79/patches-4.14/430-drivers-link-spi-before-mtd.patch
new file mode 100644
index 0000000000..2f1549710b
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/430-drivers-link-spi-before-mtd.patch
@@ -0,0 +1,12 @@
+--- a/drivers/Makefile
++++ b/drivers/Makefile
+@@ -83,8 +83,8 @@ obj-$(CONFIG_SCSI)		+= scsi/
+ obj-y				+= nvme/
+ obj-$(CONFIG_ATA)		+= ata/
+ obj-$(CONFIG_TARGET_CORE)	+= target/
+-obj-$(CONFIG_MTD)		+= mtd/
+ obj-$(CONFIG_SPI)		+= spi/
++obj-$(CONFIG_MTD)		+= mtd/
+ obj-$(CONFIG_SPMI)		+= spmi/
+ obj-$(CONFIG_HSI)		+= hsi/
+ obj-y				+= net/
diff --git a/target/linux/ath79/patches-4.14/461-spi-ath79-add-fast-flash-read.patch b/target/linux/ath79/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
new file mode 100644
index 0000000000..06da2b34e8
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
@@ -0,0 +1,60 @@
+--- a/drivers/spi/spi-ath79.c
++++ b/drivers/spi/spi-ath79.c
+@@ -102,9 +102,6 @@ static void ath79_spi_enable(struct ath7
+ 	/* save CTRL register */
+ 	sp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);
+ 	sp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);
+-
+-	/* TODO: setup speed? */
+-	ath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);
+ }
+ 
+ static void ath79_spi_disable(struct ath79_spi *sp)
+@@ -204,6 +201,38 @@ static u32 ath79_spi_txrx_mode0(struct s
+ 	return ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);
+ }
+ 
++static bool ath79_spi_flash_read_supported(struct spi_device *spi)
++{
++	if (spi->chip_select || gpio_is_valid(spi->cs_gpio))
++		return false;
++
++	return true;
++}
++
++static int ath79_spi_read_flash_data(struct spi_device *spi,
++				     struct spi_flash_read_message *msg)
++{
++	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
++
++	if (msg->addr_width > 3)
++		return -EOPNOTSUPP;
++
++	/* disable GPIO mode */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);
++
++	memcpy_fromio(msg->buf, sp->base + msg->from, msg->len);
++
++	/* enable GPIO mode */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);
++
++	/* restore IOC register */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
++
++	msg->retlen = msg->len;
++
++	return 0;
++}
++
+ static int ath79_spi_probe(struct platform_device *pdev)
+ {
+ 	struct spi_master *master;
+@@ -232,6 +261,8 @@ static int ath79_spi_probe(struct platfo
+ 		master->bus_num = pdata->bus_num;
+ 		master->num_chipselect = pdata->num_chipselect;
+ 	}
++	master->spi_flash_read = ath79_spi_read_flash_data;
++	master->flash_read_supported = ath79_spi_flash_read_supported;
+ 
+ 	sp->bitbang.master = master;
+ 	sp->bitbang.chipselect = ath79_spi_chipselect;
diff --git a/target/linux/ath79/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch b/target/linux/ath79/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
new file mode 100644
index 0000000000..ad8b7b47d1
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
@@ -0,0 +1,98 @@
+--- /dev/null
++++ b/arch/mips/include/asm/mach-ath79/mangle-port.h
+@@ -0,0 +1,37 @@
++/*
++ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
++ *
++ *  This file was derived from: inlude/asm-mips/mach-generic/mangle-port.h
++ *      Copyright (C) 2003, 2004 Ralf Baechle
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#ifndef __ASM_MACH_ATH79_MANGLE_PORT_H
++#define __ASM_MACH_ATH79_MANGLE_PORT_H
++
++#ifdef CONFIG_PCI_AR71XX
++extern unsigned long (ath79_pci_swizzle_b)(unsigned long port);
++extern unsigned long (ath79_pci_swizzle_w)(unsigned long port);
++#else
++#define ath79_pci_swizzle_b(port) (port)
++#define ath79_pci_swizzle_w(port) (port)
++#endif
++
++#define __swizzle_addr_b(port)	ath79_pci_swizzle_b(port)
++#define __swizzle_addr_w(port)	ath79_pci_swizzle_w(port)
++#define __swizzle_addr_l(port)	(port)
++#define __swizzle_addr_q(port)	(port)
++
++# define ioswabb(a, x)           (x)
++# define __mem_ioswabb(a, x)     (x)
++# define ioswabw(a, x)           (x)
++# define __mem_ioswabw(a, x)     cpu_to_le16(x)
++# define ioswabl(a, x)           (x)
++# define __mem_ioswabl(a, x)     cpu_to_le32(x)
++# define ioswabq(a, x)           (x)
++# define __mem_ioswabq(a, x)     cpu_to_le64(x)
++
++#endif /* __ASM_MACH_ATH79_MANGLE_PORT_H */
+--- a/arch/mips/pci/pci-ar71xx.c
++++ b/arch/mips/pci/pci-ar71xx.c
+@@ -73,6 +73,45 @@ static const u32 ar71xx_pci_read_mask[8]
+ 	0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0
+ };
+ 
++static unsigned long (*__ath79_pci_swizzle_b)(unsigned long port);
++static unsigned long (*__ath79_pci_swizzle_w)(unsigned long port);
++
++static inline bool ar71xx_is_pci_addr(unsigned long port)
++{
++	unsigned long phys = CPHYSADDR(port);
++
++	return (phys >= AR71XX_PCI_MEM_BASE &&
++		phys < AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE);
++}
++
++static unsigned long ar71xx_pci_swizzle_b(unsigned long port)
++{
++	return ar71xx_is_pci_addr(port) ? port ^ 3 : port;
++}
++
++static unsigned long ar71xx_pci_swizzle_w(unsigned long port)
++{
++	return ar71xx_is_pci_addr(port) ? port ^ 2 : port;
++}
++
++unsigned long ath79_pci_swizzle_b(unsigned long port)
++{
++	if (__ath79_pci_swizzle_b)
++		return __ath79_pci_swizzle_b(port);
++
++	return port;
++}
++EXPORT_SYMBOL(ath79_pci_swizzle_b);
++
++unsigned long ath79_pci_swizzle_w(unsigned long port)
++{
++	if (__ath79_pci_swizzle_w)
++		return __ath79_pci_swizzle_w(port);
++
++	return port;
++}
++EXPORT_SYMBOL(ath79_pci_swizzle_w);
++
+ static inline u32 ar71xx_pci_get_ble(int where, int size, int local)
+ {
+ 	u32 t;
+@@ -384,6 +423,9 @@ static int ar71xx_pci_probe(struct platf
+ 
+ 	register_pci_controller(&apc->pci_ctrl);
+ 
++	__ath79_pci_swizzle_b = ar71xx_pci_swizzle_b;
++	__ath79_pci_swizzle_w = ar71xx_pci_swizzle_w;
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/ath79/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch b/target/linux/ath79/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
new file mode 100644
index 0000000000..1d1979cd6e
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
@@ -0,0 +1,103 @@
+--- a/drivers/usb/host/ehci-hcd.c
++++ b/drivers/usb/host/ehci-hcd.c
+@@ -252,6 +252,37 @@ int ehci_reset(struct ehci_hcd *ehci)
+ 	command |= CMD_RESET;
+ 	dbg_cmd (ehci, "reset", command);
+ 	ehci_writel(ehci, command, &ehci->regs->command);
++
++	if (ehci->qca_force_host_mode) {
++		u32 usbmode;
++
++		udelay(1000);
++
++		usbmode = ehci_readl(ehci, &ehci->regs->usbmode);
++		usbmode |= USBMODE_CM_HC | (1 << 4);
++		ehci_writel(ehci, usbmode, &ehci->regs->usbmode);
++
++		ehci_dbg(ehci, "forced host mode, usbmode: %08x\n",
++			 ehci_readl(ehci, &ehci->regs->usbmode));
++	}
++
++	if (ehci->qca_force_16bit_ptw) {
++		u32 port_status;
++
++		udelay(1000);
++
++		/* enable 16-bit UTMI interface */
++		port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
++		port_status |= BIT(28);
++		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
++
++		ehci_dbg(ehci, "16-bit UTMI interface enabled, status: %08x\n",
++			 ehci_readl(ehci, &ehci->regs->port_status[0]));
++	}
++
++	if (ehci->reset_notifier)
++		ehci->reset_notifier(ehci_to_hcd(ehci));
++
+ 	ehci->rh_state = EHCI_RH_HALTED;
+ 	ehci->next_statechange = jiffies;
+ 	retval = ehci_handshake(ehci, &ehci->regs->command,
+--- a/drivers/usb/host/ehci.h
++++ b/drivers/usb/host/ehci.h
+@@ -232,6 +232,10 @@ struct ehci_hcd {			/* one per controlle
+ 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
+ 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
+ 	unsigned		ignore_oc:1;
++	unsigned		qca_force_host_mode:1;
++	unsigned		qca_force_16bit_ptw:1; /* force 16 bit UTMI */
++
++	void (*reset_notifier)(struct usb_hcd *hcd);
+ 
+ 	/* required for usb32 quirk */
+ 	#define OHCI_CTRL_HCFS          (3 << 6)
+--- a/include/linux/usb/ehci_pdriver.h
++++ b/include/linux/usb/ehci_pdriver.h
+@@ -50,6 +50,8 @@ struct usb_ehci_pdata {
+ 	unsigned	reset_on_resume:1;
+ 	unsigned	dma_mask_64:1;
+ 	unsigned	ignore_oc:1;
++	unsigned	qca_force_host_mode:1;
++	unsigned	qca_force_16bit_ptw:1;
+ 
+ 	/* Turn on all power and clocks */
+ 	int (*power_on)(struct platform_device *pdev);
+@@ -59,6 +61,7 @@ struct usb_ehci_pdata {
+ 	 * turn off everything else */
+ 	void (*power_suspend)(struct platform_device *pdev);
+ 	int (*pre_setup)(struct usb_hcd *hcd);
++	void (*reset_notifier)(struct platform_device *pdev);
+ };
+ 
+ #endif /* __USB_CORE_EHCI_PDRIVER_H */
+--- a/drivers/usb/host/ehci-platform.c
++++ b/drivers/usb/host/ehci-platform.c
+@@ -53,6 +53,14 @@ struct ehci_platform_priv {
+ 
+ static const char hcd_name[] = "ehci-platform";
+ 
++static void ehci_platform_reset_notifier(struct usb_hcd *hcd)
++{
++	struct platform_device *pdev = to_platform_device(hcd->self.controller);
++	struct usb_ehci_pdata *pdata = pdev->dev.platform_data;
++
++	pdata->reset_notifier(pdev);
++}
++
+ static int ehci_platform_reset(struct usb_hcd *hcd)
+ {
+ 	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+@@ -270,6 +278,13 @@ static int ehci_platform_probe(struct pl
+ 		priv->reset_on_resume = true;
+ 	if (pdata->ignore_oc)
+ 		ehci->ignore_oc = 1;
++	if (pdata->qca_force_host_mode)
++		ehci->qca_force_host_mode = 1;
++	if (pdata->qca_force_16bit_ptw)
++		ehci->qca_force_16bit_ptw = 1;
++
++	if (pdata->reset_notifier)
++		ehci->reset_notifier = ehci_platform_reset_notifier;
+ 
+ #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+ 	if (ehci->big_endian_mmio) {
diff --git a/target/linux/ath79/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch b/target/linux/ath79/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
new file mode 100644
index 0000000000..8f8f349a66
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
@@ -0,0 +1,32 @@
+--- a/drivers/net/phy/mdio-bitbang.c
++++ b/drivers/net/phy/mdio-bitbang.c
+@@ -155,7 +155,7 @@ static int mdiobb_cmd_addr(struct mdiobb
+ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
+-	int ret, i;
++	int ret;
+ 
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+@@ -165,19 +165,7 @@ static int mdiobb_read(struct mii_bus *b
+ 
+ 	ctrl->ops->set_mdio_dir(ctrl, 0);
+ 
+-	/* check the turnaround bit: the PHY should be driving it to zero, if this
+-	 * PHY is listed in phy_ignore_ta_mask as having broken TA, skip that
+-	 */
+-	if (mdiobb_get_bit(ctrl) != 0 &&
+-	    !(bus->phy_ignore_ta_mask & (1 << phy))) {
+-		/* PHY didn't drive TA low -- flush any bits it
+-		 * may be trying to send.
+-		 */
+-		for (i = 0; i < 32; i++)
+-			mdiobb_get_bit(ctrl);
+-
+-		return 0xffff;
+-	}
++	mdiobb_get_bit(ctrl);
+ 
+ 	ret = mdiobb_get_num(ctrl, 16);
+ 	mdiobb_get_bit(ctrl);
diff --git a/target/linux/ath79/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch b/target/linux/ath79/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
new file mode 100644
index 0000000000..a830346a31
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
@@ -0,0 +1,61 @@
+From 66e584435ac0de6e0abeb6d7166fe4fe25d6bb73 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Tue, 16 Jun 2015 13:15:08 +0200
+Subject: [PATCH] phy/mdio-bitbang: prevent rescheduling during command
+
+It seems some phys have some maximum timings for accessing the MDIO line,
+resulting in bit errors under cpu stress. Prevent this from happening by
+disabling interrupts when sending commands.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ drivers/net/phy/mdio-bitbang.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+--- a/drivers/net/phy/mdio-bitbang.c
++++ b/drivers/net/phy/mdio-bitbang.c
+@@ -17,6 +17,7 @@
+  * kind, whether express or implied.
+  */
+ 
++#include <linux/irqflags.h>
+ #include <linux/module.h>
+ #include <linux/mdio-bitbang.h>
+ #include <linux/types.h>
+@@ -156,7 +157,9 @@ static int mdiobb_read(struct mii_bus *b
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
+ 	int ret;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+ 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
+@@ -169,13 +172,17 @@ static int mdiobb_read(struct mii_bus *b
+ 
+ 	ret = mdiobb_get_num(ctrl, 16);
+ 	mdiobb_get_bit(ctrl);
++	local_irq_restore(flags);
++
+ 	return ret;
+ }
+ 
+ static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+ 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
+@@ -190,6 +197,8 @@ static int mdiobb_write(struct mii_bus *
+ 
+ 	ctrl->ops->set_mdio_dir(ctrl, 0);
+ 	mdiobb_get_bit(ctrl);
++	local_irq_restore(flags);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/ath79/patches-4.14/910-unaligned_access_hacks.patch b/target/linux/ath79/patches-4.14/910-unaligned_access_hacks.patch
new file mode 100644
index 0000000000..9897679a62
--- /dev/null
+++ b/target/linux/ath79/patches-4.14/910-unaligned_access_hacks.patch
@@ -0,0 +1,900 @@
+--- a/arch/mips/include/asm/checksum.h
++++ b/arch/mips/include/asm/checksum.h
+@@ -134,26 +134,30 @@ static inline __sum16 ip_fast_csum(const
+ 	const unsigned int *stop = word + ihl;
+ 	unsigned int csum;
+ 	int carry;
++	unsigned int w;
+ 
+-	csum = word[0];
+-	csum += word[1];
+-	carry = (csum < word[1]);
++	csum = net_hdr_word(word++);
++
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	csum += word[2];
+-	carry = (csum < word[2]);
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	csum += word[3];
+-	carry = (csum < word[3]);
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	word += 4;
+ 	do {
+-		csum += *word;
+-		carry = (csum < *word);
++		w = net_hdr_word(word++);
++		csum += w;
++		carry = (csum < w);
+ 		csum += carry;
+-		word++;
+ 	} while (word != stop);
+ 
+ 	return csum_fold(csum);
+@@ -214,73 +218,6 @@ static inline __sum16 ip_compute_csum(co
+ 	return csum_fold(csum_partial(buff, len, 0));
+ }
+ 
+-#define _HAVE_ARCH_IPV6_CSUM
+-static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
+-					  const struct in6_addr *daddr,
+-					  __u32 len, __u8 proto,
+-					  __wsum sum)
+-{
+-	__wsum tmp;
+-
+-	__asm__(
+-	"	.set	push		# csum_ipv6_magic\n"
+-	"	.set	noreorder	\n"
+-	"	.set	noat		\n"
+-	"	addu	%0, %5		# proto (long in network byte order)\n"
+-	"	sltu	$1, %0, %5	\n"
+-	"	addu	%0, $1		\n"
+-
+-	"	addu	%0, %6		# csum\n"
+-	"	sltu	$1, %0, %6	\n"
+-	"	lw	%1, 0(%2)	# four words source address\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 4(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 8(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 12(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 0(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 4(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 8(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 12(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	addu	%0, $1		# Add final carry\n"
+-	"	.set	pop"
+-	: "=&r" (sum), "=&r" (tmp)
+-	: "r" (saddr), "r" (daddr),
+-	  "0" (htonl(len)), "r" (htonl(proto)), "r" (sum));
+-
+-	return csum_fold(sum);
+-}
+-
+ #include <asm-generic/checksum.h>
+ #endif /* CONFIG_GENERIC_CSUM */
+ 
+--- a/include/uapi/linux/ip.h
++++ b/include/uapi/linux/ip.h
+@@ -103,7 +103,7 @@ struct iphdr {
+ 	__be32	saddr;
+ 	__be32	daddr;
+ 	/*The options start here. */
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ struct ip_auth_hdr {
+--- a/include/uapi/linux/ipv6.h
++++ b/include/uapi/linux/ipv6.h
+@@ -131,7 +131,7 @@ struct ipv6hdr {
+ 
+ 	struct	in6_addr	saddr;
+ 	struct	in6_addr	daddr;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ /* index values for the variables in ipv6_devconf */
+--- a/include/uapi/linux/tcp.h
++++ b/include/uapi/linux/tcp.h
+@@ -55,7 +55,7 @@ struct tcphdr {
+ 	__be16	window;
+ 	__sum16	check;
+ 	__be16	urg_ptr;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /*
+  *	The union cast uses a gcc extension to avoid aliasing problems
+@@ -65,7 +65,7 @@ struct tcphdr {
+ union tcp_word_hdr { 
+ 	struct tcphdr hdr;
+ 	__be32 		  words[5];
+-}; 
++} __attribute__((packed, aligned(2)));
+ 
+ #define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+ 
+--- a/include/uapi/linux/udp.h
++++ b/include/uapi/linux/udp.h
+@@ -25,7 +25,7 @@ struct udphdr {
+ 	__be16	dest;
+ 	__be16	len;
+ 	__sum16	check;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /* UDP socket options */
+ #define UDP_CORK	1	/* Never send partially complete segments */
+--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
++++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+@@ -48,8 +48,8 @@ static bool ipv4_pkt_to_tuple(const stru
+ 	if (ap == NULL)
+ 		return false;
+ 
+-	tuple->src.u3.ip = ap[0];
+-	tuple->dst.u3.ip = ap[1];
++	tuple->src.u3.ip = net_hdr_word(ap++);
++	tuple->dst.u3.ip = net_hdr_word(ap);
+ 
+ 	return true;
+ }
+--- a/include/uapi/linux/icmp.h
++++ b/include/uapi/linux/icmp.h
+@@ -82,7 +82,7 @@ struct icmphdr {
+ 	} frag;
+ 	__u8	reserved[4];
+   } un;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ /*
+--- a/include/uapi/linux/in6.h
++++ b/include/uapi/linux/in6.h
+@@ -43,7 +43,7 @@ struct in6_addr {
+ #define s6_addr16		in6_u.u6_addr16
+ #define s6_addr32		in6_u.u6_addr32
+ #endif
+-};
++} __attribute__((packed, aligned(2)));
+ #endif /* __UAPI_DEF_IN6_ADDR */
+ 
+ #if __UAPI_DEF_SOCKADDR_IN6
+--- a/net/ipv6/tcp_ipv6.c
++++ b/net/ipv6/tcp_ipv6.c
+@@ -39,6 +39,7 @@
+ #include <linux/ipsec.h>
+ #include <linux/times.h>
+ #include <linux/slab.h>
++#include <asm/unaligned.h>
+ #include <linux/uaccess.h>
+ #include <linux/ipv6.h>
+ #include <linux/icmpv6.h>
+@@ -819,10 +820,10 @@ static void tcp_v6_send_response(const s
+ 	topt = (__be32 *)(t1 + 1);
+ 
+ 	if (tsecr) {
+-		*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+-				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
+-		*topt++ = htonl(tsval);
+-		*topt++ = htonl(tsecr);
++		put_unaligned_be32((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP, topt++);
++		put_unaligned_be32(tsval, topt++);
++		put_unaligned_be32(tsecr, topt++);
+ 	}
+ 
+ #ifdef CONFIG_TCP_MD5SIG
+--- a/include/linux/ipv6.h
++++ b/include/linux/ipv6.h
+@@ -6,6 +6,7 @@
+ 
+ #define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
+ #define ipv6_authlen(p) (((p)->hdrlen+2) << 2)
++
+ /*
+  * This structure contains configuration options per IPv6 link.
+  */
+--- a/net/ipv6/datagram.c
++++ b/net/ipv6/datagram.c
+@@ -485,7 +485,7 @@ int ipv6_recv_error(struct sock *sk, str
+ 				ipv6_iface_scope_id(&sin->sin6_addr,
+ 						    IP6CB(skb)->iif);
+ 		} else {
+-			ipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),
++			ipv6_addr_set_v4mapped(net_hdr_word(nh + serr->addr_offset),
+ 					       &sin->sin6_addr);
+ 			sin->sin6_scope_id = 0;
+ 		}
+@@ -833,12 +833,12 @@ int ip6_datagram_send_ctl(struct net *ne
+ 			}
+ 
+ 			if (fl6->flowlabel&IPV6_FLOWINFO_MASK) {
+-				if ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {
++				if ((fl6->flowlabel^net_hdr_word(CMSG_DATA(cmsg)))&~IPV6_FLOWINFO_MASK) {
+ 					err = -EINVAL;
+ 					goto exit_f;
+ 				}
+ 			}
+-			fl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);
++			fl6->flowlabel = IPV6_FLOWINFO_MASK & net_hdr_word(CMSG_DATA(cmsg));
+ 			break;
+ 
+ 		case IPV6_2292HOPOPTS:
+--- a/net/ipv6/ip6_gre.c
++++ b/net/ipv6/ip6_gre.c
+@@ -397,7 +397,7 @@ static void ip6gre_err(struct sk_buff *s
+ 		return;
+ 	ipv6h = (const struct ipv6hdr *)skb->data;
+ 	greh = (const struct gre_base_hdr *)(skb->data + offset);
+-	key = key_off ? *(__be32 *)(skb->data + key_off) : 0;
++	key = key_off ? net_hdr_word((__be32 *)(skb->data + key_off)) : 0;
+ 
+ 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
+ 				 key, greh->protocol);
+--- a/net/ipv6/exthdrs.c
++++ b/net/ipv6/exthdrs.c
+@@ -733,7 +733,7 @@ static bool ipv6_hop_jumbo(struct sk_buf
+ 		goto drop;
+ 	}
+ 
+-	pkt_len = ntohl(*(__be32 *)(nh + optoff + 2));
++	pkt_len = ntohl(net_hdr_word(nh + optoff + 2));
+ 	if (pkt_len <= IPV6_MAXPLEN) {
+ 		__IP6_INC_STATS(net, ipv6_skb_idev(skb),
+ 				IPSTATS_MIB_INHDRERRORS);
+--- a/include/linux/types.h
++++ b/include/linux/types.h
+@@ -229,5 +229,11 @@ struct callback_head {
+ typedef void (*rcu_callback_t)(struct rcu_head *head);
+ typedef void (*call_rcu_func_t)(struct rcu_head *head, rcu_callback_t func);
+ 
++struct net_hdr_word {
++       u32 words[1];
++} __attribute__((packed, aligned(2)));
++
++#define net_hdr_word(_p) (((struct net_hdr_word *) (_p))->words[0])
++
+ #endif /*  __ASSEMBLY__ */
+ #endif /* _LINUX_TYPES_H */
+--- a/net/ipv4/af_inet.c
++++ b/net/ipv4/af_inet.c
+@@ -1351,8 +1351,8 @@ struct sk_buff **inet_gro_receive(struct
+ 	if (unlikely(ip_fast_csum((u8 *)iph, 5)))
+ 		goto out_unlock;
+ 
+-	id = ntohl(*(__be32 *)&iph->id);
+-	flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));
++	id = ntohl(net_hdr_word(&iph->id));
++	flush = (u16)((ntohl(net_hdr_word(iph)) ^ skb_gro_len(skb)) | (id & ~IP_DF));
+ 	id >>= 16;
+ 
+ 	for (p = *head; p; p = p->next) {
+--- a/net/ipv4/route.c
++++ b/net/ipv4/route.c
+@@ -465,7 +465,7 @@ static struct neighbour *ipv4_neigh_look
+ 	else if (skb)
+ 		pkey = &ip_hdr(skb)->daddr;
+ 
+-	n = __ipv4_neigh_lookup(dev, *(__force u32 *)pkey);
++	n = __ipv4_neigh_lookup(dev, net_hdr_word(pkey));
+ 	if (n)
+ 		return n;
+ 	return neigh_create(&arp_tbl, pkey, dev);
+--- a/net/ipv4/tcp_output.c
++++ b/net/ipv4/tcp_output.c
+@@ -449,48 +449,53 @@ static void tcp_options_write(__be32 *pt
+ 	u16 options = opts->options;	/* mungable copy */
+ 
+ 	if (unlikely(OPTION_MD5 & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+-			       (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++			      (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
+ 		/* overload cookie hash location */
+ 		opts->hash_location = (__u8 *)ptr;
+ 		ptr += 4;
+ 	}
+ 
+ 	if (unlikely(opts->mss)) {
+-		*ptr++ = htonl((TCPOPT_MSS << 24) |
+-			       (TCPOLEN_MSS << 16) |
+-			       opts->mss);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) |
++			      opts->mss);
+ 	}
+ 
+ 	if (likely(OPTION_TS & options)) {
+ 		if (unlikely(OPTION_SACK_ADVERTISE & options)) {
+-			*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |
+-				       (TCPOLEN_SACK_PERM << 16) |
+-				       (TCPOPT_TIMESTAMP << 8) |
+-				       TCPOLEN_TIMESTAMP);
++			net_hdr_word(ptr++) =
++				htonl((TCPOPT_SACK_PERM << 24) |
++				      (TCPOLEN_SACK_PERM << 16) |
++				      (TCPOPT_TIMESTAMP << 8) |
++				      TCPOLEN_TIMESTAMP);
+ 			options &= ~OPTION_SACK_ADVERTISE;
+ 		} else {
+-			*ptr++ = htonl((TCPOPT_NOP << 24) |
+-				       (TCPOPT_NOP << 16) |
+-				       (TCPOPT_TIMESTAMP << 8) |
+-				       TCPOLEN_TIMESTAMP);
++			net_hdr_word(ptr++) =
++				htonl((TCPOPT_NOP << 24) |
++				      (TCPOPT_NOP << 16) |
++				      (TCPOPT_TIMESTAMP << 8) |
++				      TCPOLEN_TIMESTAMP);
+ 		}
+-		*ptr++ = htonl(opts->tsval);
+-		*ptr++ = htonl(opts->tsecr);
++		net_hdr_word(ptr++) = htonl(opts->tsval);
++		net_hdr_word(ptr++) = htonl(opts->tsecr);
+ 	}
+ 
+ 	if (unlikely(OPTION_SACK_ADVERTISE & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) |
+-			       (TCPOPT_NOP << 16) |
+-			       (TCPOPT_SACK_PERM << 8) |
+-			       TCPOLEN_SACK_PERM);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_NOP << 16) |
++			      (TCPOPT_SACK_PERM << 8) |
++			      TCPOLEN_SACK_PERM);
+ 	}
+ 
+ 	if (unlikely(OPTION_WSCALE & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) |
+-			       (TCPOPT_WINDOW << 16) |
+-			       (TCPOLEN_WINDOW << 8) |
+-			       opts->ws);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_WINDOW << 16) |
++			      (TCPOLEN_WINDOW << 8) |
++			      opts->ws);
+ 	}
+ 
+ 	if (unlikely(opts->num_sack_blocks)) {
+@@ -498,16 +503,17 @@ static void tcp_options_write(__be32 *pt
+ 			tp->duplicate_sack : tp->selective_acks;
+ 		int this_sack;
+ 
+-		*ptr++ = htonl((TCPOPT_NOP  << 24) |
+-			       (TCPOPT_NOP  << 16) |
+-			       (TCPOPT_SACK <<  8) |
+-			       (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_NOP << 16) |
++			      (TCPOPT_SACK << 8) |
++			      (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
+ 						     TCPOLEN_SACK_PERBLOCK)));
+ 
+ 		for (this_sack = 0; this_sack < opts->num_sack_blocks;
+ 		     ++this_sack) {
+-			*ptr++ = htonl(sp[this_sack].start_seq);
+-			*ptr++ = htonl(sp[this_sack].end_seq);
++			net_hdr_word(ptr++) = htonl(sp[this_sack].start_seq);
++			net_hdr_word(ptr++) = htonl(sp[this_sack].end_seq);
+ 		}
+ 
+ 		tp->rx_opt.dsack = 0;
+@@ -520,13 +526,14 @@ static void tcp_options_write(__be32 *pt
+ 
+ 		if (foc->exp) {
+ 			len = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
+-			*ptr = htonl((TCPOPT_EXP << 24) | (len << 16) |
++			net_hdr_word(ptr) =
++				htonl((TCPOPT_EXP << 24) | (len << 16) |
+ 				     TCPOPT_FASTOPEN_MAGIC);
+ 			p += TCPOLEN_EXP_FASTOPEN_BASE;
+ 		} else {
+ 			len = TCPOLEN_FASTOPEN_BASE + foc->len;
+-			*p++ = TCPOPT_FASTOPEN;
+-			*p++ = len;
++			net_hdr_word(p++) = TCPOPT_FASTOPEN;
++			net_hdr_word(p++) = len;
+ 		}
+ 
+ 		memcpy(p, foc->val, foc->len);
+--- a/include/uapi/linux/igmp.h
++++ b/include/uapi/linux/igmp.h
+@@ -33,7 +33,7 @@ struct igmphdr {
+ 	__u8 code;		/* For newer IGMP */
+ 	__sum16 csum;
+ 	__be32 group;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /* V3 group record types [grec_type] */
+ #define IGMPV3_MODE_IS_INCLUDE		1
+@@ -49,7 +49,7 @@ struct igmpv3_grec {
+ 	__be16	grec_nsrcs;
+ 	__be32	grec_mca;
+ 	__be32	grec_src[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct igmpv3_report {
+ 	__u8 type;
+@@ -58,7 +58,7 @@ struct igmpv3_report {
+ 	__be16 resv2;
+ 	__be16 ngrec;
+ 	struct igmpv3_grec grec[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct igmpv3_query {
+ 	__u8 type;
+@@ -79,7 +79,7 @@ struct igmpv3_query {
+ 	__u8 qqic;
+ 	__be16 nsrcs;
+ 	__be32 srcs[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
+ #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
+--- a/net/core/flow_dissector.c
++++ b/net/core/flow_dissector.c
+@@ -108,7 +108,7 @@ __be32 __skb_flow_get_ports(const struct
+ 		ports = __skb_header_pointer(skb, thoff + poff,
+ 					     sizeof(_ports), data, hlen, &_ports);
+ 		if (ports)
+-			return *ports;
++			return (__be32)net_hdr_word(ports);
+ 	}
+ 
+ 	return 0;
+--- a/include/uapi/linux/icmpv6.h
++++ b/include/uapi/linux/icmpv6.h
+@@ -77,7 +77,7 @@ struct icmp6hdr {
+ #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
+ #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
+ #define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ #define ICMPV6_ROUTER_PREF_LOW		0x3
+--- a/include/net/ndisc.h
++++ b/include/net/ndisc.h
+@@ -89,7 +89,7 @@ struct ra_msg {
+         struct icmp6hdr		icmph;
+ 	__be32			reachable_time;
+ 	__be32			retrans_timer;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct rd_msg {
+ 	struct icmp6hdr icmph;
+@@ -368,10 +368,10 @@ static inline u32 ndisc_hashfn(const voi
+ {
+ 	const u32 *p32 = pkey;
+ 
+-	return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
+-		(p32[1] * hash_rnd[1]) +
+-		(p32[2] * hash_rnd[2]) +
+-		(p32[3] * hash_rnd[3]));
++	return (((net_hdr_word(&p32[0]) ^ hash32_ptr(dev)) * hash_rnd[0]) +
++		(net_hdr_word(&p32[1]) * hash_rnd[1]) +
++		(net_hdr_word(&p32[2]) * hash_rnd[2]) +
++		(net_hdr_word(&p32[3]) * hash_rnd[3]));
+ }
+ 
+ static inline struct neighbour *__ipv6_neigh_lookup_noref(struct net_device *dev, const void *pkey)
+--- a/net/sched/cls_u32.c
++++ b/net/sched/cls_u32.c
+@@ -165,7 +165,7 @@ next_knode:
+ 			data = skb_header_pointer(skb, toff, 4, &hdata);
+ 			if (!data)
+ 				goto out;
+-			if ((*data ^ key->val) & key->mask) {
++			if ((net_hdr_word(data) ^ key->val) & key->mask) {
+ 				n = rcu_dereference_bh(n->next);
+ 				goto next_knode;
+ 			}
+@@ -218,8 +218,8 @@ check_terminal:
+ 						  &hdata);
+ 			if (!data)
+ 				goto out;
+-			sel = ht->divisor & u32_hash_fold(*data, &n->sel,
+-							  n->fshift);
++			sel = ht->divisor & u32_hash_fold(net_hdr_word(data),
++							  &n->sel, n->fshift);
+ 		}
+ 		if (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))
+ 			goto next_ht;
+--- a/net/ipv6/ip6_offload.c
++++ b/net/ipv6/ip6_offload.c
+@@ -220,7 +220,7 @@ static struct sk_buff **ipv6_gro_receive
+ 			continue;
+ 
+ 		iph2 = (struct ipv6hdr *)(p->data + off);
+-		first_word = *(__be32 *)iph ^ *(__be32 *)iph2;
++		first_word = net_hdr_word(iph) ^ net_hdr_word(iph2);
+ 
+ 		/* All fields must match except length and Traffic Class.
+ 		 * XXX skbs on the gro_list have all been parsed and pulled
+--- a/include/net/addrconf.h
++++ b/include/net/addrconf.h
+@@ -47,7 +47,7 @@ struct prefix_info {
+ 	__be32			reserved2;
+ 
+ 	struct in6_addr		prefix;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #include <linux/netdevice.h>
+ #include <net/if_inet6.h>
+--- a/include/net/inet_ecn.h
++++ b/include/net/inet_ecn.h
+@@ -125,9 +125,9 @@ static inline int IP6_ECN_set_ce(struct
+ 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
+ 		return 0;
+ 
+-	from = *(__be32 *)iph;
++	from = net_hdr_word(iph);
+ 	to = from | htonl(INET_ECN_CE << 20);
+-	*(__be32 *)iph = to;
++	net_hdr_word(iph) = to;
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_add(csum_sub(skb->csum, (__force __wsum)from),
+ 				     (__force __wsum)to);
+@@ -136,7 +136,7 @@ static inline int IP6_ECN_set_ce(struct
+ 
+ static inline void IP6_ECN_clear(struct ipv6hdr *iph)
+ {
+-	*(__be32*)iph &= ~htonl(INET_ECN_MASK << 20);
++	net_hdr_word(iph) &= ~htonl(INET_ECN_MASK << 20);
+ }
+ 
+ static inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
+--- a/include/net/ipv6.h
++++ b/include/net/ipv6.h
+@@ -108,7 +108,7 @@ struct frag_hdr {
+ 	__u8	reserved;
+ 	__be16	frag_off;
+ 	__be32	identification;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #define	IP6_MF		0x0001
+ #define	IP6_OFFSET	0xFFF8
+@@ -451,8 +451,8 @@ static inline void __ipv6_addr_set_half(
+ 	}
+ #endif
+ #endif
+-	addr[0] = wh;
+-	addr[1] = wl;
++	net_hdr_word(&addr[0]) = wh;
++	net_hdr_word(&addr[1]) = wl;
+ }
+ 
+ static inline void ipv6_addr_set(struct in6_addr *addr, 
+@@ -511,6 +511,8 @@ static inline bool ipv6_prefix_equal(con
+ 	const __be32 *a1 = addr1->s6_addr32;
+ 	const __be32 *a2 = addr2->s6_addr32;
+ 	unsigned int pdw, pbi;
++	/* Used for last <32-bit fraction of prefix */
++	u32 pbia1, pbia2;
+ 
+ 	/* check complete u32 in prefix */
+ 	pdw = prefixlen >> 5;
+@@ -519,7 +521,9 @@ static inline bool ipv6_prefix_equal(con
+ 
+ 	/* check incomplete u32 in prefix */
+ 	pbi = prefixlen & 0x1f;
+-	if (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))
++	pbia1 = net_hdr_word(&a1[pdw]);
++	pbia2 = net_hdr_word(&a2[pdw]);
++	if (pbi && ((pbia1 ^ pbia2) & htonl((0xffffffff) << (32 - pbi))))
+ 		return false;
+ 
+ 	return true;
+@@ -663,13 +667,13 @@ static inline void ipv6_addr_set_v4mappe
+  */
+ static inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)
+ {
+-	const __be32 *a1 = token1, *a2 = token2;
++	const struct in6_addr *a1 = token1, *a2 = token2;
+ 	int i;
+ 
+ 	addrlen >>= 2;
+ 
+ 	for (i = 0; i < addrlen; i++) {
+-		__be32 xb = a1[i] ^ a2[i];
++		__be32 xb = a1->s6_addr32[i] ^ a2->s6_addr32[i];
+ 		if (xb)
+ 			return i * 32 + 31 - __fls(ntohl(xb));
+ 	}
+@@ -838,17 +842,18 @@ static inline int ip6_default_np_autolab
+ static inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,
+ 				__be32 flowlabel)
+ {
+-	*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;
++	net_hdr_word((__be32 *)hdr) =
++		htonl(0x60000000 | (tclass << 20)) | flowlabel;
+ }
+ 
+ static inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)
+ {
+-	return *(__be32 *)hdr & IPV6_FLOWINFO_MASK;
++	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWINFO_MASK;
+ }
+ 
+ static inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)
+ {
+-	return *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;
++	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWLABEL_MASK;
+ }
+ 
+ static inline u8 ip6_tclass(__be32 flowinfo)
+--- a/include/net/secure_seq.h
++++ b/include/net/secure_seq.h
+@@ -3,6 +3,7 @@
+ #define _NET_SECURE_SEQ
+ 
+ #include <linux/types.h>
++#include <linux/in6.h>
+ 
+ u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
+ u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
+--- a/include/uapi/linux/in.h
++++ b/include/uapi/linux/in.h
+@@ -84,7 +84,7 @@ enum {
+ /* Internet address. */
+ struct in_addr {
+ 	__be32	s_addr;
+-};
++} __attribute__((packed, aligned(2)));
+ #endif
+ 
+ #define IP_TOS		1
+--- a/net/ipv6/ip6_fib.c
++++ b/net/ipv6/ip6_fib.c
+@@ -137,7 +137,7 @@ static __be32 addr_bit_set(const void *t
+ 	 * See include/asm-generic/bitops/le.h.
+ 	 */
+ 	return (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &
+-	       addr[fn_bit >> 5];
++	       net_hdr_word(&addr[fn_bit >> 5]);
+ }
+ 
+ static struct fib6_node *node_alloc(void)
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -447,7 +447,7 @@ static void tcp_sack(const struct sk_buf
+ 
+ 	/* Fast path for timestamp-only option */
+ 	if (length == TCPOLEN_TSTAMP_ALIGNED
+-	    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)
++	    && net_hdr_word(ptr) == htonl((TCPOPT_NOP << 24)
+ 				       | (TCPOPT_NOP << 16)
+ 				       | (TCPOPT_TIMESTAMP << 8)
+ 				       | TCPOLEN_TIMESTAMP))
+--- a/net/xfrm/xfrm_input.c
++++ b/net/xfrm/xfrm_input.c
+@@ -193,8 +193,8 @@ int xfrm_parse_spi(struct sk_buff *skb,
+ 	if (!pskb_may_pull(skb, hlen))
+ 		return -EINVAL;
+ 
+-	*spi = *(__be32 *)(skb_transport_header(skb) + offset);
+-	*seq = *(__be32 *)(skb_transport_header(skb) + offset_seq);
++	*spi = net_hdr_word(skb_transport_header(skb) + offset);
++	*seq = net_hdr_word(skb_transport_header(skb) + offset_seq);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(xfrm_parse_spi);
+--- a/net/ipv4/tcp_input.c
++++ b/net/ipv4/tcp_input.c
+@@ -3844,14 +3844,16 @@ static bool tcp_parse_aligned_timestamp(
+ {
+ 	const __be32 *ptr = (const __be32 *)(th + 1);
+ 
+-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
+-			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
++	if (net_hdr_word(ptr) ==
++	    htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++		  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
+ 		tp->rx_opt.saw_tstamp = 1;
+ 		++ptr;
+-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
++		tp->rx_opt.rcv_tsval = get_unaligned_be32(ptr);
+ 		++ptr;
+-		if (*ptr)
+-			tp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;
++		if (net_hdr_word(ptr))
++			tp->rx_opt.rcv_tsecr = get_unaligned_be32(ptr) -
++					       tp->tsoffset;
+ 		else
+ 			tp->rx_opt.rcv_tsecr = 0;
+ 		return true;
+--- a/include/uapi/linux/if_pppox.h
++++ b/include/uapi/linux/if_pppox.h
+@@ -51,6 +51,7 @@ struct pppoe_addr {
+  */
+ struct pptp_addr {
+ 	__u16		call_id;
++	__u16		pad;
+ 	struct in_addr	sin_addr;
+ };
+ 
+--- a/net/ipv6/netfilter/nf_log_ipv6.c
++++ b/net/ipv6/netfilter/nf_log_ipv6.c
+@@ -66,9 +66,9 @@ static void dump_ipv6_packet(struct nf_l
+ 	/* Max length: 44 "LEN=65535 TC=255 HOPLIMIT=255 FLOWLBL=FFFFF " */
+ 	nf_log_buf_add(m, "LEN=%zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",
+ 	       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),
+-	       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,
++	       (ntohl(net_hdr_word(ih)) & 0x0ff00000) >> 20,
+ 	       ih->hop_limit,
+-	       (ntohl(*(__be32 *)ih) & 0x000fffff));
++	       (ntohl(net_hdr_word(ih)) & 0x000fffff));
+ 
+ 	fragment = 0;
+ 	ptr = ip6hoff + sizeof(struct ipv6hdr);
+--- a/include/net/neighbour.h
++++ b/include/net/neighbour.h
+@@ -265,8 +265,10 @@ static inline bool neigh_key_eq128(const
+ 	const u32 *n32 = (const u32 *)n->primary_key;
+ 	const u32 *p32 = pkey;
+ 
+-	return ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
+-		(n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0;
++	return ((n32[0] ^ net_hdr_word(&p32[0])) |
++		(n32[1] ^ net_hdr_word(&p32[1])) |
++		(n32[2] ^ net_hdr_word(&p32[2])) |
++		(n32[3] ^ net_hdr_word(&p32[3]))) == 0;
+ }
+ 
+ static inline struct neighbour *___neigh_lookup_noref(
+--- a/include/uapi/linux/netfilter_arp/arp_tables.h
++++ b/include/uapi/linux/netfilter_arp/arp_tables.h
+@@ -70,7 +70,7 @@ struct arpt_arp {
+ 	__u8 flags;
+ 	/* Inverse flags */
+ 	__u16 invflags;
+-};
++} __attribute__((aligned(4)));
+ 
+ /* Values for "flag" field in struct arpt_ip (general arp structure).
+  * No flags defined yet.
+--- a/net/core/utils.c
++++ b/net/core/utils.c
+@@ -424,8 +424,14 @@ void inet_proto_csum_replace16(__sum16 *
+ 			       bool pseudohdr)
+ {
+ 	__be32 diff[] = {
+-		~from[0], ~from[1], ~from[2], ~from[3],
+-		to[0], to[1], to[2], to[3],
++		~net_hdr_word(&from[0]),
++		~net_hdr_word(&from[1]),
++		~net_hdr_word(&from[2]),
++		~net_hdr_word(&from[3]),
++		net_hdr_word(&to[0]),
++		net_hdr_word(&to[1]),
++		net_hdr_word(&to[2]),
++		net_hdr_word(&to[3]),
+ 	};
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+ 		*sum = csum_fold(csum_partial(diff, sizeof(diff),
+--- a/include/linux/etherdevice.h
++++ b/include/linux/etherdevice.h
+@@ -480,7 +480,7 @@ static inline bool is_etherdev_addr(cons
+  * @b: Pointer to Ethernet header
+  *
+  * Compare two Ethernet headers, returns 0 if equal.
+- * This assumes that the network header (i.e., IP header) is 4-byte
++ * This assumes that the network header (i.e., IP header) is 2-byte
+  * aligned OR the platform can handle unaligned access.  This is the
+  * case for all packets coming into netif_receive_skb or similar
+  * entry points.
+@@ -503,11 +503,12 @@ static inline unsigned long compare_ethe
+ 	fold |= *(unsigned long *)(a + 6) ^ *(unsigned long *)(b + 6);
+ 	return fold;
+ #else
+-	u32 *a32 = (u32 *)((u8 *)a + 2);
+-	u32 *b32 = (u32 *)((u8 *)b + 2);
++	const u16 *a16 = a;
++	const u16 *b16 = b;
+ 
+-	return (*(u16 *)a ^ *(u16 *)b) | (a32[0] ^ b32[0]) |
+-	       (a32[1] ^ b32[1]) | (a32[2] ^ b32[2]);
++	return (a16[0] ^ b16[0]) | (a16[1] ^ b16[1]) | (a16[2] ^ b16[2]) |
++	       (a16[3] ^ b16[3]) | (a16[4] ^ b16[4]) | (a16[5] ^ b16[5]) |
++	       (a16[6] ^ b16[6]);
+ #endif
+ }
+ 
+--- a/net/ipv4/tcp_offload.c
++++ b/net/ipv4/tcp_offload.c
+@@ -226,7 +226,7 @@ struct sk_buff **tcp_gro_receive(struct
+ 
+ 		th2 = tcp_hdr(p);
+ 
+-		if (*(u32 *)&th->source ^ *(u32 *)&th2->source) {
++		if (net_hdr_word(&th->source) ^ net_hdr_word(&th2->source)) {
+ 			NAPI_GRO_CB(p)->same_flow = 0;
+ 			continue;
+ 		}
+@@ -244,8 +244,8 @@ found:
+ 		  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));
+ 	flush |= (__force int)(th->ack_seq ^ th2->ack_seq);
+ 	for (i = sizeof(*th); i < thlen; i += 4)
+-		flush |= *(u32 *)((u8 *)th + i) ^
+-			 *(u32 *)((u8 *)th2 + i);
++		flush |= net_hdr_word((u8 *)th + i) ^
++			 net_hdr_word((u8 *)th2 + i);
+ 
+ 	/* When we receive our second frame we can made a decision on if we
+ 	 * continue this flow as an atomic flow with a fixed ID or if we use
+--- a/net/ipv6/netfilter/ip6table_mangle.c
++++ b/net/ipv6/netfilter/ip6table_mangle.c
+@@ -50,7 +50,7 @@ ip6t_mangle_out(struct sk_buff *skb, con
+ 	hop_limit = ipv6_hdr(skb)->hop_limit;
+ 
+ 	/* flowlabel and prio (includes version, which shouldn't change either */
+-	flowlabel = *((u_int32_t *)ipv6_hdr(skb));
++	flowlabel = net_hdr_word(ipv6_hdr(skb));
+ 
+ 	ret = ip6t_do_table(skb, state, state->net->ipv6.ip6table_mangle);
+ 
+@@ -59,7 +59,7 @@ ip6t_mangle_out(struct sk_buff *skb, con
+ 	     !ipv6_addr_equal(&ipv6_hdr(skb)->daddr, &daddr) ||
+ 	     skb->mark != mark ||
+ 	     ipv6_hdr(skb)->hop_limit != hop_limit ||
+-	     flowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {
++	     flowlabel != net_hdr_word(ipv6_hdr(skb)))) {
+ 		err = ip6_route_me_harder(state->net, skb);
+ 		if (err < 0)
+ 			ret = NF_DROP_ERR(err);
diff --git a/target/linux/ath79/tiny/config-default b/target/linux/ath79/tiny/config-default
new file mode 100644
index 0000000000..01af54446d
--- /dev/null
+++ b/target/linux/ath79/tiny/config-default
@@ -0,0 +1,14 @@
+CONFIG_BLK_MQ_PCI=y
+CONFIG_LEDS_RESET=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_PCI=y
+CONFIG_PCI_AR71XX=y
+CONFIG_PCI_AR724X=y
+CONFIG_PCI_DISABLE_COMMON_QUIRKS=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PHY_AR7100_USB=y
+CONFIG_PHY_AR7200_USB=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
diff --git a/target/linux/ath79/tiny/profiles/00-default.mk b/target/linux/ath79/tiny/profiles/00-default.mk
new file mode 100644
index 0000000000..aa8e1195f8
--- /dev/null
+++ b/target/linux/ath79/tiny/profiles/00-default.mk
@@ -0,0 +1,9 @@
+define Profile/Default
+	NAME:=Default Profile (all drivers)
+	PRIORITY := 1
+endef
+
+define Profile/Default/Description
+	Default package set compatible with most boards.
+endef
+$(eval $(call Profile,Default))
diff --git a/target/linux/ath79/tiny/target.mk b/target/linux/ath79/tiny/target.mk
new file mode 100644
index 0000000000..87af3ef2bf
--- /dev/null
+++ b/target/linux/ath79/tiny/target.mk
@@ -0,0 +1,6 @@
+BOARDNAME:=Devices with small flash
+FEATURES += squashfs small_flash
+
+define Target/Description
+	Build firmware images for Atheros AR71xx/AR913x/AR934x based boards with small flash
+endef
-- 
2.18.0

