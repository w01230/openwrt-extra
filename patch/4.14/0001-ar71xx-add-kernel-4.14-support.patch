From 6485f9628834b2b7298552cee1a62a1a9e46ab5f Mon Sep 17 00:00:00 2001
From: jollaman999 <admin@jollaman999.com>
Date: Tue, 5 Jun 2018 11:08:15 +0900
Subject: [PATCH 1/5] ar71xx: add kernel 4.14 support

Copied from kernel 4.9 and refreshed for kernel 4.14.

Signed-off-by: jollaman999 <admin@jollaman999.com>
---
 target/linux/ar71xx/config-4.14               |  479 ++++
 .../arch/mips/ath79/Kconfig.openwrt           |    0
 .../files-4.14/arch/mips/ath79/Makefile       |  284 ++
 .../arch/mips/ath79/dev-ap9x-pci.c            |    0
 .../arch/mips/ath79/dev-ap9x-pci.h            |    0
 .../arch/mips/ath79/dev-dsa.c                 |    0
 .../arch/mips/ath79/dev-dsa.h                 |    0
 .../arch/mips/ath79/dev-eth.c                 |    0
 .../arch/mips/ath79/dev-eth.h                 |    0
 .../arch/mips/ath79/dev-m25p80.c              |    0
 .../arch/mips/ath79/dev-m25p80.h              |    0
 .../arch/mips/ath79/dev-nfc.c                 |    0
 .../arch/mips/ath79/dev-nfc.h                 |    0
 .../files-4.14/arch/mips/ath79/mach-a60.c     |  183 ++
 .../arch/mips/ath79/mach-alfa-ap120c.c        |  148 +
 .../arch/mips/ath79/mach-alfa-ap96.c          |    0
 .../arch/mips/ath79/mach-alfa-nx.c            |    0
 .../arch/mips/ath79/mach-all0258n.c           |    0
 .../arch/mips/ath79/mach-all0315n.c           |    0
 .../arch/mips/ath79/mach-antminer-s1.c        |    0
 .../arch/mips/ath79/mach-antminer-s3.c        |    0
 .../arch/mips/ath79/mach-antrouter-r1.c       |    0
 .../arch/mips/ath79/mach-ap121f.c             |    0
 .../files-4.14/arch/mips/ath79/mach-ap132.c   |  190 ++
 .../arch/mips/ath79/mach-ap143.c              |    0
 .../arch/mips/ath79/mach-ap147.c              |    0
 .../files-4.14/arch/mips/ath79/mach-ap152.c   |  141 +
 .../arch/mips/ath79/mach-ap531b0.c            |    0
 .../arch/mips/ath79/mach-ap90q.c              |    0
 .../arch/mips/ath79/mach-ap91-5g.c            |    0
 .../arch/mips/ath79/mach-ap96.c               |    0
 .../arch/mips/ath79/mach-archer-c25-v1.c      |    0
 .../arch/mips/ath79/mach-archer-c59-v1.c      |    0
 .../arch/mips/ath79/mach-archer-c60-v1.c      |    0
 .../arch/mips/ath79/mach-archer-c7-v4.c       |  261 ++
 .../arch/mips/ath79/mach-archer-c7.c          |  303 +++
 .../arch/mips/ath79/mach-arduino-yun.c        |    0
 .../arch/mips/ath79/mach-aw-nr580.c           |    0
 .../arch/mips/ath79/mach-bhr-4grv2.c          |  172 ++
 .../arch/mips/ath79/mach-bhu-bxu2000n2-a.c    |    0
 .../arch/mips/ath79/mach-bsb.c                |    0
 .../arch/mips/ath79/mach-c55.c                |    0
 .../files-4.14/arch/mips/ath79/mach-c60.c     |  261 ++
 .../arch/mips/ath79/mach-cap324.c             |    0
 .../arch/mips/ath79/mach-cap4200ag.c          |    0
 .../arch/mips/ath79/mach-carambola2.c         |    0
 .../arch/mips/ath79/mach-cf-e316n-v2.c        |  768 ++++++
 .../arch/mips/ath79/mach-cpe510.c             |    0
 .../arch/mips/ath79/mach-cpe870.c             |    0
 .../arch/mips/ath79/mach-cr3000.c             |    0
 .../files-4.14/arch/mips/ath79/mach-cr5000.c  |  177 ++
 .../arch/mips/ath79/mach-dap-1330-a1.c        |    0
 .../arch/mips/ath79/mach-dap-2695-a1.c        |  192 ++
 .../arch/mips/ath79/mach-dgl-5500-a1.c        |  151 ++
 .../arch/mips/ath79/mach-dhp-1565-a1.c        |  171 ++
 .../arch/mips/ath79/mach-dir-505-a1.c         |    0
 .../arch/mips/ath79/mach-dir-600-a1.c         |    0
 .../arch/mips/ath79/mach-dir-615-c1.c         |    0
 .../arch/mips/ath79/mach-dir-615-i1.c         |    0
 .../arch/mips/ath79/mach-dir-825-b1.c         |    0
 .../arch/mips/ath79/mach-dir-825-c1.c         |  242 ++
 .../arch/mips/ath79/mach-dir-869-a1.c         |  176 ++
 .../arch/mips/ath79/mach-dlan-hotspot.c       |    0
 .../arch/mips/ath79/mach-dlan-pro-1200-ac.c   |  191 ++
 .../arch/mips/ath79/mach-dlan-pro-500-wp.c    |  204 ++
 .../arch/mips/ath79/mach-domywifi-dw33d.c     |  188 ++
 .../files-4.14/arch/mips/ath79/mach-dr344.c   |  225 ++
 .../arch/mips/ath79/mach-dr531.c              |    0
 .../arch/mips/ath79/mach-dragino2.c           |    0
 .../arch/mips/ath79/mach-e1700ac-v2.c         |  146 +
 .../arch/mips/ath79/mach-e2100l.c             |    0
 .../arch/mips/ath79/mach-e600g-v2.c           |    0
 .../arch/mips/ath79/mach-eap120.c             |    0
 .../arch/mips/ath79/mach-eap300v2.c           |    0
 .../arch/mips/ath79/mach-eap7660d.c           |    0
 .../arch/mips/ath79/mach-el-m150.c            |    0
 .../arch/mips/ath79/mach-el-mini.c            |    0
 .../arch/mips/ath79/mach-ens202ext.c          |    0
 .../files-4.14/arch/mips/ath79/mach-epg5000.c |  178 ++
 .../files-4.14/arch/mips/ath79/mach-esr1750.c |  177 ++
 .../files-4.14/arch/mips/ath79/mach-esr900.c  |  201 ++
 .../arch/mips/ath79/mach-ew-balin.c           |    0
 .../arch/mips/ath79/mach-ew-dorin.c           |    0
 .../arch/mips/ath79/mach-f9k1115v2.c          |  190 ++
 .../arch/mips/ath79/mach-fritz300e.c          |    0
 .../arch/mips/ath79/mach-fritz4020.c          |    0
 .../arch/mips/ath79/mach-gl-ar150.c           |    0
 .../arch/mips/ath79/mach-gl-ar300.c           |    0
 .../arch/mips/ath79/mach-gl-ar300m.c          |    0
 .../arch/mips/ath79/mach-gl-ar750.c           |    0
 .../arch/mips/ath79/mach-gl-ar750s.c          |  194 ++
 .../arch/mips/ath79/mach-gl-domino.c          |    0
 .../arch/mips/ath79/mach-gl-inet.c            |    0
 .../arch/mips/ath79/mach-gl-mifi.c            |    0
 .../arch/mips/ath79/mach-gl-usb150.c          |    0
 .../arch/mips/ath79/mach-gs-oolite-v1.c       |    0
 .../arch/mips/ath79/mach-gs-oolite-v5-2.c     |    0
 .../arch/mips/ath79/mach-hiveap-121.c         |    0
 .../arch/mips/ath79/mach-hiwifi-hc6361.c      |    0
 .../arch/mips/ath79/mach-hornet-ub.c          |    0
 .../arch/mips/ath79/mach-ja76pf.c             |    0
 .../arch/mips/ath79/mach-jwap003.c            |    0
 .../files-4.14/arch/mips/ath79/mach-jwap230.c |  159 ++
 .../arch/mips/ath79/mach-lan-turtle.c         |    0
 .../arch/mips/ath79/mach-lima.c               |    0
 .../arch/mips/ath79/mach-mc-mac1200r.c        |    0
 .../arch/mips/ath79/mach-mr12.c               |    0
 .../arch/mips/ath79/mach-mr16.c               |    0
 .../files-4.14/arch/mips/ath79/mach-mr1750.c  |  172 ++
 .../arch/mips/ath79/mach-mr18.c               |    0
 .../arch/mips/ath79/mach-mr600.c              |    0
 .../files-4.14/arch/mips/ath79/mach-mr900.c   |  182 ++
 .../arch/mips/ath79/mach-mynet-n600.c         |    0
 .../arch/mips/ath79/mach-mynet-n750.c         |  227 ++
 .../arch/mips/ath79/mach-mynet-rext.c         |  209 ++
 .../arch/mips/ath79/mach-mzk-w04nu.c          |    0
 .../arch/mips/ath79/mach-mzk-w300nh.c         |    0
 .../arch/mips/ath79/mach-n5q.c                |    0
 .../arch/mips/ath79/mach-nbg460n.c            |    0
 .../files-4.14/arch/mips/ath79/mach-nbg6716.c |  381 +++
 .../arch/mips/ath79/mach-om2p.c               |    0
 .../files-4.14/arch/mips/ath79/mach-om5p.c    |  219 ++
 .../files-4.14/arch/mips/ath79/mach-om5pac.c  |  195 ++
 .../arch/mips/ath79/mach-om5pacv2.c           |  223 ++
 .../arch/mips/ath79/mach-omy-g1.c             |    0
 .../arch/mips/ath79/mach-omy-x1.c             |    0
 .../arch/mips/ath79/mach-onion-omega.c        |    0
 .../arch/mips/ath79/mach-pb42.c               |    0
 .../arch/mips/ath79/mach-pqi-air-pen.c        |    0
 .../arch/mips/ath79/mach-qihoo-c301.c         |    0
 .../arch/mips/ath79/mach-r36a.c               |    0
 .../arch/mips/ath79/mach-r602n.c              |    0
 .../arch/mips/ath79/mach-r6100.c              |    0
 .../arch/mips/ath79/mach-rambutan.c           |   92 +
 .../files-4.14/arch/mips/ath79/mach-rb2011.c  |  398 +++
 .../arch/mips/ath79/mach-rb4xx.c              |    0
 .../files-4.14/arch/mips/ath79/mach-rb750.c   |  350 +++
 .../files-4.14/arch/mips/ath79/mach-rb91x.c   |  344 +++
 .../files-4.14/arch/mips/ath79/mach-rb922.c   |  306 +++
 .../files-4.14/arch/mips/ath79/mach-rb95x.c   |  321 +++
 .../files-4.14/arch/mips/ath79/mach-rbspi.c   | 1125 ++++++++
 .../arch/mips/ath79/mach-rbsxtlite.c          |    0
 .../arch/mips/ath79/mach-re450.c              |    0
 .../arch/mips/ath79/mach-rme-eg200.c          |    0
 .../arch/mips/ath79/mach-rut9xx.c             |    0
 .../arch/mips/ath79/mach-rw2458n.c            |    0
 .../files-4.14/arch/mips/ath79/mach-sc1750.c  |  146 +
 .../files-4.14/arch/mips/ath79/mach-sc300m.c  |  133 +
 .../files-4.14/arch/mips/ath79/mach-sc450.c   |  150 ++
 .../arch/mips/ath79/mach-smart-300.c          |    0
 .../arch/mips/ath79/mach-som9331.c            |    0
 .../files-4.14/arch/mips/ath79/mach-sr3200.c  |  188 ++
 .../arch/mips/ath79/mach-t830.c               |    0
 .../mips/ath79/mach-tellstick-znet-lite.c     |    0
 .../arch/mips/ath79/mach-tew-632brp.c         |    0
 .../arch/mips/ath79/mach-tew-673gru.c         |    0
 .../arch/mips/ath79/mach-tew-712br.c          |    0
 .../arch/mips/ath79/mach-tew-732br.c          |    0
 .../arch/mips/ath79/mach-tew-823dru.c         |  182 ++
 .../arch/mips/ath79/mach-tl-mr11u.c           |    0
 .../arch/mips/ath79/mach-tl-mr13u.c           |    0
 .../arch/mips/ath79/mach-tl-mr3020.c          |    0
 .../arch/mips/ath79/mach-tl-mr3x20.c          |    0
 .../arch/mips/ath79/mach-tl-mr6400.c          |    0
 .../arch/mips/ath79/mach-tl-wa701nd-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wa7210n-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wa801nd-v3.c      |    0
 .../arch/mips/ath79/mach-tl-wa830re-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wa901nd-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wa901nd-v4.c      |    0
 .../arch/mips/ath79/mach-tl-wa901nd.c         |    0
 .../arch/mips/ath79/mach-tl-wax50re.c         |    0
 .../arch/mips/ath79/mach-tl-wdr3320-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wdr3500.c         |    0
 .../arch/mips/ath79/mach-tl-wdr4300.c         |  207 ++
 .../arch/mips/ath79/mach-tl-wdr6500-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wpa8630.c         |  173 ++
 .../arch/mips/ath79/mach-tl-wr1041n-v2.c      |  158 ++
 .../arch/mips/ath79/mach-tl-wr1043nd-v2.c     |  216 ++
 .../arch/mips/ath79/mach-tl-wr1043nd-v4.c     |  273 ++
 .../arch/mips/ath79/mach-tl-wr1043nd.c        |    0
 .../arch/mips/ath79/mach-tl-wr2543n.c         |    0
 .../arch/mips/ath79/mach-tl-wr703n.c          |    0
 .../arch/mips/ath79/mach-tl-wr720n-v3.c       |    0
 .../arch/mips/ath79/mach-tl-wr741nd-v4.c      |    0
 .../arch/mips/ath79/mach-tl-wr741nd.c         |    0
 .../arch/mips/ath79/mach-tl-wr802n.c          |    0
 .../arch/mips/ath79/mach-tl-wr810n.c          |    0
 .../arch/mips/ath79/mach-tl-wr841n-v8.c       |    0
 .../arch/mips/ath79/mach-tl-wr841n-v9.c       |    0
 .../arch/mips/ath79/mach-tl-wr841n.c          |    0
 .../arch/mips/ath79/mach-tl-wr902ac-v1.c      |    0
 .../arch/mips/ath79/mach-tl-wr940n-v4.c       |    0
 .../arch/mips/ath79/mach-tl-wr941nd-v6.c      |    0
 .../arch/mips/ath79/mach-tl-wr941nd.c         |    0
 .../arch/mips/ath79/mach-tl-wr942n-v1.c       |    0
 .../arch/mips/ath79/mach-ts-d084.c            |    0
 .../arch/mips/ath79/mach-tube2h.c             |    0
 .../arch/mips/ath79/mach-ubnt-unifiac.c       |  180 ++
 .../files-4.14/arch/mips/ath79/mach-ubnt-xm.c |  781 ++++++
 .../arch/mips/ath79/mach-ubnt.c               |    0
 .../arch/mips/ath79/mach-wam250.c             |    0
 .../arch/mips/ath79/mach-weio.c               |    0
 .../arch/mips/ath79/mach-whr-hp-g300n.c       |    0
 .../arch/mips/ath79/mach-wi2a-ac200i.c        |    0
 .../mips/ath79/mach-wifi-pineapple-nano.c     |    0
 .../arch/mips/ath79/mach-wlae-ag300n.c        |    0
 .../files-4.14/arch/mips/ath79/mach-wlr8100.c |  196 ++
 .../arch/mips/ath79/mach-wndap360.c           |    0
 .../arch/mips/ath79/mach-wndr3700.c           |    0
 .../arch/mips/ath79/mach-wndr4300.c           |  211 ++
 .../arch/mips/ath79/mach-wnr2000-v3.c         |    0
 .../arch/mips/ath79/mach-wnr2000-v4.c         |    0
 .../arch/mips/ath79/mach-wnr2000.c            |    0
 .../arch/mips/ath79/mach-wnr2200.c            |    0
 .../arch/mips/ath79/mach-wp543.c              |    0
 .../arch/mips/ath79/mach-wpe72.c              |    0
 .../files-4.14/arch/mips/ath79/mach-wpj342.c  |  179 ++
 .../files-4.14/arch/mips/ath79/mach-wpj344.c  |  170 ++
 .../arch/mips/ath79/mach-wpj531.c             |    0
 .../files-4.14/arch/mips/ath79/mach-wpj558.c  |  171 ++
 .../files-4.14/arch/mips/ath79/mach-wpj563.c  |  151 ++
 .../arch/mips/ath79/mach-wrt160nl.c           |    0
 .../arch/mips/ath79/mach-wrt400n.c            |    0
 .../arch/mips/ath79/mach-wrtnode2q.c          |    0
 .../arch/mips/ath79/mach-wzr-450hp2.c         |  222 ++
 .../arch/mips/ath79/mach-wzr-hp-ag300h.c      |    0
 .../arch/mips/ath79/mach-wzr-hp-g300nh.c      |    0
 .../arch/mips/ath79/mach-wzr-hp-g300nh2.c     |    0
 .../arch/mips/ath79/mach-wzr-hp-g450h.c       |    0
 .../files-4.14/arch/mips/ath79/mach-z1.c      |  165 ++
 .../arch/mips/ath79/mach-zbt-we1526.c         |    0
 .../arch/mips/ath79/mach-zcn-1523h.c          |    0
 .../files-4.14/arch/mips/ath79/machtypes.h    |  374 +++
 .../arch/mips/ath79/nvram.c                   |    0
 .../arch/mips/ath79/nvram.h                   |    0
 .../arch/mips/ath79/pci-ath9k-fixup.c         |    0
 .../arch/mips/ath79/pci-ath9k-fixup.h         |    0
 .../arch/mips/ath79/routerboot.c              |    0
 .../arch/mips/ath79/routerboot.h              |    0
 .../mips/include/asm/fw/myloader/myloader.h   |    0
 .../include/asm/mach-ath79/ag71xx_platform.h  |    0
 .../mips/include/asm/mach-ath79/mach-rb750.h  |    0
 .../mips/include/asm/mach-ath79/rb4xx_cpld.h  |    0
 .../drivers/gpio/gpio-latch.c                 |    0
 .../drivers/gpio/gpio-nxp-74hc153.c           |    0
 .../drivers/leds/leds-nu801.c                 |    0
 .../drivers/leds/leds-rb750.c                 |    0
 .../drivers/leds/leds-wndr3700-usb.c          |    0
 .../drivers/mtd/cybertan_part.c               |    0
 .../drivers/mtd/nand/ar934x_nfc.c             |    0
 .../drivers/mtd/nand/rb4xx_nand.c             |    0
 .../drivers/mtd/nand/rb750_nand.c             |    0
 .../drivers/mtd/nand/rb91x_nand.c             |    0
 .../drivers/mtd/tplinkpart.c                  |    0
 .../files-4.14/drivers/net/dsa/mv88e6063.c    |  307 +++
 .../net/ethernet/atheros/ag71xx/Kconfig       |    0
 .../net/ethernet/atheros/ag71xx/Makefile      |    0
 .../net/ethernet/atheros/ag71xx/ag71xx.h      |    0
 .../ethernet/atheros/ag71xx/ag71xx_ar7240.c   |    0
 .../ethernet/atheros/ag71xx/ag71xx_ar8216.c   |    0
 .../ethernet/atheros/ag71xx/ag71xx_debugfs.c  |    0
 .../ethernet/atheros/ag71xx/ag71xx_ethtool.c  |    0
 .../net/ethernet/atheros/ag71xx/ag71xx_main.c |    0
 .../net/ethernet/atheros/ag71xx/ag71xx_mdio.c |    0
 .../net/ethernet/atheros/ag71xx/ag71xx_phy.c  |    0
 .../drivers/spi/spi-rb4xx-cpld.c              |    0
 .../drivers/spi/spi-rb4xx.c                   |    0
 .../drivers/spi/spi-vsc7385.c                 |    0
 .../include/linux/leds-nu801.h                |    0
 .../include/linux/nxp_74hc153.h               |    0
 .../include/linux/platform/ar934x_nfc.h       |    0
 .../include/linux/platform_data/gpio-latch.h  |    0
 .../include/linux/platform_data/rb91x_nand.h  |    0
 .../include/linux/spi/vsc7385.h               |    0
 .../files-4.9/arch/mips/ath79/Kconfig.openwrt | 2379 +++++++++++++++++
 .../arch/mips/ath79/Makefile                  |    0
 .../files-4.9/arch/mips/ath79/dev-ap9x-pci.c  |  173 ++
 .../files-4.9/arch/mips/ath79/dev-ap9x-pci.h  |   55 +
 .../files-4.9/arch/mips/ath79/dev-dsa.c       |   36 +
 .../files-4.9/arch/mips/ath79/dev-dsa.h       |   21 +
 .../files-4.9/arch/mips/ath79/dev-eth.c       | 1248 +++++++++
 .../files-4.9/arch/mips/ath79/dev-eth.h       |   55 +
 .../files-4.9/arch/mips/ath79/dev-m25p80.c    |  101 +
 .../files-4.9/arch/mips/ath79/dev-m25p80.h    |   17 +
 .../files-4.9/arch/mips/ath79/dev-nfc.c       |  141 +
 .../files-4.9/arch/mips/ath79/dev-nfc.h       |   34 +
 .../arch/mips/ath79/mach-a60.c                |    0
 .../arch/mips/ath79/mach-alfa-ap120c.c        |    0
 .../arch/mips/ath79/mach-alfa-ap96.c          |  132 +
 .../files-4.9/arch/mips/ath79/mach-alfa-nx.c  |  113 +
 .../files-4.9/arch/mips/ath79/mach-all0258n.c |   88 +
 .../files-4.9/arch/mips/ath79/mach-all0315n.c |   85 +
 .../arch/mips/ath79/mach-antminer-s1.c        |   98 +
 .../arch/mips/ath79/mach-antminer-s3.c        |  103 +
 .../arch/mips/ath79/mach-antrouter-r1.c       |   98 +
 .../files-4.9/arch/mips/ath79/mach-ap121f.c   |  103 +
 .../arch/mips/ath79/mach-ap132.c              |    0
 .../files-4.9/arch/mips/ath79/mach-ap143.c    |  142 +
 .../files-4.9/arch/mips/ath79/mach-ap147.c    |  125 +
 .../arch/mips/ath79/mach-ap152.c              |    0
 .../files-4.9/arch/mips/ath79/mach-ap531b0.c  |  112 +
 .../files-4.9/arch/mips/ath79/mach-ap90q.c    |  201 ++
 .../files-4.9/arch/mips/ath79/mach-ap91-5g.c  |  118 +
 .../files-4.9/arch/mips/ath79/mach-ap96.c     |  142 +
 .../arch/mips/ath79/mach-archer-c25-v1.c      |  227 ++
 .../arch/mips/ath79/mach-archer-c59-v1.c      |  289 ++
 .../arch/mips/ath79/mach-archer-c60-v1.c      |  225 ++
 .../arch/mips/ath79/mach-archer-c7-v4.c       |    0
 .../arch/mips/ath79/mach-archer-c7.c          |    0
 .../arch/mips/ath79/mach-arduino-yun.c        |  157 ++
 .../files-4.9/arch/mips/ath79/mach-aw-nr580.c |  107 +
 .../arch/mips/ath79/mach-bhr-4grv2.c          |    0
 .../arch/mips/ath79/mach-bhu-bxu2000n2-a.c    |  120 +
 .../files-4.9/arch/mips/ath79/mach-bsb.c      |   83 +
 .../files-4.9/arch/mips/ath79/mach-c55.c      |  132 +
 .../arch/mips/ath79/mach-c60.c                |    0
 .../files-4.9/arch/mips/ath79/mach-cap324.c   |  133 +
 .../arch/mips/ath79/mach-cap4200ag.c          |  131 +
 .../arch/mips/ath79/mach-carambola2.c         |  105 +
 .../arch/mips/ath79/mach-cf-e316n-v2.c        |    0
 .../files-4.9/arch/mips/ath79/mach-cpe510.c   |  184 ++
 .../files-4.9/arch/mips/ath79/mach-cpe870.c   |  152 ++
 .../files-4.9/arch/mips/ath79/mach-cr3000.c   |  161 ++
 .../arch/mips/ath79/mach-cr5000.c             |    0
 .../arch/mips/ath79/mach-dap-1330-a1.c        |  146 +
 .../arch/mips/ath79/mach-dap-2695-a1.c        |    0
 .../arch/mips/ath79/mach-dgl-5500-a1.c        |    0
 .../arch/mips/ath79/mach-dhp-1565-a1.c        |    0
 .../arch/mips/ath79/mach-dir-505-a1.c         |  116 +
 .../arch/mips/ath79/mach-dir-600-a1.c         |  162 ++
 .../arch/mips/ath79/mach-dir-615-c1.c         |  135 +
 .../arch/mips/ath79/mach-dir-615-i1.c         |  133 +
 .../arch/mips/ath79/mach-dir-825-b1.c         |  191 ++
 .../arch/mips/ath79/mach-dir-825-c1.c         |    0
 .../arch/mips/ath79/mach-dir-869-a1.c         |    0
 .../arch/mips/ath79/mach-dlan-hotspot.c       |  117 +
 .../arch/mips/ath79/mach-dlan-pro-1200-ac.c   |    0
 .../arch/mips/ath79/mach-dlan-pro-500-wp.c    |    0
 .../arch/mips/ath79/mach-domywifi-dw33d.c     |    0
 .../arch/mips/ath79/mach-dr344.c              |    0
 .../files-4.9/arch/mips/ath79/mach-dr531.c    |  155 ++
 .../files-4.9/arch/mips/ath79/mach-dragino2.c |  136 +
 .../arch/mips/ath79/mach-e1700ac-v2.c         |    0
 .../files-4.9/arch/mips/ath79/mach-e2100l.c   |  126 +
 .../files-4.9/arch/mips/ath79/mach-e600g-v2.c |  184 ++
 .../files-4.9/arch/mips/ath79/mach-eap120.c   |  126 +
 .../files-4.9/arch/mips/ath79/mach-eap300v2.c |  101 +
 .../files-4.9/arch/mips/ath79/mach-eap7660d.c |  181 ++
 .../files-4.9/arch/mips/ath79/mach-el-m150.c  |  112 +
 .../files-4.9/arch/mips/ath79/mach-el-mini.c  |   86 +
 .../arch/mips/ath79/mach-ens202ext.c          |  124 +
 .../arch/mips/ath79/mach-epg5000.c            |    0
 .../arch/mips/ath79/mach-esr1750.c            |    0
 .../arch/mips/ath79/mach-esr900.c             |    0
 .../files-4.9/arch/mips/ath79/mach-ew-balin.c |  110 +
 .../files-4.9/arch/mips/ath79/mach-ew-dorin.c |  138 +
 .../arch/mips/ath79/mach-f9k1115v2.c          |    0
 .../arch/mips/ath79/mach-fritz300e.c          |  132 +
 .../arch/mips/ath79/mach-fritz4020.c          |  242 ++
 .../files-4.9/arch/mips/ath79/mach-gl-ar150.c |  125 +
 .../files-4.9/arch/mips/ath79/mach-gl-ar300.c |  103 +
 .../arch/mips/ath79/mach-gl-ar300m.c          |  165 ++
 .../files-4.9/arch/mips/ath79/mach-gl-ar750.c |  146 +
 .../arch/mips/ath79/mach-gl-ar750s.c          |    0
 .../arch/mips/ath79/mach-gl-domino.c          |  136 +
 .../files-4.9/arch/mips/ath79/mach-gl-inet.c  |  104 +
 .../files-4.9/arch/mips/ath79/mach-gl-mifi.c  |  114 +
 .../arch/mips/ath79/mach-gl-usb150.c          |   87 +
 .../arch/mips/ath79/mach-gs-oolite-v1.c       |  143 +
 .../arch/mips/ath79/mach-gs-oolite-v5-2.c     |  111 +
 .../arch/mips/ath79/mach-hiveap-121.c         |  153 ++
 .../arch/mips/ath79/mach-hiwifi-hc6361.c      |  115 +
 .../arch/mips/ath79/mach-hornet-ub.c          |  142 +
 .../files-4.9/arch/mips/ath79/mach-ja76pf.c   |  190 ++
 .../files-4.9/arch/mips/ath79/mach-jwap003.c  |   95 +
 .../arch/mips/ath79/mach-jwap230.c            |    0
 .../arch/mips/ath79/mach-lan-turtle.c         |  178 ++
 .../files-4.9/arch/mips/ath79/mach-lima.c     |   88 +
 .../arch/mips/ath79/mach-mc-mac1200r.c        |  155 ++
 .../files-4.9/arch/mips/ath79/mach-mr12.c     |  114 +
 .../files-4.9/arch/mips/ath79/mach-mr16.c     |  118 +
 .../arch/mips/ath79/mach-mr1750.c             |    0
 .../files-4.9/arch/mips/ath79/mach-mr18.c     |  286 ++
 .../files-4.9/arch/mips/ath79/mach-mr600.c    |  177 ++
 .../arch/mips/ath79/mach-mr900.c              |    0
 .../arch/mips/ath79/mach-mynet-n600.c         |  202 ++
 .../arch/mips/ath79/mach-mynet-n750.c         |    0
 .../arch/mips/ath79/mach-mynet-rext.c         |    0
 .../arch/mips/ath79/mach-mzk-w04nu.c          |  124 +
 .../arch/mips/ath79/mach-mzk-w300nh.c         |  115 +
 .../files-4.9/arch/mips/ath79/mach-n5q.c      |  132 +
 .../files-4.9/arch/mips/ath79/mach-nbg460n.c  |  220 ++
 .../arch/mips/ath79/mach-nbg6716.c            |    0
 .../files-4.9/arch/mips/ath79/mach-om2p.c     |  320 +++
 .../arch/mips/ath79/mach-om5p.c               |    0
 .../arch/mips/ath79/mach-om5pac.c             |    0
 .../arch/mips/ath79/mach-om5pacv2.c           |    0
 .../files-4.9/arch/mips/ath79/mach-omy-g1.c   |  123 +
 .../files-4.9/arch/mips/ath79/mach-omy-x1.c   |  106 +
 .../arch/mips/ath79/mach-onion-omega.c        |   84 +
 .../files-4.9/arch/mips/ath79/mach-pb42.c     |   83 +
 .../arch/mips/ath79/mach-pqi-air-pen.c        |   99 +
 .../arch/mips/ath79/mach-qihoo-c301.c         |  166 ++
 .../files-4.9/arch/mips/ath79/mach-r36a.c     |  140 +
 .../files-4.9/arch/mips/ath79/mach-r602n.c    |  213 ++
 .../files-4.9/arch/mips/ath79/mach-r6100.c    |  146 +
 .../arch/mips/ath79/mach-rambutan.c           |    0
 .../arch/mips/ath79/mach-rb2011.c             |    0
 .../files-4.9/arch/mips/ath79/mach-rb4xx.c    |  465 ++++
 .../arch/mips/ath79/mach-rb750.c              |    0
 .../arch/mips/ath79/mach-rb91x.c              |    0
 .../arch/mips/ath79/mach-rb922.c              |    0
 .../arch/mips/ath79/mach-rb95x.c              |    0
 .../arch/mips/ath79/mach-rbspi.c              |    0
 .../arch/mips/ath79/mach-rbsxtlite.c          |  297 ++
 .../files-4.9/arch/mips/ath79/mach-re450.c    |  239 ++
 .../arch/mips/ath79/mach-rme-eg200.c          |   99 +
 .../files-4.9/arch/mips/ath79/mach-rut9xx.c   |  191 ++
 .../files-4.9/arch/mips/ath79/mach-rw2458n.c  |   91 +
 .../arch/mips/ath79/mach-sc1750.c             |    0
 .../arch/mips/ath79/mach-sc300m.c             |    0
 .../arch/mips/ath79/mach-sc450.c              |    0
 .../arch/mips/ath79/mach-smart-300.c          |  135 +
 .../files-4.9/arch/mips/ath79/mach-som9331.c  |  125 +
 .../arch/mips/ath79/mach-sr3200.c             |    0
 .../files-4.9/arch/mips/ath79/mach-t830.c     |  127 +
 .../mips/ath79/mach-tellstick-znet-lite.c     |  129 +
 .../arch/mips/ath79/mach-tew-632brp.c         |  111 +
 .../arch/mips/ath79/mach-tew-673gru.c         |  198 ++
 .../arch/mips/ath79/mach-tew-712br.c          |  153 ++
 .../arch/mips/ath79/mach-tew-732br.c          |  127 +
 .../arch/mips/ath79/mach-tew-823dru.c         |    0
 .../files-4.9/arch/mips/ath79/mach-tl-mr11u.c |  183 ++
 .../files-4.9/arch/mips/ath79/mach-tl-mr13u.c |  107 +
 .../arch/mips/ath79/mach-tl-mr3020.c          |  126 +
 .../arch/mips/ath79/mach-tl-mr3x20.c          |  147 +
 .../arch/mips/ath79/mach-tl-mr6400.c          |  151 ++
 .../arch/mips/ath79/mach-tl-wa701nd-v2.c      |  116 +
 .../arch/mips/ath79/mach-tl-wa7210n-v2.c      |  125 +
 .../arch/mips/ath79/mach-tl-wa801nd-v3.c      |  136 +
 .../arch/mips/ath79/mach-tl-wa830re-v2.c      |  132 +
 .../arch/mips/ath79/mach-tl-wa901nd-v2.c      |  104 +
 .../arch/mips/ath79/mach-tl-wa901nd-v4.c      |  115 +
 .../arch/mips/ath79/mach-tl-wa901nd.c         |  127 +
 .../arch/mips/ath79/mach-tl-wax50re.c         |  445 +++
 .../arch/mips/ath79/mach-tl-wdr3320-v2.c      |  146 +
 .../arch/mips/ath79/mach-tl-wdr3500.c         |  169 ++
 .../arch/mips/ath79/mach-tl-wdr4300.c         |    0
 .../arch/mips/ath79/mach-tl-wdr6500-v2.c      |  142 +
 .../arch/mips/ath79/mach-tl-wpa8630.c         |    0
 .../arch/mips/ath79/mach-tl-wr1041n-v2.c      |    0
 .../arch/mips/ath79/mach-tl-wr1043nd-v2.c     |    0
 .../arch/mips/ath79/mach-tl-wr1043nd-v4.c     |    0
 .../arch/mips/ath79/mach-tl-wr1043nd.c        |  141 +
 .../arch/mips/ath79/mach-tl-wr2543n.c         |  150 ++
 .../arch/mips/ath79/mach-tl-wr703n.c          |  118 +
 .../arch/mips/ath79/mach-tl-wr720n-v3.c       |  108 +
 .../arch/mips/ath79/mach-tl-wr741nd-v4.c      |  187 ++
 .../arch/mips/ath79/mach-tl-wr741nd.c         |  130 +
 .../arch/mips/ath79/mach-tl-wr802n.c          |  117 +
 .../arch/mips/ath79/mach-tl-wr810n.c          |  149 ++
 .../arch/mips/ath79/mach-tl-wr841n-v8.c       |  286 ++
 .../arch/mips/ath79/mach-tl-wr841n-v9.c       |  457 ++++
 .../arch/mips/ath79/mach-tl-wr841n.c          |  140 +
 .../arch/mips/ath79/mach-tl-wr902ac-v1.c      |  145 +
 .../arch/mips/ath79/mach-tl-wr940n-v4.c       |  184 ++
 .../arch/mips/ath79/mach-tl-wr941nd-v6.c      |  149 ++
 .../arch/mips/ath79/mach-tl-wr941nd.c         |  121 +
 .../arch/mips/ath79/mach-tl-wr942n-v1.c       |  279 ++
 .../files-4.9/arch/mips/ath79/mach-ts-d084.c  |   86 +
 .../files-4.9/arch/mips/ath79/mach-tube2h.c   |  129 +
 .../arch/mips/ath79/mach-ubnt-unifiac.c       |    0
 .../arch/mips/ath79/mach-ubnt-xm.c            |    0
 .../files-4.9/arch/mips/ath79/mach-ubnt.c     |  205 ++
 .../files-4.9/arch/mips/ath79/mach-wam250.c   |  122 +
 .../files-4.9/arch/mips/ath79/mach-weio.c     |  140 +
 .../arch/mips/ath79/mach-whr-hp-g300n.c       |  155 ++
 .../arch/mips/ath79/mach-wi2a-ac200i.c        |  217 ++
 .../mips/ath79/mach-wifi-pineapple-nano.c     |  107 +
 .../arch/mips/ath79/mach-wlae-ag300n.c        |  114 +
 .../arch/mips/ath79/mach-wlr8100.c            |    0
 .../files-4.9/arch/mips/ath79/mach-wndap360.c |  105 +
 .../files-4.9/arch/mips/ath79/mach-wndr3700.c |  172 ++
 .../arch/mips/ath79/mach-wndr4300.c           |    0
 .../arch/mips/ath79/mach-wnr2000-v3.c         |  637 +++++
 .../arch/mips/ath79/mach-wnr2000-v4.c         |  214 ++
 .../files-4.9/arch/mips/ath79/mach-wnr2000.c  |  102 +
 .../files-4.9/arch/mips/ath79/mach-wnr2200.c  |  245 ++
 .../files-4.9/arch/mips/ath79/mach-wp543.c    |  109 +
 .../files-4.9/arch/mips/ath79/mach-wpe72.c    |   97 +
 .../arch/mips/ath79/mach-wpj342.c             |    0
 .../arch/mips/ath79/mach-wpj344.c             |    0
 .../files-4.9/arch/mips/ath79/mach-wpj531.c   |  143 +
 .../arch/mips/ath79/mach-wpj558.c             |    0
 .../arch/mips/ath79/mach-wpj563.c             |    0
 .../files-4.9/arch/mips/ath79/mach-wrt160nl.c |  126 +
 .../files-4.9/arch/mips/ath79/mach-wrt400n.c  |  161 ++
 .../arch/mips/ath79/mach-wrtnode2q.c          |  126 +
 .../arch/mips/ath79/mach-wzr-450hp2.c         |    0
 .../arch/mips/ath79/mach-wzr-hp-ag300h.c      |  202 ++
 .../arch/mips/ath79/mach-wzr-hp-g300nh.c      |  279 ++
 .../arch/mips/ath79/mach-wzr-hp-g300nh2.c     |  174 ++
 .../arch/mips/ath79/mach-wzr-hp-g450h.c       |  169 ++
 .../arch/mips/ath79/mach-z1.c                 |    0
 .../arch/mips/ath79/mach-zbt-we1526.c         |  153 ++
 .../arch/mips/ath79/mach-zcn-1523h.c          |  154 ++
 .../arch/mips/ath79/machtypes.h               |    0
 .../ar71xx/files-4.9/arch/mips/ath79/nvram.c  |   85 +
 .../ar71xx/files-4.9/arch/mips/ath79/nvram.h  |   19 +
 .../arch/mips/ath79/pci-ath9k-fixup.c         |  126 +
 .../arch/mips/ath79/pci-ath9k-fixup.h         |    6 +
 .../files-4.9/arch/mips/ath79/routerboot.c    |  358 +++
 .../files-4.9/arch/mips/ath79/routerboot.h    |   89 +
 .../mips/include/asm/fw/myloader/myloader.h   |   34 +
 .../include/asm/mach-ath79/ag71xx_platform.h  |   64 +
 .../mips/include/asm/mach-ath79/mach-rb750.h  |   84 +
 .../mips/include/asm/mach-ath79/rb4xx_cpld.h  |   43 +
 .../files-4.9/drivers/gpio/gpio-latch.c       |  220 ++
 .../files-4.9/drivers/gpio/gpio-nxp-74hc153.c |  243 ++
 .../files-4.9/drivers/leds/leds-nu801.c       |  396 +++
 .../files-4.9/drivers/leds/leds-rb750.c       |  144 +
 .../drivers/leds/leds-wndr3700-usb.c          |   76 +
 .../files-4.9/drivers/mtd/cybertan_part.c     |  206 ++
 .../files-4.9/drivers/mtd/nand/ar934x_nfc.c   | 1587 +++++++++++
 .../files-4.9/drivers/mtd/nand/rb4xx_nand.c   |  392 +++
 .../files-4.9/drivers/mtd/nand/rb750_nand.c   |  436 +++
 .../files-4.9/drivers/mtd/nand/rb91x_nand.c   |  460 ++++
 .../ar71xx/files-4.9/drivers/mtd/tplinkpart.c |  235 ++
 .../drivers/net/dsa/mv88e6063.c               |    0
 .../net/ethernet/atheros/ag71xx/Kconfig       |   33 +
 .../net/ethernet/atheros/ag71xx/Makefile      |   15 +
 .../net/ethernet/atheros/ag71xx/ag71xx.h      |  506 ++++
 .../ethernet/atheros/ag71xx/ag71xx_ar7240.c   | 1382 ++++++++++
 .../ethernet/atheros/ag71xx/ag71xx_ar8216.c   |   44 +
 .../ethernet/atheros/ag71xx/ag71xx_debugfs.c  |  285 ++
 .../ethernet/atheros/ag71xx/ag71xx_ethtool.c  |  131 +
 .../net/ethernet/atheros/ag71xx/ag71xx_main.c | 1479 ++++++++++
 .../net/ethernet/atheros/ag71xx/ag71xx_mdio.c |  320 +++
 .../net/ethernet/atheros/ag71xx/ag71xx_phy.c  |  261 ++
 .../files-4.9/drivers/spi/spi-rb4xx-cpld.c    |  347 +++
 .../ar71xx/files-4.9/drivers/spi/spi-rb4xx.c  |  430 +++
 .../files-4.9/drivers/spi/spi-vsc7385.c       |  621 +++++
 .../files-4.9/include/linux/leds-nu801.h      |   38 +
 .../files-4.9/include/linux/nxp_74hc153.h     |   24 +
 .../include/linux/platform/ar934x_nfc.h       |   39 +
 .../include/linux/platform_data/gpio-latch.h  |   14 +
 .../include/linux/platform_data/rb91x_nand.h  |   16 +
 .../files-4.9/include/linux/spi/vsc7385.h     |   19 +
 .../ar71xx/patches-4.14/001-spi-cs-gpio.patch |   20 +
 .../002-add_back_gpio_function_select.patch   |   92 +
 .../004-register_gpio_driver_earlier.patch    |   18 +
 ...Avoid-using-unitialized-reg-variable.patch |   42 +
 ...egister-address-in-ath79_ddr_wb_flus.patch |   23 +
 ...200-MIPS-ath79-fix-ar933x-wmac-reset.patch |   30 +
 .../201-ar913x_wmac_external_reset.patch      |   31 +
 .../202-MIPS-ath79-ar934x-wmac-revision.patch |   11 +
 .../203-MIPS-ath79-fix-restart.patch          |   20 +
 .../220-add_cpu_feature_overrides.patch       |   28 +
 ...0-MIPS-add-MIPS_MACHINE_NONAME-macro.patch |   21 +
 .../310-lib-add-rle-decompression.patch       |  124 +
 .../401-mtd-physmap-add-lock-unlock.patch     |   94 +
 .../402-mtd-SST39VF6401B-support.patch        |   29 +
 ...mtd_fix_cfi_cmdset_0002_status_check.patch |   69 +
 .../404-mtd-cybertan-trx-parser.patch         |   25 +
 .../405-mtd-tp-link-partition-parser.patch    |   25 +
 ...o-pass-probe-types-via-platform-data.patch |   34 +
 .../408-mtd-redboot_partition_scan.patch      |   44 +
 .../409-mtd-rb4xx_nand_driver.patch           |   21 +
 .../410-mtd-rb750-nand-driver.patch           |   21 +
 ...mtd-cfi_cmdset_0002-force-word-write.patch |   61 +
 .../413-mtd-ar934x-nand-driver.patch          |   25 +
 .../414-mtd-rb91x-nand-driver.patch           |   21 +
 .../420-net-ar71xx_mac_driver.patch           |   28 +
 .../423-dsa-add-88e6063-driver.patch          |   27 +
 .../430-drivers-link-spi-before-mtd.patch     |   12 +
 .../432-spi-rb4xx-spi-driver.patch            |   25 +
 .../433-spi-rb4xx-cpld-driver.patch           |   26 +
 .../patches-4.14/435-spi-vsc7385_driver.patch |   24 +
 .../440-leds-wndr3700-usb-led-driver.patch    |   26 +
 .../441-leds-rb750-led-driver.patch           |   23 +
 ...to-use-OPEN_-DRAIN-SOURCE-flags-with.patch |   45 +
 ...50-gpio-nxp-74hc153-gpio-chip-driver.patch |   25 +
 ...x164-improve-platform-device-support.patch |  119 +
 .../452-gpio-add-gpio-latch-driver.patch      |   22 +
 .../461-spi-ath79-add-fast-flash-read.patch   |   60 +
 ...ath79-swizzle-pci-address-for-ar71xx.patch |  111 +
 ...490-usb-ehci-add-quirks-for-qca-socs.patch |  103 +
 .../patches-4.14/500-MIPS-fw-myloader.patch   |   22 +
 ...-mac-argument-to-ath79_register_wmac.patch |   70 +
 ...IPS-ath79-add-ath79_device_reset_get.patch |   42 +
 ...ath79-add-ath79_gpio_function_select.patch |   39 +
 ...6-MIPS-ath79-prom-parse-redboot-args.patch |   42 +
 ...MIPS-ath79-prom-add-myloader-support.patch |   55 +
 ...S-ath79-prom-image-command-line-hack.patch |   73 +
 ...PS-ath79-process-board-kernel-option.patch |   11 +
 ...S-ath79-init-gpio-pin-of-wmac-device.patch |   14 +
 .../520-MIPS-ath79-enable-UART-function.patch |   18 +
 ...S-ath79-enable-UART-for-early_serial.patch |   61 +
 ...dd-ath79_wmac_register_simple-helper.patch |   21 +
 .../523-MIPS-ath79-OTP-support.patch          |  192 ++
 ...add-ath79_wmac_disable_25ghz-helpers.patch |   31 +
 ...525-MIPS-ath79-enable-qca-usb-quirks.patch |  101 +
 ...MIPS-ath79-add-more-register-defines.patch |  456 ++++
 .../602-MIPS-ath79-add-openwrt-stuff.patch    |   49 +
 .../603-MIPS-ath79-ap121-fixes.patch          |  149 ++
 .../605-MIPS-ath79-db120-fixes.patch          |  205 ++
 .../606-MIPS-ath79-pb44-fixes.patch           |  145 +
 .../607-MIPS-ath79-ubnt-xm-fixes.patch        |   14 +
 ...8-MIPS-ath79-ubnt-xm-add-more-boards.patch |   20 +
 .../609-MIPS-ath79-ap136-fixes.patch          |  301 +++
 .../611-MIPS-ath79-wdt-timeout.patch          |   25 +
 .../612-MIPS-ath79-set-buffalo-txgain.patch   |   24 +
 ...ath79_wmac_setup_ext_lna_gpio-helper.patch |   76 +
 ...PS-ath79-add-support-for-QCA953x-SoC.patch |  696 +++++
 ...PS-ath79-add-support-for-QCA956x-SoC.patch |  717 +++++
 ...ore-register-defines-for-QCA956x-SoC.patch |   38 +
 ...0-MIPS-ath79-fix-chained-irq-disable.patch |  106 +
 ...1-MIPS-ath79-wmac-enable-set-led-pin.patch |   24 +
 ...MIPS-ath79-gpio-enable-set-direction.patch |   32 +
 ...40-MIPS-ath79-add-QCA955x-wmac-reset.patch |   82 +
 .../641-MIPS-ath79-ath9k-exports.patch        |   26 +
 .../patches-4.14/642-MIPS-ath79-no-of.patch   |   70 +
 .../700-MIPS-ath79-add-openwrt-Kconfig.patch  |   11 +
 ...MIPS-ath79-add-routerboard-detection.patch |   34 +
 ...h79-fixup-routerboot-board-parameter.patch |   43 +
 ...d-gpio-func-register-for-QCA955x-SoC.patch |   38 +
 ...0-MIPS-ath79-add-PCI-for-QCA953x-SoC.patch |   44 +
 ...1-MIPS-ath79-add-PCI-for-QCA9556-SoC.patch |   12 +
 .../818-MIPS-ath79-add-nu801-led-driver.patch |   26 +
 ...-MIPS-ath79-add_gpio_function2_setup.patch |   67 +
 .../900-mdio_bitbang_ignore_ta_value.patch    |   32 +
 ...-prevent-rescheduling-during-command.patch |   61 +
 .../902-at803x-add-reset-gpio-pdata.patch     |   68 +
 .../910-unaligned_access_hacks.patch          |  933 +++++++
 ...usb-chipidea-AR933x-platform-support.patch |  128 +
 ...ore-register-defines-for-QCA956x-SoC.patch |  194 ++
 .../patches-4.14/930-chipidea-pullup.patch    |   72 +
 638 files changed, 63610 insertions(+)
 create mode 100644 target/linux/ar71xx/config-4.14
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/Kconfig.openwrt (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/Makefile
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-ap9x-pci.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-ap9x-pci.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-dsa.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-dsa.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-eth.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-eth.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-m25p80.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-m25p80.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-nfc.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/dev-nfc.h (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-a60.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap120c.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-alfa-ap96.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-alfa-nx.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-all0258n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-all0315n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-antminer-s1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-antminer-s3.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-antrouter-r1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap121f.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap132.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap143.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap147.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap152.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap531b0.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap90q.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap91-5g.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ap96.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-archer-c25-v1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-archer-c59-v1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-archer-c60-v1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7-v4.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-arduino-yun.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-aw-nr580.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhr-4grv2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-bhu-bxu2000n2-a.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-bsb.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-c55.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c60.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-cap324.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-cap4200ag.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-carambola2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cf-e316n-v2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-cpe510.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-cpe870.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-cr3000.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr5000.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dap-1330-a1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-2695-a1.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dgl-5500-a1.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dhp-1565-a1.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dir-505-a1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dir-600-a1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dir-615-c1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dir-615-i1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dir-825-b1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-c1.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-869-a1.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dlan-hotspot.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-1200-ac.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-500-wp.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-domywifi-dw33d.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr344.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dr531.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-dragino2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e1700ac-v2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-e2100l.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-e600g-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-eap120.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-eap300v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-eap7660d.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-el-m150.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-el-mini.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ens202ext.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-epg5000.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr1750.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr900.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ew-balin.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ew-dorin.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-f9k1115v2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-fritz300e.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-fritz4020.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-ar150.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-ar300.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-ar300m.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-ar750.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750s.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-domino.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-inet.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-mifi.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gl-usb150.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gs-oolite-v1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-gs-oolite-v5-2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-hiveap-121.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-hiwifi-hc6361.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-hornet-ub.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ja76pf.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-jwap003.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap230.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-lan-turtle.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-lima.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mc-mac1200r.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mr12.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mr16.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr1750.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mr18.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mr600.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr900.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mynet-n600.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n750.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-rext.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mzk-w04nu.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-mzk-w300nh.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-n5q.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-nbg460n.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg6716.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-om2p.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5p.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pac.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pacv2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-omy-g1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-omy-x1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-onion-omega.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-pb42.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-pqi-air-pen.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-qihoo-c301.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-r36a.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-r602n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-r6100.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rambutan.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb2011.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-rb4xx.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb750.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb91x.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb922.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb95x.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbspi.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-rbsxtlite.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-re450.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-rme-eg200.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-rut9xx.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-rw2458n.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc1750.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc300m.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc450.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-smart-300.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-som9331.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sr3200.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-t830.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tellstick-znet-lite.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tew-632brp.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tew-673gru.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tew-712br.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tew-732br.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-823dru.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-mr11u.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-mr13u.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-mr3020.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-mr3x20.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-mr6400.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa701nd-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa7210n-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa801nd-v3.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa830re-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa901nd-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa901nd-v4.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wa901nd.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wax50re.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wdr3320-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wdr3500.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr4300.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wdr6500-v2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wpa8630.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1041n-v2.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v2.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v4.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr1043nd.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr2543n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr703n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr720n-v3.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr741nd-v4.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr741nd.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr802n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr810n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr841n-v8.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr841n-v9.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr841n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr902ac-v1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr940n-v4.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr941nd-v6.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr941nd.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tl-wr942n-v1.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ts-d084.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-tube2h.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-unifiac.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-xm.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-ubnt.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wam250.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-weio.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-whr-hp-g300n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wi2a-ac200i.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wifi-pineapple-nano.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wlae-ag300n.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlr8100.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wndap360.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wndr3700.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr4300.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wnr2000-v3.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wnr2000-v4.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wnr2000.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wnr2200.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wp543.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wpe72.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj342.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj344.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wpj531.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj558.c
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj563.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wrt160nl.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wrt400n.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wrtnode2q.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-450hp2.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wzr-hp-ag300h.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wzr-hp-g300nh.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wzr-hp-g300nh2.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-wzr-hp-g450h.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-z1.c
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-zbt-we1526.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/mach-zcn-1523h.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/arch/mips/ath79/machtypes.h
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/nvram.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/nvram.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/pci-ath9k-fixup.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/pci-ath9k-fixup.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/routerboot.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/ath79/routerboot.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/include/asm/fw/myloader/myloader.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/include/asm/mach-ath79/ag71xx_platform.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/include/asm/mach-ath79/mach-rb750.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/gpio/gpio-latch.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/gpio/gpio-nxp-74hc153.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/leds/leds-nu801.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/leds/leds-rb750.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/leds/leds-wndr3700-usb.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/cybertan_part.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/nand/ar934x_nfc.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/nand/rb4xx_nand.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/nand/rb750_nand.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/nand/rb91x_nand.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/mtd/tplinkpart.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.14/drivers/net/dsa/mv88e6063.c
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/Kconfig (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/Makefile (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/spi/spi-rb4xx-cpld.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/spi/spi-rb4xx.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/drivers/spi/spi-vsc7385.c (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/leds-nu801.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/nxp_74hc153.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/platform/ar934x_nfc.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/platform_data/gpio-latch.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/platform_data/rb91x_nand.h (100%)
 rename target/linux/ar71xx/{files => files-4.14}/include/linux/spi/vsc7385.h (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/Kconfig.openwrt
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/Makefile (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.h
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-a60.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-alfa-ap120c.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap96.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-nx.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0258n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0315n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s3.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antrouter-r1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap121f.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-ap132.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap143.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap147.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-ap152.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap531b0.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap90q.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap91-5g.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap96.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c25-v1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c59-v1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c60-v1.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-archer-c7-v4.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-archer-c7.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-arduino-yun.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-aw-nr580.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-bhr-4grv2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bsb.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c55.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-c60.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap324.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap4200ag.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-carambola2.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-cf-e316n-v2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe510.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe870.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr3000.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-cr5000.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-1330-a1.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dap-2695-a1.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dgl-5500-a1.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dhp-1565-a1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-505-a1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-600-a1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-c1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-i1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-b1.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dir-825-c1.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dir-869-a1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-hotspot.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dlan-pro-1200-ac.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dlan-pro-500-wp.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-domywifi-dw33d.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-dr344.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr531.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dragino2.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-e1700ac-v2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e2100l.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e600g-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap120.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap300v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap7660d.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-m150.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-mini.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ens202ext.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-epg5000.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-esr1750.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-esr900.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-balin.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-dorin.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-f9k1115v2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz300e.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz4020.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar150.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300m.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-gl-ar750s.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-domino.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-inet.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-mifi.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-usb150.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v5-2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiveap-121.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiwifi-hc6361.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hornet-ub.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ja76pf.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap003.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-jwap230.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lan-turtle.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lima.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mc-mac1200r.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr12.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr16.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-mr1750.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr18.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr600.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-mr900.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n600.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-mynet-n750.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-mynet-rext.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w04nu.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w300nh.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-n5q.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg460n.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-nbg6716.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om2p.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-om5p.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-om5pac.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-om5pacv2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-g1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-x1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-onion-omega.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pb42.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pqi-air-pen.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-qihoo-c301.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r36a.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r602n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r6100.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rambutan.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rb2011.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb4xx.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rb750.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rb91x.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rb922.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rb95x.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-rbspi.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbsxtlite.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-re450.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rme-eg200.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rut9xx.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rw2458n.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-sc1750.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-sc300m.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-sc450.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-smart-300.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-som9331.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-sr3200.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-t830.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tellstick-znet-lite.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-632brp.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-673gru.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-712br.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-732br.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tew-823dru.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr11u.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr13u.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3020.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3x20.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr6400.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa701nd-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa7210n-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa801nd-v3.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa830re-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v4.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wax50re.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3320-v2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3500.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tl-wdr4300.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr6500-v2.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tl-wpa8630.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tl-wr1041n-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tl-wr1043nd-v2.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-tl-wr1043nd-v4.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr2543n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr703n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr720n-v3.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd-v4.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr802n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr810n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v8.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v9.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr902ac-v1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr940n-v4.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd-v6.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr942n-v1.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ts-d084.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tube2h.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-ubnt-unifiac.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-ubnt-xm.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wam250.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-weio.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-whr-hp-g300n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wi2a-ac200i.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wifi-pineapple-nano.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlae-ag300n.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wlr8100.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndap360.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr3700.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wndr4300.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v3.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v4.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2200.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wp543.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpe72.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wpj342.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wpj344.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj531.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wpj558.c (100%)
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wpj563.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt160nl.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt400n.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrtnode2q.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-wzr-450hp2.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-ag300h.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh2.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g450h.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/mach-z1.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zbt-we1526.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zcn-1523h.c
 rename target/linux/ar71xx/{files => files-4.9}/arch/mips/ath79/machtypes.h (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.c
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/include/asm/fw/myloader/myloader.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/mach-rb750.h
 create mode 100644 target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/gpio/gpio-latch.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/gpio/gpio-nxp-74hc153.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/leds/leds-nu801.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/leds/leds-rb750.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/leds/leds-wndr3700-usb.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/cybertan_part.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/nand/ar934x_nfc.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb4xx_nand.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb750_nand.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb91x_nand.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/mtd/tplinkpart.c
 rename target/linux/ar71xx/{files => files-4.9}/drivers/net/dsa/mv88e6063.c (100%)
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Kconfig
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Makefile
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx-cpld.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx.c
 create mode 100644 target/linux/ar71xx/files-4.9/drivers/spi/spi-vsc7385.c
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/leds-nu801.h
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/nxp_74hc153.h
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/platform/ar934x_nfc.h
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/platform_data/gpio-latch.h
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/platform_data/rb91x_nand.h
 create mode 100644 target/linux/ar71xx/files-4.9/include/linux/spi/vsc7385.h
 create mode 100644 target/linux/ar71xx/patches-4.14/001-spi-cs-gpio.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/002-add_back_gpio_function_select.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/004-register_gpio_driver_earlier.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/100-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/103-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/200-MIPS-ath79-fix-ar933x-wmac-reset.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/201-ar913x_wmac_external_reset.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/202-MIPS-ath79-ar934x-wmac-revision.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/203-MIPS-ath79-fix-restart.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/220-add_cpu_feature_overrides.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/300-MIPS-add-MIPS_MACHINE_NONAME-macro.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/310-lib-add-rle-decompression.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/401-mtd-physmap-add-lock-unlock.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/402-mtd-SST39VF6401B-support.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/403-mtd_fix_cfi_cmdset_0002_status_check.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/404-mtd-cybertan-trx-parser.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/405-mtd-tp-link-partition-parser.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/408-mtd-redboot_partition_scan.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/409-mtd-rb4xx_nand_driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/410-mtd-rb750-nand-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/411-mtd-cfi_cmdset_0002-force-word-write.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/413-mtd-ar934x-nand-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/414-mtd-rb91x-nand-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/420-net-ar71xx_mac_driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/423-dsa-add-88e6063-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/430-drivers-link-spi-before-mtd.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/432-spi-rb4xx-spi-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/433-spi-rb4xx-cpld-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/435-spi-vsc7385_driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/440-leds-wndr3700-usb-led-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/441-leds-rb750-led-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/442-leds-gpio-allow-to-use-OPEN_-DRAIN-SOURCE-flags-with.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/450-gpio-nxp-74hc153-gpio-chip-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/451-gpio-74x164-improve-platform-device-support.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/452-gpio-add-gpio-latch-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/500-MIPS-fw-myloader.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/501-MIPS-ath79-add-mac-argument-to-ath79_register_wmac.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/504-MIPS-ath79-add-ath79_device_reset_get.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/505-MIPS-ath79-add-ath79_gpio_function_select.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/506-MIPS-ath79-prom-parse-redboot-args.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/507-MIPS-ath79-prom-add-myloader-support.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/508-MIPS-ath79-prom-image-command-line-hack.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/509-MIPS-ath79-process-board-kernel-option.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/510-MIPS-ath79-init-gpio-pin-of-wmac-device.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/520-MIPS-ath79-enable-UART-function.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/521-MIPS-ath79-enable-UART-for-early_serial.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/523-MIPS-ath79-OTP-support.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/525-MIPS-ath79-enable-qca-usb-quirks.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/601-MIPS-ath79-add-more-register-defines.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/602-MIPS-ath79-add-openwrt-stuff.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/603-MIPS-ath79-ap121-fixes.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/605-MIPS-ath79-db120-fixes.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/606-MIPS-ath79-pb44-fixes.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/607-MIPS-ath79-ubnt-xm-fixes.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/608-MIPS-ath79-ubnt-xm-add-more-boards.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/609-MIPS-ath79-ap136-fixes.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/611-MIPS-ath79-wdt-timeout.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/612-MIPS-ath79-set-buffalo-txgain.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/620-MIPS-ath79-add-support-for-QCA953x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/621-MIPS-ath79-add-support-for-QCA956x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/622-MIPS-ath79-add-more-register-defines-for-QCA956x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/630-MIPS-ath79-fix-chained-irq-disable.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/631-MIPS-ath79-wmac-enable-set-led-pin.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/632-MIPS-ath79-gpio-enable-set-direction.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/640-MIPS-ath79-add-QCA955x-wmac-reset.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/641-MIPS-ath79-ath9k-exports.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/642-MIPS-ath79-no-of.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/700-MIPS-ath79-add-openwrt-Kconfig.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/701-MIPS-ath79-add-routerboard-detection.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/702-MIPS-ath79-fixup-routerboot-board-parameter.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/739-MIPS-ath79-add-gpio-func-register-for-QCA955x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/740-MIPS-ath79-add-PCI-for-QCA953x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/741-MIPS-ath79-add-PCI-for-QCA9556-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/818-MIPS-ath79-add-nu801-led-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/820-MIPS-ath79-add_gpio_function2_setup.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/902-at803x-add-reset-gpio-pdata.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/910-unaligned_access_hacks.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/920-usb-chipidea-AR933x-platform-support.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/921-MIPS-ath79-add-even-more-register-defines-for-QCA956x-SoC.patch
 create mode 100644 target/linux/ar71xx/patches-4.14/930-chipidea-pullup.patch

diff --git a/target/linux/ar71xx/config-4.14 b/target/linux/ar71xx/config-4.14
new file mode 100644
index 0000000000..d9445c8dfc
--- /dev/null
+++ b/target/linux/ar71xx/config-4.14
@@ -0,0 +1,479 @@
+CONFIG_AG71XX=y
+CONFIG_AG71XX_AR8216_SUPPORT=y
+# CONFIG_AG71XX_DEBUG is not set
+# CONFIG_AG71XX_DEBUG_FS is not set
+CONFIG_AR8216_PHY=y
+CONFIG_AR8216_PHY_LEDS=y
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+# CONFIG_ARCH_HAS_GCOV_PROFILE_ALL is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_AT803X_PHY=y
+CONFIG_ATH79=y
+# CONFIG_ATH79_DEV_AP9X_PCI is not set
+# CONFIG_ATH79_DEV_DSA is not set
+# CONFIG_ATH79_DEV_ETH is not set
+# CONFIG_ATH79_DEV_GPIO_BUTTONS is not set
+# CONFIG_ATH79_DEV_LEDS_GPIO is not set
+# CONFIG_ATH79_DEV_M25P80 is not set
+# CONFIG_ATH79_DEV_SPI is not set
+# CONFIG_ATH79_DEV_USB is not set
+# CONFIG_ATH79_MACH_A60 is not set
+# CONFIG_ATH79_MACH_ALFA_AP120C is not set
+# CONFIG_ATH79_MACH_ALFA_AP96 is not set
+# CONFIG_ATH79_MACH_ALFA_NX is not set
+# CONFIG_ATH79_MACH_ALL0258N is not set
+# CONFIG_ATH79_MACH_ALL0315N is not set
+# CONFIG_ATH79_MACH_ANTMINER_S1 is not set
+# CONFIG_ATH79_MACH_ANTMINER_S3 is not set
+# CONFIG_ATH79_MACH_ANTROUTER_R1 is not set
+# CONFIG_ATH79_MACH_AP121 is not set
+# CONFIG_ATH79_MACH_AP121F is not set
+# CONFIG_ATH79_MACH_AP132 is not set
+# CONFIG_ATH79_MACH_AP136 is not set
+# CONFIG_ATH79_MACH_AP143 is not set
+# CONFIG_ATH79_MACH_AP147 is not set
+# CONFIG_ATH79_MACH_AP152 is not set
+# CONFIG_ATH79_MACH_AP531B0 is not set
+# CONFIG_ATH79_MACH_AP81 is not set
+# CONFIG_ATH79_MACH_AP90Q is not set
+# CONFIG_ATH79_MACH_AP91_5G is not set
+# CONFIG_ATH79_MACH_AP96 is not set
+# CONFIG_ATH79_MACH_ARCHER_C25_V1 is not set
+# CONFIG_ATH79_MACH_ARCHER_C58_V1 is not set
+# CONFIG_ATH79_MACH_ARCHER_C59_V1 is not set
+# CONFIG_ATH79_MACH_ARCHER_C60_V1 is not set
+# CONFIG_ATH79_MACH_ARCHER_C60_V2 is not set
+# CONFIG_ATH79_MACH_ARCHER_C7 is not set
+# CONFIG_ATH79_MACH_ARDUINO_YUN is not set
+# CONFIG_ATH79_MACH_AW_NR580 is not set
+# CONFIG_ATH79_MACH_BHR_4GRV2 is not set
+# CONFIG_ATH79_MACH_BHU_BXU2000N2_A is not set
+# CONFIG_ATH79_MACH_BSB is not set
+# CONFIG_ATH79_MACH_C55 is not set
+# CONFIG_ATH79_MACH_C60 is not set
+# CONFIG_ATH79_MACH_CAP324 is not set
+# CONFIG_ATH79_MACH_CAP4200AG is not set
+# CONFIG_ATH79_MACH_CARAMBOLA2 is not set
+# CONFIG_ATH79_MACH_CF_E316N_V2 is not set
+# CONFIG_ATH79_MACH_CF_E320N_V2 is not set
+# CONFIG_ATH79_MACH_CF_E355AC is not set
+# CONFIG_ATH79_MACH_CF_E375AC is not set
+# CONFIG_ATH79_MACH_CF_E380AC_V1 is not set
+# CONFIG_ATH79_MACH_CF_E380AC_V2 is not set
+# CONFIG_ATH79_MACH_CF_E520N is not set
+# CONFIG_ATH79_MACH_CF_E530N is not set
+# CONFIG_ATH79_MACH_CPE505N is not set
+# CONFIG_ATH79_MACH_CPE510 is not set
+# CONFIG_ATH79_MACH_CPE830 is not set
+# CONFIG_ATH79_MACH_CPE870 is not set
+# CONFIG_ATH79_MACH_CR3000 is not set
+# CONFIG_ATH79_MACH_CR5000 is not set
+# CONFIG_ATH79_MACH_DAP_1330_A1 is not set
+# CONFIG_ATH79_MACH_DAP_2695_A1 is not set
+# CONFIG_ATH79_MACH_DB120 is not set
+# CONFIG_ATH79_MACH_DGL_5500_A1 is not set
+# CONFIG_ATH79_MACH_DHP_1565_A1 is not set
+# CONFIG_ATH79_MACH_DIR_505_A1 is not set
+# CONFIG_ATH79_MACH_DIR_600_A1 is not set
+# CONFIG_ATH79_MACH_DIR_615_C1 is not set
+# CONFIG_ATH79_MACH_DIR_615_I1 is not set
+# CONFIG_ATH79_MACH_DIR_825_B1 is not set
+# CONFIG_ATH79_MACH_DIR_825_C1 is not set
+# CONFIG_ATH79_MACH_DIR_869_A1 is not set
+# CONFIG_ATH79_MACH_DLAN_HOTSPOT is not set
+# CONFIG_ATH79_MACH_DLAN_PRO_1200_AC is not set
+# CONFIG_ATH79_MACH_DLAN_PRO_500_WP is not set
+# CONFIG_ATH79_MACH_DOMYWIFI_DW33D is not set
+# CONFIG_ATH79_MACH_DR342 is not set
+# CONFIG_ATH79_MACH_DR344 is not set
+# CONFIG_ATH79_MACH_DR531 is not set
+# CONFIG_ATH79_MACH_DRAGINO2 is not set
+# CONFIG_ATH79_MACH_E1700AC_V2 is not set
+# CONFIG_ATH79_MACH_E2100L is not set
+# CONFIG_ATH79_MACH_E600G_V2 is not set
+# CONFIG_ATH79_MACH_EAP120 is not set
+# CONFIG_ATH79_MACH_EAP300V2 is not set
+# CONFIG_ATH79_MACH_EAP7660D is not set
+# CONFIG_ATH79_MACH_EL_M150 is not set
+# CONFIG_ATH79_MACH_EL_MINI is not set
+# CONFIG_ATH79_MACH_ENS202EXT is not set
+# CONFIG_ATH79_MACH_EPG5000 is not set
+# CONFIG_ATH79_MACH_ESR1750 is not set
+# CONFIG_ATH79_MACH_ESR900 is not set
+# CONFIG_ATH79_MACH_EW_BALIN is not set
+# CONFIG_ATH79_MACH_EW_DORIN is not set
+# CONFIG_ATH79_MACH_F9K1115V2 is not set
+# CONFIG_ATH79_MACH_FRITZ300E is not set
+# CONFIG_ATH79_MACH_FRITZ4020 is not set
+# CONFIG_ATH79_MACH_GL_AR150 is not set
+# CONFIG_ATH79_MACH_GL_AR300 is not set
+# CONFIG_ATH79_MACH_GL_AR300M is not set
+# CONFIG_ATH79_MACH_GL_AR750 is not set
+# CONFIG_ATH79_MACH_GL_AR750S is not set
+# CONFIG_ATH79_MACH_GL_DOMINO is not set
+# CONFIG_ATH79_MACH_GL_INET is not set
+# CONFIG_ATH79_MACH_GL_MIFI is not set
+# CONFIG_ATH79_MACH_GL_USB150 is not set
+# CONFIG_ATH79_MACH_GS_OOLITE_V1 is not set
+# CONFIG_ATH79_MACH_GS_OOLITE_V5_2 is not set
+# CONFIG_ATH79_MACH_HIVEAP_121 is not set
+# CONFIG_ATH79_MACH_HIWIFI_HC6361 is not set
+# CONFIG_ATH79_MACH_HORNET_UB is not set
+# CONFIG_ATH79_MACH_JA76PF is not set
+# CONFIG_ATH79_MACH_JWAP003 is not set
+# CONFIG_ATH79_MACH_JWAP230 is not set
+# CONFIG_ATH79_MACH_LAN_TURTLE is not set
+# CONFIG_ATH79_MACH_LIMA is not set
+# CONFIG_ATH79_MACH_MC_MAC1200R is not set
+# CONFIG_ATH79_MACH_MR12 is not set
+# CONFIG_ATH79_MACH_MR16 is not set
+# CONFIG_ATH79_MACH_MR1750 is not set
+# CONFIG_ATH79_MACH_MR18 is not set
+# CONFIG_ATH79_MACH_MR600 is not set
+# CONFIG_ATH79_MACH_MR900 is not set
+# CONFIG_ATH79_MACH_MYNET_N600 is not set
+# CONFIG_ATH79_MACH_MYNET_N750 is not set
+# CONFIG_ATH79_MACH_MYNET_REXT is not set
+# CONFIG_ATH79_MACH_MZK_W04NU is not set
+# CONFIG_ATH79_MACH_MZK_W300NH is not set
+# CONFIG_ATH79_MACH_N5Q is not set
+# CONFIG_ATH79_MACH_NBG460N is not set
+# CONFIG_ATH79_MACH_NBG6716 is not set
+# CONFIG_ATH79_MACH_OM2P is not set
+# CONFIG_ATH79_MACH_OM5P is not set
+# CONFIG_ATH79_MACH_OM5P_AC is not set
+# CONFIG_ATH79_MACH_OM5P_ACv2 is not set
+# CONFIG_ATH79_MACH_OMY_G1 is not set
+# CONFIG_ATH79_MACH_OMY_X1 is not set
+# CONFIG_ATH79_MACH_ONION_OMEGA is not set
+# CONFIG_ATH79_MACH_PB42 is not set
+# CONFIG_ATH79_MACH_PB44 is not set
+# CONFIG_ATH79_MACH_PQI_AIR_PEN is not set
+# CONFIG_ATH79_MACH_QIHOO_C301 is not set
+# CONFIG_ATH79_MACH_R36A is not set
+# CONFIG_ATH79_MACH_R602N is not set
+# CONFIG_ATH79_MACH_R6100 is not set
+# CONFIG_ATH79_MACH_RAMBUTAN is not set
+# CONFIG_ATH79_MACH_RB2011 is not set
+# CONFIG_ATH79_MACH_RB4XX is not set
+# CONFIG_ATH79_MACH_RB750 is not set
+# CONFIG_ATH79_MACH_RB91X is not set
+# CONFIG_ATH79_MACH_RB922 is not set
+# CONFIG_ATH79_MACH_RB95X is not set
+# CONFIG_ATH79_MACH_RBSPI is not set
+# CONFIG_ATH79_MACH_RBSXTLITE is not set
+# CONFIG_ATH79_MACH_RE355 is not set
+# CONFIG_ATH79_MACH_RE450 is not set
+# CONFIG_ATH79_MACH_RME_EG200 is not set
+# CONFIG_ATH79_MACH_RUT9XX is not set
+# CONFIG_ATH79_MACH_RW2458N is not set
+# CONFIG_ATH79_MACH_SC1750 is not set
+# CONFIG_ATH79_MACH_SC300M is not set
+# CONFIG_ATH79_MACH_SC450 is not set
+# CONFIG_ATH79_MACH_SMART_300 is not set
+# CONFIG_ATH79_MACH_SOM9331 is not set
+# CONFIG_ATH79_MACH_SR3200 is not set
+# CONFIG_ATH79_MACH_T830 is not set
+# CONFIG_ATH79_MACH_TELLSTICK_ZNET_LITE is not set
+# CONFIG_ATH79_MACH_TEW_632BRP is not set
+# CONFIG_ATH79_MACH_TEW_673GRU is not set
+# CONFIG_ATH79_MACH_TEW_712BR is not set
+# CONFIG_ATH79_MACH_TEW_732BR is not set
+# CONFIG_ATH79_MACH_TEW_823DRU is not set
+# CONFIG_ATH79_MACH_TL_MR11U is not set
+# CONFIG_ATH79_MACH_TL_MR13U is not set
+# CONFIG_ATH79_MACH_TL_MR3020 is not set
+# CONFIG_ATH79_MACH_TL_MR3X20 is not set
+# CONFIG_ATH79_MACH_TL_MR6400 is not set
+# CONFIG_ATH79_MACH_TL_WA701ND_V2 is not set
+# CONFIG_ATH79_MACH_TL_WA7210N_V2 is not set
+# CONFIG_ATH79_MACH_TL_WA801ND_V3 is not set
+# CONFIG_ATH79_MACH_TL_WA830RE_V2 is not set
+# CONFIG_ATH79_MACH_TL_WA850RE_V2 is not set
+# CONFIG_ATH79_MACH_TL_WA855RE_V1 is not set
+# CONFIG_ATH79_MACH_TL_WA901ND is not set
+# CONFIG_ATH79_MACH_TL_WA901ND_V2 is not set
+# CONFIG_ATH79_MACH_TL_WA901ND_V4 is not set
+# CONFIG_ATH79_MACH_TL_WAX50RE is not set
+# CONFIG_ATH79_MACH_TL_WDR3320_V2 is not set
+# CONFIG_ATH79_MACH_TL_WDR3500 is not set
+# CONFIG_ATH79_MACH_TL_WDR4300 is not set
+# CONFIG_ATH79_MACH_TL_WDR6500_V2 is not set
+# CONFIG_ATH79_MACH_TL_WPA8630 is not set
+# CONFIG_ATH79_MACH_TL_WR1041N_V2 is not set
+# CONFIG_ATH79_MACH_TL_WR1043ND is not set
+# CONFIG_ATH79_MACH_TL_WR1043ND_V2 is not set
+# CONFIG_ATH79_MACH_TL_WR1043ND_V4 is not set
+# CONFIG_ATH79_MACH_TL_WR1043N_V5 is not set
+# CONFIG_ATH79_MACH_TL_WR2543N is not set
+# CONFIG_ATH79_MACH_TL_WR703N is not set
+# CONFIG_ATH79_MACH_TL_WR720N_V3 is not set
+# CONFIG_ATH79_MACH_TL_WR741ND is not set
+# CONFIG_ATH79_MACH_TL_WR741ND_V4 is not set
+# CONFIG_ATH79_MACH_TL_WR802N_V1 is not set
+# CONFIG_ATH79_MACH_TL_WR802N_V2 is not set
+# CONFIG_ATH79_MACH_TL_WR810N is not set
+# CONFIG_ATH79_MACH_TL_WR810N_V2 is not set
+# CONFIG_ATH79_MACH_TL_WR840N_V2 is not set
+# CONFIG_ATH79_MACH_TL_WR841N_V1 is not set
+# CONFIG_ATH79_MACH_TL_WR841N_V8 is not set
+# CONFIG_ATH79_MACH_TL_WR841N_V9 is not set
+# CONFIG_ATH79_MACH_TL_WR902AC_V1 is not set
+# CONFIG_ATH79_MACH_TL_WR940N_V4 is not set
+# CONFIG_ATH79_MACH_TL_WR941ND is not set
+# CONFIG_ATH79_MACH_TL_WR941ND_V6 is not set
+# CONFIG_ATH79_MACH_TL_WR942N_V1 is not set
+# CONFIG_ATH79_MACH_TS_D084 is not set
+# CONFIG_ATH79_MACH_TUBE2H is not set
+# CONFIG_ATH79_MACH_UBNT is not set
+# CONFIG_ATH79_MACH_UBNT_UNIFIAC is not set
+# CONFIG_ATH79_MACH_UBNT_XM is not set
+# CONFIG_ATH79_MACH_WAM250 is not set
+# CONFIG_ATH79_MACH_WEIO is not set
+# CONFIG_ATH79_MACH_WHR_HP_G300N is not set
+# CONFIG_ATH79_MACH_WI2A_AC200I is not set
+# CONFIG_ATH79_MACH_WIFI_PINEAPPLE_NANO is not set
+# CONFIG_ATH79_MACH_WLAE_AG300N is not set
+# CONFIG_ATH79_MACH_WLR8100 is not set
+# CONFIG_ATH79_MACH_WNDAP360 is not set
+# CONFIG_ATH79_MACH_WNDR3700 is not set
+# CONFIG_ATH79_MACH_WNDR4300 is not set
+# CONFIG_ATH79_MACH_WNR2000 is not set
+# CONFIG_ATH79_MACH_WNR2000_V3 is not set
+# CONFIG_ATH79_MACH_WNR2000_V4 is not set
+# CONFIG_ATH79_MACH_WNR2200 is not set
+# CONFIG_ATH79_MACH_WP543 is not set
+# CONFIG_ATH79_MACH_WPE72 is not set
+# CONFIG_ATH79_MACH_WPJ342 is not set
+# CONFIG_ATH79_MACH_WPJ344 is not set
+# CONFIG_ATH79_MACH_WPJ531 is not set
+# CONFIG_ATH79_MACH_WPJ558 is not set
+# CONFIG_ATH79_MACH_WPJ563 is not set
+# CONFIG_ATH79_MACH_WRT160NL is not set
+# CONFIG_ATH79_MACH_WRT400N is not set
+# CONFIG_ATH79_MACH_WRTNODE2Q is not set
+# CONFIG_ATH79_MACH_WZR_450HP2 is not set
+# CONFIG_ATH79_MACH_WZR_HP_AG300H is not set
+# CONFIG_ATH79_MACH_WZR_HP_G300NH is not set
+# CONFIG_ATH79_MACH_WZR_HP_G300NH2 is not set
+# CONFIG_ATH79_MACH_WZR_HP_G450H is not set
+# CONFIG_ATH79_MACH_XD3200 is not set
+# CONFIG_ATH79_MACH_Z1 is not set
+# CONFIG_ATH79_MACH_ZBT_WE1526 is not set
+# CONFIG_ATH79_MACH_ZCN_1523H is not set
+# CONFIG_ATH79_NVRAM is not set
+# CONFIG_ATH79_PCI_ATH9K_FIXUP is not set
+# CONFIG_ATH79_ROUTERBOOT is not set
+CONFIG_ATH79_WDT=y
+CONFIG_CEVT_R4K=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMDLINE="rootfstype=squashfs noinitrd"
+CONFIG_CMDLINE_BOOL=y
+# CONFIG_CMDLINE_OVERRIDE is not set
+CONFIG_COMMON_CLK=y
+# CONFIG_COMMON_CLK_BOSTON is not set
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_CPU_GENERIC_DUMP_TLB=y
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_RIXI=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+CONFIG_CPU_R4K_CACHE_TLB=y
+CONFIG_CPU_R4K_FPU=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_MSA=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CSRC_R4K=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_ETHERNET_PACKET_MANGLE=y
+CONFIG_FIXED_PHY=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_GPIO_74X164=y
+CONFIG_GPIO_ATH79=y
+CONFIG_GPIO_GENERIC=y
+# CONFIG_GPIO_LATCH is not set
+CONFIG_GPIO_NXP_74HC153=y
+CONFIG_GPIO_PCF857X=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_HARDWARE_WATCHPOINTS=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_HAVE_CBPF_JIT=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HZ_PERIODIC=y
+CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_GPIO=y
+CONFIG_IMAGE_CMDLINE_HACK=y
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_SOURCE="../../root"
+CONFIG_INTEL_XWAY_PHY=y
+CONFIG_IP17XX_PHY=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_MIPS_CPU=y
+CONFIG_IRQ_WORK=y
+CONFIG_LEDS_GPIO=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BOARDINFO=y
+CONFIG_MDIO_GPIO=y
+CONFIG_MICREL_PHY=y
+CONFIG_MIPS=y
+CONFIG_MIPS_ASID_BITS=8
+CONFIG_MIPS_ASID_SHIFT=0
+CONFIG_MIPS_CLOCK_VSYSCALL=y
+# CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND is not set
+CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_MIPS_HUGE_TLB_SUPPORT is not set
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+CONFIG_MIPS_MACHINE=y
+CONFIG_MIPS_SPRAM=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CYBERTAN_PARTS=y
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+CONFIG_MTD_MYLOADER_PARTS=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-2
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPLIT_EVA_FW=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_LZMA_FW=y
+CONFIG_MTD_SPLIT_MINOR_FW=y
+CONFIG_MTD_SPLIT_SEAMA_FW=y
+CONFIG_MTD_SPLIT_TPLINK_FW=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_SPLIT_WRGG_FW=y
+CONFIG_MTD_TPLINK_PARTS=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MV88E6060=y
+CONFIG_NET_DSA_MV88E6063=y
+CONFIG_NET_DSA_TAG_TRAILER=y
+CONFIG_NET_SWITCHDEV=y
+CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
+# CONFIG_NO_IOPORT_MAP is not set
+# CONFIG_OF is not set
+# CONFIG_PCI_AR724X is not set
+CONFIG_PCI_DRIVERS_LEGACY=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_PHYLIB=y
+CONFIG_RATIONAL=y
+# CONFIG_RCU_STALL_COMMON is not set
+CONFIG_RTL8306_PHY=y
+CONFIG_RTL8366RB_PHY=y
+CONFIG_RTL8366S_PHY=y
+CONFIG_RTL8366_SMI=y
+CONFIG_RTL8367_PHY=y
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SERIAL_8250_FSL is not set
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SOC_AR71XX is not set
+# CONFIG_SOC_AR724X is not set
+# CONFIG_SOC_AR913X is not set
+# CONFIG_SOC_AR933X is not set
+# CONFIG_SOC_AR934X is not set
+# CONFIG_SOC_QCA953X is not set
+# CONFIG_SOC_QCA955X is not set
+# CONFIG_SOC_QCA956X is not set
+CONFIG_SPI=y
+CONFIG_SPI_ATH79=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_RB4XX is not set
+# CONFIG_SPI_VSC7385 is not set
+CONFIG_SRCU=y
+CONFIG_SWCONFIG=y
+CONFIG_SWCONFIG_LEDS=y
+CONFIG_SWPHY=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_EARLY_PRINTK=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_MIPS16=y
+CONFIG_SYS_SUPPORTS_ZBOOT=y
+CONFIG_SYS_SUPPORTS_ZBOOT_UART_PROM=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_USB_SUPPORT=y
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt b/target/linux/ar71xx/files-4.14/arch/mips/ath79/Kconfig.openwrt
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/Kconfig.openwrt
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/Makefile b/target/linux/ar71xx/files-4.14/arch/mips/ath79/Makefile
new file mode 100644
index 0000000000..9ed4c6688e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/Makefile
@@ -0,0 +1,284 @@
+#
+# Makefile for the Atheros AR71XX/AR724X/AR913X specific parts of the kernel
+#
+# Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+# Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 as published
+# by the Free Software Foundation.
+
+obj-y	:= prom.o setup.o irq.o common.o clock.o gpio.o
+
+obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+obj-$(CONFIG_PCI)			+= pci.o
+
+#
+# Devices
+#
+obj-y					+= dev-common.o
+obj-$(CONFIG_ATH79_DEV_AP9X_PCI)	+= dev-ap9x-pci.o
+obj-$(CONFIG_ATH79_DEV_DSA)		+= dev-dsa.o
+obj-$(CONFIG_ATH79_DEV_ETH)		+= dev-eth.o
+obj-$(CONFIG_ATH79_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
+obj-$(CONFIG_ATH79_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
+obj-$(CONFIG_ATH79_DEV_M25P80)		+= dev-m25p80.o
+obj-$(CONFIG_ATH79_DEV_NFC)		+= dev-nfc.o
+obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
+obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
+obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+
+#
+# Miscellaneous objects
+#
+obj-$(CONFIG_ATH79_NVRAM)		+= nvram.o
+obj-$(CONFIG_ATH79_PCI_ATH9K_FIXUP)	+= pci-ath9k-fixup.o
+obj-$(CONFIG_ATH79_ROUTERBOOT)		+= routerboot.o
+
+#
+# Machines
+#
+obj-$(CONFIG_ATH79_MACH_A60)			+= mach-a60.o
+obj-$(CONFIG_ATH79_MACH_WI2A_AC200I)		+= mach-wi2a-ac200i.o
+obj-$(CONFIG_ATH79_MACH_ALFA_AP120C)		+= mach-alfa-ap120c.o
+obj-$(CONFIG_ATH79_MACH_ALFA_AP96)		+= mach-alfa-ap96.o
+obj-$(CONFIG_ATH79_MACH_ALFA_NX)		+= mach-alfa-nx.o
+obj-$(CONFIG_ATH79_MACH_ALL0258N)		+= mach-all0258n.o
+obj-$(CONFIG_ATH79_MACH_ALL0315N)		+= mach-all0315n.o
+obj-$(CONFIG_ATH79_MACH_ANTMINER_S1)		+= mach-antminer-s1.o
+obj-$(CONFIG_ATH79_MACH_ANTMINER_S3)		+= mach-antminer-s3.o
+obj-$(CONFIG_ATH79_MACH_ANTROUTER_R1)		+= mach-antrouter-r1.o
+obj-$(CONFIG_ATH79_MACH_AP121)			+= mach-ap121.o
+obj-$(CONFIG_ATH79_MACH_AP121F)			+= mach-ap121f.o
+obj-$(CONFIG_ATH79_MACH_AP132)			+= mach-ap132.o
+obj-$(CONFIG_ATH79_MACH_AP136)			+= mach-ap136.o
+obj-$(CONFIG_ATH79_MACH_AP143)			+= mach-ap143.o
+obj-$(CONFIG_ATH79_MACH_AP147)			+= mach-ap147.o
+obj-$(CONFIG_ATH79_MACH_AP152)			+= mach-ap152.o
+obj-$(CONFIG_ATH79_MACH_AP531B0)		+= mach-ap531b0.o
+obj-$(CONFIG_ATH79_MACH_AP90Q)			+= mach-ap90q.o
+obj-$(CONFIG_ATH79_MACH_AP91_5G)		+= mach-ap91-5g.o
+obj-$(CONFIG_ATH79_MACH_AP96)			+= mach-ap96.o
+obj-$(CONFIG_ATH79_MACH_AP81)			+= mach-ap81.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C25_V1)		+= mach-archer-c25-v1.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C58_V1)		+= mach-archer-c59-v1.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C59_V1)		+= mach-archer-c59-v1.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C60_V1)		+= mach-archer-c60-v1.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C60_V2)		+= mach-archer-c60-v1.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C7)		+= mach-archer-c7.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C7)		+= mach-archer-c7-v4.o
+obj-$(CONFIG_ATH79_MACH_ARDUINO_YUN)		+= mach-arduino-yun.o
+obj-$(CONFIG_ATH79_MACH_AW_NR580)		+= mach-aw-nr580.o
+obj-$(CONFIG_ATH79_MACH_BHR_4GRV2)		+= mach-bhr-4grv2.o
+obj-$(CONFIG_ATH79_MACH_BHU_BXU2000N2_A)	+= mach-bhu-bxu2000n2-a.o
+obj-$(CONFIG_ATH79_MACH_BSB)			+= mach-bsb.o
+obj-$(CONFIG_ATH79_MACH_C55)			+= mach-c55.o
+obj-$(CONFIG_ATH79_MACH_C60)			+= mach-c60.o
+obj-$(CONFIG_ATH79_MACH_CAP324)			+= mach-cap324.o
+obj-$(CONFIG_ATH79_MACH_CAP4200AG)		+= mach-cap4200ag.o
+obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)		+= mach-carambola2.o
+obj-$(CONFIG_ATH79_MACH_CF_E316N_V2)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E320N_V2)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E355AC)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E375AC)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E380AC_V1)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E380AC_V2)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E520N)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CF_E530N)		+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CPE505N)		+= mach-r602n.o
+obj-$(CONFIG_ATH79_MACH_CPE510)			+= mach-cpe510.o
+obj-$(CONFIG_ATH79_MACH_CPE830)			+= mach-ap90q.o
+obj-$(CONFIG_ATH79_MACH_CPE870)			+= mach-cpe870.o
+obj-$(CONFIG_ATH79_MACH_CR3000)			+= mach-cr3000.o
+obj-$(CONFIG_ATH79_MACH_CR5000)			+= mach-cr5000.o
+obj-$(CONFIG_ATH79_MACH_DAP_1330_A1)		+= mach-dap-1330-a1.o
+obj-$(CONFIG_ATH79_MACH_DAP_2695_A1)		+= mach-dap-2695-a1.o
+obj-$(CONFIG_ATH79_MACH_DB120)			+= mach-db120.o
+obj-$(CONFIG_ATH79_MACH_DGL_5500_A1)		+= mach-dgl-5500-a1.o
+obj-$(CONFIG_ATH79_MACH_DHP_1565_A1)		+= mach-dhp-1565-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_505_A1)		+= mach-dir-505-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_600_A1)		+= mach-dir-600-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_615_C1)		+= mach-dir-615-c1.o
+obj-$(CONFIG_ATH79_MACH_DIR_615_I1)		+= mach-dir-615-i1.o
+obj-$(CONFIG_ATH79_MACH_DIR_825_B1)		+= mach-dir-825-b1.o
+obj-$(CONFIG_ATH79_MACH_DIR_825_C1)		+= mach-dir-825-c1.o
+obj-$(CONFIG_ATH79_MACH_DIR_869_A1)		+= mach-dir-869-a1.o
+obj-$(CONFIG_ATH79_MACH_DLAN_HOTSPOT)		+= mach-dlan-hotspot.o
+obj-$(CONFIG_ATH79_MACH_DLAN_PRO_1200_AC)	+= mach-dlan-pro-1200-ac.o
+obj-$(CONFIG_ATH79_MACH_DLAN_PRO_500_WP)	+= mach-dlan-pro-500-wp.o
+obj-$(CONFIG_ATH79_MACH_DOMYWIFI_DW33D)		+= mach-domywifi-dw33d.o
+obj-$(CONFIG_ATH79_MACH_DR342)			+= mach-dr344.o
+obj-$(CONFIG_ATH79_MACH_DR344)			+= mach-dr344.o
+obj-$(CONFIG_ATH79_MACH_DR531)			+= mach-dr531.o
+obj-$(CONFIG_ATH79_MACH_DRAGINO2)		+= mach-dragino2.o
+obj-$(CONFIG_ATH79_MACH_E1700AC_V2)		+= mach-e1700ac-v2.o
+obj-$(CONFIG_ATH79_MACH_E600G_V2)		+= mach-e600g-v2.o
+obj-$(CONFIG_ATH79_MACH_EAP120)			+= mach-eap120.o
+obj-$(CONFIG_ATH79_MACH_EAP300V2)		+= mach-eap300v2.o
+obj-$(CONFIG_ATH79_MACH_EAP7660D)		+= mach-eap7660d.o
+obj-$(CONFIG_ATH79_MACH_EL_M150)		+= mach-el-m150.o
+obj-$(CONFIG_ATH79_MACH_EL_MINI)		+= mach-el-mini.o
+obj-$(CONFIG_ATH79_MACH_ENS202EXT)		+= mach-ens202ext.o
+obj-$(CONFIG_ATH79_MACH_EPG5000)		+= mach-epg5000.o
+obj-$(CONFIG_ATH79_MACH_ESR1750)		+= mach-esr1750.o
+obj-$(CONFIG_ATH79_MACH_ESR900)			+= mach-esr900.o
+obj-$(CONFIG_ATH79_MACH_EW_BALIN)		+= mach-ew-balin.o
+obj-$(CONFIG_ATH79_MACH_EW_DORIN)		+= mach-ew-dorin.o
+obj-$(CONFIG_ATH79_MACH_F9K1115V2)		+= mach-f9k1115v2.o
+obj-$(CONFIG_ATH79_MACH_FRITZ300E)		+= mach-fritz300e.o
+obj-$(CONFIG_ATH79_MACH_FRITZ4020)		+= mach-fritz4020.o
+obj-$(CONFIG_ATH79_MACH_GL_AR150)		+= mach-gl-ar150.o
+obj-$(CONFIG_ATH79_MACH_GL_AR300)		+= mach-gl-ar300.o
+obj-$(CONFIG_ATH79_MACH_GL_AR300M)		+= mach-gl-ar300m.o
+obj-$(CONFIG_ATH79_MACH_GL_AR750)		+= mach-gl-ar750.o
+obj-$(CONFIG_ATH79_MACH_GL_AR750S)		+= mach-gl-ar750s.o
+obj-$(CONFIG_ATH79_MACH_GL_DOMINO)		+= mach-gl-domino.o
+obj-$(CONFIG_ATH79_MACH_GL_INET)		+= mach-gl-inet.o
+obj-$(CONFIG_ATH79_MACH_GL_MIFI)		+= mach-gl-mifi.o
+obj-$(CONFIG_ATH79_MACH_GL_USB150)		+= mach-gl-usb150.o
+obj-$(CONFIG_ATH79_MACH_GS_OOLITE_V1)		+= mach-gs-oolite-v1.o
+obj-$(CONFIG_ATH79_MACH_GS_OOLITE_V5_2)		+= mach-gs-oolite-v5-2.o
+obj-$(CONFIG_ATH79_MACH_HIVEAP_121)		+= mach-hiveap-121.o
+obj-$(CONFIG_ATH79_MACH_HIWIFI_HC6361)		+= mach-hiwifi-hc6361.o
+obj-$(CONFIG_ATH79_MACH_HORNET_UB)		+= mach-hornet-ub.o
+obj-$(CONFIG_ATH79_MACH_JA76PF)			+= mach-ja76pf.o
+obj-$(CONFIG_ATH79_MACH_JWAP003)		+= mach-jwap003.o
+obj-$(CONFIG_ATH79_MACH_JWAP230)		+= mach-jwap230.o
+obj-$(CONFIG_ATH79_MACH_LAN_TURTLE)		+= mach-lan-turtle.o
+obj-$(CONFIG_ATH79_MACH_LIMA)			+= mach-lima.o
+obj-$(CONFIG_ATH79_MACH_MC_MAC1200R)		+= mach-mc-mac1200r.o
+obj-$(CONFIG_ATH79_MACH_MR12)			+= mach-mr12.o
+obj-$(CONFIG_ATH79_MACH_MR16)			+= mach-mr16.o
+obj-$(CONFIG_ATH79_MACH_MR1750)			+= mach-mr1750.o
+obj-$(CONFIG_ATH79_MACH_MR18)			+= mach-mr18.o
+obj-$(CONFIG_ATH79_MACH_MR600)			+= mach-mr600.o
+obj-$(CONFIG_ATH79_MACH_MR900)			+= mach-mr900.o
+obj-$(CONFIG_ATH79_MACH_MYNET_N600)		+= mach-mynet-n600.o
+obj-$(CONFIG_ATH79_MACH_MYNET_N750)		+= mach-mynet-n750.o
+obj-$(CONFIG_ATH79_MACH_MYNET_REXT)		+= mach-mynet-rext.o
+obj-$(CONFIG_ATH79_MACH_MZK_W04NU)		+= mach-mzk-w04nu.o
+obj-$(CONFIG_ATH79_MACH_MZK_W300NH)		+= mach-mzk-w300nh.o
+obj-$(CONFIG_ATH79_MACH_N5Q)			+= mach-n5q.o
+obj-$(CONFIG_ATH79_MACH_NBG460N)		+= mach-nbg460n.o
+obj-$(CONFIG_ATH79_MACH_NBG6716)		+= mach-nbg6716.o
+obj-$(CONFIG_ATH79_MACH_RAMBUTAN)		+= mach-rambutan.o
+obj-$(CONFIG_ATH79_MACH_OM2P)			+= mach-om2p.o
+obj-$(CONFIG_ATH79_MACH_OM5P)			+= mach-om5p.o
+obj-$(CONFIG_ATH79_MACH_OM5P_AC)		+= mach-om5pac.o
+obj-$(CONFIG_ATH79_MACH_OM5P_ACv2)		+= mach-om5pacv2.o
+obj-$(CONFIG_ATH79_MACH_OMY_G1)			+= mach-omy-g1.o
+obj-$(CONFIG_ATH79_MACH_OMY_X1)			+= mach-omy-x1.o
+obj-$(CONFIG_ATH79_MACH_ONION_OMEGA)		+= mach-onion-omega.o
+obj-$(CONFIG_ATH79_MACH_PB42)			+= mach-pb42.o
+obj-$(CONFIG_ATH79_MACH_PB44)			+= mach-pb44.o
+obj-$(CONFIG_ATH79_MACH_PQI_AIR_PEN)		+= mach-pqi-air-pen.o
+obj-$(CONFIG_ATH79_MACH_QIHOO_C301)		+= mach-qihoo-c301.o
+obj-$(CONFIG_ATH79_MACH_R36A)			+= mach-r36a.o
+obj-$(CONFIG_ATH79_MACH_R602N)			+= mach-r602n.o
+obj-$(CONFIG_ATH79_MACH_R6100)			+= mach-r6100.o
+obj-$(CONFIG_ATH79_MACH_RB2011)			+= mach-rb2011.o
+obj-$(CONFIG_ATH79_MACH_RB4XX)			+= mach-rb4xx.o
+obj-$(CONFIG_ATH79_MACH_RB750)			+= mach-rb750.o
+obj-$(CONFIG_ATH79_MACH_RB91X)			+= mach-rb91x.o
+obj-$(CONFIG_ATH79_MACH_RB922)			+= mach-rb922.o
+obj-$(CONFIG_ATH79_MACH_RB941)			+= mach-rb941.o
+obj-$(CONFIG_ATH79_MACH_RB95X)			+= mach-rb95x.o
+obj-$(CONFIG_ATH79_MACH_RBSPI)			+= mach-rbspi.o
+obj-$(CONFIG_ATH79_MACH_RBSXTLITE)		+= mach-rbsxtlite.o
+obj-$(CONFIG_ATH79_MACH_RE355)			+= mach-re450.o
+obj-$(CONFIG_ATH79_MACH_RE450)			+= mach-re450.o
+obj-$(CONFIG_ATH79_MACH_RME_EG200)		+= mach-rme-eg200.o
+obj-$(CONFIG_ATH79_MACH_RUT9XX)			+= mach-rut9xx.o
+obj-$(CONFIG_ATH79_MACH_RW2458N)		+= mach-rw2458n.o
+obj-$(CONFIG_ATH79_MACH_SC1750)			+= mach-sc1750.o
+obj-$(CONFIG_ATH79_MACH_SC300M)			+= mach-sc300m.o
+obj-$(CONFIG_ATH79_MACH_SC450)			+= mach-sc450.o
+obj-$(CONFIG_ATH79_MACH_SMART_300)		+= mach-smart-300.o
+obj-$(CONFIG_ATH79_MACH_SOM9331)		+= mach-som9331.o
+obj-$(CONFIG_ATH79_MACH_SR3200)			+= mach-sr3200.o
+obj-$(CONFIG_ATH79_MACH_T830)			+= mach-t830.o
+obj-$(CONFIG_ATH79_MACH_TELLSTICK_ZNET_LITE)	+= mach-tellstick-znet-lite.o
+obj-$(CONFIG_ATH79_MACH_TEW_632BRP)		+= mach-tew-632brp.o
+obj-$(CONFIG_ATH79_MACH_TEW_673GRU)		+= mach-tew-673gru.o
+obj-$(CONFIG_ATH79_MACH_TEW_712BR)		+= mach-tew-712br.o
+obj-$(CONFIG_ATH79_MACH_TEW_732BR)		+= mach-tew-732br.o
+obj-$(CONFIG_ATH79_MACH_TEW_823DRU)		+= mach-tew-823dru.o
+obj-$(CONFIG_ATH79_MACH_TL_MR11U)		+= mach-tl-mr11u.o
+obj-$(CONFIG_ATH79_MACH_TL_MR13U)		+= mach-tl-mr13u.o
+obj-$(CONFIG_ATH79_MACH_TL_MR3020)		+= mach-tl-mr3020.o
+obj-$(CONFIG_ATH79_MACH_TL_MR3X20)		+= mach-tl-mr3x20.o
+obj-$(CONFIG_ATH79_MACH_TL_MR6400)		+= mach-tl-mr6400.o
+obj-$(CONFIG_ATH79_MACH_TL_WA701ND_V2)		+= mach-tl-wa701nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA7210N_V2)		+= mach-tl-wa7210n-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA801ND_V3)		+= mach-tl-wa801nd-v3.o
+obj-$(CONFIG_ATH79_MACH_TL_WA830RE_V2)		+= mach-tl-wa830re-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA850RE_V2)		+= mach-tl-wax50re.o
+obj-$(CONFIG_ATH79_MACH_TL_WA855RE_V1)		+= mach-tl-wax50re.o
+obj-$(CONFIG_ATH79_MACH_TL_WA901ND)		+= mach-tl-wa901nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WA901ND_V2)		+= mach-tl-wa901nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA901ND_V4)		+= mach-tl-wa901nd-v4.o
+obj-$(CONFIG_ATH79_MACH_TL_WAX50RE)		+= mach-tl-wax50re.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR3320_V2)		+= mach-tl-wdr3320-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR3500)		+= mach-tl-wdr3500.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR4300)		+= mach-tl-wdr4300.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR6500_V2)		+= mach-tl-wdr6500-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WPA8630)		+= mach-tl-wpa8630.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1041N_V2)		+= mach-tl-wr1041n-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1043ND)		+= mach-tl-wr1043nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1043ND_V2)		+= mach-tl-wr1043nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1043ND_V4)		+= mach-tl-wr1043nd-v4.o
+obj-$(CONFIG_ATH79_MACH_TL_WR2543N)		+= mach-tl-wr2543n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR703N)		+= mach-tl-wr703n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR720N_V3)		+= mach-tl-wr720n-v3.o
+obj-$(CONFIG_ATH79_MACH_TL_WR741ND)		+= mach-tl-wr741nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR741ND_V4)		+= mach-tl-wr741nd-v4.o
+obj-$(CONFIG_ATH79_MACH_TL_WR802N_V1)		+= mach-tl-wr802n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR802N_V2)		+= mach-tl-wr802n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR810N)		+= mach-tl-wr810n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR810N_V2)		+= mach-tl-wr810n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR840N_V2)		+= mach-tl-wr841n-v9.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V1)		+= mach-tl-wr841n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V8)		+= mach-tl-wr841n-v8.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V9)		+= mach-tl-wr841n-v9.o
+obj-$(CONFIG_ATH79_MACH_TL_WR902AC_V1)		+= mach-tl-wr902ac-v1.o
+obj-$(CONFIG_ATH79_MACH_TL_WR941ND)		+= mach-tl-wr941nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR941ND_V6)		+= mach-tl-wr941nd-v6.o
+obj-$(CONFIG_ATH79_MACH_TL_WR940N_V4)		+= mach-tl-wr940n-v4.o
+obj-$(CONFIG_ATH79_MACH_TL_WR942N_V1)		+= mach-tl-wr942n-v1.o
+obj-$(CONFIG_ATH79_MACH_TS_D084)		+= mach-ts-d084.o
+obj-$(CONFIG_ATH79_MACH_TUBE2H)			+= mach-tube2h.o
+obj-$(CONFIG_ATH79_MACH_UBNT)			+= mach-ubnt.o
+obj-$(CONFIG_ATH79_MACH_UBNT_UNIFIAC)		+= mach-ubnt-unifiac.o
+obj-$(CONFIG_ATH79_MACH_UBNT_XM)		+= mach-ubnt-xm.o
+obj-$(CONFIG_ATH79_MACH_WAM250)			+= mach-wam250.o
+obj-$(CONFIG_ATH79_MACH_WEIO)			+= mach-weio.o
+obj-$(CONFIG_ATH79_MACH_WHR_HP_G300N)		+= mach-whr-hp-g300n.o
+obj-$(CONFIG_ATH79_MACH_WIFI_PINEAPPLE_NANO)	+= mach-wifi-pineapple-nano.o
+obj-$(CONFIG_ATH79_MACH_WLAE_AG300N)		+= mach-wlae-ag300n.o
+obj-$(CONFIG_ATH79_MACH_WLR8100)		+= mach-wlr8100.o
+obj-$(CONFIG_ATH79_MACH_WNDAP360)		+= mach-wndap360.o
+obj-$(CONFIG_ATH79_MACH_WNDR3700)		+= mach-wndr3700.o
+obj-$(CONFIG_ATH79_MACH_WNDR4300)		+= mach-wndr4300.o
+obj-$(CONFIG_ATH79_MACH_WNR2000)		+= mach-wnr2000.o
+obj-$(CONFIG_ATH79_MACH_WNR2000_V3)		+= mach-wnr2000-v3.o
+obj-$(CONFIG_ATH79_MACH_WNR2000_V4)		+= mach-wnr2000-v4.o
+obj-$(CONFIG_ATH79_MACH_WNR2200)		+= mach-wnr2200.o
+obj-$(CONFIG_ATH79_MACH_WP543)			+= mach-wp543.o
+obj-$(CONFIG_ATH79_MACH_WPE72)			+= mach-wpe72.o
+obj-$(CONFIG_ATH79_MACH_WPJ342)			+= mach-wpj342.o
+obj-$(CONFIG_ATH79_MACH_WPJ344)			+= mach-wpj344.o
+obj-$(CONFIG_ATH79_MACH_WPJ531)			+= mach-wpj531.o
+obj-$(CONFIG_ATH79_MACH_WPJ558)			+= mach-wpj558.o
+obj-$(CONFIG_ATH79_MACH_WPJ563)			+= mach-wpj563.o
+obj-$(CONFIG_ATH79_MACH_WRT160NL)		+= mach-wrt160nl.o
+obj-$(CONFIG_ATH79_MACH_WRT400N)		+= mach-wrt400n.o
+obj-$(CONFIG_ATH79_MACH_WRTNODE2Q)		+= mach-wrtnode2q.o
+obj-$(CONFIG_ATH79_MACH_WZR_450HP2)		+= mach-wzr-450hp2.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_AG300H)		+= mach-wzr-hp-ag300h.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G300NH)		+= mach-wzr-hp-g300nh.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G300NH2)		+= mach-wzr-hp-g300nh2.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G450H)		+= mach-wzr-hp-g450h.o
+obj-$(CONFIG_ATH79_MACH_XD3200)			+= mach-sr3200.o
+obj-$(CONFIG_ATH79_MACH_Z1)			+= mach-z1.o
+obj-$(CONFIG_ATH79_MACH_ZBT_WE1526)		+= mach-zbt-we1526.o
+obj-$(CONFIG_ATH79_MACH_ZCN_1523H)		+= mach-zcn-1523h.o
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-ap9x-pci.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-ap9x-pci.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-ap9x-pci.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-ap9x-pci.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-ap9x-pci.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-ap9x-pci.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-ap9x-pci.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-ap9x-pci.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-dsa.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-dsa.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-dsa.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-dsa.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-dsa.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-dsa.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-dsa.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-dsa.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-eth.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-eth.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-eth.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-eth.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-m25p80.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-m25p80.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-m25p80.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-m25p80.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-m25p80.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-m25p80.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-m25p80.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-m25p80.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-nfc.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-nfc.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-nfc.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-nfc.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/dev-nfc.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-nfc.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/dev-nfc.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/dev-nfc.h
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-a60.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-a60.c
new file mode 100644
index 0000000000..be41081fc6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-a60.c
@@ -0,0 +1,183 @@
+/*
+ *  OpenMesh A60 support
+ *
+ *  Copyright (C) 2013 Marek Lindner <marek@open-mesh.com>
+ *  Copyright (C) 2014-2017 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-usb.h"
+
+#define A60_GPIO_LED_RED	22
+#define A60_GPIO_LED_GREEN	23
+#define A60_GPIO_LED_BLUE	13
+
+#define A60_GPIO_BTN_RESET	17
+
+#define A60_KEYS_POLL_INTERVAL	20	/* msecs */
+#define A60_KEYS_DEBOUNCE_INTERVAL	(3 * A60_KEYS_POLL_INTERVAL)
+
+#define A60_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led a40_leds_gpio[] __initdata = {
+	{
+		.name		= "a40:red:status",
+		.gpio		= A60_GPIO_LED_RED,
+	}, {
+		.name		= "a40:green:status",
+		.gpio		= A60_GPIO_LED_GREEN,
+	}, {
+		.name		= "a40:blue:status",
+		.gpio		= A60_GPIO_LED_BLUE,
+	}
+};
+
+static struct gpio_led a60_leds_gpio[] __initdata = {
+	{
+		.name		= "a60:red:status",
+		.gpio		= A60_GPIO_LED_RED,
+	}, {
+		.name		= "a60:green:status",
+		.gpio		= A60_GPIO_LED_GREEN,
+	}, {
+		.name		= "a60:blue:status",
+		.gpio		= A60_GPIO_LED_BLUE,
+	}
+};
+
+static struct gpio_keys_button a60_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = A60_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= A60_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data a60_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info a60_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "a60_1",
+		.mdio_addr = 1,
+		.platform_data = &a60_at803x_data,
+	},
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "a60_2",
+		.mdio_addr = 2,
+		.platform_data = &a60_at803x_data,
+	},
+};
+
+static void __init a60_setup_qca955x_eth_cfg(u32 mask,
+					     unsigned int rxd,
+					     unsigned int rxdv,
+					     unsigned int txd,
+					     unsigned int txe)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = mask;
+	t |= rxd << QCA955X_ETH_CFG_RXD_DELAY_SHIFT;
+	t |= rxdv << QCA955X_ETH_CFG_RDV_DELAY_SHIFT;
+	t |= txd << QCA955X_ETH_CFG_TXD_DELAY_SHIFT;
+	t |= txe << QCA955X_ETH_CFG_TXE_DELAY_SHIFT;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init a60_setup_common(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+	ath79_register_gpio_keys_polled(-1, A60_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(a60_gpio_keys),
+					a60_gpio_keys);
+
+	ath79_init_mac(mac, art, 0x02);
+	ath79_register_wmac(art + A60_WMAC_CALDATA_OFFSET, mac);
+
+	a60_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN, 3, 3, 0, 0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(a60_mdio0_info, ARRAY_SIZE(a60_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0x00);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0x01);
+
+	/* GMAC0 is connected to the PHY1 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(1);
+	ath79_eth0_pll_data.pll_1000 = 0x82000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to MDIO1 in SGMII mode */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth1_data.phy_mask = BIT(2);
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_eth1_pll_data.pll_100 = 0x80000101;
+	ath79_eth1_pll_data.pll_10 = 0x80001313;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+static void __init a40_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(a40_leds_gpio), a40_leds_gpio);
+	a60_setup_common();
+}
+
+MIPS_MACHINE(ATH79_MACH_A40, "A40", "OpenMesh A40", a40_setup);
+
+static void __init a60_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(a60_leds_gpio), a60_leds_gpio);
+	a60_setup_common();
+}
+
+MIPS_MACHINE(ATH79_MACH_A60, "A60", "OpenMesh A60", a60_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap120c.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap120c.c
new file mode 100644
index 0000000000..b53d24b42b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap120c.c
@@ -0,0 +1,148 @@
+/*
+ *  ALFA Network AP120C board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2016 Luka Perkov <luka@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/ar8216_platform.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-ap9x-pci.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define ALFA_AP120C_GPIO_LED	0
+
+#define ALFA_AP120C_GPIO_BUTTON_WIFI	16
+
+#define ALFA_AP120C_GPIO_WATCH_DOG	20
+
+#define ALFA_AP120C_KEYS_POLL_INTERVAL		20	/* msecs */
+#define ALFA_AP120C_KEYS_DEBOUNCE_INTERVAL	(3 * ALFA_AP120C_KEYS_POLL_INTERVAL)
+
+#define ALFA_AP120C_MAC_OFFSET		0x1002
+#define ALFA_AP120C_CAL0_OFFSET		0x1000
+
+static struct gpio_keys_button alfa_ap120c_gpio_keys[] __initdata = {
+	{
+		.desc		= "Wireless button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = ALFA_AP120C_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_AP120C_GPIO_BUTTON_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led alfa_ap120c_leds_gpio[] __initdata = {
+	{
+			.name		= "ap120c:red:wlan",
+			.gpio		= ALFA_AP120C_GPIO_LED,
+			.active_low = 0,
+	}
+};
+
+static struct ar8327_pad_cfg ap120c_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data ap120c_ar8327_data = {
+	.pad0_cfg = &ap120c_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info ap120c_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "ap120c",
+		.mdio_addr = 0,
+		.platform_data = &ap120c_ar8327_data,
+	},
+};
+
+static struct flash_platform_data flash __initdata = { NULL, NULL, 0 };
+
+#define ALFA_AP120C_LAN_PHYMASK		BIT(5)
+#define ALFA_AP120C_MDIO_PHYMASK	ALFA_AP120C_LAN_PHYMASK
+
+static void __init alfa_ap120c_init(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac[ETH_ALEN];
+
+	struct ath9k_platform_data *pdata;
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(alfa_ap120c_leds_gpio),
+							 alfa_ap120c_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ALFA_AP120C_KEYS_POLL_INTERVAL,
+									ARRAY_SIZE(alfa_ap120c_gpio_keys),
+									alfa_ap120c_gpio_keys);
+
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+							   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_m25p80_multi(&flash);
+
+	ath79_init_mac(mac, art + ALFA_AP120C_MAC_OFFSET, 1);
+	ath79_register_wmac(art + ALFA_AP120C_CAL0_OFFSET, mac);
+
+	ath79_init_mac(mac, art + ALFA_AP120C_MAC_OFFSET, 2);
+	ap91_pci_init(NULL, mac);
+	pdata = ap9x_pci_get_wmac_data(0);
+	if (!pdata) {
+		pr_err("ap120c: unable to get address of wlan data\n");
+		return;
+	}
+	pdata->use_eeprom = true;
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+							   BIT(15) | BIT(17) | BIT(19) | BIT(21));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + ALFA_AP120C_MAC_OFFSET, 0);
+
+	mdiobus_register_board_info(ap120c_mdio0_info, ARRAY_SIZE(ap120c_mdio0_info));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ALFA_AP120C_LAN_PHYMASK;
+
+	ath79_eth0_pll_data.pll_1000 = 0x42000000;
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_AP120C, "ALFA-AP120C", "ALFA Network AP120C",
+			 alfa_ap120c_init);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-ap96.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap96.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-ap96.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-ap96.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-nx.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-nx.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-nx.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-alfa-nx.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-all0258n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-all0258n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-all0258n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-all0258n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-all0315n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-all0315n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-all0315n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-all0315n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-antminer-s1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antminer-s1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-antminer-s1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antminer-s1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-antminer-s3.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antminer-s3.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-antminer-s3.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antminer-s3.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-antrouter-r1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antrouter-r1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-antrouter-r1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-antrouter-r1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap121f.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap121f.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap121f.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap121f.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap132.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap132.c
new file mode 100644
index 0000000000..ae3097692a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap132.c
@@ -0,0 +1,190 @@
+/*
+ * Atheros AP132 reference board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2013 Embedded Wireless GmbH <info@embeddedwireless.de>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP132_GPIO_LED_USB		4
+#define AP132_GPIO_LED_WLAN_5G		12
+#define AP132_GPIO_LED_WLAN_2G		13
+#define AP132_GPIO_LED_STATUS_RED	14
+#define AP132_GPIO_LED_WPS_RED		15
+
+#define AP132_GPIO_BTN_WPS		16
+
+#define AP132_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP132_KEYS_DEBOUNCE_INTERVAL	(3 * AP132_KEYS_POLL_INTERVAL)
+
+#define AP132_MAC0_OFFSET		0
+#define AP132_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap132_leds_gpio[] __initdata = {
+	{
+		.name		= "ap132:red:status",
+		.gpio		= AP132_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:wps",
+		.gpio		= AP132_GPIO_LED_WPS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:wlan-2g",
+		.gpio		= AP132_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:usb",
+		.gpio		= AP132_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap132_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP132_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP132_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg ap132_ar8327_pad0_cfg;
+
+static struct ar8327_platform_data ap132_ar8327_data = {
+	.pad0_cfg = &ap132_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info ap132_mdio1_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.1",
+		.modalias = "ap132",
+		.mdio_addr = 0,
+		.platform_data = &ap132_ar8327_data,
+	},
+};
+
+static void __init ap132_mdio_setup(void)
+{
+	void __iomem *base;
+	u32 t;
+
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x0050
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MASK                             0x00ff0000
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_LSB                              16
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_SET(x)                           (((x) << GPIO_IN_ENABLE3_MII_GE1_MDI_LSB) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK)
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x003c
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB                        24
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+
+	base = ioremap(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+
+	t = __raw_readl(base + GPIO_IN_ENABLE3_ADDRESS);
+	t &= ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	t |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	__raw_writel(t, base + GPIO_IN_ENABLE3_ADDRESS);
+
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << 19), base + AR71XX_GPIO_REG_OE);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << 17), base + AR71XX_GPIO_REG_OE);
+
+
+	t = __raw_readl(base + GPIO_OUT_FUNCTION4_ADDRESS);
+	t &= ~(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK | GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+	t |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) | GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+	__raw_writel(t, base + GPIO_OUT_FUNCTION4_ADDRESS);
+
+	iounmap(base);
+
+}
+
+static void __init ap132_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap132_leds_gpio),
+				 ap132_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP132_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap132_gpio_keys),
+					ap132_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + AP132_WMAC_CALDATA_OFFSET, NULL);
+
+	/* GMAC0 of the AR8327 switch is connected to GMAC1 via SGMII */
+	ap132_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_SGMII;
+	ap132_ar8327_pad0_cfg.sgmii_delay_en = true;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ap132_mdio_setup();
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP132_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(ap132_mdio1_info,
+				    ARRAY_SIZE(ap132_mdio1_info));
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP132, "AP132",
+	     "Atheros AP132 reference board",
+	     ap132_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap143.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap143.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap143.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap143.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap147.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap147.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap147.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap147.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap152.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap152.c
new file mode 100644
index 0000000000..9b7b682434
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap152.c
@@ -0,0 +1,141 @@
+
+/*
+ * Qualcomm Atheros AP152 reference board support
+ *
+ * Copyright (c) 2015 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+#define AP152_GPIO_LED_USB0		7
+#define AP152_GPIO_LED_USB1		8
+
+#define AP152_GPIO_BTN_RESET            2
+#define AP152_GPIO_BTN_WPS              1
+#define AP152_KEYS_POLL_INTERVAL        20     /* msecs */
+#define AP152_KEYS_DEBOUNCE_INTERVAL    (3 * AP152_KEYS_POLL_INTERVAL)
+
+#define AP152_MAC0_OFFSET               0
+#define AP152_WMAC_CALDATA_OFFSET       0x1000
+
+static struct gpio_led ap152_leds_gpio[] __initdata = {
+	{
+		.name		= "ap152:green:usb0",
+		.gpio		= AP152_GPIO_LED_USB0,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap152:green:usb1",
+		.gpio		= AP152_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap152_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP152_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP152_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP152_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP152_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg ap152_ar8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data ap152_ar8337_data = {
+	.pad0_cfg = &ap152_ar8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info ap152_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "ap152",
+		.mdio_addr = 0,
+		.platform_data = &ap152_ar8337_data,
+	},
+};
+
+static void __init ap152_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap152_leds_gpio),
+				 ap152_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP152_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap152_gpio_keys),
+					ap152_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&ath79_mdio0_device);
+
+	mdiobus_register_board_info(ap152_mdio0_info,
+				    ARRAY_SIZE(ap152_mdio0_info));
+
+	ath79_register_wmac(art + AP152_WMAC_CALDATA_OFFSET, NULL);
+	ath79_register_pci();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP152_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP152, "AP152", "Qualcomm Atheros AP152 reference board",
+	     ap152_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap531b0.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap531b0.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap531b0.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap531b0.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap90q.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap90q.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap90q.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap90q.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap91-5g.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap91-5g.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap91-5g.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap91-5g.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap96.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap96.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap96.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ap96.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c25-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c25-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c25-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c25-v1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c59-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c59-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c59-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c59-v1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c60-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c60-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c60-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c60-v1.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7-v4.c
new file mode 100644
index 0000000000..2dcd66af5b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7-v4.c
@@ -0,0 +1,261 @@
+
+/*
+ * Atheros ARCHER_C7 reference board support
+ *
+ * Copyright (c) 2017 Felix Fietkau <nbd@nbd.name>
+ * Copyright (c) 2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/74x164.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+
+#define ARCHER_C7_GPIO_SHIFT_OE		1
+#define ARCHER_C7_GPIO_SHIFT_SER	14
+#define ARCHER_C7_GPIO_SHIFT_SRCLK	15
+#define ARCHER_C7_GPIO_SHIFT_RCLK	16
+#define ARCHER_C7_GPIO_SHIFT_SRCLR	21
+
+#define ARCHER_C7_GPIO_BTN_RESET	5
+#define ARCHER_C7_GPIO_BTN_WPS_WIFI	2
+
+#define ARCHER_C7_GPIO_LED_WLAN5	9
+#define ARCHER_C7_GPIO_LED_POWER	6
+#define ARCHER_C7_GPIO_LED_USB1		7
+#define ARCHER_C7_GPIO_LED_USB2		8
+
+#define ARCHER_C7_74HC_GPIO_BASE	32
+#define ARCHER_C7_GPIO_LED_WPS		(ARCHER_C7_74HC_GPIO_BASE + 0)
+#define ARCHER_C7_GPIO_LED_LAN1		(ARCHER_C7_74HC_GPIO_BASE + 1)
+#define ARCHER_C7_GPIO_LED_LAN2		(ARCHER_C7_74HC_GPIO_BASE + 2)
+#define ARCHER_C7_GPIO_LED_LAN3		(ARCHER_C7_74HC_GPIO_BASE + 3)
+#define ARCHER_C7_GPIO_LED_LAN4		(ARCHER_C7_74HC_GPIO_BASE + 4)
+#define ARCHER_C7_GPIO_LED_WAN_GREEN	(ARCHER_C7_74HC_GPIO_BASE + 5)
+#define ARCHER_C7_GPIO_LED_WAN_AMBER	(ARCHER_C7_74HC_GPIO_BASE + 6)
+#define ARCHER_C7_GPIO_LED_WLAN2	(ARCHER_C7_74HC_GPIO_BASE + 7)
+
+#define ARCHER_C7_KEYS_POLL_INTERVAL        20     /* msecs */
+#define ARCHER_C7_KEYS_DEBOUNCE_INTERVAL    (3 * ARCHER_C7_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C7_MAC0_OFFSET               0
+#define ARCHER_C7_MAC1_OFFSET               6
+#define ARCHER_C7_WMAC_CALDATA_OFFSET       0x1000
+
+#define ARCHER_C7_GPIO_MDC			3
+#define ARCHER_C7_GPIO_MDIO			4
+
+static struct spi_gpio_platform_data archer_c7_v4_spi_data = {
+	.sck		= ARCHER_C7_GPIO_SHIFT_SRCLK,
+	.miso		= SPI_GPIO_NO_MISO,
+	.mosi		= ARCHER_C7_GPIO_SHIFT_SER,
+	.num_chipselect	= 1,
+};
+
+static u8 archer_c7_v4_ssr_initdata = 0xff;
+
+static struct gen_74x164_chip_platform_data archer_c7_v4_ssr_data = {
+	.base = ARCHER_C7_74HC_GPIO_BASE,
+	.num_registers = 1,
+	.init_data = &archer_c7_v4_ssr_initdata,
+};
+
+static struct platform_device archer_c7_v4_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &archer_c7_v4_spi_data,
+	},
+};
+
+static struct spi_board_info archer_c7_v4_spi_info[] = {
+	{
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 10000000,
+		.modalias		= "74x164",
+		.platform_data		= &archer_c7_v4_ssr_data,
+		.controller_data	= (void *) ARCHER_C7_GPIO_SHIFT_RCLK,
+	},
+};
+
+static struct gpio_led archer_c7_v4_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c7-v4:green:power",
+		.gpio		= ARCHER_C7_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:wps",
+		.gpio		= ARCHER_C7_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:wlan2g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:wlan5g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:lan1",
+		.gpio		= ARCHER_C7_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:lan2",
+		.gpio		= ARCHER_C7_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:lan3",
+		.gpio		= ARCHER_C7_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:lan4",
+		.gpio		= ARCHER_C7_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:wan",
+		.gpio		=  ARCHER_C7_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:amber:wan",
+		.gpio		=  ARCHER_C7_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:usb1",
+		.gpio		=  ARCHER_C7_GPIO_LED_USB1,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c7-v4:green:usb2",
+		.gpio		=  ARCHER_C7_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c7_v4_gpio_keys[] __initdata = {
+        {
+                .desc           = "WPS and WIFI button",
+                .type           = EV_KEY,
+                .code           = KEY_WPS_BUTTON,
+                .debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+                .gpio           = ARCHER_C7_GPIO_BTN_WPS_WIFI,
+                .active_low     = 1,
+        },
+        {
+                .desc           = "Reset button",
+                .type           = EV_KEY,
+                .code           = KEY_RESTART,
+                .debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+                .gpio           = ARCHER_C7_GPIO_BTN_RESET,
+                .active_low     = 1,
+        },
+};
+
+static struct ar8327_pad_cfg archer_c7_v4_ar8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data archer_c7_v4_ar8337_data = {
+	.pad0_cfg = &archer_c7_v4_ar8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info archer_c7_v4_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "archer_c7_v4",
+		.mdio_addr = 0,
+		.platform_data = &archer_c7_v4_ar8337_data,
+	},
+};
+
+
+static void __init archer_c7_v4_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ff00008);
+
+	ath79_register_m25p80(NULL);
+
+	spi_register_board_info(archer_c7_v4_spi_info,
+				ARRAY_SIZE(archer_c7_v4_spi_info));
+
+	platform_device_register(&archer_c7_v4_spi_device);
+
+	gpio_request_one(ARCHER_C7_GPIO_SHIFT_OE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "LED control");
+
+	gpio_request_one(ARCHER_C7_GPIO_SHIFT_SRCLR,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LED reset");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c7_v4_leds_gpio),
+				archer_c7_v4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_v4_gpio_keys),
+					archer_c7_v4_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_gpio_output_select(ARCHER_C7_GPIO_MDC, QCA956X_GPIO_OUT_MUX_GE0_MDC);
+	ath79_gpio_output_select(ARCHER_C7_GPIO_MDIO, QCA956X_GPIO_OUT_MUX_GE0_MDO);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(archer_c7_v4_mdio0_info,
+				    ARRAY_SIZE(archer_c7_v4_mdio0_info));
+
+	ath79_register_wmac(art + ARCHER_C7_WMAC_CALDATA_OFFSET, mac);
+	ath79_register_pci();
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C7_V4, "ARCHER-C7-V4", "TP-LINK Archer C7 v4",
+	     archer_c7_v4_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7.c
new file mode 100644
index 0000000000..2127d5a967
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-archer-c7.c
@@ -0,0 +1,303 @@
+/*
+ * TP-LINK Archer C5/C7/TL-WDR4900 v2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2014  <tenninjas@tenninjas.ca>
+ * Copyright (c) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ARCHER_C7_GPIO_LED_WLAN2G	12
+#define ARCHER_C7_GPIO_LED_SYSTEM	14
+#define ARCHER_C7_GPIO_LED_QSS		15
+#define ARCHER_C7_GPIO_LED_WLAN5G	17
+#define ARCHER_C7_GPIO_LED_USB1		18
+#define ARCHER_C7_GPIO_LED_USB2		19
+
+#define ARCHER_C7_GPIO_BTN_RFKILL	13
+#define ARCHER_C7_V2_GPIO_BTN_RFKILL	23
+#define ARCHER_C7_GPIO_BTN_RESET	16
+
+#define ARCHER_C7_GPIO_USB1_POWER	22
+#define ARCHER_C7_GPIO_USB2_POWER	21
+
+#define ARCHER_C7_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ARCHER_C7_KEYS_DEBOUNCE_INTERVAL (3 * ARCHER_C7_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C7_WMAC_CALDATA_OFFSET	0x1000
+#define ARCHER_C7_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *archer_c7_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data archer_c7_flash_data = {
+	.part_probes	= archer_c7_part_probes,
+};
+
+static struct gpio_led archer_c7_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= ARCHER_C7_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= ARCHER_C7_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan2g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan5g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb1",
+		.gpio		= ARCHER_C7_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb2",
+		.gpio		= ARCHER_C7_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c7_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_GPIO_BTN_RFKILL,
+	},
+};
+
+static struct gpio_keys_button archer_c7_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_V2_GPIO_BTN_RFKILL,
+	},
+};
+
+static const struct ar8327_led_info archer_c7_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:blue:wan"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:blue:lan1"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:blue:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:blue:lan3"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:blue:lan4"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg archer_c7_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg archer_c7_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg archer_c7_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data archer_c7_ar8327_data = {
+	.pad0_cfg = &archer_c7_ar8327_pad0_cfg,
+	.pad6_cfg = &archer_c7_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &archer_c7_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(archer_c7_leds_ar8327),
+	.leds = archer_c7_leds_ar8327,
+};
+
+static struct mdio_board_info archer_c7_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "archer_c7",
+		.mdio_addr = 0,
+		.platform_data = &archer_c7_ar8327_data,
+	},
+};
+
+static void __init common_setup(bool pcie_slot)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&archer_c7_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c7_leds_gpio),
+				 archer_c7_leds_gpio);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + ARCHER_C7_WMAC_CALDATA_OFFSET, tmpmac);
+
+	if (pcie_slot) {
+		ath79_register_pci();
+	} else {
+		ath79_init_mac(tmpmac, mac, -1);
+		ap9x_pci_setup_wmac_led_pin(0, 0);
+		ap91_pci_init(art + ARCHER_C7_PCIE_CALDATA_OFFSET, tmpmac);
+	}
+
+	mdiobus_register_board_info(archer_c7_mdio0_info,
+				    ARRAY_SIZE(archer_c7_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	gpio_request_one(ARCHER_C7_GPIO_USB1_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB1 power");
+	gpio_request_one(ARCHER_C7_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+	ath79_register_usb();
+}
+
+static void __init archer_c5_setup(void)
+{
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_gpio_keys),
+					archer_c7_gpio_keys);
+	common_setup(true);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C5, "ARCHER-C5", "TP-LINK Archer C5",
+	     archer_c5_setup);
+
+static void __init archer_c7_setup(void)
+{
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_gpio_keys),
+					archer_c7_gpio_keys);
+	common_setup(true);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C7, "ARCHER-C7", "TP-LINK Archer C7",
+	     archer_c7_setup);
+
+static void __init archer_c7_v2_setup(void)
+{
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_v2_gpio_keys),
+					archer_c7_v2_gpio_keys);
+	common_setup(true);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C7_V2, "ARCHER-C7-V2", "TP-LINK Archer C7",
+	     archer_c7_v2_setup);
+
+static void __init tl_wdr4900_v2_setup(void)
+{
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_gpio_keys),
+					archer_c7_gpio_keys);
+	common_setup(false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR4900_V2, "TL-WDR4900-v2", "TP-LINK TL-WDR4900 v2",
+	     tl_wdr4900_v2_setup)
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-arduino-yun.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-arduino-yun.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-arduino-yun.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-arduino-yun.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-aw-nr580.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-aw-nr580.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-aw-nr580.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-aw-nr580.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhr-4grv2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhr-4grv2.c
new file mode 100644
index 0000000000..978ef82047
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhr-4grv2.c
@@ -0,0 +1,172 @@
+/*
+ * Buffalo BHR-4GRV2 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2016 FUKAUMI Naoki <naobsd@gmail.com>
+ *
+ * Based on mach-ap136.c and mach-wzr-450hp2.c
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define BHR_4GRV2_GPIO_LED_VPN_RED	3
+#define BHR_4GRV2_GPIO_LED_VPN_GREEN	18
+#define BHR_4GRV2_GPIO_LED_POWER_GREEN	19
+#define BHR_4GRV2_GPIO_LED_DIAG_RED	20
+
+#define BHR_4GRV2_GPIO_BTN_RESET	17
+#define BHR_4GRV2_GPIO_BTN_ECO		21
+
+#define BHR_4GRV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define BHR_4GRV2_KEYS_DEBOUNCE_INTERVAL	(3 * BHR_4GRV2_KEYS_POLL_INTERVAL)
+#define BHR_4GRV2_MAC0_OFFSET		0
+#define BHR_4GRV2_MAC1_OFFSET		6
+
+static struct gpio_led bhr_4grv2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:vpn",
+		.gpio		= BHR_4GRV2_GPIO_LED_VPN_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:vpn",
+		.gpio		= BHR_4GRV2_GPIO_LED_VPN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:power",
+		.gpio		= BHR_4GRV2_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= BHR_4GRV2_GPIO_LED_DIAG_RED,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button bhr_4grv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = BHR_4GRV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BHR_4GRV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "ECO button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = BHR_4GRV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BHR_4GRV2_GPIO_BTN_ECO,
+		.active_low	= 1,
+	},
+};
+
+/* GMAC0 of the AR8327 switch is connected to GMAC1 via SGMII */
+static struct ar8327_pad_cfg bhr_4grv2_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to GMAC0 via RGMII */
+static struct ar8327_pad_cfg bhr_4grv2_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data bhr_4grv2_ar8327_data = {
+	.pad0_cfg = &bhr_4grv2_ar8327_pad0_cfg,
+	.pad6_cfg = &bhr_4grv2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info bhr_4grv2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "bhr_4grv2",
+		.mdio_addr = 0,
+		.platform_data = &bhr_4grv2_ar8327_data,
+	},
+};
+
+static void __init bhr_4grv2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(bhr_4grv2_leds_gpio),
+				 bhr_4grv2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, BHR_4GRV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(bhr_4grv2_gpio_keys),
+					bhr_4grv2_gpio_keys);
+
+	mdiobus_register_board_info(bhr_4grv2_mdio0_info,
+				    ARRAY_SIZE(bhr_4grv2_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RGMII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + BHR_4GRV2_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + BHR_4GRV2_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_BHR_4GRV2, "BHR-4GRV2",
+	     "Buffalo BHR-4GRV2", bhr_4grv2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-bhu-bxu2000n2-a.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-bsb.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bsb.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-bsb.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-bsb.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-c55.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c55.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-c55.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c55.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c60.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c60.c
new file mode 100644
index 0000000000..1804e4a4df
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-c60.c
@@ -0,0 +1,261 @@
+/*
+ *  AirTight Networks C-60 board support
+ *
+ *  Copyright (C) 2016 Christian Lamparter <chunkeey@googlemail.com>
+ *
+ *  Based on AirTight Networks C-55 board support
+ *
+ *  Copyright (C) 2014-2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/platform/ar934x_nfc.h>
+#include <linux/ar8216_platform.h>
+#include <linux/ath9k_platform.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "dev-nfc.h"
+#include "machtypes.h"
+
+#define C60_GPIO_LED_PWR_AMBER		11
+#define C60_GPIO_LED_WLAN2_GREEN	12
+#define C60_GPIO_LED_WLAN2_AMBER	13
+#define C60_GPIO_LED_PWR_GREEN		16
+
+#define C60_GPIO_BTN_RESET		17
+
+/* GPIOs of the AR9300 PCIe chip */
+#define C60_GPIO_WMAC_LED_WLAN1_AMBER	0
+#define C60_GPIO_WMAC_LED_WLAN1_GREEN	3
+
+#define C60_KEYS_POLL_INTERVAL		20	/* msecs */
+#define C60_KEYS_DEBOUNCE_INTERVAL (3 * C60_KEYS_POLL_INTERVAL)
+
+#define C60_ART_ADDR			0x1f7f0000
+#define C60_ART_SIZE			0xffff
+#define C60_MAC_OFFSET			0
+#define C60_WMAC_CALDATA_OFFSET		0x1000
+#define C60_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led c60_leds_gpio[] __initdata = {
+	{
+		.name		= "c-60:amber:pwr",
+		.gpio		= C60_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-60:green:pwr",
+		.gpio		= C60_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-60:green:wlan2",
+		.gpio		= C60_GPIO_LED_WLAN2_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-60:amber:wlan2",
+		.gpio		= C60_GPIO_LED_WLAN2_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button c60_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = C60_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= C60_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg c60_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data c60_ar8327_data = {
+	.pad0_cfg = &c60_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info c60_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "c60",
+		.mdio_addr = 0,
+		.platform_data = &c60_ar8327_data,
+	},
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout c60_nand_ecclayout = {
+	.eccbytes       = 7,
+	.eccpos         = { 4, 8, 9, 10, 13, 14, 15 },
+	.oobavail       = 9,
+	.oobfree        = { { 0, 3 }, { 6, 2 }, { 11, 2 }, }
+};
+
+#else
+
+static int c60_ooblayout_ecc(struct mtd_info *mtd, int section,
+			     struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 1:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 2:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int c60_ooblayout_free(struct mtd_info *mtd, int section,
+			      struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 2:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops c60_nand_ecclayout_ops = {
+	.ecc = c60_ooblayout_ecc,
+	.free = c60_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int c60_nand_scan_fixup(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct nand_chip *chip = mtd->priv;
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+#endif
+
+	chip->ecc.size = 512;
+	chip->ecc.strength = 4;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	chip->ecc.layout = &c60_nand_ecclayout;
+#else
+	mtd_set_ooblayout(mtd, &c60_nand_ecclayout_ops);
+#endif
+	return 0;
+}
+
+static struct gpio_led c60_wmac0_leds_gpio[] = {
+	{
+		.name		= "c-60:amber:wlan1",
+		.gpio		= C60_GPIO_WMAC_LED_WLAN1_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-60:green:wlan1",
+		.gpio		= C60_GPIO_WMAC_LED_WLAN1_GREEN,
+		.active_low	= 1,
+	},
+};
+
+static void __init c60_setup(void)
+{
+	u8 tmpmac[6];
+	u8 *art = (u8 *) KSEG1ADDR(C60_ART_ADDR);
+
+	/* NAND */
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_SOFT_BCH);
+	ath79_nfc_set_scan_fixup(c60_nand_scan_fixup);
+	ath79_register_nfc();
+
+	/* SPI Storage*/
+	ath79_register_m25p80(NULL);
+
+	/* AR8327 Switch Ethernet */
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(c60_mdio0_info,
+				    ARRAY_SIZE(c60_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + C60_MAC_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	/* LEDs & GPIO */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(c60_leds_gpio),
+				 c60_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, C60_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(c60_gpio_keys),
+					c60_gpio_keys);
+	ap9x_pci_setup_wmac_leds(0, c60_wmac0_leds_gpio,
+				 ARRAY_SIZE(c60_wmac0_leds_gpio));
+	/* USB */
+	ath79_register_usb();
+
+	/* WiFi */
+	ath79_init_mac(tmpmac, art + C60_MAC_OFFSET, 1);
+	ap91_pci_init(art + C60_PCIE_CALDATA_OFFSET, tmpmac);
+	ath79_init_mac(tmpmac, art + C60_MAC_OFFSET, 2);
+	ath79_register_wmac(art + C60_WMAC_CALDATA_OFFSET, tmpmac);
+}
+MIPS_MACHINE(ATH79_MACH_C60, "C-60", "AirTight Networks C-60",
+	     c60_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cap324.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cap324.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cap324.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cap324.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cap4200ag.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cap4200ag.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cap4200ag.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cap4200ag.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-carambola2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-carambola2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-carambola2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-carambola2.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cf-e316n-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cf-e316n-v2.c
new file mode 100644
index 0000000000..cde91dc741
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cf-e316n-v2.c
@@ -0,0 +1,768 @@
+/*
+ *  Support for COMFAST boards:
+ *  - CF-E316N v2 (AR9341)
+ *  - CF-E320N v2 (QCA9531)
+ *  - CF-E355AC v1 (QCA9531 + QCA9882)
+ *  - CF-E355AC v2 (QCA9531 + QCA9886)
+ *  - CF-E375AC (QCA9563 + QCA9886 + QCA8337)
+ *  - CF-E380AC v1/v2 (QCA9558)
+ *  - CF-E385AC (QCA9558 + QCA9984 + QCA8337)
+ *  - CF-E520N/CF-E530N (QCA9531)
+ *
+ *  Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *  Copyright (C) 2016 Gareth Parker <gareth41@orcon.net.nz>
+ *  Copyright (C) 2015 Paul Fertser <fercerpav@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define CF_EXXXN_KEYS_POLL_INTERVAL	20
+#define CF_EXXXN_KEYS_DEBOUNCE_INTERVAL	(3 * CF_EXXXN_KEYS_POLL_INTERVAL)
+
+/* CF-E316N v2 */
+#define CF_E316N_V2_GPIO_LED_DIAG_B	0
+#define CF_E316N_V2_GPIO_LED_DIAG_R	2
+#define CF_E316N_V2_GPIO_LED_DIAG_G	3
+#define CF_E316N_V2_GPIO_LED_WLAN	12
+#define CF_E316N_V2_GPIO_LED_WAN	17
+#define CF_E316N_V2_GPIO_LED_LAN	19
+
+#define CF_E316N_V2_GPIO_EXT_WDT	16
+
+#define CF_E316N_V2_GPIO_EXTERNAL_PA0	13
+#define CF_E316N_V2_GPIO_EXTERNAL_PA1	14
+
+#define CF_E316N_V2_GPIO_BTN_RESET	20
+
+static struct gpio_led cf_e316n_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e316n-v2:blue:diag",
+		.gpio		= CF_E316N_V2_GPIO_LED_DIAG_B,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:red:diag",
+		.gpio		= CF_E316N_V2_GPIO_LED_DIAG_R,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:green:diag",
+		.gpio		= CF_E316N_V2_GPIO_LED_DIAG_G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:blue:wlan",
+		.gpio		= CF_E316N_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "cf-e316n-v2:blue:wan",
+		.gpio		= CF_E316N_V2_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "cf-e316n-v2:blue:lan",
+		.gpio		= CF_E316N_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cf_e316n_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CF_EXXXN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CF_E316N_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+/* CF-E320N v2 */
+#define CF_E320N_V2_GPIO_LED_WLAN	0
+#define CF_E320N_V2_GPIO_LED_WAN	2
+#define CF_E320N_V2_GPIO_LED_LAN	3
+
+#define CF_E320N_V2_GPIO_HEADER_J9_1	14
+#define CF_E320N_V2_GPIO_HEADER_J9_2	12
+#define CF_E320N_V2_GPIO_HEADER_J9_3	11
+#define CF_E320N_V2_GPIO_HEADER_J9_4	16
+
+#define CF_E320N_V2_GPIO_EXT_WDT	13
+
+#define CF_E320N_V2_GPIO_BTN_RESET	17
+
+static struct gpio_led cf_e320n_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e320n-v2:green:lan",
+		.gpio		= CF_E320N_V2_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e320n-v2:red:wan",
+		.gpio		= CF_E320N_V2_GPIO_LED_WAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e320n-v2:blue:wlan",
+		.gpio		= CF_E320N_V2_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button cf_e320n_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CF_EXXXN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CF_E320N_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+/* CF-E355AC v1/v2 */
+#define CF_E355AC_GPIO_LED_LAN		3
+#define CF_E355AC_GPIO_LED_WLAN2G	0
+#define CF_E355AC_GPIO_LED_WLAN5G	2
+
+#define CF_E355AC_GPIO_EXT_WDT		13
+
+#define CF_E355AC_GPIO_BTN_RESET	17
+
+static struct gpio_led cf_e355ac_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e355ac-v1:green:lan",
+		.gpio		= CF_E355AC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e355ac-v1:blue:wlan2g",
+		.gpio		= CF_E355AC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e355ac-v1:red:wlan5g",
+		.gpio		= CF_E355AC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_led cf_e355ac_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e355ac-v2:green:lan",
+		.gpio		= CF_E355AC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e355ac-v2:blue:wlan2g",
+		.gpio		= CF_E355AC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e355ac-v2:red:wlan5g",
+		.gpio		= CF_E355AC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button cf_e355ac_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CF_EXXXN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CF_E355AC_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+/* CF-E375AC */
+#define CF_E375AC_GPIO_LED_LAN		17
+#define CF_E375AC_GPIO_LED_WLAN2G	16
+#define CF_E375AC_GPIO_LED_WLAN5G	15
+
+#define CF_E375AC_GPIO_EXT_WDT		6
+
+#define CF_E375AC_GPIO_BTN_RESET	2
+
+static struct gpio_led cf_e375ac_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e375ac:green:lan",
+		.gpio		= CF_E375AC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e375ac:red:wlan5g",
+		.gpio		= CF_E375AC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e375ac:blue:wlan2g",
+		.gpio		= CF_E375AC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button cf_e375ac_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CF_EXXXN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CF_E375AC_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg cf_e375ac_ar8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data cf_e375ac_ar8337_data = {
+	.pad0_cfg = &cf_e375ac_ar8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info cf_e375ac_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "cf_e375ac",
+		.mdio_addr = 0,
+		.platform_data = &cf_e375ac_ar8337_data,
+	},
+};
+
+/* CF-E380AC v1/v2, CF-E385AC */
+#define CF_E38XAC_GPIO_LED_LAN		0
+#define CF_E38XAC_GPIO_LED_WLAN2G	2
+#define CF_E38XAC_GPIO_LED_WLAN5G	3
+
+#define CF_E38XAC_GPIO_EXT_WDT		17
+
+#define CF_E38XAC_GPIO_BTN_RESET	19
+
+static struct gpio_led cf_e380ac_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e380ac-v1:green:lan",
+		.gpio		= CF_E38XAC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e380ac-v1:blue:wlan2g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e380ac-v1:red:wlan5g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_led cf_e380ac_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e380ac-v2:green:lan",
+		.gpio		= CF_E38XAC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e380ac-v2:blue:wlan2g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e380ac-v2:red:wlan5g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_led cf_e385ac_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e385ac:green:lan",
+		.gpio		= CF_E38XAC_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e385ac:blue:wlan2g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN2G,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e385ac:red:wlan5g",
+		.gpio		= CF_E38XAC_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button cf_e38xac_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CF_EXXXN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CF_E38XAC_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data cf_e380ac_v1v2_at803x_data = {
+	.disable_smarteee = 1,
+};
+
+static struct mdio_board_info cf_e380ac_v1v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "cf_e380ac_v1v2",
+		.mdio_addr = 0,
+		.platform_data = &cf_e380ac_v1v2_at803x_data,
+	},
+};
+
+/* CF-E520N/CF-E530N */
+#define CF_E5X0N_GPIO_LED_WAN		11
+#define CF_E5X0N_GPIO_BTN_RESET		17
+
+static struct gpio_led cf_e520n_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e520n:blue:wan",
+		.gpio		= CF_E5X0N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led cf_e530n_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e530n:blue:wan",
+		.gpio		= CF_E5X0N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+/*
+ * Some COMFAST devices include external hardware watchdog chip,
+ * Pericon Technology PT7A7514, connected to a selected GPIO
+ * and WiSoC RESET_L input. Watchdog time-out is ~1.6 s.
+ */
+#define CF_EXXXN_EXT_WDT_TIMEOUT_MS	500
+
+static struct timer_list gpio_wdt_timer;
+
+static void gpio_wdt_toggle(unsigned long gpio)
+{
+	static int state;
+
+	state = !state;
+	gpio_set_value(gpio, state);
+
+	mod_timer(&gpio_wdt_timer,
+		  jiffies + msecs_to_jiffies(CF_EXXXN_EXT_WDT_TIMEOUT_MS));
+}
+
+static void __init cf_exxxn_common_setup(unsigned long art_ofs, int gpio_wdt)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f001000 + art_ofs);
+
+	if (gpio_wdt > -1) {
+		gpio_request_one(gpio_wdt, GPIOF_OUT_INIT_HIGH,
+				 "PT7A7514 watchdog");
+
+		setup_timer(&gpio_wdt_timer, gpio_wdt_toggle, gpio_wdt);
+		gpio_wdt_toggle(gpio_wdt);
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_wmac(art, NULL);
+
+	ath79_register_usb();
+}
+
+static void __init cf_e316n_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f010000);
+
+	cf_exxxn_common_setup(0x10000, CF_E316N_V2_GPIO_EXT_WDT);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+	ath79_register_eth(1);
+
+	/* Enable 2x Skyworks SE2576L WLAN power amplifiers */
+	gpio_request_one(CF_E316N_V2_GPIO_EXTERNAL_PA0, GPIOF_OUT_INIT_HIGH,
+			 "WLAN PA0");
+	gpio_request_one(CF_E316N_V2_GPIO_EXTERNAL_PA1, GPIOF_OUT_INIT_HIGH,
+			 "WLAN PA1");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e316n_v2_leds_gpio),
+				 cf_e316n_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e316n_v2_gpio_keys),
+					cf_e316n_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E316N_V2, "CF-E316N-V2", "COMFAST CF-E316N v2",
+	     cf_e316n_v2_setup);
+
+static void __init cf_exxxn_qca953x_eth_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f010000);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+}
+
+static void __init cf_e320n_v2_setup(void)
+{
+	cf_exxxn_common_setup(0x10000, CF_E320N_V2_GPIO_EXT_WDT);
+
+	cf_exxxn_qca953x_eth_setup();
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_direction_select(CF_E320N_V2_GPIO_LED_LAN, true);
+	ath79_gpio_direction_select(CF_E320N_V2_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(CF_E320N_V2_GPIO_LED_WLAN, true);
+
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_LED_LAN, 0);
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_LED_WAN, 0);
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_LED_WLAN, 0);
+
+	/* Enable GPIO function for GPIOs in J9 header */
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_HEADER_J9_1, 0);
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_HEADER_J9_2, 0);
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_HEADER_J9_3, 0);
+	ath79_gpio_output_select(CF_E320N_V2_GPIO_HEADER_J9_4, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e320n_v2_leds_gpio),
+				 cf_e320n_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e320n_v2_gpio_keys),
+					cf_e320n_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E320N_V2, "CF-E320N-V2", "COMFAST CF-E320N v2",
+	     cf_e320n_v2_setup);
+
+static void __init cf_e355ac_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f010000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE, 0);
+
+	cf_exxxn_common_setup(0x10000, CF_E355AC_GPIO_EXT_WDT);
+
+	cf_exxxn_qca953x_eth_setup();
+
+	ath79_gpio_output_select(CF_E355AC_GPIO_LED_LAN, 0);
+	ath79_gpio_output_select(CF_E355AC_GPIO_LED_WLAN2G, 0);
+	ath79_gpio_output_select(CF_E355AC_GPIO_LED_WLAN5G, 0);
+
+	ap91_pci_init(art + 0x5000, NULL);
+
+	ath79_register_gpio_keys_polled(1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e355ac_gpio_keys),
+					cf_e355ac_gpio_keys);
+}
+
+static void __init cf_e355ac_v1_setup(void)
+{
+	cf_e355ac_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e355ac_v1_leds_gpio),
+				 cf_e355ac_v1_leds_gpio);
+}
+
+static void __init cf_e355ac_v2_setup(void)
+{
+	cf_e355ac_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e355ac_v2_leds_gpio),
+				 cf_e355ac_v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E355AC, "CF-E355AC-V1", "COMFAST CF-E355AC v1",
+	     cf_e355ac_v1_setup);
+
+MIPS_MACHINE(ATH79_MACH_CF_E355AC_V2, "CF-E355AC-V2", "COMFAST CF-E355AC v2",
+	     cf_e355ac_v2_setup);
+
+static void __init cf_e375ac_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f040000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE, 0);
+
+	cf_exxxn_common_setup(0x40000, CF_E375AC_GPIO_EXT_WDT);
+
+	ath79_gpio_output_select(CF_E375AC_GPIO_LED_LAN, 0);
+	ath79_gpio_output_select(CF_E375AC_GPIO_LED_WLAN2G, 0);
+	ath79_gpio_output_select(CF_E375AC_GPIO_LED_WLAN5G, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e375ac_leds_gpio),
+				 cf_e375ac_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e375ac_gpio_keys),
+					cf_e375ac_gpio_keys);
+
+	platform_device_register(&ath79_mdio0_device);
+
+	mdiobus_register_board_info(cf_e375ac_mdio0_info,
+				    ARRAY_SIZE(cf_e375ac_mdio0_info));
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E375AC, "CF-E375AC", "COMFAST CF-E375AC",
+	     cf_e375ac_setup);
+
+static void __init cf_e38xac_common_setup(unsigned long art_ofs)
+{
+	cf_exxxn_common_setup(art_ofs, CF_E38XAC_GPIO_EXT_WDT);
+
+	ath79_register_pci();
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_direction_select(CF_E38XAC_GPIO_LED_LAN, true);
+	ath79_gpio_direction_select(CF_E38XAC_GPIO_LED_WLAN2G, true);
+	ath79_gpio_direction_select(CF_E38XAC_GPIO_LED_WLAN5G, true);
+
+	ath79_gpio_output_select(CF_E38XAC_GPIO_LED_LAN, 0);
+	ath79_gpio_output_select(CF_E38XAC_GPIO_LED_WLAN2G, 0);
+	ath79_gpio_output_select(CF_E38XAC_GPIO_LED_WLAN5G, 0);
+
+	/* For J7-4 */
+	ath79_gpio_function_disable(AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_gpio_keys_polled(-1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e38xac_gpio_keys),
+					cf_e38xac_gpio_keys);
+}
+
+static void __init cf_e380ac_v1v2_common_setup(unsigned long art_ofs)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f000000 + art_ofs);
+
+	cf_e38xac_common_setup(art_ofs);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(cf_e380ac_v1v2_mdio0_info,
+				    ARRAY_SIZE(cf_e380ac_v1v2_mdio0_info));
+
+	/* LAN */
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_pll_data.pll_1000 = 0xbe000000;
+	ath79_eth0_pll_data.pll_100 = 0xb0000101;
+	ath79_eth0_pll_data.pll_10 = 0xb0001313;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+}
+
+static void __init cf_e380ac_v1_setup(void)
+{
+	cf_e380ac_v1v2_common_setup(0x20000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e380ac_v1_leds_gpio),
+				 cf_e380ac_v1_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E380AC_V1, "CF-E380AC-V1", "COMFAST CF-E380AC v1",
+	     cf_e380ac_v1_setup);
+
+static void __init cf_e380ac_v2_setup(void)
+{
+	cf_e380ac_v1v2_common_setup(0x40000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e380ac_v2_leds_gpio),
+				 cf_e380ac_v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E380AC_V2, "CF-E380AC-V2", "COMFAST CF-E380AC v2",
+	     cf_e380ac_v2_setup);
+
+/* QCA8337 GMAC0 is connected with QCA9558 over RGMII */
+static struct ar8327_pad_cfg cf_e385ac_qca8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+};
+
+/* QCA8337 GMAC6 is connected with QCA9558 over SGMII */
+static struct ar8327_pad_cfg cf_e385ac_qca8337_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data cf_e385ac_qca8337_data = {
+	.pad0_cfg = &cf_e385ac_qca8337_pad0_cfg,
+	.pad6_cfg = &cf_e385ac_qca8337_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info cf_e385ac_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "cf_e385ac",
+		.mdio_addr = 0,
+		.platform_data = &cf_e385ac_qca8337_data,
+	},
+};
+
+static void __init cf_e385ac_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f040000);
+
+	cf_e38xac_common_setup(0x40000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e385ac_leds_gpio),
+				 cf_e385ac_leds_gpio);
+
+	mdiobus_register_board_info(cf_e385ac_mdio0_info,
+				    ARRAY_SIZE(cf_e385ac_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* QCA9558 GMAC0 is connected to RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x96000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	/* QCA9558 GMAC1 is connected to SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E385AC, "CF-E385AC", "COMFAST CF-E385AC",
+	     cf_e385ac_setup);
+
+static void __init cf_e5x0n_gpio_setup(void)
+{
+	ath79_gpio_direction_select(CF_E5X0N_GPIO_LED_WAN, true);
+
+	ath79_gpio_output_select(CF_E5X0N_GPIO_LED_WAN, 0);
+
+	ath79_register_gpio_keys_polled(-1, CF_EXXXN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cf_e320n_v2_gpio_keys),
+					cf_e320n_v2_gpio_keys);
+}
+
+static void __init cf_e520n_setup(void)
+{
+	cf_exxxn_common_setup(0x10000, -1);
+
+	cf_exxxn_qca953x_eth_setup();
+
+	cf_e5x0n_gpio_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e520n_leds_gpio),
+				 cf_e520n_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E520N, "CF-E520N", "COMFAST CF-E520N",
+	     cf_e520n_setup);
+
+static void __init cf_e530n_setup(void)
+{
+	cf_exxxn_common_setup(0x10000, -1);
+
+	cf_exxxn_qca953x_eth_setup();
+
+	cf_e5x0n_gpio_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e530n_leds_gpio),
+				 cf_e530n_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E530N, "CF-E530N", "COMFAST CF-E530N",
+	     cf_e530n_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cpe510.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cpe510.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cpe510.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cpe510.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cpe870.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cpe870.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cpe870.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cpe870.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cr3000.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr3000.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cr3000.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr3000.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr5000.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr5000.c
new file mode 100644
index 0000000000..536ceeebf0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-cr5000.c
@@ -0,0 +1,177 @@
+/*
+ * PowerCloud CR5000 support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2012-2013 PowerCloud Systems
+ * Copyright (c) 2015 Daniel Dickinson <openwrt@daniel.thecshore.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CR5000_GPIO_LED_WLAN_2G		14
+#define CR5000_GPIO_LED_WPS		12
+#define CR5000_GPIO_LED_POWER_AMBER      4
+/* GPIO2 has to have JTAG disabled as it is also to
+ * power led
+ */
+#define CR5000_GPIO_LED_POWER_ENABLE     2
+#define CR5000_GPIO_BTN_WPS		16
+#define CR5000_GPIO_BTN_RESET		17
+
+#define CR5000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define CR5000_KEYS_DEBOUNCE_INTERVAL	(3 * CR5000_KEYS_POLL_INTERVAL)
+
+#define CR5000_MAC0_OFFSET		0
+#define CR5000_WMAC_CALDATA_OFFSET	0x1000
+#define CR5000_WMAC_MAC_OFFSET	        0x1002
+#define CR5000_PCIE_CALDATA_OFFSET	0x5000
+#define CR5000_PCIE_MAC_OFFSET	        0x5002
+
+static struct gpio_led cr5000_leds_gpio[] __initdata = {
+	{
+		.name		= "pcs:amber:power",
+		.gpio		= CR5000_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:white:wps",
+		.gpio		= CR5000_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:wlan",
+		.gpio		= CR5000_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cr5000_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CR5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CR5000_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CR5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CR5000_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg cr5000_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg cr5000_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data cr5000_ar8327_data = {
+	.pad0_cfg = &cr5000_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &cr5000_ar8327_led_cfg,
+};
+
+static struct mdio_board_info cr5000_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "cr5000",
+		.mdio_addr = 0,
+		.platform_data = &cr5000_ar8327_data,
+	},
+};
+
+static void __init cr5000_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+	gpio_request_one(CR5000_GPIO_LED_POWER_ENABLE,
+	GPIOF_OUT_INIT_LOW, "Power LED enable");
+	ath79_gpio_output_select(CR5000_GPIO_LED_POWER_AMBER, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(CR5000_GPIO_LED_WLAN_2G, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(CR5000_GPIO_LED_WPS, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cr5000_leds_gpio),
+				 cr5000_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CR5000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cr5000_gpio_keys),
+					cr5000_gpio_keys);
+	ath79_register_usb();
+	ath79_register_wmac(art + CR5000_WMAC_CALDATA_OFFSET, art + CR5000_WMAC_MAC_OFFSET);
+	ap94_pci_init(NULL, NULL, NULL, art + CR5000_PCIE_MAC_OFFSET);
+
+        ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + CR5000_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(cr5000_mdio0_info,
+				    ARRAY_SIZE(cr5000_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_CR5000, "CR5000", "PowerCloud CR5000",
+	     cr5000_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dap-1330-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-1330-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dap-1330-a1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-1330-a1.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-2695-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-2695-a1.c
new file mode 100644
index 0000000000..1715a647ed
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dap-2695-a1.c
@@ -0,0 +1,192 @@
+/*
+ * D-Link DAP-2695 rev. A1 support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2016 Stijn Tintel <stijn@linux-ipv6.be>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DAP2695_GPIO_LED_GREEN_POWER	23
+#define DAP2695_GPIO_LED_RED_POWER	14
+#define DAP2695_GPIO_LED_WLAN_2G	13
+
+#define DAP2695_GPIO_BTN_RESET		17
+
+#define DAP2695_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DAP2695_KEYS_DEBOUNCE_INTERVAL	(3 * DAP2695_KEYS_POLL_INTERVAL)
+
+#define DAP2695_NVRAM_ADDR		0x1f040000
+#define DAP2695_NVRAM_SIZE		0x10000
+
+#define DAP2695_MAC0_OFFSET		1
+#define DAP2695_MAC1_OFFSET		2
+#define DAP2695_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led dap2695_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DAP2695_GPIO_LED_GREEN_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:red:power",
+		.gpio		= DAP2695_GPIO_LED_RED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:wlan2g",
+		.gpio		= DAP2695_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dap2695_gpio_keys[] __initdata = {
+	{
+		.desc			= "Soft reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= DAP2695_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= DAP2695_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dap2695_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_dis = true,
+};
+
+static struct ar8327_pad_cfg dap2695_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data dap2695_ar8327_data = {
+	.pad0_cfg = &dap2695_ar8327_pad0_cfg,
+	.pad6_cfg = &dap2695_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dap2695_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dap2695",
+		.mdio_addr = 0,
+		.platform_data = &dap2695_ar8327_data,
+	},
+};
+
+static struct flash_platform_data dap2695_flash_data = {
+	.type = "mx25l12805d",
+};
+
+static void dap2695_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(DAP2695_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, DAP2695_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init dap2695_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN], wmac0[ETH_ALEN];
+
+	dap2695_get_mac("lanmac=", mac0);
+	dap2695_get_mac("wanmac=", mac1);
+	dap2695_get_mac("wlanmac=", wmac0);
+
+	ath79_register_m25p80(&dap2695_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dap2695_leds_gpio),
+				 dap2695_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DAP2695_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dap2695_gpio_keys),
+					dap2695_gpio_keys);
+
+	ath79_register_wmac(art + DAP2695_WMAC_CALDATA_OFFSET, wmac0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(dap2695_mdio0_info,
+					ARRAY_SIZE(dap2695_mdio0_info));
+
+	/* GMAC0 is connected to the RGMII interface */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, DAP2695_MAC0_OFFSET);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, DAP2695_MAC1_OFFSET);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_DAP_2695_A1, "DAP-2695-A1",
+		"D-Link DAP-2695 rev. A1",
+		dap2695_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dgl-5500-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dgl-5500-a1.c
new file mode 100644
index 0000000000..0a4250254a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dgl-5500-a1.c
@@ -0,0 +1,151 @@
+/*
+ *  D-Link DGL-5500 board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DGL_5500_A1_GPIO_LED_POWER_ORANGE	14
+#define DGL_5500_A1_GPIO_LED_POWER_GREEN	19
+#define DGL_5500_A1_GPIO_LED_PLANET_GREEN	22
+#define DGL_5500_A1_GPIO_LED_PLANET_ORANGE	23
+
+#define DGL_5500_A1_GPIO_BTN_WPS		16
+#define DGL_5500_A1_GPIO_BTN_RESET		17
+
+#define DGL_5500_A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * DGL_5500_A1_KEYS_POLL_INTERVAL)
+
+#define DGL_5500_A1_WMAC_CALDATA_OFFSET		0x1000
+
+#define DGL_5500_A1_LAN_MAC_OFFSET	0x04
+#define DGL_5500_A1_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led dgl_5500_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DGL_5500_A1_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:orange:power",
+		.gpio		= DGL_5500_A1_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DGL_5500_A1_GPIO_LED_PLANET_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:orange:planet",
+		.gpio		= DGL_5500_A1_GPIO_LED_PLANET_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dgl_5500_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DGL_5500_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DGL_5500_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dgl_5500_a1_ar8327_pad0_cfg = {
+	/* Use the SGMII interface for the GMAC0 of the AR8327 switch */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data dgl_5500_a1_ar8327_data = {
+	.pad0_cfg = &dgl_5500_a1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dgl_5500_a1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dgl_5500_a1",
+		.mdio_addr = 0,
+		.platform_data = &dgl_5500_a1_ar8327_data,
+	},
+};
+
+static void __init dgl_5500_a1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 lan_mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DGL_5500_A1_LAN_MAC_OFFSET, lan_mac);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dgl_5500_a1_leds_gpio),
+				 dgl_5500_a1_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DGL_5500_A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dgl_5500_a1_gpio_keys),
+					dgl_5500_a1_gpio_keys);
+
+	ath79_register_wmac(art + DGL_5500_A1_WMAC_CALDATA_OFFSET, lan_mac);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(dgl_5500_a1_mdio0_info,
+				    ARRAY_SIZE(dgl_5500_a1_mdio0_info));
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	/* GMAC1 is connected to an AR8327N switch via the SMGII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_DGL_5500_A1, "DGL-5500-A1", "D-Link DGL-5500 rev. A1",
+	     dgl_5500_a1_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dhp-1565-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dhp-1565-a1.c
new file mode 100644
index 0000000000..e7d26468da
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dhp-1565-a1.c
@@ -0,0 +1,171 @@
+/*
+ *  D-Link DHP-1565 rev. A1 board support
+ *
+ *  Copyright (C) 2014 Jacek Kikiewicz
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DHP1565A1_GPIO_LED_BLUE_USB		11
+#define DHP1565A1_GPIO_LED_AMBER_POWER		14
+#define DHP1565A1_GPIO_LED_BLUE_POWER		22
+#define DHP1565A1_GPIO_LED_BLUE_WPS		15
+#define DHP1565A1_GPIO_LED_AMBER_PLANET		19
+#define DHP1565A1_GPIO_LED_BLUE_PLANET		18
+#define DHP1565A1_GPIO_LED_WLAN_2G		13
+
+#define DHP1565A1_GPIO_WAN_LED_ENABLE		20
+
+#define DHP1565A1_GPIO_BTN_RESET			17
+#define DHP1565A1_GPIO_BTN_WPS			16
+
+#define DHP1565A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DHP1565A1_KEYS_DEBOUNCE_INTERVAL		(3 * DHP1565A1_KEYS_POLL_INTERVAL)
+
+#define DHP1565A1_MAC0_OFFSET			0xFFA0
+#define DHP1565A1_MAC1_OFFSET			0xFFB4
+#define DHP1565A1_WMAC0_OFFSET			0x5
+#define DHP1565A1_WMAC_CALDATA_OFFSET		0x1000
+#define DHP1565A1_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dhp1565a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DHP1565A1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DHP1565A1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DHP1565A1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DHP1565A1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dhp1565a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Soft reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DHP1565A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DHP1565A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DHP1565A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DHP1565A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dhp1565a1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data dhp1565a1_ar8327_data = {
+	.pad0_cfg = &dhp1565a1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dhp1565a1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dhp1565a1",
+		.mdio_addr = 0,
+		.platform_data = &dhp1565a1_ar8327_data,
+	},
+};
+
+static void __init dhp1565a1_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DHP1565A1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(mac + DHP1565A1_MAC1_OFFSET, mac1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_gpio_keys_polled(-1, DHP1565A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dhp1565a1_gpio_keys),
+					dhp1565a1_gpio_keys);
+
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_register_wmac(art + DHP1565A1_WMAC_CALDATA_OFFSET, wmac0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(dhp1565a1_mdio0_info,
+				    ARRAY_SIZE(dhp1565a1_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 1);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+static void __init dhp1565a1_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dhp1565a1_leds_gpio),
+				 dhp1565a1_leds_gpio);
+
+	dhp1565a1_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DHP_1565_A1, "DHP-1565-A1",
+	     "D-Link DHP-1565 rev. A1",
+	     dhp1565a1_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-505-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-505-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-505-a1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-505-a1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-600-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-600-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-600-a1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-600-a1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-615-c1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-615-c1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-615-c1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-615-c1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-615-i1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-615-i1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-615-i1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-615-i1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-825-b1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-b1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-825-b1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-b1.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-c1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-c1.c
new file mode 100644
index 0000000000..627ae245ea
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-825-c1.c
@@ -0,0 +1,242 @@
+/*
+ *  D-Link DIR-825 rev. C1 board support
+ *
+ *  Copyright (C) 2013 Alexander Stadler
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DIR825C1_GPIO_LED_BLUE_USB		11
+#define DIR825C1_GPIO_LED_AMBER_POWER		14
+#define DIR825C1_GPIO_LED_BLUE_POWER		22
+#define DIR825C1_GPIO_LED_BLUE_WPS		15
+#define DIR825C1_GPIO_LED_AMBER_PLANET		19
+#define DIR825C1_GPIO_LED_BLUE_PLANET		18
+#define DIR825C1_GPIO_LED_WLAN_2G		13
+
+#define DIR825C1_GPIO_WAN_LED_ENABLE		20
+
+#define DIR825C1_GPIO_BTN_RESET			17
+#define DIR825C1_GPIO_BTN_WPS			16
+
+#define DIR825C1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825C1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825C1_KEYS_POLL_INTERVAL)
+
+#define DIR825C1_MAC0_OFFSET			0x4
+#define DIR825C1_MAC1_OFFSET			0x18
+#define DIR825C1_WMAC_CALDATA_OFFSET		0x1000
+#define DIR825C1_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dir825c1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:blue:usb",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:power",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wlan2g",
+		.gpio		= DIR825C1_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led dir835a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dir825c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Soft reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825C1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825C1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dir825c1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg dir825c1_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data dir825c1_ar8327_data = {
+	.pad0_cfg = &dir825c1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &dir825c1_ar8327_led_cfg,
+};
+
+static struct mdio_board_info dir825c1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dir825c1",
+		.mdio_addr = 0,
+		.platform_data = &dir825c1_ar8327_data,
+	},
+};
+
+static void __init dir825c1_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN], wmac1[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DIR825C1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(mac + DIR825C1_MAC1_OFFSET, mac1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_gpio_keys_polled(-1, DIR825C1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825c1_gpio_keys),
+					dir825c1_gpio_keys);
+
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_register_wmac(art + DIR825C1_WMAC_CALDATA_OFFSET, wmac0);
+
+	ath79_init_mac(wmac1, mac1, 1);
+	ap91_pci_init(art + DIR825C1_PCIE_CALDATA_OFFSET, wmac1);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(dir825c1_mdio0_info,
+				    ARRAY_SIZE(dir825c1_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+static void __init dir825c1_setup(void)
+{
+	ath79_gpio_output_select(DIR825C1_GPIO_LED_BLUE_USB,
+				 AR934X_GPIO_OUT_GPIO);
+
+	gpio_request_one(DIR825C1_GPIO_WAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir825c1_leds_gpio),
+				 dir825c1_leds_gpio);
+
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+
+	dir825c1_generic_setup();
+}
+
+static void __init dir835a1_setup(void)
+{
+	dir825c1_ar8327_data.led_cfg = NULL;
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir835a1_leds_gpio),
+				 dir835a1_leds_gpio);
+
+	dir825c1_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_825_C1, "DIR-825-C1",
+	     "D-Link DIR-825 rev. C1",
+	     dir825c1_setup);
+
+MIPS_MACHINE(ATH79_MACH_DIR_835_A1, "DIR-835-A1",
+	     "D-Link DIR-835 rev. A1",
+	     dir835a1_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-869-a1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-869-a1.c
new file mode 100644
index 0000000000..4d6d91794f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dir-869-a1.c
@@ -0,0 +1,176 @@
+/*
+ *  D-Link DIR-869 A1 support
+ *
+ *  Copyright (C) 2015-2016 P. Wassi <p.wassi at gmx.at>
+ *  Copyright (C) 2016 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  Derived from: mach-ubnt-unifiac.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+
+#define DIR869A1_GPIO_BTN_RESET		1
+#define DIR869A1_GPIO_BTN_WPS		2
+#define DIR869A1_GPIO_SWITCH_MODE	8
+
+#define DIR869A1_GPIO_ENABLE_SWITCH	11
+
+#define DIR869A1_GPIO_LED_ORANGE	15
+#define DIR869A1_GPIO_LED_WHITE		16
+
+#define DIR869A1_KEYS_POLL_INTERVAL	20 /* msecs */
+#define DIR869A1_KEYS_DEBOUNCE_INTERVAL	(3 * DIR869A1_KEYS_POLL_INTERVAL)
+
+
+#define DIR869A1_DEVDATA_ADDR		0x1f050000
+#define DIR869A1_DEVDATA_SIZE		0x10000
+
+#define DIR869A1_EEPROM_ADDR		0x1fff0000
+#define DIR869A1_WMAC_CALDATA_OFFSET	0x1000
+#define DIR869A1_PCI_CALDATA_OFFSET	0x5000
+
+
+static struct gpio_led dir869a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:white:status",
+		.gpio		= DIR869A1_GPIO_LED_WHITE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:orange:status",
+		.gpio		= DIR869A1_GPIO_LED_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dir869a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR869A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR869A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR869A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR869A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "mode",
+		.type		= EV_SW,
+		.code		= BTN_0,
+		.debounce_interval = DIR869A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR869A1_GPIO_SWITCH_MODE,
+		.active_low	= 0,
+	},
+};
+
+
+static struct ar8327_pad_cfg dir869a1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data dir869a1_ar8327_data = {
+	.pad0_cfg = &dir869a1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+
+static struct mdio_board_info dir869a1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dir869a1",
+		.mdio_addr = 0,
+		.platform_data = &dir869a1_ar8327_data,
+	},
+};
+
+
+static void dir869a1_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(DIR869A1_DEVDATA_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, DIR869A1_DEVDATA_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init dir869a1_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(DIR869A1_EEPROM_ADDR);
+	u8 wlan24mac[ETH_ALEN] = {}, wlan5mac[ETH_ALEN] = {};
+
+	ath79_register_m25p80(NULL);
+
+	gpio_request_one(DIR869A1_GPIO_ENABLE_SWITCH,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "Switch power");
+
+	dir869a1_get_mac("lanmac=", ath79_eth0_data.mac_addr);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	mdiobus_register_board_info(dir869a1_mdio0_info,
+	                            ARRAY_SIZE(dir869a1_mdio0_info));
+
+	ath79_register_mdio(0, 0);
+	ath79_register_eth(0);
+
+	dir869a1_get_mac("wlan24mac=", wlan24mac);
+	ath79_register_wmac(eeprom + DIR869A1_WMAC_CALDATA_OFFSET, wlan24mac);
+
+	dir869a1_get_mac("wlan5mac=", wlan5mac);
+	ap91_pci_init(eeprom + DIR869A1_PCI_CALDATA_OFFSET, wlan5mac);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir869a1_leds_gpio),
+	                         dir869a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR869A1_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(dir869a1_gpio_keys),
+	                                dir869a1_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_869_A1, "DIR-869-A1", "D-Link DIR-869 rev. A1",
+             dir869a1_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-hotspot.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-hotspot.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-hotspot.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-hotspot.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-1200-ac.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-1200-ac.c
new file mode 100644
index 0000000000..0dffc21a0b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-1200-ac.c
@@ -0,0 +1,191 @@
+/*
+ * devolo dLAN pro 500 Wireless+ support
+ *
+ * Copyright (c) 2013-2015 devolo AG
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_PRO_1200_AC_GPIO_DLAN_POWER_ENABLE		13
+#define DLAN_PRO_1200_AC_GPIO_WLAN_POWER_ENABLE		21
+#define DLAN_PRO_1200_AC_GPIO_LED_WLAN		12
+#define DLAN_PRO_1200_AC_GPIO_LED_DLAN			14
+#define DLAN_PRO_1200_AC_GPIO_LED_DLAN_ERR			15
+
+#define DLAN_PRO_1200_AC_GPIO_BTN_WLAN			20
+#define DLAN_PRO_1200_AC_GPIO_BTN_DLAN			22
+#define DLAN_PRO_1200_AC_GPIO_BTN_RESET			4
+#define DLAN_PRO_1200_AC_GPIO_DLAN_IND          17
+#define DLAN_PRO_1200_AC_GPIO_DLAN_ERR_IND      16
+
+#define DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL		(3 * DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL)
+
+#define DLAN_PRO_1200_AC_ART_ADDRESS			0x1fff0000
+#define DLAN_PRO_1200_AC_CALDATA_OFFSET			0x1000
+#define DLAN_PRO_1200_AC_WIFIMAC_OFFSET			0x1002
+#define DLAN_PRO_1200_AC_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led dlan_pro_1200_ac_leds_gpio[] __initdata = {
+	{
+		.name		        = "devolo:status:wlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_WLAN,
+		.active_low	        = 1,
+	},
+	{
+		.name		        = "devolo:status:dlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_DLAN,
+		.active_low	        = 1,
+	},
+	{
+		.name		        = "devolo:error:dlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_DLAN_ERR,
+		.active_low	        = 0,
+	}
+};
+
+static struct gpio_keys_button dlan_pro_1200_ac_gpio_keys[] __initdata = {
+	{
+		.desc		= "dLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_DLAN,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg dlan_pro_1200_ac_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = false,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+	.mac06_exchange_dis = true,
+};
+
+static struct ar8327_pad_cfg dlan_pro_1200_ac_ar8327_pad5_cfg = {
+	.mode = 0,
+	.txclk_delay_en = 0,
+	.rxclk_delay_en = 0,
+	.txclk_delay_sel = 0,
+	.rxclk_delay_sel = 0,
+};
+
+static struct ar8327_platform_data dlan_pro_1200_ac_ar8327_data = {
+	.pad0_cfg = &dlan_pro_1200_ac_ar8327_pad0_cfg,
+	.pad5_cfg = &dlan_pro_1200_ac_ar8327_pad5_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dlan_pro_1200_ac_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dlan_pro_1200_ac",
+		.mdio_addr = 0,
+		.platform_data = &dlan_pro_1200_ac_ar8327_data,
+	},
+};
+
+static void __init dlan_pro_1200_ac_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_PRO_1200_AC_ART_ADDRESS);
+	u8 *cal = art + DLAN_PRO_1200_AC_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_PRO_1200_AC_WIFIMAC_OFFSET;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_pro_1200_ac_leds_gpio),
+				 dlan_pro_1200_ac_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_pro_1200_ac_gpio_keys),
+					dlan_pro_1200_ac_gpio_keys);
+
+	/* dLAN power must be enabled from user-space as soon as the boot-from-host daemon is running */
+	gpio_request_one(DLAN_PRO_1200_AC_GPIO_DLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "dLAN power");
+
+	/* WLAN power is turned on initially to allow the PCI bus scan to succeed */
+	gpio_request_one(DLAN_PRO_1200_AC_GPIO_WLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "WLAN power");
+
+	ath79_register_wmac(cal, wifi_mac);
+	ap91_pci_init(art + DLAN_PRO_1200_AC_PCIE_CALDATA_OFFSET, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 | AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 2);
+
+	mdiobus_register_board_info(dlan_pro_1200_ac_mdio0_info,
+				    ARRAY_SIZE(dlan_pro_1200_ac_mdio0_info));
+
+	/* GMAC0 is connected to an AR8337 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_PRO_1200_AC, "dLAN-pro-1200-ac", "devolo dLAN pro 1200+ WiFi ac",
+	     dlan_pro_1200_ac_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-500-wp.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-500-wp.c
new file mode 100644
index 0000000000..a6a85ebe35
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dlan-pro-500-wp.c
@@ -0,0 +1,204 @@
+/*
+ * devolo dLAN pro 500 Wireless+ support
+ *
+ * Copyright (c) 2013-2015 devolo AG
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_PRO_500_WP_GPIO_DLAN_POWER_ENABLE		13
+#define DLAN_PRO_500_WP_GPIO_DLAN_LED_ENABLE		17
+#define DLAN_PRO_500_WP_GPIO_LED_WLAN_5G		11
+#define DLAN_PRO_500_WP_GPIO_LED_WLAN_2G		12
+#define DLAN_PRO_500_WP_GPIO_LED_STATUS			16
+#define DLAN_PRO_500_WP_GPIO_LED_ETH			14
+
+#define DLAN_PRO_500_WP_GPIO_BTN_WPS			20
+#define DLAN_PRO_500_WP_GPIO_BTN_WLAN			22
+#define DLAN_PRO_500_WP_GPIO_BTN_DLAN			21
+#define DLAN_PRO_500_WP_GPIO_BTN_RESET			4
+
+#define DLAN_PRO_500_WP_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL		(3 * DLAN_PRO_500_WP_KEYS_POLL_INTERVAL)
+
+#define DLAN_PRO_500_WP_ART_ADDRESS			0x1fff0000
+#define DLAN_PRO_500_WP_CALDATA_OFFSET			0x1000
+#define DLAN_PRO_500_WP_MAC_ADDRESS_OFFSET		0x1002
+#define DLAN_PRO_500_WP_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dlan_pro_500_wp_leds_gpio[] __initdata = {
+	{
+		.name		= "devolo:green:status",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:green:eth",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_ETH,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:blue:wlan-5g",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:green:wlan-2g",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dlan_pro_500_wp_gpio_keys[] __initdata = {
+	{
+		.desc		= "dLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_DLAN,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code           = KEY_RESTART,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg dlan_pro_500_wp_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_PHY_RGMII,
+	.txclk_delay_en = false,
+	.rxclk_delay_en = false,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_led_cfg dlan_pro_500_wp_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data dlan_pro_500_wp_ar8327_data = {
+	.pad0_cfg = &dlan_pro_500_wp_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 0,
+		.rxpause = 0,
+	},
+	.led_cfg = &dlan_pro_500_wp_ar8327_led_cfg,
+};
+
+static struct mdio_board_info dlan_pro_500_wp_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dlan_pro_500_wp",
+		.mdio_addr = 0,
+		.platform_data = &dlan_pro_500_wp_ar8327_data,
+	},
+};
+
+static void __init dlan_pro_500_wp_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_PRO_500_WP_ART_ADDRESS);
+	u8 *cal = art + DLAN_PRO_500_WP_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_PRO_500_WP_MAC_ADDRESS_OFFSET;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_pro_500_wp_leds_gpio),
+				 dlan_pro_500_wp_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_PRO_500_WP_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_pro_500_wp_gpio_keys),
+					dlan_pro_500_wp_gpio_keys);
+
+	gpio_request_one(DLAN_PRO_500_WP_GPIO_DLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC power");
+	gpio_request_one(DLAN_PRO_500_WP_GPIO_DLAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC LEDs");
+
+	ath79_register_wmac(cal, wifi_mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(dlan_pro_500_wp_mdio0_info,
+				    ARRAY_SIZE(dlan_pro_500_wp_mdio0_info));
+
+	/* GMAC0 is connected to a AR7400 PLC in PHY mode */
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 2);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, wifi_mac, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_PRO_500_WP, "dLAN-pro-500-wp", "devolo dLAN pro 500 Wireless+",
+	     dlan_pro_500_wp_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-domywifi-dw33d.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-domywifi-dw33d.c
new file mode 100644
index 0000000000..e3d1718ddb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-domywifi-dw33d.c
@@ -0,0 +1,188 @@
+/*
+ * DomyWifi DW33D support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DW33D_GPIO_LED_MMC		4
+#define DW33D_GPIO_LED_WLAN_2G		13
+#define DW33D_GPIO_LED_STATUS		14
+#define DW33D_GPIO_LED_USB		15
+#define DW33D_GPIO_LED_INTERNET		22
+
+#define DW33D_GPIO_BTN_RESET		17
+
+#define DW33D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DW33D_KEYS_DEBOUNCE_INTERVAL	(3 * DW33D_KEYS_POLL_INTERVAL)
+
+#define DW33D_MAC0_OFFSET		0
+#define DW33D_MAC1_OFFSET		6
+#define DW33D_WMAC_OFFSET		12
+#define DW33D_WMAC_CALDATA_OFFSET	0x1000
+#define DW33D_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led dw33d_leds_gpio[] __initdata = {
+	{
+		.name		= "dw33d:blue:status",
+		.gpio		= DW33D_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dw33d:blue:mmc",
+		.gpio		= DW33D_GPIO_LED_MMC,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dw33d:blue:usb",
+		.gpio		= DW33D_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dw33d:blue:wlan-2g",
+		.gpio		= DW33D_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dw33d:blue:internet",
+		.gpio		= DW33D_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dw33d_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DW33D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DW33D_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+/* GMAC6 of the QCA8337 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg dw33d_qca8337_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC0 of the QCA8337 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg dw33d_qca8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data dw33d_qca8337_data = {
+	.pad0_cfg = &dw33d_qca8337_pad0_cfg,
+	.pad6_cfg = &dw33d_qca8337_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dw33d_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dw33d",
+		.mdio_addr = 0,
+		.platform_data = &dw33d_qca8337_data,
+	},
+};
+
+static void __init dw33d_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dw33d_leds_gpio),
+				 dw33d_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DW33D_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dw33d_gpio_keys),
+					dw33d_gpio_keys);
+
+	ath79_register_usb();
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+	ath79_register_pci();
+
+	ath79_register_wmac(art + DW33D_WMAC_CALDATA_OFFSET, art + DW33D_WMAC_OFFSET);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + DW33D_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + DW33D_MAC1_OFFSET, 0);
+
+	mdiobus_register_board_info(dw33d_mdio0_info,
+				    ARRAY_SIZE(dw33d_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+        ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected tot eh SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+        ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DOMYWIFI_DW33D, "DW33D",
+	     "DomyWifi DW33D",
+	     dw33d_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr344.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr344.c
new file mode 100644
index 0000000000..c0ae52f962
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr344.c
@@ -0,0 +1,225 @@
+/*
+ * Wallys DR342/DR344 boards support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2015 Philippe Duchein <wireless-dev@duchein.net>
+ * Copyright (c) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DR34X_GPIO_LED_SIG1		12
+#define DR34X_GPIO_LED_SIG2		13
+#define DR34X_GPIO_LED_SIG3		14
+#define DR34X_GPIO_LED_SIG4		15
+#define DR34X_GPIO_LED_STATUS		11
+#define DR344_GPIO_LED_LAN		17
+#define DR344_GPIO_EXTERNAL_LNA0	18
+#define DR344_GPIO_EXTERNAL_LNA1	19
+
+#define DR34X_GPIO_BTN_RESET		16
+
+#define DR344_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DR344_KEYS_DEBOUNCE_INTERVAL	(3 * DR344_KEYS_POLL_INTERVAL)
+
+#define DR34X_MAC0_OFFSET		0
+#define DR34X_MAC1_OFFSET		8
+#define DR34X_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led dr342_leds_gpio[] __initdata = {
+	{
+		.name		= "dr342:green:status",
+		.gpio		= DR34X_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr342:green:sig1",
+		.gpio		= DR34X_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr342:green:sig2",
+		.gpio		= DR34X_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr342:green:sig3",
+		.gpio		= DR34X_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr342:green:sig4",
+		.gpio		= DR34X_GPIO_LED_SIG4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led dr344_leds_gpio[] __initdata = {
+	{
+		.name		= "dr344:green:lan",
+		.gpio		= DR344_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr344:green:status",
+		.gpio		= DR34X_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr344:green:sig1",
+		.gpio		= DR34X_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr344:green:sig2",
+		.gpio		= DR34X_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr344:green:sig3",
+		.gpio		= DR34X_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr344:green:sig4",
+		.gpio		= DR34X_GPIO_LED_SIG4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dr34x_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DR344_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DR34X_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data dr34x_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info dr34x_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "dr34x",
+		.mdio_addr = 0,
+		.platform_data = &dr34x_at803x_data,
+	},
+};
+
+static void __init dr34x_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f03f810);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_direction_select(DR34X_GPIO_LED_STATUS, true);
+	gpio_set_value(DR34X_GPIO_LED_STATUS, 1);
+	ath79_gpio_output_select(DR34X_GPIO_LED_STATUS, 0);
+
+	ath79_register_gpio_keys_polled(-1, DR344_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dr34x_gpio_keys),
+					dr34x_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + DR34X_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(dr34x_mdio0_info,
+				    ARRAY_SIZE(dr34x_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* GMAC0 is connected to an AR8035 Gbps PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+	ath79_eth0_pll_data.pll_100 = 0x0101;
+	ath79_eth0_pll_data.pll_10 = 0x1313;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + DR34X_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+}
+
+static void __init dr342_setup(void)
+{
+	dr34x_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dr342_leds_gpio),
+				 dr342_leds_gpio);
+}
+
+static void __init dr344_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f03f810);
+
+	dr34x_setup();
+
+	ath79_gpio_direction_select(DR344_GPIO_LED_LAN, true);
+	gpio_set_value(DR344_GPIO_LED_LAN, 1);
+	ath79_gpio_output_select(DR344_GPIO_LED_LAN, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dr344_leds_gpio),
+				 dr344_leds_gpio);
+
+	ath79_wmac_set_ext_lna_gpio(0, DR344_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, DR344_GPIO_EXTERNAL_LNA1);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + DR34X_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DR342, "DR342", "Wallys DR342", dr342_setup);
+MIPS_MACHINE(ATH79_MACH_DR344, "DR344", "Wallys DR344", dr344_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dr531.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr531.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dr531.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dr531.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dragino2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dragino2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dragino2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-dragino2.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e1700ac-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e1700ac-v2.c
new file mode 100644
index 0000000000..b0b8252801
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e1700ac-v2.c
@@ -0,0 +1,146 @@
+/*
+ *  Qxwlan E1700AC v2 board support
+ *
+ *  Copyright (C) 2017 Peng Zhang <sd20@qxwlan.com>
+ *  Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define E1700AC_V2_GPIO_LED_SYS		1
+#define E1700AC_V2_GPIO_LED_USB		7
+#define E1700AC_V2_GPIO_LED_WLAN2G	19
+
+#define E1700AC_V2_GPIO_BTN_SW1		2
+#define E1700AC_V2_GPIO_BTN_RESET	11
+
+#define E1700AC_V2_KEYS_POLL_INTERVAL		20 /* msecs */
+#define E1700AC_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * E1700AC_V2_KEYS_POLL_INTERVAL)
+
+static struct gpio_led e1700ac_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "e1700ac-v2:green:system",
+		.gpio		= E1700AC_V2_GPIO_LED_SYS,
+		.active_low	= 1,
+	}, {
+		.name		= "e1700ac-v2:green:usb",
+		.gpio		= E1700AC_V2_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "e1700ac-v2:green:wlan2g",
+		.gpio		= E1700AC_V2_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button e1700ac_v2_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= E1700AC_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= E1700AC_V2_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw1",
+		.type			= EV_KEY,
+		.code			= BTN_0,
+		.debounce_interval	= E1700AC_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= E1700AC_V2_GPIO_BTN_SW1,
+		.active_low		= 1,
+	},
+};
+
+static const struct ar8327_led_info e1700ac_v2_leds_qca8334[] = {
+	AR8327_LED_INFO(PHY1_0, HW, "e1700ac-v2:green:lan"),
+	AR8327_LED_INFO(PHY2_0, HW, "e1700ac-v2:green:wan"),
+};
+
+/* Blink rate: 1 Gbps -> 8 hz, 100 Mbs -> 4 Hz, 10 Mbps -> 2 Hz */
+static struct ar8327_led_cfg e1700ac_v2_qca8334_led_cfg = {
+	.led_ctrl0 = 0xcf37cf37,
+	.led_ctrl1 = 0xcf37cf37,
+	.led_ctrl2 = 0xcf37cf37,
+	.led_ctrl3 = 0x0,
+	.open_drain = true,
+};
+
+static struct ar8327_pad_cfg e1700ac_v2_qca8334_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data e1700ac_v2_qca8334_data = {
+	.pad0_cfg = &e1700ac_v2_qca8334_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &e1700ac_v2_qca8334_led_cfg,
+	.leds = e1700ac_v2_leds_qca8334,
+	.num_leds = ARRAY_SIZE(e1700ac_v2_leds_qca8334),
+};
+
+static struct mdio_board_info e1700ac_v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "e1700ac_v2",
+		.mdio_addr = 0,
+		.platform_data = &e1700ac_v2_qca8334_data,
+	},
+};
+
+static void __init e1700ac_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f050400);
+	u8 *art = (u8 *) KSEG1ADDR(0x1f061000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(e1700ac_v2_leds_gpio),
+				 e1700ac_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, E1700AC_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(e1700ac_v2_gpio_keys),
+					e1700ac_v2_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(e1700ac_v2_mdio0_info,
+				    ARRAY_SIZE(e1700ac_v2_mdio0_info));
+
+	/* GMAC0 is connected to QCA8334 switch */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_pll_data.pll_1000 = 0x03000101;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+	ath79_register_usb();
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_E1700AC_V2, "E1700AC-V2", "Qxwlan E1700AC v2",
+	     e1700ac_v2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-e2100l.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e2100l.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-e2100l.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e2100l.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-e600g-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e600g-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-e600g-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-e600g-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-eap120.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap120.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-eap120.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap120.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-eap300v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap300v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-eap300v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap300v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-eap7660d.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap7660d.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-eap7660d.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-eap7660d.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-el-m150.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-el-m150.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-el-m150.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-el-m150.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-el-mini.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-el-mini.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-el-mini.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-el-mini.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ens202ext.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ens202ext.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ens202ext.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ens202ext.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-epg5000.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-epg5000.c
new file mode 100644
index 0000000000..c7ceecbc96
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-epg5000.c
@@ -0,0 +1,178 @@
+/*
+ *  EnGenius EPG5000 board support
+ *
+ *  Copyright (c) 2014 Jon Suphammer <jon@suphammer.net>
+ *  Copyright (c) 2015 Christian Beier <cb@shoutrlabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define EPG5000_GPIO_LED_WLAN_5G	23
+#define EPG5000_GPIO_LED_WLAN_2G	13
+#define EPG5000_GPIO_LED_POWER_AMBER	2
+#define EPG5000_GPIO_LED_WPS_AMBER	22
+#define EPG5000_GPIO_LED_WPS_BLUE	19
+
+#define EPG5000_GPIO_BTN_WPS		16
+#define EPG5000_GPIO_BTN_RESET		17
+
+#define EPG5000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EPG5000_KEYS_DEBOUNCE_INTERVAL	(3 * EPG5000_KEYS_POLL_INTERVAL)
+
+#define EPG5000_CALDATA_ADDR 0x1fff0000
+#define EPG5000_WMAC_CALDATA_OFFSET	0x1000
+#define EPG5000_PCIE_CALDATA_OFFSET	0x5000
+
+#define EPG5000_NVRAM_ADDR	0x1f030000
+#define EPG5000_NVRAM_SIZE	0x10000
+
+static struct gpio_led epg5000_leds_gpio[] __initdata = {
+	{
+		.name		= "epg5000:amber:power",
+		.gpio		= EPG5000_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wps",
+		.gpio		= EPG5000_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:amber:wps",
+		.gpio		= EPG5000_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wlan-2g",
+		.gpio		= EPG5000_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wlan-5g",
+		.gpio		= EPG5000_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button epg5000_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EPG5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EPG5000_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EPG5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EPG5000_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg epg5000_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data epg5000_ar8327_data = {
+	.pad0_cfg = &epg5000_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info epg5000_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "epg5000",
+		.mdio_addr = 0,
+		.platform_data = &epg5000_ar8327_data,
+	},
+};
+
+static int epg5000_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(EPG5000_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, EPG5000_NVRAM_SIZE,
+					 name, mac);
+	if (err) {
+		pr_err("no MAC address found for %s\n", name);
+		return false;
+	}
+
+	return true;
+}
+
+static void __init epg5000_setup(void)
+{
+	u8 *caldata = (u8 *) KSEG1ADDR(EPG5000_CALDATA_ADDR);
+	u8 mac1[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(epg5000_leds_gpio),
+					epg5000_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EPG5000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(epg5000_gpio_keys),
+					epg5000_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(epg5000_mdio0_info,
+					ARRAY_SIZE(epg5000_mdio0_info));
+
+	/* GMAC0 is connected to an QCA8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	if (epg5000_get_mac("ethaddr=", mac1))
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(caldata + EPG5000_WMAC_CALDATA_OFFSET, mac1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_EPG5000, "EPG5000",
+	     "EnGenius EPG5000",
+	     epg5000_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr1750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr1750.c
new file mode 100644
index 0000000000..9fbd46b640
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr1750.c
@@ -0,0 +1,177 @@
+/*
+ *  EnGenius ESR1750 board support
+ *
+ *  Copyright (c) 2014 Jon Suphammer <jon@suphammer.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define ESR1750_GPIO_LED_WLAN_5G	23
+#define ESR1750_GPIO_LED_WLAN_2G	13
+#define ESR1750_GPIO_LED_POWER_AMBER	2
+#define ESR1750_GPIO_LED_WPS_AMBER	22
+#define ESR1750_GPIO_LED_WPS_BLUE	19
+
+#define ESR1750_GPIO_BTN_WPS		16
+#define ESR1750_GPIO_BTN_RESET		17
+
+#define ESR1750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ESR1750_KEYS_DEBOUNCE_INTERVAL	(3 * ESR1750_KEYS_POLL_INTERVAL)
+
+#define ESR1750_CALDATA_ADDR 0x1fff0000
+#define ESR1750_WMAC_CALDATA_OFFSET	0x1000
+#define ESR1750_PCIE_CALDATA_OFFSET	0x5000
+
+#define ESR1750_NVRAM_ADDR	0x1f030000
+#define ESR1750_NVRAM_SIZE	0x10000
+
+static struct gpio_led esr1750_leds_gpio[] __initdata = {
+	{
+		.name		= "esr1750:amber:power",
+		.gpio		= ESR1750_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wps",
+		.gpio		= ESR1750_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:amber:wps",
+		.gpio		= ESR1750_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wlan-2g",
+		.gpio		= ESR1750_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wlan-5g",
+		.gpio		= ESR1750_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button esr1750_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ESR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR1750_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ESR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR1750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg esr1750_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data esr1750_ar8327_data = {
+	.pad0_cfg = &esr1750_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info esr1750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "esr1750",
+		.mdio_addr = 0,
+		.platform_data = &esr1750_ar8327_data,
+	},
+};
+
+static int esr1750_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(ESR1750_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, ESR1750_NVRAM_SIZE,
+					 name, mac);
+	if (err) {
+		pr_err("no MAC address found for %s\n", name);
+		return false;
+	}
+
+	return true;
+}
+
+static void __init esr1750_setup(void)
+{
+	u8 *caldata = (u8 *) KSEG1ADDR(ESR1750_CALDATA_ADDR);
+	u8 mac1[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(esr1750_leds_gpio),
+					esr1750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ESR1750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(esr1750_gpio_keys),
+					esr1750_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(esr1750_mdio0_info,
+					ARRAY_SIZE(esr1750_mdio0_info));
+
+	/* GMAC0 is connected to an QCA8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	if (esr1750_get_mac("ethaddr=", mac1))
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(caldata + ESR1750_WMAC_CALDATA_OFFSET, mac1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_ESR1750, "ESR1750",
+	     "EnGenius ESR1750",
+	     esr1750_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr900.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr900.c
new file mode 100644
index 0000000000..85f512f841
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-esr900.c
@@ -0,0 +1,201 @@
+/*
+ *  EnGenius ESR900 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "esr900: " fmt
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define ESR900_GPIO_LED_POWER           2
+#define ESR900_GPIO_LED_WLAN_2G         13
+#define ESR900_GPIO_LED_WPS_BLUE        19
+#define ESR900_GPIO_LED_WPS_AMBER       22
+#define ESR900_GPIO_LED_WLAN_5G         23
+
+#define ESR900_GPIO_BTN_WPS             16
+#define ESR900_GPIO_BTN_RESET           17
+
+#define ESR900_KEYS_POLL_INTERVAL       20 /* msecs */
+#define ESR900_KEYS_DEBOUNCE_INTERVAL   (3 * ESR900_KEYS_POLL_INTERVAL)
+
+#define ESR900_CALDATA_ADDR             0x1fff0000
+#define ESR900_WMAC_CALDATA_OFFSET      0x1000
+#define ESR900_PCIE_CALDATA_OFFSET      0x5000
+
+#define ESR900_CONFIG_ADDR              0x1f030000
+#define ESR900_CONFIG_SIZE              0x10000
+
+#define ESR900_LAN_PHYMASK              BIT(0)
+#define ESR900_WAN_PHYMASK              BIT(5)
+#define ESR900_MDIO_MASK                (~(ESR900_LAN_PHYMASK | ESR900_WAN_PHYMASK))
+
+static struct gpio_led esr900_leds_gpio[] __initdata = {
+	{
+		.name		= "engenius:amber:power",
+		.gpio		= ESR900_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wlan-2g",
+		.gpio		= ESR900_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wps",
+		.gpio		= ESR900_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:amber:wps",
+		.gpio		= ESR900_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wlan-5g",
+		.gpio		= ESR900_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button esr900_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ESR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR900_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ESR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR900_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg esr900_ar8327_pad0_cfg = {
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_pad_cfg esr900_ar8327_pad6_cfg = {
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.rxclk_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data esr900_ar8327_data = {
+	.pad0_cfg = &esr900_ar8327_pad0_cfg,
+	.pad6_cfg = &esr900_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info esr900_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "esr900",
+		.mdio_addr = 0,
+		.platform_data = &esr900_ar8327_data,
+	},
+};
+
+static void __init esr900_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(ESR900_CONFIG_ADDR);
+	u8 *art = (u8 *) KSEG1ADDR(ESR900_CALDATA_ADDR);
+	u8 lan_mac[ETH_ALEN];
+	u8 wlan0_mac[ETH_ALEN];
+	u8 wlan1_mac[ETH_ALEN];
+
+	if (ath79_nvram_parse_mac_addr(config, ESR900_CONFIG_SIZE,
+				       "ethaddr=", lan_mac) == 0) {
+		ath79_init_local_mac(ath79_eth0_data.mac_addr, lan_mac);
+		ath79_init_mac(wlan0_mac, lan_mac, 0);
+		ath79_init_mac(wlan1_mac, lan_mac, 1);
+	} else {
+		pr_err("could not find ethaddr in u-boot environment\n");
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(esr900_leds_gpio),
+					esr900_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ESR900_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(esr900_gpio_keys),
+					esr900_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + ESR900_WMAC_CALDATA_OFFSET, wlan0_mac);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(esr900_mdio0_info,
+				    ARRAY_SIZE(esr900_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ESR900_LAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_register_eth(1);
+
+	ap91_pci_init(art + ESR900_PCIE_CALDATA_OFFSET, wlan1_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ESR900, "ESR900", "EnGenius ESR900", esr900_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ew-balin.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ew-balin.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ew-balin.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ew-balin.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ew-dorin.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ew-dorin.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ew-dorin.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ew-dorin.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-f9k1115v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-f9k1115v2.c
new file mode 100644
index 0000000000..88c695a35c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-f9k1115v2.c
@@ -0,0 +1,190 @@
+/*
+ *  Belkin AC1750DB (F9K1115V2) board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define F9K1115V2_GPIO_LED_USB2		4
+#define F9K1115V2_GPIO_LED_WPS_AMBER	14
+#define F9K1115V2_GPIO_LED_STATUS_AMBER	15
+#define F9K1115V2_GPIO_LED_WPS_BLUE	19
+#define F9K1115V2_GPIO_LED_STATUS_BLUE	20
+
+#define F9K1115V2_GPIO_BTN_WPS		16
+#define F9K1115V2_GPIO_BTN_RESET	17
+
+#define F9K1115V2_GPIO_USB2_POWER	21
+
+#define F9K1115V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define F9K1115V2_KEYS_DEBOUNCE_INTERVAL (3 * F9K1115V2_KEYS_POLL_INTERVAL)
+
+#define F9K1115V2_WAN_MAC_OFFSET	0
+#define F9K1115V2_LAN_MAC_OFFSET	6
+#define F9K1115V2_WMAC_CALDATA_OFFSET	0x1000
+#define F9K1115V2_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led f9k1115v2_leds_gpio[] __initdata = {
+	{
+		.name		= "belkin:amber:status",
+		.gpio		= F9K1115V2_GPIO_LED_STATUS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:blue:status",
+		.gpio		= F9K1115V2_GPIO_LED_STATUS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:blue:wps",
+		.gpio		= F9K1115V2_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:amber:wps",
+		.gpio		= F9K1115V2_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:green:usb2",
+		.gpio		= F9K1115V2_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button f9k1115v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = F9K1115V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= F9K1115V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = F9K1115V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= F9K1115V2_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg f9k1115v2_ar8327_pad0_cfg = {
+	/* Use the RGMII interface for the GMAC0 of the AR8337 switch */
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_pad_cfg f9k1115v2_ar8327_pad6_cfg = {
+	/* Use the SGMII interface for the GMAC6 of the AR8337 switch */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.rxclk_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data f9k1115v2_ar8327_data = {
+	.pad0_cfg = &f9k1115v2_ar8327_pad0_cfg,
+	.pad6_cfg = &f9k1115v2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info f9k1115v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "f9k1115v2",
+		.mdio_addr = 0,
+		.platform_data = &f9k1115v2_ar8327_data,
+	},
+};
+
+static void __init f9k1115v2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(f9k1115v2_leds_gpio),
+				 f9k1115v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, F9K1115V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(f9k1115v2_gpio_keys),
+					f9k1115v2_gpio_keys);
+
+	ath79_register_wmac(art + F9K1115V2_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(f9k1115v2_mdio0_info,
+				    ARRAY_SIZE(f9k1115v2_mdio0_info));
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + F9K1115V2_WAN_MAC_OFFSET, 0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + F9K1115V2_LAN_MAC_OFFSET, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+	gpio_request_one(F9K1115V2_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+}
+
+MIPS_MACHINE(ATH79_MACH_F9K1115V2, "F9K1115V2", "Belkin AC1750DB",
+	     f9k1115v2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-fritz300e.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-fritz300e.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-fritz300e.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-fritz300e.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-fritz4020.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-fritz4020.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-fritz4020.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-fritz4020.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar150.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar150.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar150.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar150.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar300.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar300.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar300m.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar300m.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750s.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750s.c
new file mode 100644
index 0000000000..503636eb0d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-ar750s.c
@@ -0,0 +1,194 @@
+/*
+ *  GL.iNet GL-AR750S board support
+ *
+ *  Copyright (C) 2018 luochongjun <luochongjun@gl-inet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+
+#define GL_AR750S_KEYS_POLL_INTERVAL	20
+#define GL_AR750S_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR750S_KEYS_POLL_INTERVAL)
+
+
+#define GL_AR750S_GPIO_LED_WLAN2G       19
+#define GL_AR750S_GPIO_LED_WLAN5G       20
+#define GL_AR750S_GPIO_LED_POWER	1
+#define GL_AR750S_GPIO_USB_POWER	7
+
+#define GL_AR750S_GPIO_BTN_RESET	2
+#define GL_AR750S_GPIO_BTN_RIGHT	8
+
+#define GL_AR750S_MAC0_OFFSET             0x0000
+#define GL_AR750S_WMAC_CALDATA_OFFSET     0x1000
+#define GL_AR750S_PCI_CALDATA_OFFSET      0x5000
+
+#define GL_AR750S_GPIO_I2C_SDA	5
+#define GL_AR750S_GPIO_I2C_SCL	21
+
+
+
+static struct spi_board_info gl_ar750s_spi_info[] = {
+    {
+        .bus_num    = 0,
+        .chip_select    = 0,
+        .max_speed_hz   = 25000000,
+        .modalias   = "m25p80",
+        .platform_data  = NULL,
+    },
+};
+
+static struct ath79_spi_platform_data gl_ar750s_spi_data = {
+    .bus_num        = 0,
+    .num_chipselect     = 2,
+};
+
+static struct gpio_led gl_ar750s_leds_gpio[] __initdata = {
+	{
+		 .name           = "gl-ar750s:green:power",
+		 .gpio           = GL_AR750S_GPIO_LED_POWER,
+		.default_state  = LEDS_GPIO_DEFSTATE_KEEP,
+		.active_low     = 1,
+   	 },{
+		 .name           = "gl-ar750s:green:usbpower",
+		 .gpio           = GL_AR750S_GPIO_USB_POWER,
+		.active_low     = 1,
+   	 },{
+		.name		= "gl-ar750s:green:wlan2g",
+		.gpio		= GL_AR750S_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},{
+		.name		= "gl-ar750s:green:wlan5g",
+		.gpio		= GL_AR750S_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button gl_ar750s_gpio_keys[] __initdata = {
+    {
+        .desc                   = "reset",
+        .type                   = EV_KEY,
+        .code                   = KEY_RESTART,
+        .debounce_interval      = GL_AR750S_KEYS_DEBOUNCE_INTERVAL,
+        .gpio                   = GL_AR750S_GPIO_BTN_RESET,
+        .active_low             = 1,
+       }, {
+        .desc                   = "right",
+        .type                   = EV_KEY,
+        .code                   = BTN_0,
+        .debounce_interval      = GL_AR750S_KEYS_DEBOUNCE_INTERVAL,
+        .gpio                   = GL_AR750S_GPIO_BTN_RIGHT,
+        .active_low             = 1,
+       },
+};
+
+static struct i2c_gpio_platform_data gl_ar750s_i2c_gpio_data = {
+        .sda_pin        = GL_AR750S_GPIO_I2C_SDA,
+        .scl_pin        = GL_AR750S_GPIO_I2C_SCL,
+};
+
+static struct platform_device gl_ar750s_i2c_gpio_device = {
+        .name           = "i2c-gpio",
+        .id             = 0,
+        .dev = {
+                .platform_data  = &gl_ar750s_i2c_gpio_data,
+	}
+
+};
+
+static struct ar8327_pad_cfg gl_ar750s_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data gl_ar750s_ar8327_data = {
+	.pad0_cfg = &gl_ar750s_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+
+static struct mdio_board_info gl_ar750s_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "gl_ar750s",
+		.mdio_addr = 0,
+		.platform_data = &gl_ar750s_ar8327_data,
+	},
+};
+
+static void __init  gl_ar750s_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1f050000);
+
+	ath79_register_spi(&gl_ar750s_spi_data, gl_ar750s_spi_info, 1);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+	               eeprom + GL_AR750S_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	mdiobus_register_board_info(gl_ar750s_mdio0_info,
+	                            ARRAY_SIZE(gl_ar750s_mdio0_info));
+
+	ath79_register_mdio(0, 0x00);
+	ath79_register_eth(0);
+
+
+	ath79_register_usb();
+
+
+	ath79_register_wmac(eeprom + GL_AR750S_WMAC_CALDATA_OFFSET, NULL);
+
+
+	ap91_pci_init(eeprom + GL_AR750S_PCI_CALDATA_OFFSET, NULL);
+
+	platform_device_register(&gl_ar750s_i2c_gpio_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar750s_leds_gpio),
+	                         gl_ar750s_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GL_AR750S_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(gl_ar750s_gpio_keys),
+	                                gl_ar750s_gpio_keys);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_GL_AR750S, "GL-AR750S", "GL-AR750S",
+         gl_ar750s_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-domino.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-domino.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-domino.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-domino.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-inet.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-inet.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-inet.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-inet.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-mifi.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-mifi.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-usb150.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gl-usb150.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gs-oolite-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gs-oolite-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gs-oolite-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gs-oolite-v1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gs-oolite-v5-2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gs-oolite-v5-2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gs-oolite-v5-2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-gs-oolite-v5-2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-hiveap-121.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hiveap-121.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-hiveap-121.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hiveap-121.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-hiwifi-hc6361.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hiwifi-hc6361.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-hiwifi-hc6361.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hiwifi-hc6361.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-hornet-ub.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hornet-ub.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-hornet-ub.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-hornet-ub.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ja76pf.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ja76pf.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ja76pf.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ja76pf.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-jwap003.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap003.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-jwap003.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap003.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap230.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap230.c
new file mode 100644
index 0000000000..820d3eeabb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-jwap230.c
@@ -0,0 +1,159 @@
+/*
+ * jjPlus JWAP230 board support
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * Based on mach-wpj558.c and mach-tl-wr1043nd-v2.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JWAP230_GPIO_LED_LED1		23
+#define JWAP230_GPIO_LED_LED2		22
+#define JWAP230_GPIO_LED_LED3		21
+
+#define JWAP230_MAC0_OFFSET		0x0
+#define JWAP230_MAC1_OFFSET		0x6
+#define JWAP230_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led jwap230_leds_gpio[] __initdata = {
+	{
+		.name		= "jwap230:green:led1",
+		.gpio		= JWAP230_GPIO_LED_LED1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "jwap230:green:led2",
+		.gpio		= JWAP230_GPIO_LED_LED2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "jwap230:green:led3",
+		.gpio		= JWAP230_GPIO_LED_LED3,
+		.active_low	= 1,
+	}
+};
+
+static const struct ar8327_led_info jwap230_leds_qca8337[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "jwap230:green:lan"),
+	AR8327_LED_INFO(PHY4_0, HW, "jwap230:green:wan"),
+};
+
+/* Blink rate: 1 Gbps -> 8 hz, 100 Mbs -> 4 Hz, 10 Mbps -> 2 Hz */
+static struct ar8327_led_cfg jwap230_qca8337_led_cfg = {
+	.led_ctrl0 = 0xcf37cf37,
+	.led_ctrl1 = 0xcf37cf37,
+	.led_ctrl2 = 0xcf37cf37,
+	.led_ctrl3 = 0x0,
+	.open_drain = true,
+};
+
+/* QCA8337 GMAC0 is connected with QCA9558 over RGMII */
+static struct ar8327_pad_cfg jwap230_qca8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_dis = true,
+};
+
+/* QCA8337 GMAC6 is connected with QCA9558 over SGMII */
+static struct ar8327_pad_cfg jwap230_qca8337_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data jwap230_qca8337_data = {
+	.pad0_cfg = &jwap230_qca8337_pad0_cfg,
+	.pad6_cfg = &jwap230_qca8337_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &jwap230_qca8337_led_cfg,
+	.num_leds = ARRAY_SIZE(jwap230_leds_qca8337),
+	.leds = jwap230_leds_qca8337,
+};
+
+static struct mdio_board_info jwap230_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "jwap230",
+		.mdio_addr = 0,
+		.platform_data = &jwap230_qca8337_data,
+	},
+};
+
+static void __init jwap230_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(jwap230_leds_gpio),
+				 jwap230_leds_gpio);
+
+	mdiobus_register_board_info(jwap230_mdio0_info,
+				    ARRAY_SIZE(jwap230_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* QCA9558 GMAC0 is connected to RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + JWAP230_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* QCA9558 GMAC1 is connected to SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + JWAP230_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + JWAP230_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_JWAP230, "JWAP230", "jjPlus JWAP230", jwap230_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-lan-turtle.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-lan-turtle.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-lan-turtle.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-lan-turtle.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-lima.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-lima.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-lima.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-lima.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mc-mac1200r.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mc-mac1200r.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mc-mac1200r.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mc-mac1200r.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr12.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr12.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr12.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr12.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr16.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr16.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr16.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr16.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr1750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr1750.c
new file mode 100644
index 0000000000..0b92154ae3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr1750.c
@@ -0,0 +1,172 @@
+/*
+ * MR1750 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define MR1750_GPIO_LED_LAN		12
+#define MR1750_GPIO_LED_WLAN_2G		13
+#define MR1750_GPIO_LED_STATUS_GREEN	19
+#define MR1750_GPIO_LED_STATUS_RED	21
+#define MR1750_GPIO_LED_POWER		22
+#define MR1750_GPIO_LED_WLAN_5G		23
+
+#define MR1750_GPIO_BTN_RESET		17
+
+#define MR1750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR1750_KEYS_DEBOUNCE_INTERVAL	(3 * MR1750_KEYS_POLL_INTERVAL)
+
+#define MR1750_MAC0_OFFSET		0
+#define MR1750_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led mr1750_leds_gpio[] __initdata = {
+	{
+		.name		= "mr1750:blue:power",
+		.gpio		= MR1750_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wan",
+		.gpio		= MR1750_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wlan24",
+		.gpio		= MR1750_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wlan58",
+		.gpio		= MR1750_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:green:status",
+		.gpio		= MR1750_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:red:status",
+		.gpio		= MR1750_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr1750_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR1750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data mr1750_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 0,
+	.fixup_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info mr1750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "mr1750",
+		.mdio_addr = 5,
+		.platform_data = &mr1750_at803x_data,
+	},
+};
+
+static void __init mr1750_setup_qca955x_eth_cfg(u32 mask,
+						unsigned int rxd,
+						unsigned int rxdv,
+						unsigned int txd,
+						unsigned int txe)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = mask;
+	t |= rxd << QCA955X_ETH_CFG_RXD_DELAY_SHIFT;
+	t |= rxdv << QCA955X_ETH_CFG_RDV_DELAY_SHIFT;
+	t |= txd << QCA955X_ETH_CFG_TXD_DELAY_SHIFT;
+	t |= txe << QCA955X_ETH_CFG_TXE_DELAY_SHIFT;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init mr1750_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_eth0_pll_data.pll_1000 = 0xae000000;
+	ath79_eth0_pll_data.pll_100 = 0xa0000101;
+	ath79_eth0_pll_data.pll_10 = 0xa0001313;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mr1750_leds_gpio),
+				 mr1750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR1750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr1750_gpio_keys),
+					mr1750_gpio_keys);
+
+	ath79_init_mac(mac, art + MR1750_MAC0_OFFSET, 1);
+	ath79_register_wmac(art + MR1750_WMAC_CALDATA_OFFSET, mac);
+	ath79_register_pci();
+
+	mr1750_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN, 3, 3, 0, 0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(mr1750_mdio0_info,
+				    ARRAY_SIZE(mr1750_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR1750_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(5);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR1750, "MR1750", "OpenMesh MR1750", mr1750_setup);
+MIPS_MACHINE(ATH79_MACH_MR1750V2, "MR1750v2", "OpenMesh MR1750v2", mr1750_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr18.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr18.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr18.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr18.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr600.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr600.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr600.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr600.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr900.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr900.c
new file mode 100644
index 0000000000..6fe6764c1d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mr900.c
@@ -0,0 +1,182 @@
+/*
+ * MR900 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define MR900_GPIO_LED_LAN		12
+#define MR900_GPIO_LED_WLAN_2G		13
+#define MR900_GPIO_LED_STATUS_GREEN	19
+#define MR900_GPIO_LED_STATUS_RED	21
+#define MR900_GPIO_LED_POWER		22
+#define MR900_GPIO_LED_WLAN_5G		23
+
+#define MR900_GPIO_BTN_RESET		17
+
+#define MR900_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR900_KEYS_DEBOUNCE_INTERVAL	(3 * MR900_KEYS_POLL_INTERVAL)
+
+#define MR900_MAC0_OFFSET		0
+#define MR900_WMAC_CALDATA_OFFSET	0x1000
+#define MR900_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led mr900_leds_gpio[] __initdata = {
+	{
+		.name		= "mr900:blue:power",
+		.gpio		= MR900_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wan",
+		.gpio		= MR900_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wlan24",
+		.gpio		= MR900_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wlan58",
+		.gpio		= MR900_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:green:status",
+		.gpio		= MR900_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:red:status",
+		.gpio		= MR900_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr900_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR900_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data mr900_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 0,
+	.fixup_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info mr900_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "mr900",
+		.mdio_addr = 5,
+		.platform_data = &mr900_at803x_data,
+	},
+};
+
+static void __init mr900_setup_qca955x_eth_cfg(u32 mask,
+					       unsigned int rxd,
+					       unsigned int rxdv,
+					       unsigned int txd,
+					       unsigned int txe)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = mask;
+	t |= rxd << QCA955X_ETH_CFG_RXD_DELAY_SHIFT;
+	t |= rxdv << QCA955X_ETH_CFG_RDV_DELAY_SHIFT;
+	t |= txd << QCA955X_ETH_CFG_TXD_DELAY_SHIFT;
+	t |= txe << QCA955X_ETH_CFG_TXE_DELAY_SHIFT;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init mr900_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6], pcie_mac[6];
+	struct ath9k_platform_data *pdata;
+
+	ath79_eth0_pll_data.pll_1000 = 0xae000000;
+	ath79_eth0_pll_data.pll_100 = 0xa0000101;
+	ath79_eth0_pll_data.pll_10 = 0xa0001313;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mr900_leds_gpio),
+				 mr900_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR900_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr900_gpio_keys),
+					mr900_gpio_keys);
+
+	ath79_init_mac(mac, art + MR900_MAC0_OFFSET, 1);
+	ath79_register_wmac(art + MR900_WMAC_CALDATA_OFFSET, mac);
+	ath79_init_mac(pcie_mac, art + MR900_MAC0_OFFSET, 16);
+	ap91_pci_init(art + MR900_PCIE_CALDATA_OFFSET, pcie_mac);
+	pdata = ap9x_pci_get_wmac_data(0);
+	if (!pdata) {
+		pr_err("mr900: unable to get address of wlan data\n");
+		return;
+	}
+	pdata->use_eeprom = true;
+
+	mr900_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN, 3, 3, 0, 0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(mr900_mdio0_info,
+				    ARRAY_SIZE(mr900_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR900_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(5);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR900, "MR900", "OpenMesh MR900", mr900_setup);
+MIPS_MACHINE(ATH79_MACH_MR900v2, "MR900v2", "OpenMesh MR900v2", mr900_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n600.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n600.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n750.c
new file mode 100644
index 0000000000..713f354fe3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-n750.c
@@ -0,0 +1,227 @@
+/*
+ *  WD My Net N750 board support
+ *
+ *  Copyright (C) 2013 Felix Kaechele <felix@fetzig.org>
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+
+/*
+ * Taken from GPL bootloader source:
+ *   board/ar7240/db12x/alpha_gpio.c
+ */
+#define MYNET_N750_GPIO_LED_WIFI	11
+#define MYNET_N750_GPIO_LED_INTERNET	12
+#define MYNET_N750_GPIO_LED_WPS		13
+#define MYNET_N750_GPIO_LED_POWER	14
+
+#define MYNET_N750_GPIO_BTN_RESET	17
+#define MYNET_N750_GPIO_BTN_WPS		19
+
+#define MYNET_N750_GPIO_EXTERNAL_LNA0	15
+#define MYNET_N750_GPIO_EXTERNAL_LNA1	18
+
+#define MYNET_N750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N750_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N750_KEYS_POLL_INTERVAL)
+
+#define MYNET_N750_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N750_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N750_NVRAM_ADDR		0x1f058010
+#define MYNET_N750_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n750_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N750_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N750_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N750_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N750_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button mynet_n750_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info mynet_n750_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "wd:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "wd:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "wd:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "wd:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "wd:green:wan"),
+	AR8327_LED_INFO(PHY0_1, HW, "wd:yellow:lan1"),
+	AR8327_LED_INFO(PHY1_1, HW, "wd:yellow:lan2"),
+	AR8327_LED_INFO(PHY2_1, HW, "wd:yellow:lan3"),
+	AR8327_LED_INFO(PHY3_1, HW, "wd:yellow:lan4"),
+	AR8327_LED_INFO(PHY4_1, HW, "wd:yellow:wan"),
+};
+
+static struct ar8327_pad_cfg mynet_n750_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg mynet_n750_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data mynet_n750_ar8327_data = {
+	.pad0_cfg = &mynet_n750_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &mynet_n750_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(mynet_n750_leds_ar8327),
+	.leds = mynet_n750_leds_ar8327,
+};
+
+static struct mdio_board_info mynet_n750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "mynet_n750",
+		.mdio_addr = 0,
+		.platform_data = &mynet_n750_ar8327_data,
+	},
+};
+
+static void mynet_n750_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N750_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N750_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+/*
+ * The bootloader on this board powers down all PHYs on the switch
+ * before booting the kernel. We bring all PHYs back up so that they are
+ * discoverable by the mdio bus scan and the switch is detected
+ * correctly.
+ */
+static void mynet_n750_mdio_fixup(struct mii_bus *bus)
+{
+	int i;
+
+	for (i = 0; i < 5; i++)
+		bus->write(bus, i, MII_BMCR,
+			   (BMCR_RESET | BMCR_ANENABLE | BMCR_SPEED1000));
+
+	mdelay(1000);
+}
+
+static void __init mynet_n750_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n750_leds_gpio),
+				 mynet_n750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MYNET_N750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n750_gpio_keys),
+					mynet_n750_gpio_keys);
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N750_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N750_GPIO_EXTERNAL_LNA1);
+
+	mynet_n750_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N750_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n750_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N750_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(mynet_n750_mdio0_info,
+				    ARRAY_SIZE(mynet_n750_mdio0_info));
+
+	ath79_mdio0_data.reset = mynet_n750_mdio_fixup;
+	ath79_register_mdio(0, 0x0);
+
+	mynet_n750_get_mac("lanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N750, "MYNET-N750", "WD My Net N750",
+	     mynet_n750_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-rext.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-rext.c
new file mode 100644
index 0000000000..e202f0fc63
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mynet-rext.c
@@ -0,0 +1,209 @@
+/*
+ *  WD My Net WI-FI Range Extender (Codename:Starfish db12x) board support
+ *
+ *  Copyright (C) 2013 Christian Lamparter <chunkeey@googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_REXT_GPIO_LED_POWER	11
+#define MYNET_REXT_GPIO_LED_ETHERNET	12
+#define MYNET_REXT_GPIO_LED_WIFI	19
+
+#define MYNET_REXT_GPIO_LED_RF_QTY1	20
+#define MYNET_REXT_GPIO_LED_RF_QTY2	21
+#define MYNET_REXT_GPIO_LED_RF_QTY3	22
+
+#define MYNET_REXT_GPIO_BTN_RESET	13
+#define MYNET_REXT_GPIO_BTN_WPS		15
+#define MYNET_REXT_GPIO_SW_RF		14
+
+#define MYNET_REXT_GPIO_PHY_SWRST	16	/* disables Ethernet PHY */
+#define MYNET_REXT_GPIO_PHY_INT		17
+#define MYNET_REXT_GPIO_18		18
+
+#define MYNET_REXT_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_REXT_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_REXT_KEYS_POLL_INTERVAL)
+
+#define MYNET_REXT_WMAC_CALDATA_OFFSET	0x1000
+
+#define MYNET_REXT_NVRAM_ADDR		0x1f7e0010
+#define MYNET_REXT_NVRAM_SIZE		0xfff0
+
+#define MYNET_REXT_ART_ADDR		0x1f7f0000
+
+static const char *mynet_rext_part_probes[] = {
+	"cybertan",
+	NULL,
+};
+
+static struct flash_platform_data mynet_rext_flash_data = {
+	.type		= "s25fl064k",
+	.part_probes	= mynet_rext_part_probes,
+};
+
+static struct gpio_led mynet_rext_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_REXT_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_REXT_GPIO_LED_WIFI,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:ethernet",
+		.gpio		= MYNET_REXT_GPIO_LED_ETHERNET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality1",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality2",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality3",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY3,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_rext_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc           = "RF Band switch",
+		.type           = EV_SW,
+		.code           = BTN_1,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = MYNET_REXT_GPIO_SW_RF,
+	},
+};
+
+static struct at803x_platform_data mynet_rext_at803x_data = {
+	.disable_smarteee = 0,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 0,
+	.fixup_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info mynet_rext_mdio0_info[] = {
+        {
+                .bus_id = "ag71xx-mdio.0",
+		.modalias = "mynet_rext",
+		.mdio_addr = 4,
+                .platform_data = &mynet_rext_at803x_data,
+        },
+};
+
+static void mynet_rext_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_REXT_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_REXT_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init mynet_rext_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(MYNET_REXT_ART_ADDR);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&mynet_rext_flash_data);
+
+	/* GPIO configuration from drivers/char/GPIO8.c */
+
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_WIFI,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_ETHERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_rext_leds_gpio),
+				 mynet_rext_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_REXT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_rext_gpio_keys),
+					mynet_rext_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_RDV_DELAY);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(mynet_rext_mdio0_info,
+				    ARRAY_SIZE(mynet_rext_mdio0_info));
+
+	/* LAN */
+	mynet_rext_get_mac("et0macaddr=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an external PHY on Port 4 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_10   = 0x00001313; /* athrs_mac.c */
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000; /* athrs_mac.c */
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+
+	/* WLAN */
+	mynet_rext_get_mac("wl0_hwaddr=", tmpmac);
+	ap91_pci_init(art + MYNET_REXT_WMAC_CALDATA_OFFSET, tmpmac);
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_REXT, "MYNET-REXT",
+	     "WD My Net Wi-Fi Range Extender", mynet_rext_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mzk-w04nu.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mzk-w04nu.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mzk-w04nu.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mzk-w04nu.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mzk-w300nh.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mzk-w300nh.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mzk-w300nh.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-mzk-w300nh.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-n5q.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-n5q.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-n5q.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-n5q.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-nbg460n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg460n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-nbg460n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg460n.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg6716.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg6716.c
new file mode 100644
index 0000000000..f2b3b8d512
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-nbg6716.c
@@ -0,0 +1,381 @@
+/*
+ * ZyXEL NBG6716/NBG6616 board support
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2013 Andre Valentin <avalentin@marcant.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define NBG6716_GPIO_LED_INTERNET	18
+#define NBG6716_GPIO_LED_POWER		15
+#define NBG6716_GPIO_LED_USB1		4
+#define NBG6716_GPIO_LED_USB2		13
+#define NBG6716_GPIO_LED_WIFI2G		19
+#define NBG6716_GPIO_LED_WIFI5G		17
+#define NBG6716_GPIO_LED_WPS		21
+
+#define NBG6716_GPIO_BTN_RESET		23
+#define NBG6716_GPIO_BTN_RFKILL		1
+#define NBG6716_GPIO_BTN_USB1		0
+#define NBG6716_GPIO_BTN_USB2		14
+#define NBG6716_GPIO_BTN_WPS		22
+
+#define NBG6716_GPIO_USB_POWER		16
+
+#define NBG6716_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG6716_KEYS_DEBOUNCE_INTERVAL	(3 * NBG6716_KEYS_POLL_INTERVAL)
+
+#define NBG6716_MAC0_OFFSET		0
+#define NBG6716_MAC1_OFFSET		6
+#define NBG6716_WMAC_CALDATA_OFFSET	0x1000
+#define NBG6716_PCIE_CALDATA_OFFSET	0x5000
+
+/* NBG6616 has a different GPIO usage as it does not have USB Buttons */
+#define NBG6616_GPIO_LED_USB0		14
+#define NBG6616_GPIO_LED_USB1		21
+#define NBG6616_GPIO_LED_WPS		0
+
+static struct gpio_led nbg6716_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg6716:white:internet",
+		.gpio		= NBG6716_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:power",
+		.gpio		= NBG6716_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:usb1",
+		.gpio		= NBG6716_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:usb2",
+		.gpio		= NBG6716_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wifi2g",
+		.gpio		= NBG6716_GPIO_LED_WIFI2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wifi5g",
+		.gpio		= NBG6716_GPIO_LED_WIFI5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wps",
+		.gpio		= NBG6716_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button nbg6716_gpio_keys[] __initdata = {
+	{
+		.desc		= "RESET button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RFKILL,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "USB1 eject button",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_USB1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "USB2 eject button",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_USB2,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+
+static struct gpio_led nbg6616_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg6616:green:power",
+		.gpio		= NBG6716_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:usb2",
+		.gpio		= NBG6616_GPIO_LED_USB0,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:usb1",
+		.gpio		= NBG6616_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wifi2g",
+		.gpio		= NBG6716_GPIO_LED_WIFI2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wifi5g",
+		.gpio		= NBG6716_GPIO_LED_WIFI5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wps",
+		.gpio		= NBG6616_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button nbg6616_gpio_keys[] __initdata = {
+	{
+		.desc		= "RESET button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+static struct ar8327_pad_cfg nbg6716_ar8327_pad0_cfg;
+static struct ar8327_pad_cfg nbg6716_ar8327_pad6_cfg;
+static struct ar8327_led_cfg nbg6716_ar8327_led_cfg;
+
+static struct ar8327_platform_data nbg6716_ar8327_data = {
+	.pad0_cfg = &nbg6716_ar8327_pad0_cfg,
+	.pad6_cfg = &nbg6716_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &nbg6716_ar8327_led_cfg
+};
+
+static struct mdio_board_info nbg6716_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "nbg6716",
+		.mdio_addr = 0,
+		.platform_data = &nbg6716_ar8327_data,
+	},
+};
+
+static void nbg6716_get_mac(void* nvram_addr, const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(nvram_addr);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, 0x10000,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init nbg6716_common_setup(u32 leds_num, struct gpio_led* leds,
+					u32 keys_num,
+					struct gpio_keys_button* keys,
+					void* art_addr, void* nvram)
+{
+	u8 *art = (u8 *) KSEG1ADDR(art_addr);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, leds_num, leds);
+	ath79_register_gpio_keys_polled(-1, NBG6716_KEYS_POLL_INTERVAL,
+					keys_num, keys);
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	gpio_request_one(NBG6716_GPIO_USB_POWER,
+		GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+		"USB power");
+
+	ath79_register_usb();
+
+	nbg6716_get_mac(nvram, "ethaddr=", tmpmac);
+
+	ath79_register_pci();
+
+	ath79_register_wmac(art + NBG6716_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, tmpmac, 2);
+	ath79_init_mac(ath79_eth1_data.mac_addr, tmpmac, 3);
+
+	mdiobus_register_board_info(nbg6716_mdio0_info,
+				    ARRAY_SIZE(nbg6716_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+static void __init nbg6716_010_setup(void)
+{
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	nbg6716_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	nbg6716_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	nbg6716_ar8327_led_cfg.open_drain = 0;
+	nbg6716_ar8327_led_cfg.led_ctrl0 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl1 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl2 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl3 = 0x03ffff00;
+
+	nbg6716_common_setup(ARRAY_SIZE(nbg6716_leds_gpio), nbg6716_leds_gpio,
+			     ARRAY_SIZE(nbg6716_gpio_keys), nbg6716_gpio_keys,
+			     (void*) 0x1f050000, (void*) 0x1f040000);
+}
+
+static void __init nbg6616_010_setup(void)
+{
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	nbg6716_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	nbg6716_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	nbg6716_ar8327_led_cfg.open_drain = 0;
+	nbg6716_ar8327_led_cfg.led_ctrl0 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl1 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl2 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl3 = 0x03ffff00;
+
+
+	nbg6716_common_setup(ARRAY_SIZE(nbg6616_leds_gpio), nbg6616_leds_gpio,
+			     ARRAY_SIZE(nbg6616_gpio_keys), nbg6616_gpio_keys,
+			     (void*) 0x1f040000, (void*) 0x1f030000);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_NBG6716, "NBG6716",
+	     "Zyxel NBG6716",
+	     nbg6716_010_setup);
+
+MIPS_MACHINE(ATH79_MACH_NBG6616, "NBG6616",
+	     "Zyxel NBG6616",
+	     nbg6616_010_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-om2p.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om2p.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-om2p.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om2p.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5p.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5p.c
new file mode 100644
index 0000000000..c002ee0c84
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5p.c
@@ -0,0 +1,219 @@
+/*
+ *  OpenMesh OM5P support
+ *
+ *  Copyright (C) 2013 Marek Lindner <marek@open-mesh.com>
+ *  Copyright (C) 2014 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OM5P_GPIO_LED_POWER	13
+#define OM5P_GPIO_LED_GREEN	16
+#define OM5P_GPIO_LED_RED	19
+#define OM5P_GPIO_LED_YELLOW	17
+#define OM5P_GPIO_LED_LAN	14
+#define OM5P_GPIO_LED_WAN	15
+#define OM5P_GPIO_BTN_RESET	4
+#define OM5P_GPIO_I2C_SCL	20
+#define OM5P_GPIO_I2C_SDA	21
+
+#define OM5P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM5P_KEYS_DEBOUNCE_INTERVAL	(3 * OM5P_KEYS_POLL_INTERVAL)
+
+#define OM5P_WMAC_CALDATA_OFFSET	0x1000
+#define OM5P_PCI_CALDATA_OFFSET		0x5000
+
+static struct gpio_led om5p_leds_gpio[] __initdata = {
+	{
+		.name		= "om5p:blue:power",
+		.gpio		= OM5P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:red:wifi",
+		.gpio		= OM5P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:yellow:wifi",
+		.gpio		= OM5P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:green:wifi",
+		.gpio		= OM5P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:blue:lan",
+		.gpio		= OM5P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:blue:wan",
+		.gpio		= OM5P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om5p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM5P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM5P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct flash_platform_data om5p_flash_data = {
+	.type = "mx25l12805d",
+};
+
+static void __init om5p_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM5P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM5P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&om5p_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5p_leds_gpio),
+				 om5p_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM5P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om5p_gpio_keys),
+					om5p_gpio_keys);
+
+	ath79_init_mac(mac, art, 2);
+	ath79_register_wmac(art + OM5P_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P, "OM5P", "OpenMesh OM5P", om5p_setup);
+
+static struct i2c_gpio_platform_data om5pan_i2c_device_platdata = {
+	.sda_pin		= OM5P_GPIO_I2C_SDA,
+	.scl_pin		= OM5P_GPIO_I2C_SCL,
+	.udelay			= 10,
+	.sda_is_open_drain	= 1,
+	.scl_is_open_drain	= 1,
+};
+
+static struct platform_device om5pan_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &om5pan_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info om5pan_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("tmp423", 0x4c),
+	},
+};
+
+static struct at803x_platform_data om5p_an_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info om5p_an_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "om5p_an",
+		.mdio_addr = 7,
+		.platform_data = &om5p_an_at803x_data,
+	},
+};
+
+static void __init om5p_an_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* temperature sensor */
+	platform_device_register(&om5pan_i2c_device);
+	i2c_register_board_info(0, om5pan_i2c_devs,
+				ARRAY_SIZE(om5pan_i2c_devs));
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM5P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM5P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&om5p_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5p_leds_gpio),
+				 om5p_leds_gpio);
+
+	ath79_init_mac(mac, art, 0x02);
+	ath79_register_wmac(art + OM5P_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_setup_ar934x_eth_rx_delay(2, 2);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	mdiobus_register_board_info(om5p_an_mdio0_info,
+				    ARRAY_SIZE(om5p_an_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0x00);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0x01);
+
+	/* GMAC0 is connected to the PHY7 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(7);
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+	ath79_eth0_pll_data.pll_100 = 0x00000101;
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(1);
+
+	ath79_init_mac(mac, art, 0x10);
+	ap91_pci_init(art + OM5P_PCI_CALDATA_OFFSET, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P_AN, "OM5P-AN", "OpenMesh OM5P AN", om5p_an_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pac.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pac.c
new file mode 100644
index 0000000000..ad4f18c74d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pac.c
@@ -0,0 +1,195 @@
+/*
+ *  OpenMesh OM5P-AC support
+ *
+ *  Copyright (C) 2013 Marek Lindner <marek@open-mesh.com>
+ *  Copyright (C) 2014 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define OM5PAC_GPIO_LED_POWER	18
+#define OM5PAC_GPIO_LED_GREEN	21
+#define OM5PAC_GPIO_LED_RED	23
+#define OM5PAC_GPIO_LED_YELLOW	22
+#define OM5PAC_GPIO_LED_LAN	20
+#define OM5PAC_GPIO_LED_WAN	19
+#define OM5PAC_GPIO_I2C_SCL	12
+#define OM5PAC_GPIO_I2C_SDA	11
+
+#define OM5PAC_KEYS_POLL_INTERVAL	20	/* msecs */
+#define OM5PAC_KEYS_DEBOUNCE_INTERVAL	(3 * OM5PAC_KEYS_POLL_INTERVAL)
+
+#define OM5PAC_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led om5pac_leds_gpio[] __initdata = {
+	{
+		.name		= "om5pac:blue:power",
+		.gpio		= OM5PAC_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:red:wifi",
+		.gpio		= OM5PAC_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:yellow:wifi",
+		.gpio		= OM5PAC_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:green:wifi",
+		.gpio		= OM5PAC_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:blue:lan",
+		.gpio		= OM5PAC_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:blue:wan",
+		.gpio		= OM5PAC_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct flash_platform_data om5pac_flash_data = {
+	.type = "mx25l12805d",
+};
+
+static struct i2c_gpio_platform_data om5pac_i2c_device_platdata = {
+	.sda_pin		= OM5PAC_GPIO_I2C_SDA,
+	.scl_pin		= OM5PAC_GPIO_I2C_SCL,
+	.udelay			= 10,
+	.sda_is_open_drain	= 1,
+	.scl_is_open_drain	= 1,
+};
+
+static struct platform_device om5pac_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &om5pac_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info om5pac_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("tmp423", 0x4c),
+	},
+};
+
+static struct at803x_platform_data om5pac_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info om5pac_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "om5pac_1",
+		.mdio_addr = 1,
+		.platform_data = &om5pac_at803x_data,
+	},
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "om5pac_2",
+		.mdio_addr = 2,
+		.platform_data = &om5pac_at803x_data,
+	},
+};
+
+static void __init om5p_ac_setup_qca955x_eth_cfg(u32 mask,
+						 unsigned int rxd,
+						 unsigned int rxdv,
+						 unsigned int txd,
+						 unsigned int txe)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = mask;
+	t |= rxd << QCA955X_ETH_CFG_RXD_DELAY_SHIFT;
+	t |= rxdv << QCA955X_ETH_CFG_RDV_DELAY_SHIFT;
+	t |= txd << QCA955X_ETH_CFG_TXD_DELAY_SHIFT;
+	t |= txe << QCA955X_ETH_CFG_TXE_DELAY_SHIFT;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init om5p_ac_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* temperature sensor */
+	platform_device_register(&om5pac_i2c_device);
+	i2c_register_board_info(0, om5pac_i2c_devs,
+				ARRAY_SIZE(om5pac_i2c_devs));
+
+	ath79_gpio_output_select(OM5PAC_GPIO_LED_WAN, QCA955X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&om5pac_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5pac_leds_gpio),
+				 om5pac_leds_gpio);
+
+	ath79_init_mac(mac, art, 0x02);
+	ath79_register_wmac(art + OM5PAC_WMAC_CALDATA_OFFSET, mac);
+
+	om5p_ac_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN, 3, 3, 0, 0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(om5pac_mdio0_info,
+				    ARRAY_SIZE(om5pac_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0x00);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0x01);
+
+	/* GMAC0 is connected to the PHY1 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(1);
+	ath79_eth0_pll_data.pll_1000 = 0x82000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to MDIO1 in SGMII mode */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth1_data.phy_mask = BIT(2);
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_eth1_pll_data.pll_100 = 0x80000101;
+	ath79_eth1_pll_data.pll_10 = 0x80001313;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P_AC, "OM5P-AC", "OpenMesh OM5P AC", om5p_ac_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pacv2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pacv2.c
new file mode 100644
index 0000000000..6dba514be5
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-om5pacv2.c
@@ -0,0 +1,223 @@
+/*
+ *  OpenMesh OM5P-ACv2 support
+ *
+ *  Copyright (C) 2013 Marek Lindner <marek@open-mesh.com>
+ *  Copyright (C) 2014-2016 Sven Eckelmann <sven@open-mesh.com>
+ *  Copyright (C) 2015 Open-Mesh - Jim Collar <jim.collar@eqware.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0)
+#include <linux/mdio-gpio.h>
+#else
+#include <linux/platform_data/mdio-gpio.h> 
+#endif
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define OM5PACV2_GPIO_LED_POWER	14
+#define OM5PACV2_GPIO_LED_GREEN	13
+#define OM5PACV2_GPIO_LED_RED	23
+#define OM5PACV2_GPIO_LED_YELLOW	15
+#define OM5PACV2_GPIO_BTN_RESET	1
+#define OM5PACV2_GPIO_I2C_SCL	18
+#define OM5PACV2_GPIO_I2C_SDA	19
+#define OM5PACV2_GPIO_PA_DCDC	2
+#define OM5PACV2_GPIO_PA_HIGH	16
+
+#define OM5PACV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define OM5PACV2_KEYS_DEBOUNCE_INTERVAL	(3 * OM5PACV2_KEYS_POLL_INTERVAL)
+
+#define OM5PACV2_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led om5pacv2_leds_gpio[] __initdata = {
+	{
+		.name		= "om5pac:blue:power",
+		.gpio		= OM5PACV2_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:red:wifi",
+		.gpio		= OM5PACV2_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:yellow:wifi",
+		.gpio		= OM5PACV2_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om5pac:green:wifi",
+		.gpio		= OM5PACV2_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om5pacv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM5PACV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM5PACV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data om5pacv2_i2c_device_platdata = {
+	.sda_pin		= OM5PACV2_GPIO_I2C_SDA,
+	.scl_pin		= OM5PACV2_GPIO_I2C_SCL,
+	.udelay			= 10,
+	.sda_is_open_drain	= 1,
+	.scl_is_open_drain	= 1,
+};
+
+static struct platform_device om5pacv2_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &om5pacv2_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info om5pacv2_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("tmp423", 0x4e),
+	},
+};
+
+static struct flash_platform_data om5pacv2_flash_data = {
+	.type = "mx25l12805d",
+};
+
+static struct at803x_platform_data om5pacv2_an_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct at803x_platform_data om5pacv2_an_at8031_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info om5pacv2_an_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "ag71xx-mdio",
+		.mdio_addr = 4,
+		.platform_data = &om5pacv2_an_at803x_data,
+	},
+	{
+		.bus_id = "ag71xx-mdio.1",
+		.modalias = "ag71xx-mdio",
+		.mdio_addr = 1,
+		.platform_data = &om5pacv2_an_at8031_data,
+	},
+};
+
+static void __init om5p_acv2_setup_qca955x_eth_cfg(u32 mask,
+						   unsigned int rxd,
+						   unsigned int rxdv,
+						   unsigned int txd,
+						   unsigned int txe)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = mask;
+	t |= rxd << QCA955X_ETH_CFG_RXD_DELAY_SHIFT;
+	t |= rxdv << QCA955X_ETH_CFG_RDV_DELAY_SHIFT;
+	t |= txd << QCA955X_ETH_CFG_TXD_DELAY_SHIFT;
+	t |= txe << QCA955X_ETH_CFG_TXE_DELAY_SHIFT;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static void __init om5p_acv2_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* power amplifier high power, 4.2V at RFFM4203/4503 instead of 3.3 */
+	ath79_gpio_function_enable(QCA955X_GPIO_FUNC_JTAG_DISABLE);
+	ath79_gpio_output_select(OM5PACV2_GPIO_PA_DCDC, QCA955X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM5PACV2_GPIO_PA_HIGH, QCA955X_GPIO_OUT_GPIO);
+	gpio_request_one(OM5PACV2_GPIO_PA_DCDC, GPIOF_OUT_INIT_HIGH,
+			 "PA DC/DC");
+	gpio_request_one(OM5PACV2_GPIO_PA_HIGH, GPIOF_OUT_INIT_HIGH, "PA HIGH");
+
+	/* temperature sensor */
+	platform_device_register(&om5pacv2_i2c_device);
+	i2c_register_board_info(0, om5pacv2_i2c_devs,
+				ARRAY_SIZE(om5pacv2_i2c_devs));
+
+	ath79_register_m25p80(&om5pacv2_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5pacv2_leds_gpio),
+				 om5pacv2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM5PACV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om5pacv2_gpio_keys),
+					om5pacv2_gpio_keys);
+
+	ath79_init_mac(mac, art, 0x02);
+	ath79_register_wmac(art + OM5PACV2_WMAC_CALDATA_OFFSET, mac);
+
+	om5p_acv2_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN, 2, 2, 0, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	mdiobus_register_board_info(om5pacv2_an_mdio0_info,
+				    ARRAY_SIZE(om5pacv2_an_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0x00);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0x01);
+
+	/* GMAC0 is connected to the PHY4 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_1000 = 0x82000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to MDIO1 in SGMII mode */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth1_data.phy_mask = BIT(1);
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_eth1_pll_data.pll_100 = 0x80000101;
+	ath79_eth1_pll_data.pll_10 = 0x80001313;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P_ACv2, "OM5P-ACv2", "OpenMesh OM5P ACv2", om5p_acv2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-omy-g1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-omy-g1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-omy-g1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-omy-g1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-omy-x1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-omy-x1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-omy-x1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-omy-x1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-onion-omega.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-onion-omega.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-onion-omega.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-onion-omega.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-pb42.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-pb42.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-pb42.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-pb42.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-pqi-air-pen.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-pqi-air-pen.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-pqi-air-pen.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-pqi-air-pen.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-qihoo-c301.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-qihoo-c301.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-qihoo-c301.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-qihoo-c301.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-r36a.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r36a.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-r36a.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r36a.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-r602n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r602n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-r602n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r602n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-r6100.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r6100.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-r6100.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-r6100.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rambutan.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rambutan.c
new file mode 100644
index 0000000000..8cf8dab4db
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rambutan.c
@@ -0,0 +1,92 @@
+/*
+ *  8devices Rambutan board support
+ *
+ *  Copyright (C) 2017 Mantas Pucka <mantas@8devices.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/platform/ar934x_nfc.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+static struct at803x_platform_data rambutan_ar8032_data = {
+	.has_reset_gpio = 1,
+	.reset_gpio = 17,
+};
+
+static struct mdio_board_info rambutan_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rambutan_1",
+		.mdio_addr = 0,
+		.platform_data = &rambutan_ar8032_data,
+	},
+};
+
+static struct at803x_platform_data rambutan_ar8033_data = {
+	.has_reset_gpio = 1,
+	.reset_gpio = 23,
+};
+
+static struct mdio_board_info rambutan_mdio1_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.1",
+		.modalias = "rambutan_2",
+		.mdio_addr = 0,
+		.platform_data = &rambutan_ar8033_data,
+	},
+};
+
+static void __init rambutan_setup(void)
+{
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+	ath79_register_usb();
+	ath79_register_pci();
+	ath79_register_wmac_simple();
+
+	mdiobus_register_board_info(rambutan_mdio0_info,
+				    ARRAY_SIZE(rambutan_mdio0_info));
+	mdiobus_register_board_info(rambutan_mdio1_info,
+				    ARRAY_SIZE(rambutan_mdio1_info));
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth1_pll_data.pll_1000 = 0x17000000;
+	ath79_eth1_pll_data.pll_10 = 0x1313;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_RAMBUTAN, "RAMBUTAN", "8devices Rambutan board",
+	     rambutan_setup);
+
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb2011.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb2011.c
new file mode 100644
index 0000000000..230d0e0911
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb2011.c
@@ -0,0 +1,398 @@
+/*
+ *  MikroTik RouterBOARD 2011 support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb2011: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/version.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "routerboot.h"
+
+#define RB2011_GPIO_NAND_NCE	14
+#define RB2011_GPIO_SFP_LOS	21
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+#define RB_ART_SIZE		0x10000
+
+#define RB2011_FLAG_SFP		BIT(0)
+#define RB2011_FLAG_USB		BIT(1)
+#define RB2011_FLAG_WLAN	BIT(2)
+
+static struct mtd_partition rb2011_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static void __init rb2011_init_partitions(const struct rb_info *info)
+{
+	rb2011_spi_partitions[0].size = info->hard_cfg_offs;
+	rb2011_spi_partitions[1].offset = info->hard_cfg_offs;
+	rb2011_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+static struct mtd_partition rb2011_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data rb2011_spi_flash_data = {
+	.parts		= rb2011_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb2011_spi_partitions),
+};
+
+static struct ar8327_pad_cfg rb2011_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL3,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_pad_cfg rb2011_ar8327_pad6_cfg;
+static struct ar8327_sgmii_cfg rb2011_ar8327_sgmii_cfg;
+
+static struct ar8327_led_cfg rb2011_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc731c731,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static const struct ar8327_led_info rb2011_ar8327_leds[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "rb:green:eth1"),
+	AR8327_LED_INFO(PHY1_0, HW, "rb:green:eth2"),
+	AR8327_LED_INFO(PHY2_0, HW, "rb:green:eth3"),
+	AR8327_LED_INFO(PHY3_0, HW, "rb:green:eth4"),
+	AR8327_LED_INFO(PHY4_0, HW, "rb:green:eth5"),
+	AR8327_LED_INFO(PHY0_1, SW, "rb:green:eth6"),
+	AR8327_LED_INFO(PHY1_1, SW, "rb:green:eth7"),
+	AR8327_LED_INFO(PHY2_1, SW, "rb:green:eth8"),
+	AR8327_LED_INFO(PHY3_1, SW, "rb:green:eth9"),
+	AR8327_LED_INFO(PHY4_1, SW, "rb:green:eth10"),
+	AR8327_LED_INFO(PHY4_2, SW, "rb:green:usr"),
+};
+
+static struct ar8327_platform_data rb2011_ar8327_data = {
+	.pad0_cfg = &rb2011_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &rb2011_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(rb2011_ar8327_leds),
+	.leds = rb2011_ar8327_leds,
+};
+
+static struct mdio_board_info rb2011_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rb2011",
+		.mdio_addr = 0,
+		.platform_data = &rb2011_ar8327_data,
+	},
+};
+
+static void __init rb2011_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 11);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rb2011_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB2011_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB2011_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout rb2011_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb2011_ooblayout_ecc(struct mtd_info *mtd, int section,
+				struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb2011_ooblayout_free(struct mtd_info *mtd, int section,
+				 struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb2011_nand_ecclayout_ops = {
+	.ecc = rb2011_ooblayout_ecc,
+	.free = rb2011_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int rb2011_nand_scan_fixup(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct nand_chip *chip = mtd->priv;
+#endif
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		chip->ecc.layout = &rb2011_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb2011_nand_ecclayout_ops);
+#endif
+	}
+
+	return 0;
+}
+
+static void __init rb2011_nand_init(void)
+{
+	gpio_request_one(RB2011_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb2011_nand_scan_fixup);
+	ath79_nfc_set_parts(rb2011_nand_partitions,
+			    ARRAY_SIZE(rb2011_nand_partitions));
+	ath79_nfc_set_select_chip(rb2011_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static int rb2011_get_port_link(unsigned port)
+{
+	if (port != 6)
+		return -EINVAL;
+
+	/* The Loss of signal line is active low */
+	return !gpio_get_value(RB2011_GPIO_SFP_LOS);
+}
+
+static void __init rb2011_sfp_init(void)
+{
+	gpio_request_one(RB2011_GPIO_SFP_LOS, GPIOF_IN, "SFP LOS");
+
+	rb2011_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+
+	rb2011_ar8327_data.pad6_cfg = &rb2011_ar8327_pad6_cfg;
+
+	rb2011_ar8327_sgmii_cfg.sgmii_ctrl = 0xc70167d0;
+	rb2011_ar8327_sgmii_cfg.serdes_aen = true;
+
+	rb2011_ar8327_data.sgmii_cfg = &rb2011_ar8327_sgmii_cfg;
+
+	rb2011_ar8327_data.port6_cfg.force_link = 1;
+	rb2011_ar8327_data.port6_cfg.speed = AR8327_PORT_SPEED_1000;
+	rb2011_ar8327_data.port6_cfg.duplex = 1;
+
+	rb2011_ar8327_data.get_port_link = rb2011_get_port_link;
+}
+
+static int __init rb2011_setup(u32 flags)
+{
+	const struct rb_info *info;
+	char buf[64];
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return -ENODEV;
+
+	scnprintf(buf, sizeof(buf), "Mikrotik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb2011_init_partitions(info);
+
+	ath79_register_m25p80(&rb2011_spi_flash_data);
+	rb2011_nand_init();
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb2011_mdio0_info,
+				    ARRAY_SIZE(rb2011_mdio0_info));
+
+	/* GMAC0 is connected to an ar8327 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x6f000000;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 5);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	if (flags & RB2011_FLAG_SFP)
+		rb2011_sfp_init();
+
+	if (flags & RB2011_FLAG_WLAN)
+		rb2011_wlan_init();
+
+	if (flags & RB2011_FLAG_USB)
+		ath79_register_usb();
+
+	return 0;
+}
+
+static void __init rb2011l_setup(void)
+{
+	rb2011_setup(0);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011L, "2011L", rb2011l_setup);
+
+static void __init rb2011us_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP | RB2011_FLAG_USB);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011US, "2011US", rb2011us_setup);
+
+static void __init rb2011r5_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP | RB2011_FLAG_USB | RB2011_FLAG_WLAN);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011R5, "2011r5", rb2011r5_setup);
+
+static void __init rb2011g_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP |
+		     RB2011_FLAG_USB |
+		     RB2011_FLAG_WLAN);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011G, "2011G", rb2011g_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb4xx.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb4xx.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb4xx.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb4xx.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb750.c
new file mode 100644
index 0000000000..f552e63afd
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb750.c
@@ -0,0 +1,350 @@
+/*
+ *  MikroTik RouterBOARD 750/750GL support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+#include <linux/ar8216_platform.h>
+#include <linux/rle.h>
+#include <linux/routerboot.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/mach-rb750.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-usb.h"
+#include "dev-eth.h"
+#include "machtypes.h"
+#include "routerboot.h"
+
+static struct rb750_led_data rb750_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB750_LED_ACT,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port1",
+		.mask		= RB750_LED_PORT5,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port2",
+		.mask		= RB750_LED_PORT4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port3",
+		.mask		= RB750_LED_PORT3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port4",
+		.mask		= RB750_LED_PORT2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port5",
+		.mask		= RB750_LED_PORT1,
+		.active_low	= 1,
+	}
+};
+
+static struct rb750_led_data rb750gr3_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB7XX_LED_ACT,
+		.active_low	= 1,
+	},
+};
+
+static struct rb750_led_platform_data rb750_leds_data;
+static struct platform_device rb750_leds_device = {
+	.name	= "leds-rb750",
+	.dev	= {
+		.platform_data = &rb750_leds_data,
+	}
+};
+
+static struct rb7xx_nand_platform_data rb750_nand_data;
+static struct platform_device rb750_nand_device = {
+	.name	= "rb750-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb750_nand_data,
+	}
+};
+
+static void rb750_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB750_LED_BITS | RB750_LVC573_LE;
+	static u32 latch_oe;
+	static u32 latch_clr;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if ((mask_clr & BIT(31)) != 0 &&
+	    (latch_set & RB750_LVC573_LE) == 0) {
+		goto unlock;
+	}
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	if (latch_oe == 0)
+		latch_oe = __raw_readl(ath79_gpio_base + AR71XX_GPIO_REG_OE);
+
+	if (likely(latch_set & RB750_LVC573_LE)) {
+		void __iomem *base = ath79_gpio_base;
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= mask_clr | latch_oe | mask_set;
+
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+		__raw_writel(latch_clr, base + AR71XX_GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + AR71XX_GPIO_REG_SET);
+	} else if (mask_clr & RB750_LVC573_LE) {
+		void __iomem *base = ath79_gpio_base;
+
+		latch_oe = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+	}
+
+unlock:
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void rb750_nand_enable_pins(void)
+{
+	rb750_latch_change(RB750_LVC573_LE, 0);
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN);
+}
+
+static void rb750_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+	rb750_latch_change(0, RB750_LVC573_LE);
+}
+
+static void __init rb750_setup(void)
+{
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750_leds);
+	rb750_leds_data.leds = rb750_leds;
+	rb750_leds_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB750_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_nand_device);
+
+	/* USB */
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750, "750i", "MikroTik RouterBOARD 750",
+	     rb750_setup);
+
+static struct ar8327_pad_cfg rb750gr3_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data rb750gr3_ar8327_data = {
+	.pad0_cfg = &rb750gr3_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info rb750g3_mdio_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rb750g3",
+		.mdio_addr = 0,
+		.platform_data = &rb750gr3_ar8327_data,
+	},
+};
+
+static void rb750gr3_nand_enable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2);
+}
+
+static void rb750gr3_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+}
+
+static void rb750gr3_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB7XX_LED_ACT;
+	static u32 latch_clr;
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	mask_set = latch_set & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+	mask_clr = latch_clr & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+
+	if ((latch_set ^ RB7XX_LED_ACT) & RB7XX_LED_ACT) {
+		/* enable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+
+		mask_clr |= RB7XX_LED_ACT;
+	} else {
+		/* disable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t &= ~RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+	}
+
+	__raw_writel(mask_set, base + AR71XX_GPIO_REG_SET);
+	__raw_writel(mask_clr, base + AR71XX_GPIO_REG_CLEAR);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void __init rb750gr3_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(rb750g3_mdio_info,
+				    ARRAY_SIZE(rb750g3_mdio_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_pll_data.pll_1000 = 0x62000000;
+
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750gr3_leds);
+	rb750_leds_data.leds = rb750gr3_leds;
+	rb750_leds_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB7XX_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750gr3_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750gr3_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750G_R3, "750Gr3", "MikroTik RouterBOARD 750GL",
+	     rb750gr3_setup);
+
+#define RB751_HARDCONFIG	0x1f00b000
+#define RB751_HARDCONFIG_SIZE	0x1000
+
+static void __init rb751_wlan_setup(void)
+{
+	u8 *hardconfig = (u8 *) KSEG1ADDR(RB751_HARDCONFIG);
+	struct ath9k_platform_data *wmac_data;
+	u16 tag_len;
+	u8 *tag;
+	u16 mac_len;
+	u8 *mac;
+	int err;
+
+	wmac_data = ap9x_pci_get_wmac_data(0);
+	if (!wmac_data) {
+		pr_err("rb75x: unable to get address of wlan data\n");
+		return;
+	}
+
+	ap9x_pci_setup_wmac_led_pin(0, 9);
+
+	err = routerboot_find_tag(hardconfig, RB751_HARDCONFIG_SIZE,
+				  RB_ID_WLAN_DATA, &tag, &tag_len);
+	if (err) {
+		pr_err("rb75x: no calibration data found\n");
+		return;
+	}
+
+	err = rle_decode(tag, tag_len, (unsigned char *) wmac_data->eeprom_data,
+			 sizeof(wmac_data->eeprom_data), NULL, NULL);
+	if (err) {
+		pr_err("rb75x: unable to decode wlan eeprom data\n");
+		return;
+	}
+
+	err = routerboot_find_tag(hardconfig, RB751_HARDCONFIG_SIZE,
+                                 RB_ID_MAC_ADDRESS_PACK, &mac, &mac_len);
+	if (err) {
+		pr_err("rb75x: no mac address found\n");
+		return;
+	}
+
+	ap91_pci_init(NULL, mac);
+}
+
+static void __init rb751_setup(void)
+{
+	rb750_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751, "751", "MikroTik RouterBOARD 751",
+	     rb751_setup);
+
+static void __init rb751g_setup(void)
+{
+	rb750gr3_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751G, "751g", "MikroTik RouterBOARD 751G",
+	     rb751g_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb91x.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb91x.c
new file mode 100644
index 0000000000..2dacc09869
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb91x.c
@@ -0,0 +1,344 @@
+/*
+ *  MikroTik RouterBOARD 91X support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb91x: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/74x164.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/gpio-latch.h>
+#include <linux/platform_data/rb91x_nand.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ath79_spi_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "routerboot.h"
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+#define RB91X_FLAG_USB		BIT(0)
+#define RB91X_FLAG_PCIE		BIT(1)
+
+#define RB91X_LATCH_GPIO_BASE	32
+#define RB91X_LATCH_GPIO(_x)	(RB91X_LATCH_GPIO_BASE + (_x))
+
+#define RB91X_SSR_GPIO_BASE	(RB91X_LATCH_GPIO_BASE + AR934X_GPIO_COUNT)
+#define RB91X_SSR_GPIO(_x)	(RB91X_SSR_GPIO_BASE + (_x))
+
+#define RB91X_SSR_BIT_LED1		0
+#define RB91X_SSR_BIT_LED2		1
+#define RB91X_SSR_BIT_LED3		2
+#define RB91X_SSR_BIT_LED4		3
+#define RB91X_SSR_BIT_LED5		4
+#define RB91X_SSR_BIT_5			5
+#define RB91X_SSR_BIT_USB_POWER		6
+#define RB91X_SSR_BIT_PCIE_POWER	7
+
+#define RB91X_GPIO_SSR_STROBE	RB91X_LATCH_GPIO(0)
+#define RB91X_GPIO_LED_POWER	RB91X_LATCH_GPIO(1)
+#define RB91X_GPIO_LED_USER	RB91X_LATCH_GPIO(2)
+#define RB91X_GPIO_NAND_READ	RB91X_LATCH_GPIO(3)
+#define RB91X_GPIO_NAND_RDY	RB91X_LATCH_GPIO(4)
+#define RB91X_GPIO_NLE		RB91X_LATCH_GPIO(11)
+#define RB91X_GPIO_NAND_NRW	RB91X_LATCH_GPIO(12)
+#define RB91X_GPIO_NAND_NCE	RB91X_LATCH_GPIO(13)
+#define RB91X_GPIO_NAND_CLE	RB91X_LATCH_GPIO(14)
+#define RB91X_GPIO_NAND_ALE	RB91X_LATCH_GPIO(15)
+
+#define RB91X_GPIO_LED_1	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED1)
+#define RB91X_GPIO_LED_2	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED2)
+#define RB91X_GPIO_LED_3	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED3)
+#define RB91X_GPIO_LED_4	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED4)
+#define RB91X_GPIO_LED_5	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED5)
+#define RB91X_GPIO_USB_POWER	RB91X_SSR_GPIO(RB91X_SSR_BIT_USB_POWER)
+#define RB91X_GPIO_PCIE_POWER	RB91X_SSR_GPIO(RB91X_SSR_BIT_PCIE_POWER)
+
+struct rb_board_info {
+	const char *name;
+	u32 flags;
+};
+
+static struct mtd_partition rb711gr100_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static struct flash_platform_data rb711gr100_spi_flash_data = {
+	.parts		= rb711gr100_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb711gr100_spi_partitions),
+};
+
+static int rb711gr100_gpio_latch_gpios[AR934X_GPIO_COUNT] __initdata = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
+	12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
+};
+
+static struct gpio_latch_platform_data rb711gr100_gpio_latch_data __initdata = {
+	.base = RB91X_LATCH_GPIO_BASE,
+	.num_gpios = ARRAY_SIZE(rb711gr100_gpio_latch_gpios),
+	.gpios = rb711gr100_gpio_latch_gpios,
+	.le_gpio_index = 11,
+	.le_active_low = true,
+};
+
+static struct rb91x_nand_platform_data rb711gr100_nand_data __initdata = {
+	.gpio_nce = RB91X_GPIO_NAND_NCE,
+	.gpio_ale = RB91X_GPIO_NAND_ALE,
+	.gpio_cle = RB91X_GPIO_NAND_CLE,
+	.gpio_rdy = RB91X_GPIO_NAND_RDY,
+	.gpio_read = RB91X_GPIO_NAND_READ,
+	.gpio_nrw = RB91X_GPIO_NAND_NRW,
+	.gpio_nle = RB91X_GPIO_NLE,
+};
+
+static u8 rb711gr100_ssr_initdata[] = {
+	BIT(RB91X_SSR_BIT_PCIE_POWER) |
+	BIT(RB91X_SSR_BIT_USB_POWER) |
+	BIT(RB91X_SSR_BIT_5)
+};
+
+static struct gen_74x164_chip_platform_data rb711gr100_ssr_data = {
+	.base = RB91X_SSR_GPIO_BASE,
+	.num_registers = ARRAY_SIZE(rb711gr100_ssr_initdata),
+	.init_data = rb711gr100_ssr_initdata,
+};
+
+static struct spi_board_info rb711gr100_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data  = &rb711gr100_spi_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 10000000,
+		.modalias	= "74x164",
+		.platform_data	= &rb711gr100_ssr_data,
+	}
+};
+
+static int rb711gr100_spi_cs_gpios[2] = {
+	-ENOENT,
+	RB91X_GPIO_SSR_STROBE,
+};
+
+static struct ath79_spi_platform_data rb711gr100_spi_data __initdata = {
+	.bus_num = 0,
+	.num_chipselect = 2,
+	.cs_gpios = rb711gr100_spi_cs_gpios,
+};
+
+static struct gpio_led rb711gr100_leds[] __initdata = {
+	{
+		.name		= "rb:green:led1",
+		.gpio		= RB91X_GPIO_LED_1,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led2",
+		.gpio		= RB91X_GPIO_LED_2,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led3",
+		.gpio		= RB91X_GPIO_LED_3,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led4",
+		.gpio		= RB91X_GPIO_LED_4,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led5",
+		.gpio		= RB91X_GPIO_LED_5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:user",
+		.gpio		= RB91X_GPIO_LED_USER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:power",
+		.gpio		= RB91X_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_state	= LEDS_GPIO_DEFSTATE_KEEP,
+	},
+};
+
+static struct at803x_platform_data rb91x_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info rb91x_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rb91x",
+		.mdio_addr = 0,
+		.platform_data = &rb91x_at803x_data,
+	},
+};
+
+static void __init rb711gr100_init_partitions(const struct rb_info *info)
+{
+	rb711gr100_spi_partitions[0].size = info->hard_cfg_offs;
+	rb711gr100_spi_partitions[1].offset = info->hard_cfg_offs;
+
+	rb711gr100_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+void __init rb711gr100_wlan_init(void)
+{
+	char *caldata;
+	u8 wlan_mac[ETH_ALEN];
+
+	caldata = rb_get_wlan_data();
+	if (caldata == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 1);
+	ath79_register_wmac(caldata + 0x1000, wlan_mac);
+
+	kfree(caldata);
+}
+
+#define RB_BOARD_INFO(_name, _flags)	\
+	{				\
+		.name = (_name),	\
+		.flags = (_flags),	\
+	}
+
+static const struct rb_board_info rb711gr100_boards[] __initconst = {
+	RB_BOARD_INFO("911G-2HPnD", 0),
+	RB_BOARD_INFO("911G-5HPnD", 0),
+	RB_BOARD_INFO("912UAG-2HPnD", RB91X_FLAG_USB | RB91X_FLAG_PCIE),
+	RB_BOARD_INFO("912UAG-5HPnD", RB91X_FLAG_USB | RB91X_FLAG_PCIE),
+};
+
+static u32 rb711gr100_get_flags(const struct rb_info *info)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rb711gr100_boards); i++) {
+		const struct rb_board_info *bi;
+
+		bi = &rb711gr100_boards[i];
+		if (strcmp(info->board_name, bi->name) == 0)
+			return bi->flags;
+	}
+
+	return 0;
+}
+
+static void __init rb711gr100_setup(void)
+{
+	const struct rb_info *info;
+	char buf[64];
+	u32 flags;
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return;
+
+	scnprintf(buf, sizeof(buf), "Mikrotik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb711gr100_init_partitions(info);
+	ath79_register_spi(&rb711gr100_spi_data, rb711gr100_spi_info,
+			   ARRAY_SIZE(rb711gr100_spi_info));
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb91x_mdio0_info,
+				    ARRAY_SIZE(rb91x_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+
+	ath79_register_eth(0);
+
+	rb711gr100_wlan_init();
+
+	platform_device_register_data(NULL, "rb91x-nand", -1,
+				      &rb711gr100_nand_data,
+				      sizeof(rb711gr100_nand_data));
+
+	platform_device_register_data(NULL, "gpio-latch", -1,
+				      &rb711gr100_gpio_latch_data,
+				      sizeof(rb711gr100_gpio_latch_data));
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb711gr100_leds),
+				 rb711gr100_leds);
+
+	flags = rb711gr100_get_flags(info);
+
+	if (flags & RB91X_FLAG_USB)
+		ath79_register_usb();
+
+	if (flags & RB91X_FLAG_PCIE)
+		ath79_register_pci();
+
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_711GR100, "711Gr100", rb711gr100_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb922.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb922.c
new file mode 100644
index 0000000000..c0e90d1ade
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb922.c
@@ -0,0 +1,306 @@
+/*
+ *  MikroTik RouterBOARD 91X support
+ *
+ *  Copyright (C) 2015 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/version.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "routerboot.h"
+
+#define RB922_GPIO_LED_USR	12
+#define RB922_GPIO_USB_POWER	13
+#define RB922_GPIO_FAN_CTRL	14
+#define RB922_GPIO_BTN_RESET	20
+#define RB922_GPIO_NAND_NCE	23
+
+#define RB922_PHY_ADDR		4
+
+#define RB922_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB922_KEYS_DEBOUNCE_INTERVAL	(3 * RB922_KEYS_POLL_INTERVAL)
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+static struct mtd_partition rb922gs_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static struct flash_platform_data rb922gs_spi_flash_data = {
+	.parts		= rb922gs_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb922gs_spi_partitions),
+};
+
+static struct gpio_led rb922gs_leds[] __initdata = {
+	{
+		.name		= "rb:green:user",
+		.gpio		= RB922_GPIO_LED_USR,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button rb922gs_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB922_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB922_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data rb922gs_at803x_data = {
+	.disable_smarteee = 1,
+};
+
+static struct mdio_board_info rb922gs_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rb922gs",
+		.mdio_addr = RB922_PHY_ADDR,
+		.platform_data = &rb922gs_at803x_data,
+	},
+};
+
+static void __init rb922gs_init_partitions(const struct rb_info *info)
+{
+	rb922gs_spi_partitions[0].size = info->hard_cfg_offs;
+	rb922gs_spi_partitions[1].offset = info->hard_cfg_offs;
+	rb922gs_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+static void rb922gs_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB922_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB922_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout rb922gs_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb922gs_ooblayout_ecc(struct mtd_info *mtd, int section,
+				 struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb922gs_ooblayout_free(struct mtd_info *mtd, int section,
+				  struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb922gs_nand_ecclayout_ops = {
+	.ecc = rb922gs_ooblayout_ecc,
+	.free = rb922gs_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int rb922gs_nand_scan_fixup(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct nand_chip *chip = mtd->priv;
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+#endif /* < 4.6.0 */
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		chip->ecc.layout = &rb922gs_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb922gs_nand_ecclayout_ops);
+#endif
+	}
+
+	chip->options = NAND_NO_SUBPAGE_WRITE;
+
+	return 0;
+}
+
+static struct mtd_partition rb922gs_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void __init rb922gs_nand_init(void)
+{
+	gpio_request_one(RB922_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb922gs_nand_scan_fixup);
+	ath79_nfc_set_parts(rb922gs_nand_partitions,
+			    ARRAY_SIZE(rb922gs_nand_partitions));
+	ath79_nfc_set_select_chip(rb922gs_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static void __init rb922gs_setup(void)
+{
+	const struct rb_info *info;
+	char buf[64];
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return;
+
+	scnprintf(buf, sizeof(buf), "MikroTik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb922gs_init_partitions(info);
+	ath79_register_m25p80(&rb922gs_spi_flash_data);
+
+	rb922gs_nand_init();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb922gs_mdio0_info,
+				    ARRAY_SIZE(rb922gs_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(RB922_PHY_ADDR);
+	if (strcmp(info->board_name, "921GS-5HPacD r2") == 0) {
+		ath79_eth0_pll_data.pll_10 = 0xa0001313;
+		ath79_eth0_pll_data.pll_100 = 0xa0000101;
+		ath79_eth0_pll_data.pll_1000 = 0x8f000000;
+	}
+	else {
+		ath79_eth0_pll_data.pll_10 = 0x81001313;
+		ath79_eth0_pll_data.pll_100 = 0x81000101;
+		ath79_eth0_pll_data.pll_1000 = 0x8f000000;
+	}
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb922gs_leds), rb922gs_leds);
+	ath79_register_gpio_keys_polled(-1, RB922_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rb922gs_gpio_keys),
+					rb922gs_gpio_keys);
+
+	/* NOTE:
+	 * This only supports the RB911G-5HPacD board for now. For other boards
+	 * more devices must be registered based on the hardware options which
+	 * can be found in the hardware configuration of RouterBOOT.
+	 */
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_922GS, "922gs", rb922gs_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb95x.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb95x.c
new file mode 100644
index 0000000000..308de29ebc
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rb95x.c
@@ -0,0 +1,321 @@
+/*
+ *  MikroTik RouterBOARD 95X support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Kamil Trzcinski <ayufan@ayufan.eu>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb95x: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "routerboot.h"
+#include "dev-leds-gpio.h"
+
+#define RB95X_GPIO_NAND_NCE	14
+
+static struct mtd_partition rb95x_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct gpio_led rb951ui_leds_gpio[] __initdata = {
+	{
+		.name		= "rb:green:wlan",
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:act",
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port1",
+		.gpio		= 13,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port2",
+		.gpio		= 12,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port3",
+		.gpio		= 4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port4",
+		.gpio		= 21,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port5",
+		.gpio		= 16,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg rb95x_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data rb95x_ar8327_data = {
+	.pad0_cfg = &rb95x_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info rb95x_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "rb95x",
+		.mdio_addr = 0,
+		.platform_data = &rb95x_ar8327_data,
+	},
+};
+
+void __init rb95x_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 11);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rb95x_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB95X_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB95X_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout rb95x_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb95x_ooblayout_ecc(struct mtd_info *mtd, int section,
+			       struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb95x_ooblayout_free(struct mtd_info *mtd, int section,
+				struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb95x_nand_ecclayout_ops = {
+	.ecc = rb95x_ooblayout_ecc,
+	.free = rb95x_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int rb95x_nand_scan_fixup(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct nand_chip *chip = mtd->priv;
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+#endif /* < 4.6.0 */
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		chip->ecc.layout = &rb95x_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb95x_nand_ecclayout_ops);
+#endif
+	}
+
+	chip->options = NAND_NO_SUBPAGE_WRITE;
+
+	return 0;
+}
+
+void __init rb95x_nand_init(void)
+{
+	gpio_request_one(RB95X_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb95x_nand_scan_fixup);
+	ath79_nfc_set_parts(rb95x_nand_partitions,
+			    ARRAY_SIZE(rb95x_nand_partitions));
+	ath79_nfc_set_select_chip(rb95x_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static int __init rb95x_setup(void)
+{
+	const struct rb_info *info;
+
+	info = rb_init_info((void *)(KSEG1ADDR(AR71XX_SPI_BASE)), 0x10000);
+	if (!info)
+		return -EINVAL;
+
+	rb95x_nand_init();
+
+	return 0;
+}
+
+static void __init rb951g_setup(void)
+{
+	if (rb95x_setup())
+		return;
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb95x_mdio0_info,
+				    ARRAY_SIZE(rb95x_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	rb95x_wlan_init();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_951G, "951G", "MikroTik RouterBOARD 951G-2HnD",
+	     rb951g_setup);
+
+static void __init rb951ui_setup(void)
+{
+	if (rb95x_setup())
+		return;
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	gpio_request_one(20, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	gpio_request_one(2, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "POE power");
+
+	rb95x_wlan_init();
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb951ui_leds_gpio),
+				 rb951ui_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_951U, "951HnD", "MikroTik RouterBOARD 951Ui-2HnD",
+	     rb951ui_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbspi.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbspi.c
new file mode 100644
index 0000000000..ff5cf95037
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbspi.c
@@ -0,0 +1,1125 @@
+/*
+ *  MikroTik SPI-NOR RouterBOARDs support
+ *
+ *  - MikroTik RouterBOARD mAP 2nD
+ *  - MikroTik RouterBOARD mAP L-2nD
+ *  - MikroTik RouterBOARD 911-2Hn (911 Lite2)
+ *  - MikroTik RouterBOARD 911-5Hn (911 Lite5)
+ *  - MikroTik RouterBOARD 941L-2nD
+ *  - MikroTik RouterBOARD 951Ui-2nD
+ *  - MikroTik RouterBOARD 952Ui-5ac2nD
+ *  - MikroTik RouterBOARD 962UiGS-5HacT2HnT
+ *  - MikroTik RouterBOARD 750UP r2
+ *  - MikroTik RouterBOARD 750P-PBr2
+ *  - MikroTik RouterBOARD 750 r2
+ *  - MikroTik RouterBOARD LHG 5nD
+ *  - MikroTik RouterBOARD wAP2nD
+ *  - MikroTik RouterBOARD wAP G-5HacT2HnDwAP (wAP AC)
+ *
+ *  Preliminary support for the following hardware
+ *  - MikroTik RouterBOARD cAP2nD
+ *  Furthermore, the cAP lite (cAPL2nD) appears to feature the exact same
+ *  hardware as the mAP L-2nD. It is unknown if they share the same board
+ *  identifier.
+ *
+ *  Copyright (C) 2017 Thibaut VARENE <varenet@parisc-linux.org>
+ *  Copyright (C) 2016 David Hutchison <dhutchison@bluemesh.net>
+ *  Copyright (C) 2017 Ryan Mounce <ryan@mounce.com.au>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/74x164.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/platform_data/mdio-gpio.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-spi.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "routerboot.h"
+
+#define RBSPI_KEYS_POLL_INTERVAL 20 /* msecs */
+#define RBSPI_KEYS_DEBOUNCE_INTERVAL (3 * RBSPI_KEYS_POLL_INTERVAL)
+
+#define RBSPI_HAS_USB		BIT(0)
+#define RBSPI_HAS_WLAN0		BIT(1)
+#define RBSPI_HAS_WLAN1		BIT(2)
+#define RBSPI_HAS_WAN4		BIT(3)	/* has WAN port on PHY4 */
+#define RBSPI_HAS_SSR		BIT(4)	/* has an SSR on SPI bus 0 */
+#define RBSPI_HAS_POE		BIT(5)
+#define RBSPI_HAS_MDIO1		BIT(6)
+#define RBSPI_HAS_PCI		BIT(7)
+
+#define RB_ROUTERBOOT_OFFSET    0x0000
+#define RB_BIOS_SIZE            0x1000
+#define RB_SOFT_CFG_SIZE        0x1000
+
+/* Flash partitions indexes */
+enum {
+	RBSPI_PART_RBOOT,
+	RBSPI_PART_HCONF,
+	RBSPI_PART_BIOS,
+	RBSPI_PART_RBOOT2,
+	RBSPI_PART_SCONF,
+	RBSPI_PART_FIRMW,
+	RBSPI_PARTS
+};
+
+static struct mtd_partition rbspi_spi_partitions[RBSPI_PARTS];
+
+/*
+ * Setup the SPI flash partition table based on initial parsing.
+ * The kernel can be at any aligned position and have any size.
+ */
+static void __init rbspi_init_partitions(const struct rb_info *info)
+{
+	struct mtd_partition *parts = rbspi_spi_partitions;
+	memset(parts, 0x0, sizeof(*parts));
+
+	parts[RBSPI_PART_RBOOT].name = "routerboot";
+	parts[RBSPI_PART_RBOOT].offset = RB_ROUTERBOOT_OFFSET;
+	parts[RBSPI_PART_RBOOT].size = info->hard_cfg_offs;
+	parts[RBSPI_PART_RBOOT].mask_flags = MTD_WRITEABLE;
+
+	parts[RBSPI_PART_HCONF].name = "hard_config";
+	parts[RBSPI_PART_HCONF].offset = info->hard_cfg_offs;
+	parts[RBSPI_PART_HCONF].size = info->hard_cfg_size;
+	parts[RBSPI_PART_HCONF].mask_flags = MTD_WRITEABLE;
+
+	parts[RBSPI_PART_BIOS].name = "bios";
+	parts[RBSPI_PART_BIOS].offset = info->hard_cfg_offs
+					+ info->hard_cfg_size;
+	parts[RBSPI_PART_BIOS].size = RB_BIOS_SIZE;
+	parts[RBSPI_PART_BIOS].mask_flags = MTD_WRITEABLE;
+
+	parts[RBSPI_PART_RBOOT2].name = "routerboot2";
+	parts[RBSPI_PART_RBOOT2].offset = parts[RBSPI_PART_BIOS].offset
+					+ RB_BIOS_SIZE;
+	parts[RBSPI_PART_RBOOT2].size = info->soft_cfg_offs
+					- parts[RBSPI_PART_RBOOT2].offset;
+	parts[RBSPI_PART_RBOOT2].mask_flags = MTD_WRITEABLE;
+
+	parts[RBSPI_PART_SCONF].name = "soft_config";
+	parts[RBSPI_PART_SCONF].offset = info->soft_cfg_offs;
+	parts[RBSPI_PART_SCONF].size = RB_SOFT_CFG_SIZE;
+
+	parts[RBSPI_PART_FIRMW].name = "firmware";
+	parts[RBSPI_PART_FIRMW].offset = parts[RBSPI_PART_SCONF].offset
+					+ parts[RBSPI_PART_SCONF].size;
+	parts[RBSPI_PART_FIRMW].size = MTDPART_SIZ_FULL;
+}
+
+static struct flash_platform_data rbspi_spi_flash_data = {
+	.parts = rbspi_spi_partitions,
+	.nr_parts = ARRAY_SIZE(rbspi_spi_partitions),
+};
+
+/*
+ * Several boards only have a single reset button, use a common
+ * structure for that.
+ */
+static struct gpio_keys_button rbspi_gpio_keys_reset[] __initdata = {
+	{
+		.desc = "Reset button",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = RBSPI_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = -ENOENT, /* filled dynamically */
+		.active_low = 1,
+	},
+};
+
+/* RB mAP L-2nD gpios */
+#define RBMAPL_GPIO_LED_POWER	17
+#define RBMAPL_GPIO_LED_USER	14
+#define RBMAPL_GPIO_LED_ETH	4
+#define RBMAPL_GPIO_LED_WLAN	11
+#define RBMAPL_GPIO_BTN_RESET	16
+
+static struct gpio_led rbmapl_leds[] __initdata = {
+	{
+		.name = "rb:green:power",
+		.gpio = RBMAPL_GPIO_LED_POWER,
+		.active_low = 0,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	}, {
+		.name = "rb:green:user",
+		.gpio = RBMAPL_GPIO_LED_USER,
+		.active_low = 0,
+	}, {
+		.name = "rb:green:eth",
+		.gpio = RBMAPL_GPIO_LED_ETH,
+		.active_low = 0,
+	}, {
+		.name = "rb:green:wlan",
+		.gpio = RBMAPL_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+};
+
+/* RB 941L-2nD gpios */
+#define RBHAPL_GPIO_LED_USER   14
+#define RBHAPL_GPIO_BTN_RESET	16
+
+static struct gpio_led rbhapl_leds[] __initdata = {
+	{
+		.name = "rb:green:user",
+		.gpio = RBHAPL_GPIO_LED_USER,
+		.active_low = 1,
+	},
+};
+
+/* common RB SSRs */
+#define RBSPI_SSR_GPIO_BASE	40
+#define RBSPI_SSR_GPIO(bit)	(RBSPI_SSR_GPIO_BASE + (bit))
+
+/* RB 951Ui-2nD gpios */
+#define RB952_SSR_BIT_LED_LAN1	0
+#define RB952_SSR_BIT_LED_LAN2	1
+#define RB952_SSR_BIT_LED_LAN3	2
+#define RB952_SSR_BIT_LED_LAN4	3
+#define RB952_SSR_BIT_LED_LAN5	4
+#define RB952_SSR_BIT_USB_POWER	5
+#define RB952_SSR_BIT_LED_WLAN	6
+#define RB952_GPIO_SSR_CS	11
+#define RB952_GPIO_LED_USER	4
+#define RB952_GPIO_POE_POWER	14
+#define RB952_GPIO_POE_STATUS	12
+#define RB952_GPIO_BTN_RESET	16
+#define RB952_GPIO_USB_POWER	RBSPI_SSR_GPIO(RB952_SSR_BIT_USB_POWER)
+#define RB952_GPIO_LED_LAN1	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_LAN1)
+#define RB952_GPIO_LED_LAN2	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_LAN2)
+#define RB952_GPIO_LED_LAN3	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_LAN3)
+#define RB952_GPIO_LED_LAN4	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_LAN4)
+#define RB952_GPIO_LED_LAN5	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_LAN5)
+#define RB952_GPIO_LED_WLAN	RBSPI_SSR_GPIO(RB952_SSR_BIT_LED_WLAN)
+
+static struct gpio_led rb952_leds[] __initdata = {
+	{
+		.name = "rb:green:user",
+		.gpio = RB952_GPIO_LED_USER,
+		.active_low = 0,
+	}, {
+		.name = "rb:blue:wlan",
+		.gpio = RB952_GPIO_LED_WLAN,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:port1",
+		.gpio = RB952_GPIO_LED_LAN1,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:port2",
+		.gpio = RB952_GPIO_LED_LAN2,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:port3",
+		.gpio = RB952_GPIO_LED_LAN3,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:port4",
+		.gpio = RB952_GPIO_LED_LAN4,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:port5",
+		.gpio = RB952_GPIO_LED_LAN5,
+		.active_low = 1,
+	},
+};
+
+
+/* RB 962UiGS-5HacT2HnT gpios */
+#define RB962_GPIO_POE_STATUS	2
+#define RB962_GPIO_POE_POWER	3
+#define RB962_GPIO_LED_USER	12
+#define RB962_GPIO_USB_POWER	13
+#define RB962_GPIO_BTN_RESET	20
+
+static struct gpio_led rb962_leds_gpio[] __initdata = {
+	{
+		.name		= "rb:green:user",
+		.gpio		= RB962_GPIO_LED_USER,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info rb962_leds_ar8327[] = {
+		AR8327_LED_INFO(PHY0_0, HW, "rb:green:port1"),
+		AR8327_LED_INFO(PHY1_0, HW, "rb:green:port2"),
+		AR8327_LED_INFO(PHY2_0, HW, "rb:green:port3"),
+		AR8327_LED_INFO(PHY3_0, HW, "rb:green:port4"),
+		AR8327_LED_INFO(PHY4_0, HW, "rb:green:port5"),
+};
+
+static struct ar8327_pad_cfg rb962_ar8327_pad0_cfg = {
+		.mode = AR8327_PAD_MAC_RGMII,
+		.txclk_delay_en = true,
+		.rxclk_delay_en = true,
+		.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+		.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+		.mac06_exchange_dis = true,
+};
+
+static struct ar8327_pad_cfg rb962_ar8327_pad6_cfg = {
+		/* Use SGMII interface for GMAC6 of the AR8337 switch */
+		.mode = AR8327_PAD_MAC_SGMII,
+		.rxclk_delay_en = true,
+		.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_led_cfg rb962_ar8327_led_cfg = {
+		.led_ctrl0 = 0xc737c737,
+		.led_ctrl1 = 0x00000000,
+		.led_ctrl2 = 0x00000000,
+		.led_ctrl3 = 0x0030c300,
+		.open_drain = false,
+};
+
+static struct ar8327_platform_data rb962_ar8327_data = {
+		.pad0_cfg = &rb962_ar8327_pad0_cfg,
+		.pad6_cfg = &rb962_ar8327_pad6_cfg,
+		.port0_cfg = {
+				.force_link = 1,
+				.speed = AR8327_PORT_SPEED_1000,
+				.duplex = 1,
+				.txpause = 1,
+				.rxpause = 1,
+		},
+		.port6_cfg = {
+				.force_link = 1,
+				.speed = AR8327_PORT_SPEED_1000,
+				.duplex = 1,
+				.txpause = 1,
+				.rxpause = 1,
+		},
+		.led_cfg = &rb962_ar8327_led_cfg,
+		.num_leds = ARRAY_SIZE(rb962_leds_ar8327),
+		.leds = rb962_leds_ar8327,
+};
+
+static struct mdio_board_info rb962_mdio0_info[] = {
+		{
+				.bus_id = "ag71xx-mdio.0",
+				.modalias = "rb962",
+				.mdio_addr = 0,
+				.platform_data = &rb962_ar8327_data,
+		},
+};
+
+/* RB wAP-2nD gpios */
+#define RBWAP_GPIO_LED_USER	14
+#define RBWAP_GPIO_LED_WLAN	11
+#define RBWAP_GPIO_BTN_RESET	16
+
+static struct gpio_led rbwap_leds[] __initdata = {
+	{
+		.name = "rb:green:user",
+		.gpio = RBWAP_GPIO_LED_USER,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:wlan",
+		.gpio = RBWAP_GPIO_LED_WLAN,
+		.active_low = 1,
+	},
+};
+
+/* RB cAP-2nD gpios */
+#define RBCAP_GPIO_LED_1	14
+#define RBCAP_GPIO_LED_2	12
+#define RBCAP_GPIO_LED_3	11
+#define RBCAP_GPIO_LED_4	4
+#define RBCAP_GPIO_LED_ALL	13
+
+static struct gpio_led rbcap_leds[] __initdata = {
+	{
+		.name = "rb:green:rssi1",
+		.gpio = RBCAP_GPIO_LED_1,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi2",
+		.gpio = RBCAP_GPIO_LED_2,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi3",
+		.gpio = RBCAP_GPIO_LED_3,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi4",
+		.gpio = RBCAP_GPIO_LED_4,
+		.active_low = 1,
+	},
+};
+
+/* RB mAP-2nD gpios */
+#define RBMAP_SSR_BIT_LED_LAN1	0
+#define RBMAP_SSR_BIT_LED_LAN2	1
+#define RBMAP_SSR_BIT_LED_POEO	2
+#define RBMAP_SSR_BIT_LED_USER	3
+#define RBMAP_SSR_BIT_LED_WLAN	4
+#define RBMAP_SSR_BIT_USB_POWER	5
+#define RBMAP_SSR_BIT_LED_APCAP	6
+#define RBMAP_GPIO_BTN_RESET	16
+#define RBMAP_GPIO_SSR_CS	11
+#define RBMAP_GPIO_LED_POWER	4
+#define RBMAP_GPIO_POE_POWER	14
+#define RBMAP_GPIO_POE_STATUS	12
+#define RBMAP_GPIO_USB_POWER	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_USB_POWER)
+#define RBMAP_GPIO_LED_LAN1	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_LAN1)
+#define RBMAP_GPIO_LED_LAN2	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_LAN2)
+#define RBMAP_GPIO_LED_POEO	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_POEO)
+#define RBMAP_GPIO_LED_USER	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_USER)
+#define RBMAP_GPIO_LED_WLAN	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_WLAN)
+#define RBMAP_GPIO_LED_APCAP	RBSPI_SSR_GPIO(RBMAP_SSR_BIT_LED_APCAP)
+
+static struct gpio_led rbmap_leds[] __initdata = {
+	{
+		.name = "rb:green:power",
+		.gpio = RBMAP_GPIO_LED_POWER,
+		.active_low = 1,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	}, {
+		.name = "rb:green:eth1",
+		.gpio = RBMAP_GPIO_LED_LAN1,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:eth2",
+		.gpio = RBMAP_GPIO_LED_LAN2,
+		.active_low = 1,
+	}, {
+		.name = "rb:red:poe_out",
+		.gpio = RBMAP_GPIO_LED_POEO,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:user",
+		.gpio = RBMAP_GPIO_LED_USER,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:wlan",
+		.gpio = RBMAP_GPIO_LED_WLAN,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:ap_cap",
+		.gpio = RBMAP_GPIO_LED_APCAP,
+		.active_low = 1,
+	},
+};
+
+/* RB LHG 5nD gpios */
+#define RBLHG_GPIO_LED_0	13
+#define RBLHG_GPIO_LED_1	12
+#define RBLHG_GPIO_LED_2	4
+#define RBLHG_GPIO_LED_3	21
+#define RBLHG_GPIO_LED_4	18
+#define RBLHG_GPIO_LED_ETH	14
+#define RBLHG_GPIO_LED_POWER	11
+#define RBLHG_GPIO_LED_USER	20
+#define RBLHG_GPIO_BTN_RESET	15
+
+static struct gpio_led rblhg_leds[] __initdata = {
+	{
+		.name = "rb:green:rssi0",
+		.gpio = RBLHG_GPIO_LED_0,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi1",
+		.gpio = RBLHG_GPIO_LED_1,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi2",
+		.gpio = RBLHG_GPIO_LED_2,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi3",
+		.gpio = RBLHG_GPIO_LED_3,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:rssi4",
+		.gpio = RBLHG_GPIO_LED_4,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:eth",
+		.gpio = RBLHG_GPIO_LED_ETH,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:user",
+		.gpio = RBLHG_GPIO_LED_USER,
+		.active_low = 1,
+	}, {
+		.name = "rb:blue:power",
+		.gpio = RBLHG_GPIO_LED_POWER,
+		.active_low = 0,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	},
+};
+
+/* RB w APG-5HacT2HnD (wAP AC) gpios*/
+#define RBWAPGSC_LED1		1
+#define RBWAPGSC_LED2		8
+#define RBWAPGSC_LED3		9
+#define RBWAPGSC_POWERLED		16
+#define RBWAPGSC_GPIO_BTN_RESET		1
+#define RBWAPGSC_GPIO_MDIO_MDC		12
+#define RBWAPGSC_GPIO_MDIO_DATA		11
+#define RBWAPGSC_MDIO_PHYADDR		0
+
+static struct gpio_led rbwapgsc_leds[] __initdata = {
+	{
+		.name = "rb:green:led1",
+		.gpio = RBWAPGSC_LED1,
+		.active_low = 1,
+	},{
+		.name = "rb:blue:power",
+		.gpio = RBWAPGSC_POWERLED,
+		.active_low = 1,
+	},
+};
+
+static struct mdio_gpio_platform_data rbwapgsc_mdio_data = {
+	.mdc = RBWAPGSC_GPIO_MDIO_MDC,
+	.mdio = RBWAPGSC_GPIO_MDIO_DATA,
+	.phy_mask = ~BIT(RBWAPGSC_MDIO_PHYADDR),
+};
+
+static struct platform_device rbwapgsc_phy_device = {
+	.name = "mdio-gpio",
+	.id = 1,
+	.dev = {
+		.platform_data = &rbwapgsc_mdio_data
+	},
+};
+
+/* RB911L GPIOs */
+#define RB911L_GPIO_BTN_RESET	15
+#define RB911L_GPIO_LED_1	13
+#define RB911L_GPIO_LED_2	12
+#define RB911L_GPIO_LED_3	4
+#define RB911L_GPIO_LED_4	21
+#define RB911L_GPIO_LED_5	18
+#define RB911L_GPIO_LED_ETH	20
+#define RB911L_GPIO_LED_POWER	11
+#define RB911L_GPIO_LED_USER	3
+#define RB911L_GPIO_PIN_HOLE	14 /* for reference */
+
+static struct gpio_led rb911l_leds[] __initdata = {
+	{
+		.name = "rb:green:eth",
+		.gpio = RB911L_GPIO_LED_ETH,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:led1",
+		.gpio = RB911L_GPIO_LED_1,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:led2",
+		.gpio = RB911L_GPIO_LED_2,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:led3",
+		.gpio = RB911L_GPIO_LED_3,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:led4",
+		.gpio = RB911L_GPIO_LED_4,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:led5",
+		.gpio = RB911L_GPIO_LED_5,
+		.active_low = 1,
+	}, {
+		.name = "rb:green:power",
+		.gpio = RB911L_GPIO_LED_POWER,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+		.open_drain = 1,
+	}, {
+		.name = "rb:green:user",
+		.gpio = RB911L_GPIO_LED_USER,
+		.active_low = 1,
+		.open_drain = 1,
+	},
+};
+
+static struct gen_74x164_chip_platform_data rbspi_ssr_data = {
+	.base = RBSPI_SSR_GPIO_BASE,
+	.num_registers = 1,
+};
+
+/* the spi-ath79 driver can only natively handle CS0. Other CS are bit-banged */
+static int rbspi_spi_cs_gpios[] = {
+	-ENOENT,	/* CS0 is always -ENOENT: natively handled */
+	-ENOENT,	/* CS1 can be updated by the code as necessary */
+};
+
+static struct ath79_spi_platform_data rbspi_ath79_spi_data = {
+	.bus_num = 0,
+	.cs_gpios = rbspi_spi_cs_gpios,
+};
+
+/*
+ * Global spi_board_info: devices that don't have an SSR only have the SPI NOR
+ * flash on bus0 CS0, while devices that have an SSR add it on the same bus CS1
+ */
+static struct spi_board_info rbspi_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rbspi_spi_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "74x164",
+		.platform_data	= &rbspi_ssr_data,
+	}
+};
+
+void __init rbspi_wlan_init(u16 id, int wmac_offset)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_ext_wlan_data(id);
+	if (!art_buf)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, wmac_offset);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+#define RBSPI_MACH_BUFLEN	64
+/*
+ * Common platform init routine for all SPI NOR devices.
+ */
+static __init const struct rb_info *rbspi_platform_setup(void)
+{
+	const struct rb_info *info;
+	char buf[RBSPI_MACH_BUFLEN] = "MikroTik ";
+	char *str;
+	int len = RBSPI_MACH_BUFLEN - strlen(buf) - 1;
+
+	info = rb_init_info((void *)(KSEG1ADDR(AR71XX_SPI_BASE)), 0x20000);
+	if (!info)
+		return NULL;
+
+	if (info->board_name) {
+		str = "RouterBOARD ";
+		if (strncmp(info->board_name, str, strlen(str))) {
+			strncat(buf, str, len);
+			len -= strlen(str);
+		}
+		strncat(buf, info->board_name, len);
+	}
+	else
+		strncat(buf, "UNKNOWN", len);
+
+	mips_set_machine_name(buf);
+
+	/* fix partitions based on flash parsing */
+	rbspi_init_partitions(info);
+
+	return info;
+}
+
+/*
+ * Common peripherals init routine for all SPI NOR devices.
+ * Sets SPI and USB.
+ */
+static void __init rbspi_peripherals_setup(u32 flags)
+{
+	unsigned spi_n;
+
+	if (flags & RBSPI_HAS_SSR)
+		spi_n = ARRAY_SIZE(rbspi_spi_info);
+	else
+		spi_n = 1;     /* only one device on bus0 */
+
+	rbspi_ath79_spi_data.num_chipselect = spi_n;
+	rbspi_ath79_spi_data.cs_gpios = rbspi_spi_cs_gpios;
+	ath79_register_spi(&rbspi_ath79_spi_data, rbspi_spi_info, spi_n);
+
+	if (flags & RBSPI_HAS_USB)
+		ath79_register_usb();
+
+	if (flags & RBSPI_HAS_PCI)
+		ath79_register_pci();
+}
+
+/*
+ * Common network init routine for all SPI NOR devices.
+ * Sets LAN/WAN/WLAN.
+ */
+static void __init rbspi_network_setup(u32 flags, int gmac1_offset,
+					int wmac0_offset, int wmac1_offset)
+{
+	/* for QCA953x that will init mdio1_device/data */
+	ath79_register_mdio(0, 0x0);
+	if (flags & RBSPI_HAS_MDIO1)
+		ath79_register_mdio(1, 0x0);
+
+	if (flags & RBSPI_HAS_WAN4) {
+		ath79_setup_ar934x_eth_cfg(0);
+
+		/* set switch to oper mode 1, PHY4 connected to CPU */
+		ath79_switch_data.phy4_mii_en = 1;
+		ath79_switch_data.phy_poll_mask |= BIT(4);
+
+		/* init GMAC0 connected to PHY4 at 100M */
+		ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+		ath79_eth0_data.phy_mask = BIT(4);
+		ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+		ath79_register_eth(0);
+	} else {
+		/* set the SoC to SW_ONLY_MODE, which connects all PHYs
+		 * to the internal switch.
+		 * We hijack ath79_setup_ar934x_eth_cfg() to set the switch in
+		 * the QCA953x, this works because this configuration bit is
+		 * the same as the AR934x. There's no equivalent function for
+		 * QCA953x for now. */
+		ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+	}
+
+	/* init GMAC1 */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, gmac1_offset);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	if (flags & RBSPI_HAS_WLAN0)
+		rbspi_wlan_init(0, wmac0_offset);
+
+	if (flags & RBSPI_HAS_WLAN1)
+		rbspi_wlan_init(1, wmac1_offset);
+}
+
+static __init void rbspi_register_reset_button(int gpio)
+{
+	rbspi_gpio_keys_reset[0].gpio = gpio;
+	ath79_register_gpio_keys_polled(-1, RBSPI_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rbspi_gpio_keys_reset),
+					rbspi_gpio_keys_reset);
+}
+
+/*
+ * Init the mAP lite hardware (QCA953x).
+ * The mAP L-2nD (mAP lite) has a single ethernet port, connected to PHY0.
+ * Trying to use GMAC0 in direct mode was unsucessful, so we're
+ * using SW_ONLY_MODE, which connects PHY0 to MAC1 on the internal
+ * switch, which is connected to GMAC1 on the SoC. GMAC0 is unused.
+ */
+static void __init rbmapl_setup(void)
+{
+	u32 flags = RBSPI_HAS_WLAN0;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN0 MAC is HW MAC + 1 */
+	rbspi_network_setup(flags, 0, 1, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbmapl_leds), rbmapl_leds);
+
+	/* mAP lite has a single reset button as gpio 16 */
+	rbspi_register_reset_button(RBMAPL_GPIO_BTN_RESET);
+
+	/* clear internal multiplexing */
+	ath79_gpio_output_select(RBMAPL_GPIO_LED_ETH, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(RBMAPL_GPIO_LED_POWER, AR934X_GPIO_OUT_GPIO);
+}
+
+/*
+ * Init the hAP lite hardware (QCA953x).
+ * The 941-2nD (hAP lite) has 4 ethernet ports, with port 2-4
+ * being assigned to LAN on the casing, and port 1 being assigned
+ * to "internet" (WAN) on the casing. Port 1 is connected to PHY3.
+ * Since WAN is neither PHY0 nor PHY4, we cannot use GMAC0 with this device.
+ */
+static void __init rbhapl_setup(void)
+{
+	u32 flags = RBSPI_HAS_WLAN0;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN0 MAC is HW MAC + 4 */
+	rbspi_network_setup(flags, 0, 4, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbhapl_leds), rbhapl_leds);
+
+	/* hAP lite has a single reset button as gpio 16 */
+	rbspi_register_reset_button(RBHAPL_GPIO_BTN_RESET);
+}
+
+/*
+ * The hAP, hAP ac lite, hEX lite and hEX PoE lite share the same platform
+ */
+static void __init rbspi_952_750r2_setup(u32 flags)
+{
+	if (flags & RBSPI_HAS_SSR)
+		rbspi_spi_cs_gpios[1] = RB952_GPIO_SSR_CS;
+
+	rbspi_peripherals_setup(flags);
+
+	/*
+	 * GMAC1 is HW MAC + 1, WLAN0 MAC IS HW MAC + 5 (hAP),
+	 * WLAN1 MAC IS HW MAC + 6 (hAP ac lite)
+	 */
+	rbspi_network_setup(flags, 1, 5, 6);
+
+	if (flags & RBSPI_HAS_USB)
+		gpio_request_one(RB952_GPIO_USB_POWER,
+				GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+				"USB power");
+
+	if (flags & RBSPI_HAS_POE)
+		gpio_request_one(RB952_GPIO_POE_POWER,
+				GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+				"POE power");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb952_leds), rb952_leds);
+
+	/* These devices have a single reset button as gpio 16 */
+	rbspi_register_reset_button(RB952_GPIO_BTN_RESET);
+}
+
+/*
+ * Init the hAP (ac lite) hardware (QCA953x).
+ * The 951Ui-2nD (hAP) has 5 ethernet ports, with ports 2-5 being assigned
+ * to LAN on the casing, and port 1 being assigned to "internet" (WAN).
+ * Port 1 is connected to PHY4 (the ports are labelled in reverse physical
+ * number), so the SoC can be set to connect GMAC0 to PHY4 and GMAC1 to the
+ * internal switch for the LAN ports.
+ * The device also has USB, PoE output and an SSR used for LED multiplexing.
+ * The 952Ui-5ac2nD (hAP ac lite) is nearly identical to the hAP, it adds a
+ * QCA9887 5GHz radio via PCI and moves 2.4GHz from WLAN0 to WLAN1.
+ */
+static void __init rb952_setup(void)
+{
+	u32 flags = RBSPI_HAS_WAN4 | RBSPI_HAS_USB |
+			RBSPI_HAS_SSR | RBSPI_HAS_POE;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	/* differentiate the hAP from the hAP ac lite */
+	if (strstr(mips_get_machine_name(), "952Ui-5ac2nD"))
+		flags |= RBSPI_HAS_WLAN1 | RBSPI_HAS_PCI;
+	else
+		flags |= RBSPI_HAS_WLAN0;
+
+	rbspi_952_750r2_setup(flags);
+}
+
+/*
+ * Init the hEX (PoE) lite hardware (QCA953x).
+ * The 750UP r2 (hEX PoE lite) is nearly identical to the hAP, only without
+ * WLAN. The 750 r2 (hEX lite) is nearly identical to the 750UP r2, only
+ * without USB and POE. The 750P Pbr2 (Powerbox) is nearly identical to hEX PoE
+ * lite, only without USB. It shares the same bootloader board identifier.
+ */
+static void __init rb750upr2_setup(void)
+{
+	u32 flags = RBSPI_HAS_WAN4 | RBSPI_HAS_SSR;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	/* differentiate the hEX lite from the hEX PoE lite */
+	if (strstr(mips_get_machine_name(), "750UP r2"))
+		flags |= RBSPI_HAS_USB | RBSPI_HAS_POE;
+
+	/* differentiate the Powerbox from the hEX lite */
+	else if (strstr(mips_get_machine_name(), "750P r2"))
+		flags |= RBSPI_HAS_POE;
+
+	rbspi_952_750r2_setup(flags);
+}
+
+/*
+ * Init the hAP ac / 962UiGS-5HacT2HnT hardware (QCA9558).
+ * The hAP ac has 5 ethernet ports provided by an AR8337 switch. Port 1 is
+ * assigned to WAN, ports 2-5 are assigned to LAN. Port 0 is connected to the
+ * SoC, ports 1-5 of the switch are connected to physical ports 1-5 in order.
+ * The SFP cage is not assigned by default on RouterOS. Extra work is required
+ * to support this interface as it is directly connected to the SoC (eth1).
+ * Wireless is provided by a 2.4GHz radio on the SoC (WLAN1) and a 5GHz radio
+ * attached via PCI (QCA9880). Red and green WLAN LEDs are populated however
+ * they are not attached to GPIOs, extra work is required to support these.
+ * PoE and USB output power control is supported.
+ */
+static void __init rb962_setup(void)
+{
+	u32 flags = RBSPI_HAS_USB | RBSPI_HAS_POE | RBSPI_HAS_PCI;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* Do not call rbspi_network_setup as we have a discrete switch chip */
+	ath79_eth0_pll_data.pll_1000 = 0xae000000;
+	ath79_eth0_pll_data.pll_100 = 0xa0000101;
+	ath79_eth0_pll_data.pll_10 = 0xa0001313;
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(rb962_mdio0_info,
+					ARRAY_SIZE(rb962_mdio0_info));
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+
+	/* WLAN1 MAC is HW MAC + 7 */
+	rbspi_wlan_init(1, 7);
+
+	if (flags & RBSPI_HAS_USB)
+		gpio_request_one(RB962_GPIO_USB_POWER,
+				GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+				"USB power");
+
+	/* PoE output GPIO is inverted, set GPIOF_ACTIVE_LOW for consistency */
+	if (flags & RBSPI_HAS_POE)
+		gpio_request_one(RB962_GPIO_POE_POWER,
+				GPIOF_OUT_INIT_HIGH | GPIOF_ACTIVE_LOW |
+					GPIOF_EXPORT_DIR_FIXED,
+				"POE power");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb962_leds_gpio),
+				rb962_leds_gpio);
+
+	/* This device has a single reset button as gpio 20 */
+	rbspi_register_reset_button(RB962_GPIO_BTN_RESET);
+}
+
+/*
+ * Init the LHG hardware (AR9344).
+ * The LHG 5nD has a single ethernet port connected to PHY0.
+ * Wireless is provided via 5GHz WLAN1.
+ */
+static void __init rblhg_setup(void)
+{
+	u32 flags = RBSPI_HAS_WLAN1 | RBSPI_HAS_MDIO1;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN1 MAC is HW MAC + 1 */
+	rbspi_network_setup(flags, 0, 0, 1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rblhg_leds), rblhg_leds);
+
+	rbspi_register_reset_button(RBLHG_GPIO_BTN_RESET);
+}
+
+/*
+ * Init the wAP hardware.
+ * The wAP 2nD has a single ethernet port.
+ */
+static void __init rbwap_setup(void)
+{
+	u32 flags = RBSPI_HAS_WLAN0;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN0 MAC is HW MAC + 1 */
+	rbspi_network_setup(flags, 0, 1, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbwap_leds), rbwap_leds);
+
+	/* wAP has a single reset button as GPIO 16 */
+	rbspi_register_reset_button(RBWAP_GPIO_BTN_RESET);
+}
+
+/*
+ * Init the cAP hardware (EXPERIMENTAL).
+ * The cAP 2nD has a single ethernet port, and a global LED switch.
+ */
+static void __init rbcap_setup(void)
+{
+	u32 flags = RBSPI_HAS_WLAN0;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN0 MAC is HW MAC + 1 */
+	rbspi_network_setup(flags, 0, 1, 0);
+
+	gpio_request_one(RBCAP_GPIO_LED_ALL,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LEDs enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbcap_leds), rbcap_leds);
+}
+
+/*
+ * Init the mAP hardware.
+ * The mAP 2nD has two ethernet ports, PoE output, SSR for LED
+ * multiplexing and USB port.
+ */
+static void __init rbmap_setup(void)
+{
+	u32 flags = RBSPI_HAS_USB | RBSPI_HAS_WLAN0 |
+			RBSPI_HAS_SSR | RBSPI_HAS_POE;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_spi_cs_gpios[1] = RBMAP_GPIO_SSR_CS;
+	rbspi_peripherals_setup(flags);
+
+	/* GMAC1 is HW MAC, WLAN0 MAC is HW MAC + 2 */
+	rbspi_network_setup(flags, 0, 2, 0);
+
+	if (flags & RBSPI_HAS_POE)
+		gpio_request_one(RBMAP_GPIO_POE_POWER,
+				GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+				"POE power");
+
+	/* USB power GPIO is inverted, set GPIOF_ACTIVE_LOW for consistency */
+	if (flags & RBSPI_HAS_USB)
+		gpio_request_one(RBMAP_GPIO_USB_POWER,
+				GPIOF_OUT_INIT_HIGH | GPIOF_ACTIVE_LOW |
+					GPIOF_EXPORT_DIR_FIXED,
+				"USB power");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbmap_leds), rbmap_leds);
+
+	/* mAP 2nD has a single reset button as gpio 16 */
+	rbspi_register_reset_button(RBMAP_GPIO_BTN_RESET);
+}
+
+/*
+ * Init the wAPGSC (RB wAPG-5HacT2HnD // wAP AC) hardware.
+ * The wAPGSC has one Ethernet port via AR8033 with PoE input, dual radio (SoC
+ * 2.4 GHz and external QCA9880) and a ZT2046Q temperature and voltage sensor
+ * (currently not supported).
+ */
+static void __init rbwapgsc_setup(void)
+{
+	u32 flags = RBSPI_HAS_PCI;
+
+	if (!rbspi_platform_setup())
+		return;
+
+	rbspi_peripherals_setup(flags);
+
+	platform_device_register(&rbwapgsc_phy_device);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.mii_bus_dev = &rbwapgsc_phy_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.phy_mask = BIT(RBWAPGSC_MDIO_PHYADDR);
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_eth1_pll_data.pll_100 = 0x80000101;
+	ath79_eth1_pll_data.pll_10 = 0x80001313;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+
+	rbspi_wlan_init(1, 2);
+
+	rbspi_register_reset_button(RBWAPGSC_GPIO_BTN_RESET);
+
+	ath79_gpio_function_enable(QCA955X_GPIO_FUNC_JTAG_DISABLE|
+				QCA955X_GPIO_REG_OUT_FUNC4|
+				QCA955X_GPIO_REG_OUT_FUNC3);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbwapgsc_leds),
+			rbwapgsc_leds);
+}
+
+/*
+ * Setup the 911L hardware (AR9344).
+ */
+static void __init rb911l_setup(void)
+{
+	const struct rb_info *info;
+
+	info = rbspi_platform_setup();
+	if (!info)
+		return;
+
+	if (!rb_has_hw_option(info, RB_HW_OPT_NO_NAND)) {
+		/*
+		 * Old hardware revisions might be equipped with a NAND flash
+		 * chip instead of the 16MiB SPI NOR device. Those boards are
+		 * not supported at the moment, so throw a warning and skip
+		 * the peripheral setup to avoid messing up the data in the
+		 * flash chip.
+		 */
+		WARN(1, "The NAND flash on this board is not supported.\n");
+	} else {
+		rbspi_peripherals_setup(0);
+	}
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	rbspi_wlan_init(0, 1);
+
+	rbspi_register_reset_button(RB911L_GPIO_BTN_RESET);
+
+	/* Make the eth LED controllable by software. */
+	ath79_gpio_output_select(RB911L_GPIO_LED_ETH, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb911l_leds), rb911l_leds);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_MAPL, "map-hb", rbmapl_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_941, "H951L", rbhapl_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_911L, "911L", rb911l_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_952, "952-hb", rb952_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_962, "962", rb962_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_750UPR2, "750-hb", rb750upr2_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_LHG5, "lhg", rblhg_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_WAP, "wap-hb", rbwap_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_CAP, "cap-hb", rbcap_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_MAP, "map2-hb", rbmap_setup);
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_WAPAC, "wapg-sc", rbwapgsc_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rbsxtlite.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbsxtlite.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rbsxtlite.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rbsxtlite.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-re450.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-re450.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-re450.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-re450.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rme-eg200.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rme-eg200.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rme-eg200.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rme-eg200.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rut9xx.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rut9xx.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rut9xx.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rut9xx.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rw2458n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rw2458n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rw2458n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-rw2458n.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc1750.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc1750.c
new file mode 100644
index 0000000000..f8eab97340
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc1750.c
@@ -0,0 +1,146 @@
+/*
+ * Abicom International Scorpion SC1750 support.
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2017 Conor O'Gorman <i@conorogorman.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SC1750_GPIO_LED_POWER		11
+#define SC1750_GPIO_LED_ERR1		12
+#define SC1750_GPIO_LED_WLAN		13
+#define SC1750_GPIO_LED_ERR2		14
+#define SC1750_GPIO_LED_OK3		15
+#define SC1750_GPIO_LED_ERR3		16
+#define SC1750_GPIO_BTN_RESET		4
+
+#define SC1750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define SC1750_KEYS_DEBOUNCE_INTERVAL	(3 * SC1750_KEYS_POLL_INTERVAL)
+
+#define SC1750_MAC0_OFFSET		0
+#define SC1750_MAC1_OFFSET		6
+#define SC1750_WMAC_CALDATA_OFFSET	0x1000
+#define SC1750_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led sc1750_leds_gpio[] __initdata = {
+	{
+		.name		= "sc1750:green:power",
+		.gpio		= SC1750_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc1750:red:power",
+		.gpio		= SC1750_GPIO_LED_ERR1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc1750:green:wlan",
+		.gpio		= SC1750_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc1750:red:wlan",
+		.gpio		= SC1750_GPIO_LED_ERR2,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button sc1750_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SC1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SC1750_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static struct at803x_platform_data at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 0,
+	.enable_rgmii_tx_delay = 0,
+};
+
+static struct mdio_board_info sc1750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "sc1750",
+		.mdio_addr = 1,
+		.platform_data = &at803x_data,
+	},
+};
+
+static void __init sc1750_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(sc1750_leds_gpio),
+				 sc1750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, SC1750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(sc1750_gpio_keys),
+					sc1750_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_nfc();
+
+	ath79_register_wmac(art + SC1750_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0);
+	mdiobus_register_board_info(sc1750_mdio0_info,
+				    ARRAY_SIZE(sc1750_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + SC1750_MAC0_OFFSET, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000101;
+	ath79_eth0_pll_data.pll_100 = 0xa4000101;
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = 0xF;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_SC1750, "SC1750", "Abicom SC1750", sc1750_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc300m.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc300m.c
new file mode 100644
index 0000000000..f9013e3b97
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc300m.c
@@ -0,0 +1,133 @@
+/*
+ * Abicom International Scorpion SC300M Module support.
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2017 Conor O'Gorman <i@conorogorman.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SC300M_GPIO_LED_WLAN		0
+#define SC300M_GPIO_LED_POWER		1
+
+#define SC300M_GPIO_BTN_RESET		17
+
+#define SC300M_KEYS_POLL_INTERVAL	20	/* msecs */
+#define SC300M_KEYS_DEBOUNCE_INTERVAL	(3 * SC300M_KEYS_POLL_INTERVAL)
+
+#define SC300M_MAC0_OFFSET		0
+#define SC300M_MAC1_OFFSET		6
+#define SC300M_WMAC_CALDATA_OFFSET	0x1000
+#define SC300M_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led sc300m_leds_gpio[] __initdata = {
+	{
+		.name		= "sc300m:blue:wlan",
+		.gpio		= SC300M_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc300m:blue:power",
+		.gpio		= SC300M_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button sc300m_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SC300M_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SC300M_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct at803x_platform_data at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 0,
+	.enable_rgmii_tx_delay = 0,
+};
+
+static struct mdio_board_info sc300m_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "sc300m",
+		.mdio_addr = 1,
+		.platform_data = &at803x_data,
+	},
+};
+
+static void __init sc300m_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(sc300m_leds_gpio),
+				 sc300m_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, SC300M_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(sc300m_gpio_keys),
+					sc300m_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_nfc();
+
+	ath79_register_wmac(art + SC300M_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0);
+	mdiobus_register_board_info(sc300m_mdio0_info,
+				    ARRAY_SIZE(sc300m_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + SC300M_MAC0_OFFSET, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000101;
+	ath79_eth0_pll_data.pll_100 = 0xa4000101;
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = 0xF;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_SC300M, "SC300M", "Abicom SC300M", sc300m_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc450.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc450.c
new file mode 100644
index 0000000000..f45abc6a66
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sc450.c
@@ -0,0 +1,150 @@
+/*
+ * Abicom International Scorpion SC450 support.
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2017 Conor O'Gorman <i@conorogorman.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SC450_GPIO_LED_POWER		13
+#define SC450_GPIO_LED_ERR1		14
+#define SC450_GPIO_LED_ERR2		15
+#define SC450_GPIO_LED_WLAN		16
+#define SC450_GPIO_BTN_RESET		17
+#define SC450_GPIO_WP			18
+#define SC450_GPIO_POE			19
+#define SC450_GPIO_RX_LOS		20
+#define SC450_GPIO_MOD_GND		21
+#define SC450_GPIO_MOD_SCL		22
+#define SC450_GPIO_MOD_SDA		23
+
+#define SC450_KEYS_POLL_INTERVAL	20	/* msecs */
+#define SC450_KEYS_DEBOUNCE_INTERVAL	(3 * SC450_KEYS_POLL_INTERVAL)
+
+#define SC450_MAC0_OFFSET		0
+#define SC450_MAC1_OFFSET		6
+#define SC450_WMAC_CALDATA_OFFSET	0x1000
+#define SC450_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led sc450_leds_gpio[] __initdata = {
+	{
+		.name		= "sc450:green:power",
+		.gpio		= SC450_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc450:red:power",
+		.gpio		= SC450_GPIO_LED_ERR1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc450:green:wlan",
+		.gpio		= SC450_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sc450:red:wlan",
+		.gpio		= SC450_GPIO_LED_ERR2,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button sc450_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SC450_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SC450_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct at803x_platform_data at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 0,
+	.enable_rgmii_tx_delay = 0,
+};
+
+static struct mdio_board_info sc450_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "sc450",
+		.mdio_addr = 1,
+		.platform_data = &at803x_data,
+	},
+};
+
+static void __init sc450_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(sc450_leds_gpio),
+				 sc450_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, SC450_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(sc450_gpio_keys),
+					sc450_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_nfc();
+
+	ath79_register_wmac(art + SC450_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0);
+	mdiobus_register_board_info(sc450_mdio0_info,
+				    ARRAY_SIZE(sc450_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + SC450_MAC0_OFFSET, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000101;
+	ath79_eth0_pll_data.pll_100 = 0xa4000101;
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = 0xF;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_SC450, "SC450", "Abicom SC450", sc450_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-smart-300.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-smart-300.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-smart-300.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-smart-300.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-som9331.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-som9331.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-som9331.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-som9331.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sr3200.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sr3200.c
new file mode 100644
index 0000000000..b59f65d9fa
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-sr3200.c
@@ -0,0 +1,188 @@
+/*
+ * Support for YunCore SR3200 and XD3200 boards
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SR3200_XD3200_GPIO_LED_SYSTEM	1
+#define SR3200_XD3200_GPIO_LED_WLAN2G	19
+
+#define SR3200_XD3200_GPIO_BTN_RESET	2
+
+#define SR3200_XD3200_KEYS_POLL_INTERVAL	20
+#define SR3200_XD3200_KEYS_DEBOUNCE_INTERVAL	\
+		(3 * SR3200_XD3200_KEYS_POLL_INTERVAL)
+
+static struct gpio_led xd3200_leds_gpio[] __initdata = {
+	{
+		.name		= "xd3200:green:system",
+		.gpio		= SR3200_XD3200_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "xd3200:blue:wlan2g",
+		.gpio		= SR3200_XD3200_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led sr3200_leds_gpio[] __initdata = {
+	{
+		.name		= "sr3200:green:system",
+		.gpio		= SR3200_XD3200_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "sr3200:green:wlan2g",
+		.gpio		= SR3200_XD3200_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button sr3200_xd3200_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SR3200_XD3200_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SR3200_XD3200_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info sr3200_leds_qca833x[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "sr3200:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "sr3200:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "sr3200:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "sr3200:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "sr3200:green:wan"),
+};
+
+static const struct ar8327_led_info xd3200_leds_qca833x[] = {
+	AR8327_LED_INFO(PHY1_0, HW, "xd3200:green:lan"),
+	AR8327_LED_INFO(PHY2_0, HW, "xd3200:green:wan"),
+};
+
+/* Blink rate: 1 Gbps -> 8 hz, 100 Mbs -> 4 Hz, 10 Mbps -> 2 Hz */
+static struct ar8327_led_cfg sr3200_xd3200_qca833x_led_cfg = {
+	.led_ctrl0 = 0xcf37cf37,
+	.led_ctrl1 = 0xcf37cf37,
+	.led_ctrl2 = 0xcf37cf37,
+	.led_ctrl3 = 0x0,
+	.open_drain = true,
+};
+
+static struct ar8327_pad_cfg sr3200_xd3200_qca833x_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data sr3200_xd3200_qca833x_data = {
+	.pad0_cfg = &sr3200_xd3200_qca833x_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &sr3200_xd3200_qca833x_led_cfg,
+};
+
+static struct mdio_board_info sr3200_xd3200_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "sr3200_xd3200",
+		.mdio_addr = 0,
+		.platform_data = &sr3200_xd3200_qca833x_data,
+	},
+};
+
+static void __init sr3200_xd3200_common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(sr3200_xd3200_mdio0_info,
+				    ARRAY_SIZE(sr3200_xd3200_mdio0_info));
+
+	/* GMAC0 is connected to QCA8334/QCA8337N switch */
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(mac + 0x1000, NULL);
+
+	ap91_pci_init(mac + 0x5000, NULL);
+
+	ath79_gpio_direction_select(SR3200_XD3200_GPIO_LED_SYSTEM, true);
+	ath79_gpio_direction_select(SR3200_XD3200_GPIO_LED_WLAN2G, true);
+
+	/* Mute LEDs on boot */
+	gpio_set_value(SR3200_XD3200_GPIO_LED_SYSTEM, 1);
+	gpio_set_value(SR3200_XD3200_GPIO_LED_WLAN2G, 1);
+
+	ath79_gpio_output_select(SR3200_XD3200_GPIO_LED_SYSTEM, 0);
+	ath79_gpio_output_select(SR3200_XD3200_GPIO_LED_WLAN2G, 0);
+
+	ath79_register_gpio_keys_polled(-1, SR3200_XD3200_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(sr3200_xd3200_gpio_keys),
+					sr3200_xd3200_gpio_keys);
+}
+
+static void __init sr3200_setup(void)
+{
+	sr3200_xd3200_qca833x_data.leds = sr3200_leds_qca833x;
+	sr3200_xd3200_qca833x_data.num_leds = ARRAY_SIZE(sr3200_leds_qca833x);
+
+	sr3200_xd3200_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(sr3200_leds_gpio),
+				 sr3200_leds_gpio);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_SR3200, "SR3200", "YunCore SR3200", sr3200_setup);
+
+static void __init xd3200_setup(void)
+{
+	sr3200_xd3200_qca833x_data.leds = xd3200_leds_qca833x;
+	sr3200_xd3200_qca833x_data.num_leds = ARRAY_SIZE(xd3200_leds_qca833x);
+
+	sr3200_xd3200_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(xd3200_leds_gpio),
+				 xd3200_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_XD3200, "XD3200", "YunCore XD3200", xd3200_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-t830.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-t830.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-t830.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-t830.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tellstick-znet-lite.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tellstick-znet-lite.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tellstick-znet-lite.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tellstick-znet-lite.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tew-632brp.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-632brp.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tew-632brp.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-632brp.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tew-673gru.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-673gru.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tew-673gru.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-673gru.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tew-712br.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-712br.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tew-712br.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-712br.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tew-732br.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-732br.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tew-732br.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-732br.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-823dru.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-823dru.c
new file mode 100644
index 0000000000..480811f449
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tew-823dru.c
@@ -0,0 +1,182 @@
+/*
+ *  TRENDnet TEW-823DRU board support
+ *
+ *  Copyright (C) 2015 Cezary Jackiewicz <cezary.jackiewicz@gmail.com>
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TEW_823DRU_GPIO_LED_POWER_ORANGE	14
+#define TEW_823DRU_GPIO_LED_POWER_GREEN		19
+#define TEW_823DRU_GPIO_LED_PLANET_GREEN	22
+#define TEW_823DRU_GPIO_LED_PLANET_ORANGE	23
+
+#define TEW_823DRU_GPIO_BTN_WPS			16
+#define TEW_823DRU_GPIO_BTN_RESET		17
+
+#define TEW_823DRU_KEYS_POLL_INTERVAL		20	/* msecs */
+#define TEW_823DRU_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TEW_823DRU_KEYS_POLL_INTERVAL)
+
+#define TEW_823DRU_WMAC_CALDATA_OFFSET		0x1000
+
+#define TEW_823DRU_LAN_MAC_OFFSET	0x04
+#define TEW_823DRU_WAN_MAC_OFFSET	0x18
+
+static struct gpio_led tew_823dru_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:green:power",
+		.gpio		= TEW_823DRU_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "trendnet:orange:power",
+		.gpio		= TEW_823DRU_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "trendnet:green:planet",
+		.gpio		= TEW_823DRU_GPIO_LED_PLANET_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "trendnet:orange:planet",
+		.gpio		= TEW_823DRU_GPIO_LED_PLANET_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tew_823dru_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_823DRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_823DRU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_823DRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_823DRU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg tew_823dru_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg tew_823dru_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data tew_823dru_ar8327_data = {
+	.pad0_cfg = &tew_823dru_ar8327_pad0_cfg,
+	.pad6_cfg = &tew_823dru_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info tew_823dru_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "tew_823dru",
+		.mdio_addr = 0,
+		.platform_data = &tew_823dru_ar8327_data,
+	},
+};
+
+static void __init tew_823dru_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + TEW_823DRU_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(mac + TEW_823DRU_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_823dru_leds_gpio),
+				 tew_823dru_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TEW_823DRU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_823dru_gpio_keys),
+					tew_823dru_gpio_keys);
+
+	ath79_register_wmac(art + TEW_823DRU_WMAC_CALDATA_OFFSET, lan_mac);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+
+
+	mdiobus_register_board_info(tew_823dru_mdio0_info,
+			ARRAY_SIZE(tew_823dru_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_823DRU, "TEW-823DRU", "TRENDnet TEW-823DRU",
+	     tew_823dru_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr11u.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr11u.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr11u.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr11u.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr13u.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr13u.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr13u.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr13u.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr3020.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr3020.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr3020.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr3020.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr3x20.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr3x20.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr3x20.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr3x20.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr6400.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr6400.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-mr6400.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-mr6400.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa701nd-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa701nd-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa701nd-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa701nd-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa7210n-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa7210n-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa7210n-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa7210n-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa801nd-v3.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa801nd-v3.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa801nd-v3.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa801nd-v3.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa830re-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa830re-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa830re-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa830re-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd-v4.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd-v4.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wa901nd.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wa901nd.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wax50re.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wax50re.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wax50re.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wax50re.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr3320-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr3320-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr3320-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr3320-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr3500.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr3500.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr3500.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr3500.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr4300.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr4300.c
new file mode 100644
index 0000000000..88780ae029
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr4300.c
@@ -0,0 +1,207 @@
+/*
+ *  TP-LINK TL-WDR4300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR4300_GPIO_LED_USB1		11
+#define WDR4300_GPIO_LED_USB2		12
+#define WDR4300_GPIO_LED_WLAN2G		13
+#define WDR4300_GPIO_LED_SYSTEM		14
+#define WDR4300_GPIO_LED_QSS		15
+
+#define WDR4300_GPIO_BTN_WPS		16
+#define WDR4300_GPIO_BTN_RFKILL		17
+
+#define WDR4300_GPIO_EXTERNAL_LNA0	18
+#define WDR4300_GPIO_EXTERNAL_LNA1	19
+
+#define WDR4300_GPIO_USB1_POWER		22
+#define WDR4300_GPIO_USB2_POWER		21
+
+#define WDR4300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR4300_KEYS_DEBOUNCE_INTERVAL	(3 * WDR4300_KEYS_POLL_INTERVAL)
+
+#define WDR4300_MAC0_OFFSET		0
+#define WDR4300_MAC1_OFFSET		6
+#define WDR4300_WMAC_CALDATA_OFFSET	0x1000
+#define WDR4300_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr4300_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr4300_flash_data = {
+	.part_probes	= wdr4300_part_probes,
+};
+
+static struct gpio_led wdr4300_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= WDR4300_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= WDR4300_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb1",
+		.gpio		= WDR4300_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb2",
+		.gpio		= WDR4300_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan2g",
+		.gpio		= WDR4300_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr4300_gpio_keys[] __initdata = {
+	{
+		.desc		= "QSS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info wdr4300_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:blue:wan"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:blue:lan1"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:blue:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:blue:lan3"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:blue:lan4"),
+};
+
+static struct ar8327_pad_cfg wdr4300_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wdr4300_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data wdr4300_ar8327_data = {
+	.pad0_cfg = &wdr4300_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wdr4300_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(wdr4300_leds_ar8327),
+	.leds = wdr4300_leds_ar8327,
+};
+
+static struct mdio_board_info wdr4300_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wdr4300",
+		.mdio_addr = 0,
+		.platform_data = &wdr4300_ar8327_data,
+	},
+};
+
+static void __init wdr4300_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr4300_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr4300_leds_gpio),
+				 wdr4300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR4300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr4300_gpio_keys),
+					wdr4300_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, WDR4300_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, WDR4300_GPIO_EXTERNAL_LNA1);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + WDR4300_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR4300_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(wdr4300_mdio0_info,
+				    ARRAY_SIZE(wdr4300_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -2);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	gpio_request_one(WDR4300_GPIO_USB1_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB1 power");
+	gpio_request_one(WDR4300_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR4300, "TL-WDR4300",
+	     "TP-LINK TL-WDR3600/4300/4310",
+	     wdr4300_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr6500-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr6500-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr6500-v2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wdr6500-v2.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wpa8630.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wpa8630.c
new file mode 100644
index 0000000000..b3907d9bf2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wpa8630.c
@@ -0,0 +1,173 @@
+/*
+ *  TP-Link TL-WPA8630 board support
+ *
+ *  Copyright (C) 2016 Henryk Heisig <hyniu@o2.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+
+#define TL_WPA8630_KEYS_POLL_INTERVAL	20
+#define TL_WPA8630_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WPA8630_KEYS_POLL_INTERVAL)
+
+#define TL_WPA8630_GPIO_LED_POWER		1
+#define TL_WPA8630_GPIO_LED_LAN		5
+#define TL_WPA8630_GPIO_LED_WLAN		19
+#define TL_WPA8630_GPIO_LED_WLAN5		21
+
+#define TL_WPA8630_GPIO_BTN_RESET		2
+#define TL_WPA8630_GPIO_BTN_RFKILL		8
+#define TL_WPA8630_GPIO_BTN_LED		6
+#define TL_WPA8630_GPIO_BTN_PAIR		7
+
+#define TL_WPA8630_MAC0_OFFSET		0x0000
+#define TL_WPA8630_WMAC_CALDATA_OFFSET	0x1000
+#define TL_WPA8630_PCI_CALDATA_OFFSET	0x5000
+
+static const char *tl_wpa8630_part_probes[] = {
+	"tp-link-64k",
+	NULL,
+};
+
+static struct flash_platform_data tl_wpa8630_flash_data = {
+	.part_probes	= tl_wpa8630_part_probes,
+	.type		= "s25fl064k",
+};
+
+static struct gpio_led tl_wpa8630_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wpa8630:green:power",
+		.gpio		= TL_WPA8630_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tl-wpa8630:green:lan",
+		.gpio		= TL_WPA8630_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tl-wpa8630:green:wlan",
+		.gpio		= TL_WPA8630_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tl-wpa8630:green:wlan5",
+		.gpio		= TL_WPA8630_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wpa8630_gpio_keys[] __initdata = {
+	{
+		.desc			= "Reset button",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= TL_WPA8630_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WPA8630_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= TL_WPA8630_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WPA8630_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "LED",
+		.type			= EV_KEY,
+		.code			= BTN_0,
+		.debounce_interval	= TL_WPA8630_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WPA8630_GPIO_BTN_LED,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "Pair",
+		.type			= EV_KEY,
+		.code			= BTN_1,
+		.debounce_interval	= TL_WPA8630_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WPA8630_GPIO_BTN_PAIR,
+		.active_low		= 1,
+	},
+};
+
+/* GMAC0 of the QCA8337 switch is connected to the QCA9563 SoC via SGMII */
+static struct ar8327_pad_cfg tl_wpa8630_qca8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data tl_wpa8630_qca8337_data = {
+	.pad0_cfg = &tl_wpa8630_qca8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info tl_wpa8630_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "tl_wpa8630",
+		.mdio_addr = 0,
+		.platform_data = &tl_wpa8630_qca8337_data,
+	},
+};
+
+static void __init tl_wpa8630_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f00fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&tl_wpa8630_flash_data);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		art + TL_WPA8630_MAC0_OFFSET, 0);
+
+	platform_device_register(&ath79_mdio0_device);
+
+	mdiobus_register_board_info(tl_wpa8630_mdio0_info,
+				    ARRAY_SIZE(tl_wpa8630_mdio0_info));
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = ~BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + TL_WPA8630_WMAC_CALDATA_OFFSET, mac);
+
+	ap91_pci_init(art + TL_WPA8630_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wpa8630_leds_gpio),
+				tl_wpa8630_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WPA8630_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wpa8630_gpio_keys),
+					tl_wpa8630_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WPA8630, "TL-WPA8630", "TP-LINK TL-WPA8630",
+	tl_wpa8630_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1041n-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1041n-v2.c
new file mode 100644
index 0000000000..a699631103
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1041n-v2.c
@@ -0,0 +1,158 @@
+/*
+ *  TP-LINK TL-WR1041 v2 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2011-2012 Anan Huang <axishero@foxmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1041NV2_GPIO_BTN_RESET	14
+#define TL_WR1041NV2_GPIO_LED_WPS	13
+#define TL_WR1041NV2_GPIO_LED_WLAN	11
+
+#define TL_WR1041NV2_GPIO_LED_SYSTEM	12
+
+#define TL_WR1041NV2_KEYS_POLL_INTERVAL		20	/* msecs */
+#define TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR1041NV2_KEYS_POLL_INTERVAL)
+
+#define TL_WR1041NV2_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *tl_wr1041nv2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1041nv2_flash_data = {
+	.part_probes	= tl_wr1041nv2_part_probes,
+};
+
+static struct gpio_led tl_wr1041nv2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1041NV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1041nv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1041NV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static const struct ar8327_led_info tl_wr1041n_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:green:wan"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:green:lan1"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:green:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:green:lan3"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:green:lan4"),
+};
+
+static struct ar8327_led_cfg wr1041n_v2_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcf35cf35,	/* LED0: blink at 10/100/1000M */
+	.led_ctrl1 = 0xcf35cf35,	/* LED1: blink at 10/100/1000M: anyway, no LED1 on tl-wr1041n */
+	.led_ctrl2 = 0xcf35cf35,	/* LED2: blink at 10/100/1000M: anyway, no LED2 on tl-wr1041n */
+	.led_ctrl3 = 0x03ffff00,	/* Pattern enabled for LED 0-2 of port 1-3 */
+	.open_drain = true,
+};
+
+static struct ar8327_pad_cfg db120_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data db120_ar8327_data = {
+	.pad0_cfg = &db120_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wr1041n_v2_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(tl_wr1041n_leds_ar8327),
+	.leds = tl_wr1041n_leds_ar8327
+};
+
+static struct mdio_board_info db120_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "tl_wr1041nv2",
+		.mdio_addr = 0,
+		.platform_data = &db120_ar8327_data,
+	},
+};
+
+static void __init tl_wr1041nv2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr1041nv2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1041nv2_leds_gpio),
+				 tl_wr1041nv2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1041NV2_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr1041nv2_gpio_keys),
+					 tl_wr1041nv2_gpio_keys);
+	ath79_register_wmac(ee, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	mdiobus_register_board_info(db120_mdio0_info,
+				    ARRAY_SIZE(db120_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1041N_V2, "TL-WR1041N-v2",
+	     "TP-LINK TL-WR1041N v2", tl_wr1041nv2_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v2.c
new file mode 100644
index 0000000000..319225e098
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v2.c
@@ -0,0 +1,216 @@
+/*
+ * TP-LINK TL-WR1043ND v2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1043_V2_GPIO_LED_WLAN	12
+#define TL_WR1043_V2_GPIO_LED_USB	15
+#define TL_WR1043_V2_GPIO_LED_WPS	18
+#define TL_WR1043_V2_GPIO_LED_SYSTEM	19
+
+#define TL_WR1043_V2_GPIO_BTN_RESET	16
+#define TL_WR1043_V2_GPIO_BTN_RFKILL	17
+
+#define TL_WR1043_V2_GPIO_USB_POWER	21
+
+#define TL_WR1043_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043_V2_KEYS_POLL_INTERVAL)
+
+#define TL_WR1043_V2_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *wr1043nd_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wr1043nd_v2_flash_data = {
+	.part_probes	= wr1043nd_v2_part_probes,
+};
+
+static struct gpio_led tl_wr1043_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1043_V2_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043_V2_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr1043_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V2_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info tl_wr1043_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:green:lan4"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:green:lan3"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:green:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:green:lan1"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:green:wan"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg wr1043nd_v2_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg wr1043nd_v2_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wr1043nd_v2_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wr1043nd_v2_ar8327_data = {
+	.pad0_cfg = &wr1043nd_v2_ar8327_pad0_cfg,
+	.pad6_cfg = &wr1043nd_v2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wr1043nd_v2_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(tl_wr1043_leds_ar8327),
+	.leds = tl_wr1043_leds_ar8327,
+};
+
+static struct mdio_board_info wr1043nd_v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "tl_wr1043_v2",
+		.mdio_addr = 0,
+		.platform_data = &wr1043nd_v2_ar8327_data,
+	},
+};
+
+static void __init tl_wr1043nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&wr1043nd_v2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043_v2_leds_gpio),
+				 tl_wr1043_v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1043_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043_v2_gpio_keys),
+					tl_wr1043_v2_gpio_keys);
+
+	ath79_register_wmac(art + TL_WR1043_V2_WMAC_CALDATA_OFFSET, mac);
+
+	mdiobus_register_board_info(wr1043nd_v2_mdio0_info,
+				    ARRAY_SIZE(wr1043nd_v2_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	gpio_request_one(TL_WR1043_V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND_V2, "TL-WR1043ND-v2",
+	     "TP-LINK TL-WR1043ND v2", tl_wr1043nd_v2_setup);
+
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v4.c
new file mode 100644
index 0000000000..2b1c755a06
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd-v4.c
@@ -0,0 +1,273 @@
+/*
+ *  TP-LINK WR1043 V4 support
+ *
+ *  Copyright (C) 2015-2016 P. Wassi <p.wassi at gmx.at>
+ *  Copyright (C) 2016 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2016 Andreas Ziegler <github@andreas-ziegler.de>
+ *  Copyright (C) 2016 Ludwig Thomeczek <ledesrc@wxorx.net>
+ *  Copyright (C) 2017 Tim Thorpe <tim@tfthorpe.net>
+ *
+ *  Derived from: mach-dir-869-a1.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define TL_WR1043_V4_GPIO_BTN_RESET		2
+#define TL_WR1043_V4_GPIO_BTN_RFKILL		5
+
+#define TL_WR1043_V4_GPIO_LED_WLAN		19
+#define TL_WR1043_V4_GPIO_LED_USB		7
+#define TL_WR1043_V4_GPIO_LED_WPS		1
+#define TL_WR1043_V4_GPIO_LED_SYSTEM		6
+
+#define TL_WR1043_V4_GPIO_USB_POWER		8
+
+#define TL_WR1043_V4_GPIO_LED_WAN		15
+#define TL_WR1043_V4_GPIO_LED_LAN1		9
+#define TL_WR1043_V4_GPIO_LED_LAN2		14
+#define TL_WR1043_V4_GPIO_LED_LAN3		21
+#define TL_WR1043_V4_GPIO_LED_LAN4		20
+
+#define TL_WR1043_V4_KEYS_POLL_INTERVAL		20 /* msecs */
+#define TL_WR1043_V4_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR1043_V4_KEYS_POLL_INTERVAL)
+
+#define TL_WR1043_V4_MAC_LOCATION		0x1ff50008
+
+#define TL_WR1043_V4_EEPROM_ADDR		0x1fff0000
+#define TL_WR1043_V4_WMAC_CALDATA_OFFSET	0x1000
+
+#define TL_WR1043N_V5_MAC_LOCATION		0x1ff00008
+
+static struct gpio_led tl_wr1043nd_v4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043_V4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043_V4_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr1043nd_v4_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043_V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR1043_V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V4_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg tl_wr1043nd_v4_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data tl_wr1043nd_v4_ar8327_data = {
+	.pad0_cfg = &tl_wr1043nd_v4_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info tl_wr1043nd_v4_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "tl_wr1043nd_v4",
+		.mdio_addr = 0,
+		.platform_data = &tl_wr1043nd_v4_ar8327_data,
+	},
+};
+
+static void __init tl_wr1043nd_v4_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(TL_WR1043_V4_MAC_LOCATION);
+	u8 *eeprom = (u8 *) KSEG1ADDR(TL_WR1043_V4_EEPROM_ADDR);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	mdiobus_register_board_info(tl_wr1043nd_v4_mdio0_info,
+	                            ARRAY_SIZE(tl_wr1043nd_v4_mdio0_info));
+
+	ath79_register_usb();
+	ath79_register_mdio(0, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(eeprom + TL_WR1043_V4_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_v4_leds_gpio),
+	                         tl_wr1043nd_v4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR1043_V4_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(tl_wr1043nd_v4_gpio_keys),
+	                                tl_wr1043nd_v4_gpio_keys);
+
+	gpio_request_one(TL_WR1043_V4_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND_V4, "TL-WR1043ND-v4",
+	     "TP-LINK TL-WR1043ND v4", tl_wr1043nd_v4_setup);
+
+static struct gpio_led tl_wr1043n_v5_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043_V4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR1043_V4_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR1043_V4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+/* The 1043Nv5 is identical to the 1043NDv4,
+ *  only missing the usb and small firmware layout changes  */
+static void __init tl_wr1043nv5_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TL_WR1043_V4_EEPROM_ADDR);
+	u8 *mac = (u8 *) KSEG1ADDR(TL_WR1043N_V5_MAC_LOCATION);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043n_v5_leds_gpio),
+				 tl_wr1043n_v5_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1043_V4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043nd_v4_gpio_keys),
+					tl_wr1043nd_v4_gpio_keys);
+
+	platform_device_register(&ath79_mdio0_device);
+
+	mdiobus_register_board_info(tl_wr1043nd_v4_mdio0_info,
+				    ARRAY_SIZE(tl_wr1043nd_v4_mdio0_info));
+
+	ath79_register_wmac(art + TL_WR1043_V4_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043N_V5, "TL-WR1043N-v5", "TP-LINK TL-WR1043N v5",
+	     tl_wr1043nv5_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr1043nd.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr2543n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr2543n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr2543n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr2543n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr703n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr703n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr703n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr703n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr720n-v3.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr720n-v3.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr720n-v3.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr720n-v3.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr741nd-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr741nd-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr741nd-v4.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr741nd-v4.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr741nd.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr741nd.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr741nd.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr741nd.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr802n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr802n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr802n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr802n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr810n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr810n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr810n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr810n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n-v8.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n-v8.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n-v8.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n-v8.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n-v9.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n-v9.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n-v9.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n-v9.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr841n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr841n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr902ac-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr902ac-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr902ac-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr902ac-v1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr940n-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr940n-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr940n-v4.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr940n-v4.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr941nd-v6.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr941nd-v6.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr941nd-v6.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr941nd-v6.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr941nd.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr941nd.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr941nd.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr941nd.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr942n-v1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr942n-v1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr942n-v1.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tl-wr942n-v1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ts-d084.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ts-d084.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ts-d084.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ts-d084.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tube2h.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tube2h.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tube2h.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-tube2h.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-unifiac.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-unifiac.c
new file mode 100644
index 0000000000..17efb75614
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-unifiac.c
@@ -0,0 +1,180 @@
+/*
+ *  Ubiquiti UniFi AC (LITE) board support
+ *
+ *  Copyright (C) 2015-2016 P. Wassi <p.wassi at gmx.at>
+ *
+ *  Derived from: mach-ubnt-xm.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+
+#define UNIFIAC_KEYS_POLL_INTERVAL	20
+#define UNIFIAC_KEYS_DEBOUNCE_INTERVAL	(3 * UNIFIAC_KEYS_POLL_INTERVAL)
+
+#define UNIFIAC_GPIO_LED_WHITE		7
+#define UNIFIAC_GPIO_LED_BLUE		8
+
+#define UNIFIAC_GPIO_BTN_RESET		2
+
+#define UNIFIAC_MAC0_OFFSET             0x0000
+#define UNIFIAC_WMAC_CALDATA_OFFSET     0x1000
+#define UNIFIAC_PCI_CALDATA_OFFSET      0x5000
+
+
+static struct flash_platform_data ubnt_unifiac_flash_data = {
+	/* mx25l12805d and mx25l12835f have the same JEDEC ID */
+	.type = "mx25l12805d",
+};
+
+static struct gpio_led ubnt_unifiac_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:white:dome",
+		.gpio		= UNIFIAC_GPIO_LED_WHITE,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:blue:dome",
+		.gpio		= UNIFIAC_GPIO_LED_BLUE,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ubnt_unifiac_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= UNIFIAC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= UNIFIAC_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}
+};
+
+static void __init ubnt_unifiac_lite_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&ubnt_unifiac_flash_data);
+
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+	               eeprom + UNIFIAC_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+
+	ath79_register_mdio(0, ~BIT(4));
+	ath79_register_eth(0);
+
+
+	ath79_register_wmac(eeprom + UNIFIAC_WMAC_CALDATA_OFFSET, NULL);
+
+
+	ap91_pci_init(eeprom + UNIFIAC_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifiac_leds_gpio),
+	                         ubnt_unifiac_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UNIFIAC_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(ubnt_unifiac_gpio_keys),
+	                                ubnt_unifiac_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFIAC_LITE, "UBNT-UF-AC-LITE",
+	     "Ubiquiti UniFi-AC-LITE/MESH", ubnt_unifiac_lite_setup);
+
+static struct ar8327_pad_cfg ubnt_unifiac_pro_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data ubnt_unifiac_pro_ar8327_data = {
+	.pad0_cfg = &ubnt_unifiac_pro_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+
+static struct mdio_board_info ubnt_unifiac_pro_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "ubnt_unifiac_pro",
+		.mdio_addr = 0,
+		.platform_data = &ubnt_unifiac_pro_ar8327_data,
+	},
+};
+
+static void __init ubnt_unifiac_pro_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&ubnt_unifiac_flash_data);
+
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+	               eeprom + UNIFIAC_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	mdiobus_register_board_info(ubnt_unifiac_pro_mdio0_info,
+	                            ARRAY_SIZE(ubnt_unifiac_pro_mdio0_info));
+
+	ath79_register_mdio(0, 0x00);
+	ath79_register_eth(0);
+
+
+	ath79_register_usb();
+
+
+	ath79_register_wmac(eeprom + UNIFIAC_WMAC_CALDATA_OFFSET, NULL);
+
+
+	ap91_pci_init(eeprom + UNIFIAC_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifiac_leds_gpio),
+	                         ubnt_unifiac_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UNIFIAC_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(ubnt_unifiac_gpio_keys),
+	                                ubnt_unifiac_gpio_keys);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFIAC_PRO, "UBNT-UF-AC-PRO",
+	     "Ubiquiti UniFi-AC-PRO", ubnt_unifiac_pro_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-xm.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-xm.c
new file mode 100644
index 0000000000..b21f07b83a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt-xm.c
@@ -0,0 +1,781 @@
+/*
+ *  Ubiquiti Networks XM (rev 1.0) board support
+ *
+ *  Copyright (C) 2011 Ren Bolldorf <xsecute@googlemail.com>
+ *
+ *  Derived from: mach-pb44.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define UBNT_XM_GPIO_LED_L1		0
+#define UBNT_XM_GPIO_LED_L2		1
+#define UBNT_XM_GPIO_LED_L3		11
+#define UBNT_XM_GPIO_LED_L4		7
+
+#define UBNT_XM_GPIO_BTN_RESET		12
+
+#define UBNT_XM_KEYS_POLL_INTERVAL	20
+#define UBNT_XM_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_XM_KEYS_POLL_INTERVAL)
+
+#define UBNT_XM_EEPROM_ADDR		0x1fff1000
+
+static struct gpio_led ubnt_xm_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:red:link1",
+		.gpio		= UBNT_XM_GPIO_LED_L1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:orange:link2",
+		.gpio		= UBNT_XM_GPIO_LED_L2,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_XM_GPIO_LED_L3,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_XM_GPIO_LED_L4,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ubnt_xm_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= UBNT_XM_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}
+};
+
+#define UBNT_M_WAN_PHYMASK	BIT(4)
+
+static void __init ubnt_xm_init(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(UBNT_XM_EEPROM_ADDR);
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xm_leds_gpio),
+				 ubnt_xm_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_xm_gpio_keys),
+					ubnt_xm_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+	ap91_pci_init(eeprom, NULL);
+
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_XM,
+	     "UBNT-XM",
+	     "Ubiquiti Networks XM (rev 1.0) board",
+	     ubnt_xm_init);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_BULLET_M, "UBNT-BM", "Ubiquiti Bullet M",
+	     ubnt_xm_init);
+
+static void __init ubnt_rocket_m_setup(void)
+{
+	ubnt_xm_init();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M, "UBNT-RM", "Ubiquiti Rocket M",
+	     ubnt_rocket_m_setup);
+
+static void __init ubnt_nano_m_setup(void)
+{
+	ubnt_xm_init();
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_NANO_M, "UBNT-NM", "Ubiquiti Nanostation M",
+	     ubnt_nano_m_setup);
+
+static struct gpio_led ubnt_airrouter_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:globe",
+		.gpio		= 0,
+		.active_low	= 1,
+	}, {
+	        .name		= "ubnt:green:power",
+		.gpio		= 11,
+		.active_low	= 1,
+		.default_state  = LEDS_GPIO_DEFSTATE_ON,
+	}
+};
+
+static void __init ubnt_airrouter_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, mac1);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+	ath79_register_usb();
+
+	ap91_pci_init(ee, NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airrouter_leds_gpio),
+				 ubnt_airrouter_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRROUTER, "UBNT-AR", "Ubiquiti AirRouter",
+	     ubnt_airrouter_setup);
+
+static struct gpio_led ubnt_unifi_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:dome",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:dome",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_unifi_outdoor_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:front",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:front",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_unifi_outdoor_plus_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:white:front",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:blue:front",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+
+static void __init ubnt_unifi_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_leds_gpio),
+				 ubnt_unifi_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI, "UBNT-UF", "Ubiquiti UniFi",
+	     ubnt_unifi_setup);
+
+
+#define UBNT_UNIFIOD_PRI_PHYMASK	BIT(4)
+#define UBNT_UNIFIOD_2ND_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_unifi_outdoor_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~(UBNT_UNIFIOD_PRI_PHYMASK |
+				 UBNT_UNIFIOD_2ND_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_outdoor_leds_gpio),
+				 ubnt_unifi_outdoor_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI_OUTDOOR, "UBNT-U20",
+	     "Ubiquiti UniFiAP Outdoor",
+	     ubnt_unifi_outdoor_setup);
+
+
+static void __init ubnt_unifi_outdoor_plus_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~(UBNT_UNIFIOD_PRI_PHYMASK |
+				 UBNT_UNIFIOD_2ND_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap9x_pci_get_wmac_data(0)->ubnt_hsr = true;
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_outdoor_plus_leds_gpio),
+				 ubnt_unifi_outdoor_plus_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI_OUTDOOR_PLUS, "UBNT-UOP",
+	     "Ubiquiti UniFiAP Outdoor+",
+	     ubnt_unifi_outdoor_plus_setup);
+
+
+static struct gpio_led ubnt_uap_pro_gpio_leds[] __initdata = {
+	{
+		.name		= "ubnt:white:dome",
+		.gpio		= 12,
+	}, {
+		.name		= "ubnt:blue:dome",
+		.gpio		= 13,
+	}
+};
+
+static struct gpio_keys_button uap_pro_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= 17,
+		.active_low		= 1,
+	}
+};
+
+static struct ar8327_pad_cfg uap_pro_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data uap_pro_ar8327_data = {
+	.pad0_cfg = &uap_pro_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info uap_pro_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "uap_pro",
+		.mdio_addr = 0,
+		.platform_data = &uap_pro_ar8327_data,
+	},
+};
+
+#define UAP_PRO_MAC0_OFFSET		0x0000
+#define UAP_PRO_MAC1_OFFSET		0x0006
+#define UAP_PRO_WMAC_CALDATA_OFFSET	0x1000
+#define UAP_PRO_PCI_CALDATA_OFFSET	0x5000
+
+static void __init ubnt_uap_pro_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_uap_pro_gpio_leds),
+				 ubnt_uap_pro_gpio_leds);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(uap_pro_gpio_keys),
+                                        uap_pro_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(uap_pro_mdio0_info,
+				    ARRAY_SIZE(uap_pro_mdio0_info));
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UAP_PRO, "UAP-PRO", "Ubiquiti UniFi AP Pro",
+	     ubnt_uap_pro_setup);
+
+#define UBNT_XW_GPIO_LED_L1		11
+#define UBNT_XW_GPIO_LED_L2		16
+#define UBNT_XW_GPIO_LED_L3		13
+#define UBNT_XW_GPIO_LED_L4		14
+
+static struct gpio_led ubnt_xw_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:red:link1",
+		.gpio		= UBNT_XW_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:orange:link2",
+		.gpio		= UBNT_XW_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_XW_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_XW_GPIO_LED_L4,
+		.active_low	= 1,
+	},
+};
+
+#define UBNT_ROCKET_TI_GPIO_LED_L1	16
+#define UBNT_ROCKET_TI_GPIO_LED_L2	17
+#define UBNT_ROCKET_TI_GPIO_LED_L3	18
+#define UBNT_ROCKET_TI_GPIO_LED_L4	19
+#define UBNT_ROCKET_TI_GPIO_LED_L5	20
+#define UBNT_ROCKET_TI_GPIO_LED_L6	21
+static struct gpio_led ubnt_rocket_ti_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:link1",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link2",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L4,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link5",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L5,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link6",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L6,
+		.active_low	= 0,
+	},
+};
+
+static void __init ubnt_xw_init(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xw_leds_gpio),
+				 ubnt_xw_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_MII_GMAC0 | AR934X_ETH_CFG_MII_GMAC0_SLAVE);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+}
+
+static void __init ubnt_nano_m_xw_setup(void)
+{
+	ubnt_xw_init();
+
+	/* GMAC0 is connected to an AR8326 switch */
+	ath79_register_mdio(0, ~(BIT(0) | BIT(1) | BIT(5)));
+	ath79_eth0_data.phy_mask = (BIT(0) | BIT(1) | BIT(5));
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(0);
+}
+
+static struct at803x_platform_data ubnt_loco_m_xw_at803x_data = {
+	.has_reset_gpio = 1,
+	.reset_gpio = 0,
+};
+
+static struct mdio_board_info ubnt_loco_m_xw_mdio_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "ubnt_loco_m_xw",
+		.mdio_addr = 1,
+		.platform_data = &ubnt_loco_m_xw_at803x_data,
+	},
+};
+
+static void __init ubnt_loco_m_xw_setup(void)
+{
+	ubnt_xw_init();
+
+	mdiobus_register_board_info(ubnt_loco_m_xw_mdio_info,
+				    ARRAY_SIZE(ubnt_loco_m_xw_mdio_info));
+
+	ath79_register_mdio(0, ~BIT(1));
+	ath79_eth0_data.phy_mask = BIT(1);
+	ath79_register_eth(0);
+}
+
+#define UBNT_LBE_M5_GPIO_LED_LAN		13
+#define UBNT_LBE_M5_GPIO_LED_WLAN		14
+#define UBNT_LBE_M5_GPIO_LED_SYS		16
+
+static struct gpio_led ubnt_lbe_m5_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:lan",
+		.gpio		= UBNT_LBE_M5_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:wlan",
+		.gpio		= UBNT_LBE_M5_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:sys",
+		.gpio		= UBNT_LBE_M5_GPIO_LED_SYS,
+		.active_low	= 1,
+	},
+};
+
+static void __init ubnt_lbe_m5_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_lbe_m5_leds_gpio),
+				 ubnt_lbe_m5_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_xm_gpio_keys),
+					ubnt_xm_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_MII_GMAC0 |
+				   AR934X_ETH_CFG_MII_GMAC0_SLAVE);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	gpio_request_one(0, GPIOF_OUT_INIT_LOW | GPIOF_ACTIVE_LOW |
+			 GPIOF_EXPORT_DIR_FIXED, "SPI nWP");
+
+	mdiobus_register_board_info(ubnt_loco_m_xw_mdio_info,
+				    ARRAY_SIZE(ubnt_loco_m_xw_mdio_info));
+
+	ath79_register_mdio(0, ~BIT(1));
+	ath79_eth0_data.phy_mask = BIT(1);
+	ath79_register_eth(0);
+}
+
+static void __init ubnt_rocket_m_xw_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xw_leds_gpio),
+				 ubnt_xw_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_mdio(0, ~BIT(4));
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+static struct at803x_platform_data ubnt_rocket_m_ti_at803_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+static struct mdio_board_info ubnt_rocket_m_ti_mdio_info[] = {
+		{
+			.bus_id = "ag71xx-mdio.0",
+			.modalias = "ubnt_rocket_m_ti",
+			.mdio_addr = 4,
+			.platform_data = &ubnt_rocket_m_ti_at803_data,
+		},
+};
+
+static void __init ubnt_rocket_m_ti_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rocket_ti_leds_gpio),
+				 ubnt_rocket_ti_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+
+	ap91_pci_init(eeprom + 0x1000, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_setup_ar934x_eth_rx_delay(3, 3);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       eeprom + UAP_PRO_MAC1_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	mdiobus_register_board_info(ubnt_rocket_m_ti_mdio_info,
+			ARRAY_SIZE(ubnt_rocket_m_ti_mdio_info));
+	ath79_register_mdio(0, 0x0);
+
+
+	ath79_eth0_data.phy_mask = BIT(4);
+	/* read out from vendor */
+	ath79_eth0_pll_data.pll_1000 = 0x2000000;
+	ath79_eth0_pll_data.pll_10 = 0x1313;
+	ath79_register_eth(0);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_eth1_data.phy_mask = BIT(3);
+	ath79_register_eth(1);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_UBNT_NANO_M_XW, "UBNT-NM-XW", "Ubiquiti Nanostation M XW",
+	     ubnt_nano_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LBE_M5, "UBNT-LBE-M5", "Ubiquiti Litebeam M5",
+		ubnt_lbe_m5_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LOCO_M_XW, "UBNT-LOCO-XW", "Ubiquiti Loco M XW",
+	     ubnt_loco_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M_XW, "UBNT-RM-XW", "Ubiquiti Rocket M XW",
+	     ubnt_rocket_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M_TI, "UBNT-RM-TI", "Ubiquiti Rocket M TI",
+	     ubnt_rocket_m_ti_setup);
+
+static struct gpio_led ubnt_airgateway_gpio_leds[] __initdata = {
+	{
+		.name	   = "ubnt:blue:wlan",
+		.gpio	   = 0,
+	}, {
+		.name	   = "ubnt:white:status",
+		.gpio	   = 1,
+	},
+};
+
+static struct gpio_keys_button airgateway_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_airgateway_setup(void)
+{
+	u32 t;
+	u8 *mac0 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airgateway_gpio_leds),
+				 ubnt_airgateway_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(airgateway_gpio_keys),
+					airgateway_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac0, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRGW, "UBNT-AGW", "Ubiquiti AirGateway",
+	     ubnt_airgateway_setup);
+
+static struct gpio_led ubnt_airgateway_pro_gpio_leds[] __initdata = {
+	{
+		.name	   = "ubnt:blue:wlan",
+		.gpio	   = 13,
+	}, {
+		.name	   = "ubnt:white:status",
+		.gpio	   = 17,
+	},
+};
+
+
+static struct gpio_keys_button airgateway_pro_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_airgateway_pro_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac0 = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airgateway_pro_gpio_leds),
+				 ubnt_airgateway_pro_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(airgateway_pro_gpio_keys),
+					airgateway_pro_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is left unused in this configuration */
+
+	/* GMAC1 is connected to MAC0 on the internal switch */
+	/* The PoE/WAN port connects to port 5 on the internal switch */
+	/* The LAN port connects to port 4 on the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac0, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRGWP, "UBNT-AGWP", "Ubiquiti AirGateway Pro",
+	     ubnt_airgateway_pro_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-ubnt.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wam250.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wam250.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wam250.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wam250.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-weio.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-weio.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-weio.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-weio.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-whr-hp-g300n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-whr-hp-g300n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-whr-hp-g300n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-whr-hp-g300n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wi2a-ac200i.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wi2a-ac200i.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wi2a-ac200i.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wi2a-ac200i.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wifi-pineapple-nano.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wifi-pineapple-nano.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wifi-pineapple-nano.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wifi-pineapple-nano.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wlae-ag300n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlae-ag300n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wlae-ag300n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlae-ag300n.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlr8100.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlr8100.c
new file mode 100644
index 0000000000..9fc95ab5ff
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wlr8100.c
@@ -0,0 +1,196 @@
+/*
+ * Sitecom X8 AC1750 WLR-8100 board support
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WLR8100_GPIO_LED_USB		4
+#define WLR8100_GPIO_LED_WLAN_5G	12
+#define WLR8100_GPIO_LED_WLAN_2G	13
+#define WLR8100_GPIO_LED_STATUS_RED	14
+#define WLR8100_GPIO_LED_WPS_RED	15
+#define WLR8100_GPIO_LED_STATUS_AMBER	19
+#define WLR8100_GPIO_LED_WPS_GREEN	20
+
+#define WLR8100_GPIO_BTN_WPS		16
+#define WLR8100_GPIO_BTN_RFKILL		21
+
+#define WLR8100_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WLR8100_KEYS_DEBOUNCE_INTERVAL	(3 * WLR8100_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wlr8100_leds_gpio[] __initdata = {
+	{
+		.name		= "wlr8100:amber:status",
+		.gpio		= WLR8100_GPIO_LED_STATUS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:status",
+		.gpio		= WLR8100_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:green:wps",
+		.gpio		= WLR8100_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:wps",
+		.gpio		= WLR8100_GPIO_LED_WPS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:wlan-2g",
+		.gpio		= WLR8100_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:usb",
+		.gpio		= WLR8100_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wlr8100_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WLR8100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WLR8100_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WLR8100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WLR8100_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wlr8100_ar8327_pad0_cfg;
+static struct ar8327_pad_cfg wlr8100_ar8327_pad6_cfg;
+
+static struct ar8327_platform_data wlr8100_ar8327_data = {
+	.pad0_cfg = &wlr8100_ar8327_pad0_cfg,
+	.pad6_cfg = &wlr8100_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info wlr8100_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wlr8100",
+		.mdio_addr = 0,
+		.platform_data = &wlr8100_ar8327_data,
+	},
+};
+
+static void __init wlr8100_common_setup(void)
+{
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wlr8100_leds_gpio),
+				 wlr8100_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WLR8100_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wlr8100_gpio_keys),
+					wlr8100_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac_simple();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(wlr8100_mdio0_info,
+				    ARRAY_SIZE(wlr8100_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected tot eh SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+static void __init wlr8100_010_setup(void)
+{
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	wlr8100_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	wlr8100_ar8327_pad0_cfg.txclk_delay_en = true;
+	wlr8100_ar8327_pad0_cfg.rxclk_delay_en = true;
+	wlr8100_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	wlr8100_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	wlr8100_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	wlr8100_ar8327_pad6_cfg.rxclk_delay_en = true;
+	wlr8100_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	wlr8100_common_setup();
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_WLR8100, "WLR8100",
+	     "Sitecom WLR-8100",
+	     wlr8100_010_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wndap360.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndap360.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wndap360.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndap360.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wndr3700.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr3700.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wndr3700.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr3700.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr4300.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr4300.c
new file mode 100644
index 0000000000..f68307f149
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wndr4300.c
@@ -0,0 +1,211 @@
+/*
+ *  NETGEAR WNDR3700v4/WNDR4300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Ralph Perlich <rpsoft@arcor.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* AR9344 GPIOs */
+#define WNDR4300_GPIO_LED_POWER_GREEN	0
+#define WNDR4300_GPIO_LED_POWER_AMBER	2
+#define WNDR4300_GPIO_LED_USB		13
+#define WNDR4300_GPIO_LED_WAN_GREEN	1
+#define WNDR4300_GPIO_LED_WAN_AMBER	3
+#define WNDR4300_GPIO_LED_WLAN2G	11
+#define WNDR4300_GPIO_LED_WLAN5G	14
+#define WNDR4300_GPIO_LED_WPS_GREEN	16
+#define WNDR4300_GPIO_LED_WPS_AMBER	17
+
+#define WNDR4300_GPIO_BTN_RESET		21
+#define WNDR4300_GPIO_BTN_WIRELESS	15
+#define WNDR4300_GPIO_BTN_WPS		12
+
+/* AR9580 GPIOs */
+#define WNDR4300_GPIO_USB_5V		0
+
+#define WNDR4300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR4300_KEYS_DEBOUNCE_INTERVAL	(3 * WNDR4300_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wndr4300_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDR4300_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:power",
+		.gpio		= WNDR4300_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= WNDR4300_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= WNDR4300_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:usb",
+		.gpio		= WNDR4300_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wps",
+		.gpio		= WNDR4300_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wps",
+		.gpio		= WNDR4300_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wlan2g",
+		.gpio		= WNDR4300_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan5g",
+		.gpio		= WNDR4300_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wndr4300_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Wireless button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_WIRELESS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wndr4300_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wndr4300_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xcb37cb37,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00f3cf00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wndr4300_ar8327_data = {
+	.pad0_cfg = &wndr4300_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wndr4300_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wndr4300_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wndr4300",
+		.mdio_addr = 0,
+		.platform_data = &wndr4300_ar8327_data,
+	},
+};
+
+static void __init wndr4300_setup(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(wndr4300_leds_gpio); i++)
+		ath79_gpio_output_select(wndr4300_leds_gpio[i].gpio,
+					 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndr4300_leds_gpio),
+				 wndr4300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WNDR4300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wndr4300_gpio_keys),
+					wndr4300_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(wndr4300_mdio0_info,
+				    ARRAY_SIZE(wndr4300_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+	ath79_register_usb();
+
+	ath79_register_wmac_simple();
+
+	/* enable power for the USB port */
+	ap9x_pci_setup_wmac_gpio(0, BIT(WNDR4300_GPIO_USB_5V),
+				 BIT(WNDR4300_GPIO_USB_5V));
+
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDR3700_V4, "WNDR3700_V4", "NETGEAR WNDR3700v4",
+	     wndr4300_setup);
+MIPS_MACHINE(ATH79_MACH_WNDR4300, "WNDR4300", "NETGEAR WNDR4300",
+	     wndr4300_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000-v3.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000-v3.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000-v3.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000-v3.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000-v4.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000-v4.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000-v4.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2000.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2000.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2200.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2200.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wnr2200.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wnr2200.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wp543.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wp543.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wp543.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wp543.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpe72.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpe72.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpe72.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpe72.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj342.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj342.c
new file mode 100644
index 0000000000..bd6bcd9715
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj342.c
@@ -0,0 +1,179 @@
+/*
+ * Compex WPJ342 board support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/export.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "pci.h"
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ342_GPIO_LED_STATUS		11
+#define WPJ342_GPIO_LED_SIG1		14
+#define WPJ342_GPIO_LED_SIG2		13
+#define WPJ342_GPIO_LED_SIG3		12
+#define WPJ342_GPIO_LED_SIG4		11
+#define WPJ342_GPIO_BUZZER			15
+
+#define WPJ342_GPIO_BTN_RESET		17
+
+#define WPJ342_KEYS_POLL_INTERVAL	20 /* msecs */
+#define WPJ342_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ342_KEYS_POLL_INTERVAL)
+
+#define WPJ342_MAC0_OFFSET		0x10
+#define WPJ342_MAC1_OFFSET		0x18
+#define WPJ342_WMAC_CALDATA_OFFSET	0x1000
+#define WPJ342_PCIE_CALDATA_OFFSET	0x5000
+
+#define WPJ342_ART_SIZE		0x8000
+
+static struct gpio_led wpj342_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj342:red:sig1",
+		.gpio		= WPJ342_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj342:yellow:sig2",
+		.gpio		= WPJ342_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj342:green:sig3",
+		.gpio		= WPJ342_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj342:green:sig4",
+		.gpio		= WPJ342_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj342:buzzer",
+		.gpio		= WPJ342_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button wpj342_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ342_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ342_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wpj342_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wpj342_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wpj342_ar8327_data = {
+	.pad0_cfg = &wpj342_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wpj342_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wpj342_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wpj342",
+		.mdio_addr = 0,
+		.platform_data = &wpj342_ar8327_data,
+	},
+};
+
+
+static void __init wpj342_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpj342_leds_gpio),
+				wpj342_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WPJ342_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj342_gpio_keys),
+					wpj342_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WPJ342_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(wpj342_mdio0_info,
+				ARRAY_SIZE(wpj342_mdio0_info));
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ342_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + WPJ342_MAC1_OFFSET, 0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_MII_GMAC0);
+
+	/* GMAC0 is connected to an AR8236 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ342, "WPJ342", "Compex WPJ342", wpj342_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj344.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj344.c
new file mode 100644
index 0000000000..38c7e16408
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj344.c
@@ -0,0 +1,170 @@
+/*
+ * Compex WPJ344 board support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ344_GPIO_LED_SIG1	15
+#define WPJ344_GPIO_LED_SIG2	20
+#define WPJ344_GPIO_LED_SIG3	21
+#define WPJ344_GPIO_LED_SIG4	22
+#define WPJ344_GPIO_LED_STATUS	14
+
+#define WPJ344_GPIO_BTN_RESET	12
+
+#define WPJ344_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ344_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ344_KEYS_POLL_INTERVAL)
+
+#define WPJ344_MAC0_OFFSET		0x10
+#define WPJ344_MAC1_OFFSET		0x18
+#define WPJ344_WMAC_CALDATA_OFFSET	0x1000
+#define WPJ344_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led wpj344_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj344:green:status",
+		.gpio		= WPJ344_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:red:sig1",
+		.gpio		= WPJ344_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:yellow:sig2",
+		.gpio		= WPJ344_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:green:sig3",
+		.gpio		= WPJ344_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:green:sig4",
+		.gpio		= WPJ344_GPIO_LED_SIG4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpj344_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ344_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ344_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wpj344_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_dis = true,
+};
+
+static struct ar8327_led_cfg wpj344_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wpj344_ar8327_data = {
+	.pad0_cfg = &wpj344_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wpj344_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wpj344_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wpj344",
+		.mdio_addr = 0,
+		.platform_data = &wpj344_ar8327_data,
+	},
+};
+
+static void __init wpj344_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpj344_leds_gpio),
+				 wpj344_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WPJ344_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj344_gpio_keys),
+					wpj344_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WPJ344_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(wpj344_mdio0_info,
+					ARRAY_SIZE(wpj344_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ344_MAC0_OFFSET, 0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ344, "WPJ344", "Compex WPJ344", wpj344_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpj531.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj531.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpj531.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj531.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj558.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj558.c
new file mode 100644
index 0000000000..0f923b481f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj558.c
@@ -0,0 +1,171 @@
+/*
+ * Compex WPJ558 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ558_GPIO_LED_SIG1	14
+#define WPJ558_GPIO_LED_SIG2	15
+#define WPJ558_GPIO_LED_SIG3	22
+#define WPJ558_GPIO_LED_SIG4	23
+#define WPJ558_GPIO_BUZZER		4
+
+#define WPJ558_GPIO_BTN_RESET	17
+
+#define WPJ558_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ558_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ558_KEYS_POLL_INTERVAL)
+
+#define WPJ558_MAC_OFFSET		0x10
+#define WPJ558_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led wpj558_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj558:red:sig1",
+		.gpio		= WPJ558_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:yellow:sig2",
+		.gpio		= WPJ558_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:green:sig3",
+		.gpio		= WPJ558_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:green:sig4",
+		.gpio		= WPJ558_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:buzzer",
+		.gpio		= WPJ558_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button wpj558_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ558_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ558_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wpj558_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_pad_cfg wpj558_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data wpj558_ar8327_data = {
+	.pad0_cfg = &wpj558_ar8327_pad0_cfg,
+	.pad6_cfg = &wpj558_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info wpj558_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wpj558",
+		.mdio_addr = 0,
+		.platform_data = &wpj558_ar8327_data,
+	},
+};
+
+static void __init wpj558_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpj558_leds_gpio),
+					wpj558_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WPJ558_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj558_gpio_keys),
+					wpj558_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WPJ558_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(wpj558_mdio0_info,
+					ARRAY_SIZE(wpj558_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ558_MAC_OFFSET, 0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ558, "WPJ558", "Compex WPJ558", wpj558_setup);
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj563.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj563.c
new file mode 100644
index 0000000000..d4152c3091
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wpj563.c
@@ -0,0 +1,151 @@
+/*
+ * Compex WPJ563 board support
+ *
+ * Copyright (c) 2015 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+#define WPJ563_GPIO_LED_SIG1     1
+#define WPJ563_GPIO_LED_SIG2     5
+#define WPJ563_GPIO_LED_SIG3     6
+#define WPJ563_GPIO_LED_SIG4     7
+#define WPJ563_GPIO_BUZZER      19
+
+#define WPJ563_GPIO_BTN_RESET            2
+#define WPJ563_KEYS_POLL_INTERVAL        20     /* msecs */
+#define WPJ563_KEYS_DEBOUNCE_INTERVAL    (3 * WPJ563_KEYS_POLL_INTERVAL)
+
+#define WPJ563_MAC0_OFFSET               0x10
+#define WPJ563_MAC1_OFFSET               0x18
+#define WPJ563_WMAC_CALDATA_OFFSET       0x1000
+
+static struct gpio_led WPJ563_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj563:green:sig1",
+		.gpio		= WPJ563_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj563:green:sig2",
+		.gpio		= WPJ563_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj563:green:sig3",
+		.gpio		= WPJ563_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj563:green:sig4",
+		.gpio		= WPJ563_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj563:buzzer",
+		.gpio		= WPJ563_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button WPJ563_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ563_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ563_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg WPJ563_ar8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data WPJ563_ar8337_data = {
+	.pad0_cfg = &WPJ563_ar8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info WPJ563_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "WPJ563",
+		.mdio_addr = 0,
+		.platform_data = &WPJ563_ar8337_data,
+	},
+};
+
+static void __init WPJ563_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(WPJ563_leds_gpio),
+				 WPJ563_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WPJ563_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(WPJ563_gpio_keys),
+					WPJ563_gpio_keys);
+
+	ath79_register_usb();
+	
+	ath79_register_wmac(art + WPJ563_WMAC_CALDATA_OFFSET, NULL);
+	
+	ath79_register_pci();
+
+	mdiobus_register_board_info(WPJ563_mdio0_info,
+				    ARRAY_SIZE(WPJ563_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ563_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + WPJ563_MAC1_OFFSET, 0);
+
+	/* GMAC0 is connected to an QCA8334 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ563, "WPJ563", "Compex WPJ563", WPJ563_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wrt160nl.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrt160nl.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wrt160nl.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrt160nl.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wrt400n.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrt400n.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wrt400n.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrt400n.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wrtnode2q.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrtnode2q.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wrtnode2q.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wrtnode2q.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-450hp2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-450hp2.c
new file mode 100644
index 0000000000..6fa431cbf3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-450hp2.c
@@ -0,0 +1,222 @@
+/*
+ * Buffalo WZR-450HP2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WZR_450HP2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZR_450HP2_KEYS_DEBOUNCE_INTERVAL (3 * WZR_450HP2_KEYS_POLL_INTERVAL)
+
+#define WZR_450HP2_WMAC_CALDATA_OFFSET	0x1000
+
+static struct mtd_partition wzrhpg450h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x0ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0050000,
+		.size		= 0x0f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x0fe0000,
+		.size		= 0x0010000,
+	}
+};
+
+static struct flash_platform_data wzr_450hp2_flash_data = {
+	.parts		= wzrhpg450h_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg450h_partitions),
+};
+
+static struct gpio_led wzr_450hp2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:green:wps",
+		.gpio		= 3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:system",
+		.gpio		= 20,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:wlan",
+		.gpio		= 18,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzr_450hp2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZR_450HP2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 17,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WZR_450HP2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 21,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info wzr_450hp2_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "buffalo:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "buffalo:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "buffalo:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "buffalo:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "buffalo:green:wan"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg wzr_450hp2_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg wzr_450hp2_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wzr_450hp2_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wzr_450hp2_ar8327_data = {
+	.pad0_cfg = &wzr_450hp2_ar8327_pad0_cfg,
+	.pad6_cfg = &wzr_450hp2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wzr_450hp2_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(wzr_450hp2_leds_ar8327),
+	.leds = wzr_450hp2_leds_ar8327,
+};
+
+static struct mdio_board_info wzr_450hp2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "wzr_450hp2",
+		.mdio_addr = 0,
+		.platform_data = &wzr_450hp2_ar8327_data,
+	},
+};
+
+static void __init wzr_450hp2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac_wan = art;
+	u8 *mac_lan = mac_wan + ETH_ALEN;
+
+	ath79_register_m25p80(&wzr_450hp2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzr_450hp2_leds_gpio),
+				 wzr_450hp2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WZR_450HP2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzr_450hp2_gpio_keys),
+					wzr_450hp2_gpio_keys);
+
+	ath79_register_wmac(art + WZR_450HP2_WMAC_CALDATA_OFFSET, mac_lan);
+
+	mdiobus_register_board_info(wzr_450hp2_mdio0_info,
+				    ARRAY_SIZE(wzr_450hp2_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac_wan, 0);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac_lan, 0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_450HP2, "WZR-450HP2",
+	     "Buffalo WZR-450HP2", wzr_450hp2_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-ag300h.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-ag300h.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-ag300h.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-ag300h.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g300nh.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g300nh.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g300nh.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g300nh.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g300nh2.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g300nh2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g300nh2.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g300nh2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g450h.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g450h.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-hp-g450h.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-wzr-hp-g450h.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-z1.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-z1.c
new file mode 100644
index 0000000000..7756b8773f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-z1.c
@@ -0,0 +1,165 @@
+/*
+ *  Cisco Meraki Z1 board support
+ *
+ *  Copyright (C) 2016 Chris Blake <chrisrblake93@gmail.com>
+ *  Copyright (C) 2016 Christian Lamparter <chunkeey@googlemail.com>
+ *
+ *  Based on Cisco Meraki GPL Release r23-20150601 Z1 Device Config
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/leds-nu801.h>
+#include <linux/firmware.h>
+#include <linux/pci.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "dev-ap9x-pci.h"
+#include "machtypes.h"
+
+#define Z1_GPIO_LED_POWER_ORANGE	17
+
+#define Z1_GPIO_NU801_CKI		14
+#define Z1_GPIO_NU801_SDI		15
+
+#define Z1_GPIO_XLNA0			18
+#define Z1_GPIO_XLNA1			19
+
+#define Z1_GPIO_BTN_RESET		12
+#define Z1_KEYS_POLL_INTERVAL		20  /* msecs */
+#define Z1_KEYS_DEBOUNCE_INTERVAL	(3 * Z1_KEYS_POLL_INTERVAL)
+
+#define Z1_ETH_SWITCH_PHY		0
+
+static struct gpio_led Z1_leds_gpio[] __initdata = {
+	{
+		.name = "z1:orange:power",
+		.gpio = Z1_GPIO_LED_POWER_ORANGE,
+		.active_low  = 1,
+	},
+};
+
+static struct gpio_keys_button Z1_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = Z1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio    = Z1_GPIO_BTN_RESET,
+		.active_low  = 1,
+	},
+};
+
+static struct led_nu801_template tricolor_led_template = {
+	.device_name = "z1",
+	.name = "tricolor",
+	.num_leds = 1,
+	.cki = Z1_GPIO_NU801_CKI,
+	.sdi = Z1_GPIO_NU801_SDI,
+	.lei = -1,
+	.ndelay = 500,
+	.init_brightness = {
+		LED_OFF,
+		LED_OFF,
+		LED_OFF,
+	},
+	.default_trigger = "none",
+};
+
+static struct led_nu801_platform_data tricolor_led_data = {
+	.num_controllers = 1,
+	.template = &tricolor_led_template,
+};
+
+static struct platform_device tricolor_leds = {
+	.name = "leds-nu801",
+	.id = -1,
+	.dev.platform_data = &tricolor_led_data,
+};
+
+static struct ar8327_pad_cfg z1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data z1_ar8327_data = {
+	.pad0_cfg = &z1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info z1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.modalias = "z1",
+		.mdio_addr = Z1_ETH_SWITCH_PHY,
+		.platform_data = &z1_ar8327_data,
+	},
+};
+
+static void __init z1_setup(void)
+{
+	/* NAND */
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_SOFT_BCH);
+	ath79_register_nfc();
+
+	/* Eth Config */
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* MDIO Interface */
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(z1_mdio0_info,
+				    ARRAY_SIZE(z1_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(Z1_ETH_SWITCH_PHY);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	/* XLNA */
+	ath79_wmac_set_ext_lna_gpio(0, Z1_GPIO_XLNA0);
+	ath79_wmac_set_ext_lna_gpio(1, Z1_GPIO_XLNA1);
+
+	/* LEDs and Buttons */
+	platform_device_register(&tricolor_leds);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(Z1_leds_gpio),
+				 Z1_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, Z1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(Z1_gpio_keys),
+					Z1_gpio_keys);
+
+	/* USB */
+	ath79_register_usb();
+
+	/* Wireless */
+	ath79_register_wmac_simple();
+	ap91_pci_init_simple();
+}
+MIPS_MACHINE(ATH79_MACH_Z1, "Z1", "Meraki Z1", z1_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-zbt-we1526.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-zbt-we1526.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-zbt-we1526.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-zbt-we1526.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-zcn-1523h.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-zcn-1523h.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-zcn-1523h.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/mach-zcn-1523h.c
diff --git a/target/linux/ar71xx/files-4.14/arch/mips/ath79/machtypes.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/machtypes.h
new file mode 100644
index 0000000000..9f4b24bfde
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/arch/mips/ath79/machtypes.h
@@ -0,0 +1,374 @@
+/*
+ *  Atheros AR71XX/AR724X/AR913X machine type definitions
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_MACHTYPE_H
+#define _ATH79_MACHTYPE_H
+
+#include <asm/mips_machine.h>
+
+enum ath79_mach_type {
+	ATH79_MACH_GENERIC_OF = -1,	/* Device tree board */
+	ATH79_MACH_GENERIC = 0,
+	ATH79_MACH_A40,				/* OpenMesh A40 */
+	ATH79_MACH_A60,				/* OpenMesh A60 */
+	ATH79_MACH_WI2A_AC200I,			/* Nokia WI2A-AC200i */
+	ATH79_MACH_ALFA_AP120C,			/* ALFA Network AP120C board */
+	ATH79_MACH_ALFA_AP96,			/* ALFA Network AP96 board */
+	ATH79_MACH_ALFA_NX,			/* ALFA Network N2/N5 board */
+	ATH79_MACH_ALL0258N,			/* Allnet ALL0258N */
+	ATH79_MACH_ALL0305,			/* Allnet ALL0305 */
+	ATH79_MACH_ALL0315N,			/* Allnet ALL0315N */
+	ATH79_MACH_ANTMINER_S1,			/* Antminer S1 */
+	ATH79_MACH_ANTMINER_S3,			/* Antminer S3 */
+	ATH79_MACH_ANTROUTER_R1,		/* Antrouter R1 */
+	ATH79_MACH_AP121,			/* Atheros AP121 reference board */
+	ATH79_MACH_AP121_MINI,			/* Atheros AP121-MINI reference board */
+	ATH79_MACH_AP121F,			/* ALFA Network AP121F */
+	ATH79_MACH_AP132,			/* Atheros AP132 reference board */
+	ATH79_MACH_AP135_020,			/* Atheros AP135-020 reference board */
+	ATH79_MACH_AP136_010,			/* Atheros AP136-010 reference board */
+	ATH79_MACH_AP136_020,			/* Atheros AP136-020 reference board */
+	ATH79_MACH_AP143,			/* Atheros AP143 reference board */
+	ATH79_MACH_AP147_010,			/* Atheros AP147-010 reference board */
+	ATH79_MACH_AP152,			/* Atheros AP152 reference board */
+	ATH79_MACH_AP531B0,			/* Rockeetech AP531B0 */
+	ATH79_MACH_AP90Q,			/* YunCore AP80Q/AP90Q */
+	ATH79_MACH_AP91_5G,			/* ALFA Network AP91-5G */
+	ATH79_MACH_AP96,			/* Atheros AP96 */
+	ATH79_MACH_AP81,			/* Atheros AP81 reference board */
+	ATH79_MACH_ARCHER_C25_V1,		/* TP-LINK Archer C25 V1 board */
+	ATH79_MACH_ARCHER_C5,			/* TP-LINK Archer C5 board */
+	ATH79_MACH_ARCHER_C58_V1,		/* TP-LINK Archer C58 V1 board */
+	ATH79_MACH_ARCHER_C59_V1,		/* TP-LINK Archer C59 V1 board */
+	ATH79_MACH_ARCHER_C60_V1,		/* TP-LINK Archer C60 V1 board */
+	ATH79_MACH_ARCHER_C60_V2,		/* TP-LINK Archer C60 V2 board */
+	ATH79_MACH_ARCHER_C7,			/* TP-LINK Archer C7 board */
+	ATH79_MACH_ARCHER_C7_V2,		/* TP-LINK Archer C7 V2 board */
+	ATH79_MACH_ARCHER_C7_V4,		/* TP-LINK Archer C7 V4 board */
+	ATH79_MACH_ARDUINO_YUN,			/* Yun */
+	ATH79_MACH_AW_NR580,			/* AzureWave AW-NR580 */
+	ATH79_MACH_BHR_4GRV2,			/* Buffalo BHR-4GRV2 */
+	ATH79_MACH_BHU_BXU2000N2_A1,		/* BHU BXU2000n-2 A1 */
+	ATH79_MACH_BSB,				/* Smart Electronics Black Swift board */
+	ATH79_MACH_C55,				/* AirTight Networks C-55 */
+	ATH79_MACH_C60,				/* AirTight Networks C-60 */
+	ATH79_MACH_CAP324,			/* PowerCloud CAP324 */
+	ATH79_MACH_CAP4200AG,			/* Senao CAP4200AG */
+	ATH79_MACH_CARAMBOLA2,			/* 8devices Carambola2 */
+	ATH79_MACH_CF_E316N_V2,			/* COMFAST CF-E316N v2 */
+	ATH79_MACH_CF_E320N_V2,			/* COMFAST CF-E320N v2 */
+	ATH79_MACH_CF_E355AC,			/* COMFAST CF-E355AC */
+	ATH79_MACH_CF_E355AC_V2,		/* COMFAST CF-E355AC v2*/
+	ATH79_MACH_CF_E375AC,			/* COMFAST CF-E375AC */
+	ATH79_MACH_CF_E380AC_V1,		/* COMFAST CF-E380AC v1 */
+	ATH79_MACH_CF_E380AC_V2,		/* COMFAST CF-E380AC v2 */
+	ATH79_MACH_CF_E385AC,			/* COMFAST CF-E385AC */
+	ATH79_MACH_CF_E520N,			/* COMFAST CF-E520N */
+	ATH79_MACH_CF_E530N,			/* COMFAST CF-E530N */
+	ATH79_MACH_CPE210,			/* TP-LINK CPE210 */
+	ATH79_MACH_CPE505N,			/* P&W CPE505N */
+	ATH79_MACH_CPE510,			/* TP-LINK CPE510 */
+	ATH79_MACH_CPE830,			/* YunCore CPE830 */
+	ATH79_MACH_CPE870,			/* YunCore CPE870 */
+	ATH79_MACH_CR3000,			/* PowerCloud CR3000 */
+	ATH79_MACH_CR5000,			/* PowerCloud CR5000 */
+	ATH79_MACH_DAP_1330_A1,			/* D-Link DAP-1330 rev. A1 */
+	ATH79_MACH_DAP_2695_A1,			/* D-Link DAP-2695 rev. A1 */
+	ATH79_MACH_DB120,			/* Atheros DB120 reference board */
+	ATH79_MACH_DGL_5500_A1,			/* D-link DGL-5500 rev. A1 */
+	ATH79_MACH_DHP_1565_A1,			/* D-Link DHP-1565 rev. A1 */
+	ATH79_MACH_DIR_505_A1,			/* D-Link DIR-505 rev. A1 */
+	ATH79_MACH_DIR_600_A1,			/* D-Link DIR-600 rev. A1 */
+	ATH79_MACH_DIR_615_C1,			/* D-Link DIR-615 rev. C1 */
+	ATH79_MACH_DIR_615_E1,			/* D-Link DIR-615 rev. E1 */
+	ATH79_MACH_DIR_615_E4,			/* D-Link DIR-615 rev. E4 */
+	ATH79_MACH_DIR_615_I1,			/* D-Link DIR-615 rev. I1 */
+	ATH79_MACH_DIR_825_B1,			/* D-Link DIR-825 rev. B1 */
+	ATH79_MACH_DIR_825_C1,			/* D-Link DIR-825 rev. C1 */
+	ATH79_MACH_DIR_835_A1,			/* D-Link DIR-835 rev. A1 */
+	ATH79_MACH_DIR_869_A1,			/* D-Link DIR-869 rev. A1 */
+	ATH79_MACH_DLAN_HOTSPOT,		/* devolo dLAN Hotspot */
+	ATH79_MACH_DLAN_PRO_1200_AC,		/* devolo dLAN pro 1200+ WiFi ac*/
+	ATH79_MACH_DLAN_PRO_500_WP,		/* devolo dLAN pro 500 Wireless+ */
+	ATH79_MACH_DOMYWIFI_DW33D,		/* DomyWifi DW33D */
+	ATH79_MACH_DR342,			/* Wallys DR342 */
+	ATH79_MACH_DR344,			/* Wallys DR344 */
+	ATH79_MACH_DR531,			/* Wallys DR531 */
+	ATH79_MACH_DRAGINO2,			/* Dragino Version 2 */
+	ATH79_MACH_E1700AC_V2,			/* Qxwlan E1700AC v2 */
+	ATH79_MACH_E600G_V2,			/* Qxwlan E600G v2 */
+	ATH79_MACH_E600GAC_V2,			/* Qxwlan E600GAC v2 */
+	ATH79_MACH_EAP120,			/* TP-LINK EAP120 */
+	ATH79_MACH_EAP300V2,			/* EnGenius EAP300 v2 */
+	ATH79_MACH_EAP7660D,			/* Senao EAP7660D */
+	ATH79_MACH_EBR_2310_C1,			/* D-link EBR-2310 rev. C1 */
+	ATH79_MACH_EL_M150,			/* EasyLink EL-M150 */
+	ATH79_MACH_EL_MINI,			/* EasyLink EL-MINI */
+	ATH79_MACH_ENS202EXT,			/* EnGenius ENS202EXT */
+	ATH79_MACH_EPG5000,			/* EnGenius EPG5000 */
+	ATH79_MACH_ESR1750,			/* EnGenius ESR1750 */
+	ATH79_MACH_ESR900,			/* EnGenius ESR900 */
+	ATH79_MACH_EW_BALIN,			/* embedded wireless Balin Platform */
+	ATH79_MACH_EW_DORIN,			/* embedded wireless Dorin Platform */
+	ATH79_MACH_EW_DORIN_ROUTER,		/* embedded wireless Dorin Router Platform */
+	ATH79_MACH_F9K1115V2,			/* Belkin AC1750DB */
+	ATH79_MACH_FRITZ300E,			/* AVM FRITZ!WLAN Repeater 300E */
+	ATH79_MACH_FRITZ4020,			/* AVM FRITZ!Box 4020 */
+	ATH79_MACH_GL_AR150,			/* GL-AR150 support */
+	ATH79_MACH_GL_AR300,			/* GL-AR300 */
+	ATH79_MACH_GL_AR300M,			/* GL-AR300M */
+	ATH79_MACH_GL_AR750,			/* GL.iNet GL-AR750 */
+	ATH79_MACH_GL_AR750S,			/* GL.iNet GL-AR750S */
+	ATH79_MACH_GL_DOMINO,			/* Domino */
+	ATH79_MACH_GL_INET,			/* GL-CONNECT GL-INET */
+	ATH79_MACH_GL_MIFI,			/* GL-MIFI support */
+	ATH79_MACH_GL_USB150,			/* GL.iNet GL-USB150 */
+	ATH79_MACH_GS_MINIBOX_V1,		/* GainStrong MiniBox V1.0 */
+	ATH79_MACH_GS_OOLITE_V1,		/* GainStrong Oolite V1.0 */
+	ATH79_MACH_GS_OOLITE_V5_2,		/* GainStrong Oolite V5.2 */
+	ATH79_MACH_GS_OOLITE_V5_2_DEV,		/* GainStrong Oolite V5.2-Dev */
+	ATH79_MACH_HIVEAP_121,			/* Aerohive HiveAP-121*/
+	ATH79_MACH_HIWIFI_HC6361,		/* HiWiFi HC6361 */
+	ATH79_MACH_HORNET_UB,			/* ALFA Networks Hornet-UB */
+	ATH79_MACH_JA76PF,			/* jjPlus JA76PF */
+	ATH79_MACH_JA76PF2,			/* jjPlus JA76PF2 */
+	ATH79_MACH_JWAP003,			/* jjPlus JWAP003 */
+	ATH79_MACH_JWAP230,			/* jjPlus JWAP230 */
+	ATH79_MACH_LAN_TURTLE,			/* Hak5 LAN Turtle */
+	ATH79_MACH_LIMA,			/* 8devices Lima */
+	ATH79_MACH_MC_MAC1200R,			/* MERCURY MAC1200R */
+	ATH79_MACH_MR12,			/* Cisco Meraki MR12 */
+	ATH79_MACH_MR16,			/* Cisco Meraki MR16 */
+	ATH79_MACH_MR1750,			/* OpenMesh MR1750 */
+	ATH79_MACH_MR1750V2,			/* OpenMesh MR1750v2 */
+	ATH79_MACH_MR18,			/* Cisco Meraki MR18 */
+	ATH79_MACH_MR600,			/* OpenMesh MR600 */
+	ATH79_MACH_MR600V2,			/* OpenMesh MR600v2 */
+	ATH79_MACH_MR900,			/* OpenMesh MR900 */
+	ATH79_MACH_MR900v2,			/* OpenMesh MR900v2 */
+	ATH79_MACH_MYNET_N600,			/* WD My Net N600 */
+	ATH79_MACH_MYNET_N750,			/* WD My Net N750 */
+	ATH79_MACH_MYNET_REXT,			/* WD My Net Wi-Fi Range Extender */
+	ATH79_MACH_MZK_W04NU,			/* Planex MZK-W04NU */
+	ATH79_MACH_MZK_W300NH,			/* Planex MZK-W300NH */
+	ATH79_MACH_N5Q,				/* ALFA Network N5Q */
+	ATH79_MACH_NBG460N,			/* Zyxel NBG460N/550N/550NH */
+	ATH79_MACH_NBG6616,			/* Zyxel NBG6616 */
+	ATH79_MACH_NBG6716,			/* Zyxel NBG6716 */
+	ATH79_MACH_OM2P,			/* OpenMesh OM2P */
+	ATH79_MACH_OM2Pv2,			/* OpenMesh OM2Pv2 */
+	ATH79_MACH_OM2Pv4,			/* OpenMesh OM2Pv4 */
+	ATH79_MACH_OM2P_HS,			/* OpenMesh OM2P-HS */
+	ATH79_MACH_OM2P_HSv2,			/* OpenMesh OM2P-HSv2 */
+	ATH79_MACH_OM2P_HSv3,			/* OpenMesh OM2P-HSv3 */
+	ATH79_MACH_OM2P_HSv4,			/* OpenMesh OM2P-HSv4 */
+	ATH79_MACH_OM2P_LC,			/* OpenMesh OM2P-LC */
+	ATH79_MACH_OM5P,			/* OpenMesh OM5P */
+	ATH79_MACH_OM5P_AC,			/* OpenMesh OM5P-AC */
+	ATH79_MACH_OM5P_ACv2,			/* OpenMesh OM5P-ACv2 */
+	ATH79_MACH_OM5P_AN,			/* OpenMesh OM5P-AN */
+	ATH79_MACH_OMY_G1,			/* OMYlink OMY-G1 */
+	ATH79_MACH_OMY_X1,			/* OMYlink OMY-X1 */
+	ATH79_MACH_ONION_OMEGA,			/* ONION OMEGA */
+	ATH79_MACH_PACKET_SQUIRREL,		/* Hak5 Packet Squirrel */
+	ATH79_MACH_PB42,			/* Atheros PB42 */
+	ATH79_MACH_PB44,			/* Atheros PB44 reference board */
+	ATH79_MACH_PQI_AIR_PEN,			/* PQI Air Pen */
+	ATH79_MACH_QIHOO_C301,			/* Qihoo 360 C301 */
+	ATH79_MACH_R36A,			/* ALFA Network R36A */
+	ATH79_MACH_R602N,			/* P&W R602N */
+	ATH79_MACH_R6100,			/* NETGEAR R6100 */
+	ATH79_MACH_RAMBUTAN,			/* 8devices Rambutan */
+	ATH79_MACH_RB_2011G,			/* Mikrotik RouterBOARD 2011UAS-2HnD */
+	ATH79_MACH_RB_2011L,			/* Mikrotik RouterBOARD 2011L */
+	ATH79_MACH_RB_2011R5,			/* Mikrotik RouterBOARD 2011UiAS(-2Hnd) */
+	ATH79_MACH_RB_2011US,			/* Mikrotik RouterBOARD 2011UAS */
+	ATH79_MACH_RB_411,			/* MikroTik RouterBOARD 411/411A/411AH */
+	ATH79_MACH_RB_411U,			/* MikroTik RouterBOARD 411U */
+	ATH79_MACH_RB_433,			/* MikroTik RouterBOARD 433/433AH */
+	ATH79_MACH_RB_433U,			/* MikroTik RouterBOARD 433UAH */
+	ATH79_MACH_RB_435G,			/* MikroTik RouterBOARD 435G */
+	ATH79_MACH_RB_450,			/* MikroTik RouterBOARD 450 */
+	ATH79_MACH_RB_450G,			/* MikroTik RouterBOARD 450G */
+	ATH79_MACH_RB_493,			/* Mikrotik RouterBOARD 493/493AH */
+	ATH79_MACH_RB_493G,			/* Mikrotik RouterBOARD 493G */
+	ATH79_MACH_RB_711GR100,			/* Mikrotik RouterBOARD 911/912 boards */
+	ATH79_MACH_RB_750,			/* MikroTik RouterBOARD 750 */
+	ATH79_MACH_RB_750G_R3,			/* MikroTik RouterBOARD 750GL */
+	ATH79_MACH_RB_750UPR2,			/* MikroTik RouterBOARD 750UP r2 */
+	ATH79_MACH_RB_751,			/* MikroTik RouterBOARD 751 */
+	ATH79_MACH_RB_751G,			/* Mikrotik RouterBOARD 751G */
+	ATH79_MACH_RB_911L,			/* Mikrotik RouterBOARD 911-2Hn/911-5Hn boards */
+	ATH79_MACH_RB_922GS,			/* Mikrotik RouterBOARD 911/922GS boards */
+	ATH79_MACH_RB_941,			/* MikroTik RouterBOARD 941-2nD */
+	ATH79_MACH_RB_951G,			/* Mikrotik RouterBOARD 951G */
+	ATH79_MACH_RB_951U,			/* Mikrotik RouterBOARD 951Ui-2HnD */
+	ATH79_MACH_RB_952,			/* MikroTik RouterBOARD 951Ui-2nD / 952Ui-5ac2nD */
+	ATH79_MACH_RB_962,			/* MikroTik RouterBOARD 962UiGS-5HacT2HnT */
+	ATH79_MACH_RB_CAP,			/* Mikrotik RouterBOARD cAP2nD */
+	ATH79_MACH_RB_LHG5,			/* Mikrotik RouterBOARD LHG5 */
+	ATH79_MACH_RB_MAP,			/* Mikrotik RouterBOARD mAP2nD */
+	ATH79_MACH_RB_MAPL,			/* Mikrotik RouterBOARD mAP L-2nD */
+	ATH79_MACH_RB_WAP,			/* Mikrotik RouterBOARD wAP2nD */
+	ATH79_MACH_RB_WAPAC,			/* Mikrotik RouterBOARD wAPG-5HacT2HnD */
+	ATH79_MACH_RB_SXTLITE2ND,		/* Mikrotik RouterBOARD SXT Lite 2nD */
+	ATH79_MACH_RB_SXTLITE5ND,		/* Mikrotik RouterBOARD SXT Lite 5nD */
+	ATH79_MACH_RE355,			/* TP-LINK RE355 */
+	ATH79_MACH_RE450,			/* TP-LINK RE450 */
+	ATH79_MACH_RME_EG200,			/* eTactica EG200 */
+	ATH79_MACH_RUT9XX,			/* Teltonika RUT900 series */
+	ATH79_MACH_RW2458N,			/* Redwave RW2458N */
+	ATH79_MACH_SC1750,			/* Abicom SC1750 */
+	ATH79_MACH_SC300M,			/* Abicom SC300M */
+	ATH79_MACH_SC450,			/* Abicom SC450 */
+	ATH79_MACH_SMART_300,			/* NC-LINK SMART-300 */
+	ATH79_MACH_SOM9331,			/* OpenEmbed SOM9331 */
+	ATH79_MACH_SR3200,			/* YunCore SR3200 */
+	ATH79_MACH_T830,			/* YunCore T830 */
+	ATH79_MACH_TELLSTICK_ZNET_LITE,		/* TellStick ZNet Lite */
+	ATH79_MACH_TEW_632BRP,			/* TRENDnet TEW-632BRP */
+	ATH79_MACH_TEW_673GRU,			/* TRENDnet TEW-673GRU */
+	ATH79_MACH_TEW_712BR,			/* TRENDnet TEW-712BR */
+	ATH79_MACH_TEW_732BR,			/* TRENDnet TEW-732BR */
+	ATH79_MACH_TEW_823DRU,			/* TRENDnet TEW-823DRU */
+	ATH79_MACH_TL_MR10U,			/* TP-LINK TL-MR10U */
+	ATH79_MACH_TL_MR11U,			/* TP-LINK TL-MR11U */
+	ATH79_MACH_TL_MR13U,			/* TP-LINK TL-MR13U */
+	ATH79_MACH_TL_MR3020,			/* TP-LINK TL-MR3020 */
+	ATH79_MACH_TL_MR3040,			/* TP-LINK TL-MR3040 */
+	ATH79_MACH_TL_MR3040_V2,		/* TP-LINK TL-MR3040 v2 */
+	ATH79_MACH_TL_MR3220,			/* TP-LINK TL-MR3220 */
+	ATH79_MACH_TL_MR3220_V2,		/* TP-LINK TL-MR3220 v2 */
+	ATH79_MACH_TL_MR3420,			/* TP-LINK TL-MR3420 */
+	ATH79_MACH_TL_MR3420_V2,		/* TP-LINK TL-MR3420 v2 */
+	ATH79_MACH_TL_MR6400,			/* TP-LINK TL-MR6400 */
+	ATH79_MACH_TL_WA701ND_V2,		/* TP-LINK TL-WA701ND v2 */
+	ATH79_MACH_TL_WA7210N_V2,		/* TP-LINK TL-WA7210N v2 */
+	ATH79_MACH_TL_WA750RE,			/* TP-LINK TL-WA750RE */
+	ATH79_MACH_TL_WA7510N_V1,		/* TP-LINK TL-WA7510N v1 */
+	ATH79_MACH_TL_WA801ND_V2,		/* TP-LINK TL-WA801ND v2 */
+	ATH79_MACH_TL_WA801ND_V3,		/* TP-LINK TL-WA801ND v3 */
+	ATH79_MACH_TL_WA830RE_V2,		/* TP-LINK TL-WA830RE v2 */
+	ATH79_MACH_TL_WA850RE,			/* TP-LINK TL-WA850RE */
+	ATH79_MACH_TL_WA850RE_V2,		/* TP-LINK TL-WA850RE v2 */
+	ATH79_MACH_TL_WA855RE_V1,		/* TP-LINK TL-WA855RE v1 */
+	ATH79_MACH_TL_WA860RE,			/* TP-LINK TL-WA860RE */
+	ATH79_MACH_TL_WA901ND,			/* TP-LINK TL-WA901ND */
+	ATH79_MACH_TL_WA901ND_V2,		/* TP-LINK TL-WA901ND v2 */
+	ATH79_MACH_TL_WA901ND_V3,		/* TP-LINK TL-WA901ND v3 */
+	ATH79_MACH_TL_WA901ND_V4,		/* TP-LINK TL-WA901ND v4 */
+	ATH79_MACH_TL_WA901ND_V5,		/* TP-LINK TL-WA901ND v5 */
+	ATH79_MACH_TL_WDR3320_V2,		/* TP-LINK TL-WDR3320 v2 */
+	ATH79_MACH_TL_WDR3500,			/* TP-LINK TL-WDR3500 */
+	ATH79_MACH_TL_WDR4300,			/* TP-LINK TL-WDR4300 */
+	ATH79_MACH_TL_WDR4900_V2,		/* TP-LINK TL-WDR4900 v2 */
+	ATH79_MACH_TL_WDR6500_V2,		/* TP-LINK TL-WDR6500 v2 */
+	ATH79_MACH_TL_WPA8630,			/* TP-Link TL-WPA8630 */
+	ATH79_MACH_TL_WR1041N_V2,		/* TP-LINK TL-WR1041N v2 */
+	ATH79_MACH_TL_WR1043N_V5,		/* TP-LINK TL-WR1043N v5 */
+	ATH79_MACH_TL_WR1043ND,			/* TP-LINK TL-WR1043ND */
+	ATH79_MACH_TL_WR1043ND_V2,		/* TP-LINK TL-WR1043ND v2 */
+	ATH79_MACH_TL_WR1043ND_V4,		/* TP-LINK TL-WR1043ND v4 */
+	ATH79_MACH_TL_WR2543N,			/* TP-LINK TL-WR2543N/ND */
+	ATH79_MACH_TL_WR703N,			/* TP-LINK TL-WR703N */
+	ATH79_MACH_TL_WR710N,			/* TP-LINK TL-WR710N */
+	ATH79_MACH_TL_WR720N_V3,		/* TP-LINK TL-WR720N v3/v4 */
+	ATH79_MACH_TL_WR740N_V6,		/* TP-LINK TL-WR740N/ND v6 */
+	ATH79_MACH_TL_WR741ND,			/* TP-LINK TL-WR741ND */
+	ATH79_MACH_TL_WR741ND_V4,		/* TP-LINK TL-WR741ND v4 */
+	ATH79_MACH_TL_WR802N_V1,		/* TP-LINK TL-WR802N v1 */
+	ATH79_MACH_TL_WR802N_V2,		/* TP-LINK TL-WR802N v2 */
+	ATH79_MACH_TL_WR810N,			/* TP-LINK TL-WR810N */
+	ATH79_MACH_TL_WR810N_V2,		/* TP-LINK TL-WR810N v2 */
+	ATH79_MACH_TL_WR840N_V2,		/* TP-LINK TL-WR840N v2 */
+	ATH79_MACH_TL_WR840N_V3,		/* TP-LINK TL-WR840N v3 */
+	ATH79_MACH_TL_WR841N_V1,		/* TP-LINK TL-WR841N v1 */
+	ATH79_MACH_TL_WR841N_V11,		/* TP-LINK TL-WR841N/ND v11 */
+	ATH79_MACH_TL_WR841N_V7,		/* TP-LINK TL-WR841N/ND v7 */
+	ATH79_MACH_TL_WR841N_V8,		/* TP-LINK TL-WR841N/ND v8 */
+	ATH79_MACH_TL_WR841N_V9,		/* TP-LINK TL-WR841N/ND v9 */
+	ATH79_MACH_TL_WR842N_V2,		/* TP-LINK TL-WR842N/ND v2 */
+	ATH79_MACH_TL_WR842N_V3,		/* TP-LINK TL-WR842N/ND v3 */
+	ATH79_MACH_TL_WR902AC_V1,		/* TP-LINK TL-WR902AC v1 */
+	ATH79_MACH_TL_WR941ND,			/* TP-LINK TL-WR941ND */
+	ATH79_MACH_TL_WR941ND_V5,		/* TP-LINK TL-WR941ND v5 */
+	ATH79_MACH_TL_WR941ND_V6,		/* TP-LINK TL-WR941ND v6 */
+	ATH79_MACH_TL_WR940N_V4,		/* TP-LINK TL-WR940N v4 */
+	ATH79_MACH_TL_WR940N_V6,		/* TP-LINK TL-WR940N v6 */
+	ATH79_MACH_TL_WR942N_V1,		/* TP-LINK TL-WR942N v1 */
+	ATH79_MACH_TS_D084,			/* PISEN TS-D084 */
+	ATH79_MACH_TUBE2H,			/* Alfa Network Tube2H */
+	ATH79_MACH_UBNT_AIRGW,			/* Ubiquiti AirGateway */
+	ATH79_MACH_UBNT_AIRGWP,			/* Ubiquiti AirGateway Pro */
+	ATH79_MACH_UBNT_AIRROUTER,		/* Ubiquiti AirRouter */
+	ATH79_MACH_UBNT_BULLET_M,		/* Ubiquiti Bullet M */
+	ATH79_MACH_UBNT_LBE_M5,			/* Ubiquiti Litebeam M5 */
+	ATH79_MACH_UBNT_LOCO_M_XW,		/* Ubiquiti Loco M XW */
+	ATH79_MACH_UBNT_LSSR71,			/* Ubiquiti LS-SR71 */
+	ATH79_MACH_UBNT_LSX,			/* Ubiquiti LSX */
+	ATH79_MACH_UBNT_NANO_M,			/* Ubiquiti NanoStation M */
+	ATH79_MACH_UBNT_NANO_M_XW,		/* Ubiquiti NanoStation M XW */
+	ATH79_MACH_UBNT_ROCKET_M,		/* Ubiquiti Rocket M */
+	ATH79_MACH_UBNT_ROCKET_M_TI,		/* Ubiquiti Rocket M TI */
+	ATH79_MACH_UBNT_ROCKET_M_XW,		/* Ubiquiti Rocket M XW */
+	ATH79_MACH_UBNT_RS,			/* Ubiquiti RouterStation */
+	ATH79_MACH_UBNT_RSPRO,			/* Ubiquiti RouterStation Pro */
+	ATH79_MACH_UBNT_UAP_PRO,		/* Ubiquiti UniFi AP Pro */
+	ATH79_MACH_UBNT_UNIFI,			/* Ubiquiti Unifi */
+	ATH79_MACH_UBNT_UNIFIAC_LITE,		/* Ubiquiti Unifi AC LITE/LR/MESH */
+	ATH79_MACH_UBNT_UNIFIAC_PRO,		/* Ubiquiti Unifi AC PRO */
+	ATH79_MACH_UBNT_UNIFI_OUTDOOR,		/* Ubiquiti UnifiAP Outdoor */
+	ATH79_MACH_UBNT_UNIFI_OUTDOOR_PLUS,	/* Ubiquiti UnifiAP Outdoor+ */
+	ATH79_MACH_UBNT_XM,			/* Ubiquiti Networks XM board rev 1.0 */
+	ATH79_MACH_WAM250,			/* Samsung WAM250 */
+	ATH79_MACH_WBS210,			/* TP-LINK WBS210 */
+	ATH79_MACH_WBS510,			/* TP-LINK WBS510 */
+	ATH79_MACH_WEIO,			/* WeIO board */
+	ATH79_MACH_WHR_G301N,			/* Buffalo WHR-G301N */
+	ATH79_MACH_WHR_HP_G300N,		/* Buffalo WHR-HP-G300N */
+	ATH79_MACH_WHR_HP_GN,			/* Buffalo WHR-HP-GN */
+	ATH79_MACH_WIFI_PINEAPPLE_NANO,		/* Hak5 WiFi Pineapple NANO */
+	ATH79_MACH_WLAE_AG300N,			/* Buffalo WLAE-AG300N */
+	ATH79_MACH_WLR8100,			/* SITECOM WLR-8100 */
+	ATH79_MACH_WNDAP360,			/* NETGEAR WNDAP360 */
+	ATH79_MACH_WNDR3700,			/* NETGEAR WNDR3700/WNDR3800/WNDRMAC */
+	ATH79_MACH_WNDR3700_V4,			/* NETGEAR WNDR3700v4 */
+	ATH79_MACH_WNDR4300,			/* NETGEAR WNDR4300 */
+	ATH79_MACH_WNR1000_V2,			/* NETGEAR WNR1000 v2 */
+	ATH79_MACH_WNR2000,			/* NETGEAR WNR2000 */
+	ATH79_MACH_WNR2000_V3,			/* NETGEAR WNR2000 v3 */
+	ATH79_MACH_WNR2000_V4,			/* NETGEAR WNR2000 v4 */
+	ATH79_MACH_WNR2200,			/* NETGEAR WNR2200 */
+	ATH79_MACH_WNR612_V2,			/* NETGEAR WNR612 v2 */
+	ATH79_MACH_WP543,			/* Compex WP543 */
+	ATH79_MACH_WPE72,			/* Compex WPE72 */
+	ATH79_MACH_WPJ342,			/* Compex WPJ342 */
+	ATH79_MACH_WPJ344,			/* Compex WPJ344 */
+	ATH79_MACH_WPJ531,			/* Compex WPJ531 */
+	ATH79_MACH_WPJ558,			/* Compex WPJ558 */
+	ATH79_MACH_WPJ563,			/* Compex WPJ563 */
+	ATH79_MACH_WPN824N,			/* NETGEAR WPN824N */
+	ATH79_MACH_WRT160NL,			/* Linksys WRT160NL */
+	ATH79_MACH_WRT400N,			/* Linksys WRT400N */
+	ATH79_MACH_WRTNODE2Q,			/* WRTnode2Q */
+	ATH79_MACH_WZR_450HP2,			/* Buffalo WZR-450HP2 */
+	ATH79_MACH_WZR_HP_AG300H,		/* Buffalo WZR-HP-AG300H */
+	ATH79_MACH_WZR_HP_G300NH,		/* Buffalo WZR-HP-G300NH */
+	ATH79_MACH_WZR_HP_G300NH2,		/* Buffalo WZR-HP-G300NH2 */
+	ATH79_MACH_WZR_HP_G450H,		/* Buffalo WZR-HP-G450H */
+	ATH79_MACH_XD3200,			/* YunCore XD3200 */
+	ATH79_MACH_Z1,				/* Cisco Meraki Z1 */
+	ATH79_MACH_ZBT_WE1526,			/* Zbtlink ZBT-WE1526 */
+	ATH79_MACH_ZCN_1523H_2,			/* Zcomax ZCN-1523H-2-xx */
+	ATH79_MACH_ZCN_1523H_5,			/* Zcomax ZCN-1523H-5-xx */
+};
+
+#endif /* _ATH79_MACHTYPE_H */
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/nvram.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/nvram.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/nvram.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/nvram.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/nvram.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/nvram.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/nvram.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/nvram.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/pci-ath9k-fixup.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/pci-ath9k-fixup.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/pci-ath9k-fixup.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/pci-ath9k-fixup.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/pci-ath9k-fixup.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/pci-ath9k-fixup.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/pci-ath9k-fixup.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/pci-ath9k-fixup.h
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/routerboot.c b/target/linux/ar71xx/files-4.14/arch/mips/ath79/routerboot.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/routerboot.c
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/routerboot.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/routerboot.h b/target/linux/ar71xx/files-4.14/arch/mips/ath79/routerboot.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/routerboot.h
rename to target/linux/ar71xx/files-4.14/arch/mips/ath79/routerboot.h
diff --git a/target/linux/ar71xx/files/arch/mips/include/asm/fw/myloader/myloader.h b/target/linux/ar71xx/files-4.14/arch/mips/include/asm/fw/myloader/myloader.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/include/asm/fw/myloader/myloader.h
rename to target/linux/ar71xx/files-4.14/arch/mips/include/asm/fw/myloader/myloader.h
diff --git a/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h b/target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
rename to target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
diff --git a/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/mach-rb750.h b/target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/mach-rb750.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/mach-rb750.h
rename to target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/mach-rb750.h
diff --git a/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h b/target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
rename to target/linux/ar71xx/files-4.14/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
diff --git a/target/linux/ar71xx/files/drivers/gpio/gpio-latch.c b/target/linux/ar71xx/files-4.14/drivers/gpio/gpio-latch.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/gpio/gpio-latch.c
rename to target/linux/ar71xx/files-4.14/drivers/gpio/gpio-latch.c
diff --git a/target/linux/ar71xx/files/drivers/gpio/gpio-nxp-74hc153.c b/target/linux/ar71xx/files-4.14/drivers/gpio/gpio-nxp-74hc153.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/gpio/gpio-nxp-74hc153.c
rename to target/linux/ar71xx/files-4.14/drivers/gpio/gpio-nxp-74hc153.c
diff --git a/target/linux/ar71xx/files/drivers/leds/leds-nu801.c b/target/linux/ar71xx/files-4.14/drivers/leds/leds-nu801.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/leds/leds-nu801.c
rename to target/linux/ar71xx/files-4.14/drivers/leds/leds-nu801.c
diff --git a/target/linux/ar71xx/files/drivers/leds/leds-rb750.c b/target/linux/ar71xx/files-4.14/drivers/leds/leds-rb750.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/leds/leds-rb750.c
rename to target/linux/ar71xx/files-4.14/drivers/leds/leds-rb750.c
diff --git a/target/linux/ar71xx/files/drivers/leds/leds-wndr3700-usb.c b/target/linux/ar71xx/files-4.14/drivers/leds/leds-wndr3700-usb.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/leds/leds-wndr3700-usb.c
rename to target/linux/ar71xx/files-4.14/drivers/leds/leds-wndr3700-usb.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/cybertan_part.c b/target/linux/ar71xx/files-4.14/drivers/mtd/cybertan_part.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/cybertan_part.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/cybertan_part.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/nand/ar934x_nfc.c b/target/linux/ar71xx/files-4.14/drivers/mtd/nand/ar934x_nfc.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/nand/ar934x_nfc.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/nand/ar934x_nfc.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/nand/rb4xx_nand.c b/target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb4xx_nand.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/nand/rb4xx_nand.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb4xx_nand.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/nand/rb750_nand.c b/target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb750_nand.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/nand/rb750_nand.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb750_nand.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/nand/rb91x_nand.c b/target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb91x_nand.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/nand/rb91x_nand.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/nand/rb91x_nand.c
diff --git a/target/linux/ar71xx/files/drivers/mtd/tplinkpart.c b/target/linux/ar71xx/files-4.14/drivers/mtd/tplinkpart.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/mtd/tplinkpart.c
rename to target/linux/ar71xx/files-4.14/drivers/mtd/tplinkpart.c
diff --git a/target/linux/ar71xx/files-4.14/drivers/net/dsa/mv88e6063.c b/target/linux/ar71xx/files-4.14/drivers/net/dsa/mv88e6063.c
new file mode 100644
index 0000000000..9be8bf5e16
--- /dev/null
+++ b/target/linux/ar71xx/files-4.14/drivers/net/dsa/mv88e6063.c
@@ -0,0 +1,307 @@
+/*
+ * net/dsa/mv88e6063.c - Driver for Marvell 88e6063 switch chips
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This driver was base on: net/dsa/mv88e6060.c
+ *   net/dsa/mv88e6063.c - Driver for Marvell 88e6060 switch chips
+ *   Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <net/dsa.h>
+#include <linux/version.h>
+
+#define REG_BASE		0x10
+#define REG_PHY(p)		(REG_BASE + (p))
+#define REG_PORT(p)		(REG_BASE + 8 + (p))
+#define REG_GLOBAL		(REG_BASE + 0x0f)
+#define NUM_PORTS		7
+
+static int reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_read(bus, addr, reg);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->dev);
+	return mdiobus_read(bus, addr, reg);
+#endif
+}
+
+#define REG_READ(addr, reg)					\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_read(ds, addr, reg);		\
+		if (__ret < 0)					\
+			return __ret;				\
+		__ret;						\
+	})
+
+
+static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_write(bus, addr, reg, val);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->dev);
+	return mdiobus_write(bus, addr, reg, val);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+static enum dsa_tag_protocol mv88e6063_get_tag_protocol(struct dsa_switch *ds)
+{
+	return DSA_TAG_PROTO_TRAILER;
+}
+#endif
+
+#define REG_WRITE(addr, reg, val)				\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_write(ds, addr, reg, val);		\
+		if (__ret < 0)					\
+			return __ret;				\
+	})
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+static char *mv88e6063_drv_probe(struct device *host_dev, int sw_addr)
+#else
+static const char *mv88e6063_drv_probe(struct device *dsa_dev,
+				       struct device *host_dev, int sw_addr,
+				       void **_priv)
+#endif
+{
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(host_dev);
+	int ret;
+
+	if (!bus)
+		return NULL;
+
+	ret = mdiobus_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0) {
+		ret &= 0xfff0;
+		if (ret == 0x1530)
+			return "Marvell 88E6063";
+	}
+
+	return NULL;
+}
+
+static int mv88e6063_switch_reset(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Set all ports to the disabled state.
+	 */
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = REG_READ(REG_PORT(i), 0x04);
+		REG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);
+	}
+
+	/*
+	 * Wait for transmit queues to drain.
+	 */
+	msleep(2);
+
+	/*
+	 * Reset the switch.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0xa130);
+
+	/*
+	 * Wait up to one second for reset to complete.
+	 */
+	for (i = 0; i < 1000; i++) {
+		ret = REG_READ(REG_GLOBAL, 0x00);
+		if ((ret & 0x8000) == 0x0000)
+			break;
+
+		msleep(1);
+	}
+	if (i == 1000)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int mv88e6063_setup_global(struct dsa_switch *ds)
+{
+	/*
+	 * Disable discarding of frames with excessive collisions,
+	 * set the maximum frame size to 1536 bytes, and mask all
+	 * interrupt sources.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x04, 0x0800);
+
+	/*
+	 * Enable automatic address learning, set the address
+	 * database size to 1024 entries, and set the default aging
+	 * time to 5 minutes.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0x2130);
+
+	return 0;
+}
+
+static int mv88e6063_setup_port(struct dsa_switch *ds, int p)
+{
+	int addr = REG_PORT(p);
+
+	/*
+	 * Do not force flow control, disable Ingress and Egress
+	 * Header tagging, disable VLAN tunneling, and set the port
+	 * state to Forwarding.  Additionally, if this is the CPU
+	 * port, enable Ingress and Egress Trailer tagging mode.
+	 */
+	REG_WRITE(addr, 0x04, dsa_is_cpu_port(ds, p) ?  0x4103 : 0x0003);
+
+	/*
+	 * Port based VLAN map: give each port its own address
+	 * database, allow the CPU port to talk to each of the 'real'
+	 * ports, and allow each of the 'real' ports to only talk to
+	 * the CPU port.
+	 */
+	REG_WRITE(addr, 0x06,
+			((p & 0xf) << 12) |
+			 (dsa_is_cpu_port(ds, p) ?
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+				ds->phys_port_mask :
+#else
+				ds->enabled_port_mask :
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+				(1 << ds->dst->cpu_port)));
+#else
+				(1 << ds->dst->cpu_dp->index)));
+#endif
+
+	/*
+	 * Port Association Vector: when learning source addresses
+	 * of packets, add the address to the address database using
+	 * a port bitmap that has only the bit for this port set and
+	 * the other bits clear.
+	 */
+	REG_WRITE(addr, 0x0b, 1 << p);
+
+	return 0;
+}
+
+static int mv88e6063_setup(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	ret = mv88e6063_switch_reset(ds);
+	if (ret < 0)
+		return ret;
+
+	/* @@@ initialise atu */
+
+	ret = mv88e6063_setup_global(ds);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = mv88e6063_setup_port(ds, i);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mv88e6063_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	REG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);
+	REG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);
+	REG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);
+
+	return 0;
+}
+
+static int mv88e6063_port_to_phy_addr(int port)
+{
+	if (port >= 0 && port <= NUM_PORTS)
+		return REG_PHY(port);
+	return -1;
+}
+
+static int mv88e6063_phy_read(struct dsa_switch *ds, int port, int regnum)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_read(ds, addr, regnum);
+}
+
+static int
+mv88e6063_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_write(ds, addr, regnum, val);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+static struct dsa_switch_driver mv88e6063_switch_ops = {
+#else
+static struct dsa_switch_ops mv88e6063_switch_ops = {
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	.tag_protocol	= htons(ETH_P_TRAILER),
+#else
+	.get_tag_protocol = mv88e6063_get_tag_protocol,
+#endif
+	.probe		= mv88e6063_drv_probe,
+	.setup		= mv88e6063_setup,
+	.set_addr	= mv88e6063_set_addr,
+	.phy_read	= mv88e6063_phy_read,
+	.phy_write	= mv88e6063_phy_write,
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,9,0)
+static struct dsa_switch_driver mv88e6063_switch_drv = {
+	.ops		= &mv88e6063_switch_ops,
+};
+#endif
+
+static int __init mv88e6063_init(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	register_switch_driver(&mv88e6063_switch_ops);
+#else
+	register_switch_driver(&mv88e6063_switch_drv);
+#endif
+	return 0;
+}
+module_init(mv88e6063_init);
+
+static void __exit mv88e6063_cleanup(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	unregister_switch_driver(&mv88e6063_switch_ops);
+#else
+	unregister_switch_driver(&mv88e6063_switch_drv);
+#endif
+}
+module_exit(mv88e6063_cleanup);
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/Kconfig b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/Kconfig
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/Kconfig
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/Kconfig
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/Makefile b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/Makefile
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/Makefile
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/Makefile
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
diff --git a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c b/target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
rename to target/linux/ar71xx/files-4.14/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
diff --git a/target/linux/ar71xx/files/drivers/spi/spi-rb4xx-cpld.c b/target/linux/ar71xx/files-4.14/drivers/spi/spi-rb4xx-cpld.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/spi/spi-rb4xx-cpld.c
rename to target/linux/ar71xx/files-4.14/drivers/spi/spi-rb4xx-cpld.c
diff --git a/target/linux/ar71xx/files/drivers/spi/spi-rb4xx.c b/target/linux/ar71xx/files-4.14/drivers/spi/spi-rb4xx.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/spi/spi-rb4xx.c
rename to target/linux/ar71xx/files-4.14/drivers/spi/spi-rb4xx.c
diff --git a/target/linux/ar71xx/files/drivers/spi/spi-vsc7385.c b/target/linux/ar71xx/files-4.14/drivers/spi/spi-vsc7385.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/spi/spi-vsc7385.c
rename to target/linux/ar71xx/files-4.14/drivers/spi/spi-vsc7385.c
diff --git a/target/linux/ar71xx/files/include/linux/leds-nu801.h b/target/linux/ar71xx/files-4.14/include/linux/leds-nu801.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/leds-nu801.h
rename to target/linux/ar71xx/files-4.14/include/linux/leds-nu801.h
diff --git a/target/linux/ar71xx/files/include/linux/nxp_74hc153.h b/target/linux/ar71xx/files-4.14/include/linux/nxp_74hc153.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/nxp_74hc153.h
rename to target/linux/ar71xx/files-4.14/include/linux/nxp_74hc153.h
diff --git a/target/linux/ar71xx/files/include/linux/platform/ar934x_nfc.h b/target/linux/ar71xx/files-4.14/include/linux/platform/ar934x_nfc.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/platform/ar934x_nfc.h
rename to target/linux/ar71xx/files-4.14/include/linux/platform/ar934x_nfc.h
diff --git a/target/linux/ar71xx/files/include/linux/platform_data/gpio-latch.h b/target/linux/ar71xx/files-4.14/include/linux/platform_data/gpio-latch.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/platform_data/gpio-latch.h
rename to target/linux/ar71xx/files-4.14/include/linux/platform_data/gpio-latch.h
diff --git a/target/linux/ar71xx/files/include/linux/platform_data/rb91x_nand.h b/target/linux/ar71xx/files-4.14/include/linux/platform_data/rb91x_nand.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/platform_data/rb91x_nand.h
rename to target/linux/ar71xx/files-4.14/include/linux/platform_data/rb91x_nand.h
diff --git a/target/linux/ar71xx/files/include/linux/spi/vsc7385.h b/target/linux/ar71xx/files-4.14/include/linux/spi/vsc7385.h
similarity index 100%
rename from target/linux/ar71xx/files/include/linux/spi/vsc7385.h
rename to target/linux/ar71xx/files-4.14/include/linux/spi/vsc7385.h
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/Kconfig.openwrt b/target/linux/ar71xx/files-4.9/arch/mips/ath79/Kconfig.openwrt
new file mode 100644
index 0000000000..7400f2c86d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/Kconfig.openwrt
@@ -0,0 +1,2379 @@
+config ATH79_MACH_A60
+	bool "OpenMesh A40/A60 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WI2A_AC200I
+	bool "Nokia WI2A-AC200i support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_ALFA_AP120C
+	bool "ALFA Network AP120C board support"
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP121F
+	bool "ALFA Network AP121F support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ALFA_AP96
+	bool "ALFA Network AP96 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_HORNET_UB
+	bool "ALFA Network Hornet-UB board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ALFA_NX
+	bool "ALFA Network N2/N5 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TUBE2H
+	bool "ALFA Network Tube2H board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_SC1750
+	bool "Abicom SC1750 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_SC300M
+	bool "Abicom SC300M board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_SC450
+	bool "Abicom SC450 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ALL0258N
+	bool "Allnet ALL0258N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_ALL0315N
+	bool "Allnet ALL0315N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_ANTMINER_S1
+	bool "Bitmain Antminer S1 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ANTMINER_S3
+	bool "Bitmain Antminer S3 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ANTROUTER_R1
+	bool "Bitmain Antrouter R1 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARDUINO_YUN
+	bool "Arduino Yun"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP132
+	bool "Atheros AP132 reference board"
+	select SOC_QCA955X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP143
+	bool "Atheros AP143 reference board"
+	select SOC_QCA953X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_AP147
+	bool "Atheros AP147 reference board"
+	select SOC_QCA953X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_AP9X_PCI if PCI
+
+config ATH79_MACH_AP152
+	bool "Atheros AP152 reference board"
+	select SOC_QCA956X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_AP9X_PCI if PCI
+
+config ATH79_MACH_AP531B0
+	bool "Rockeetech AP531B0 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_SPI
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP90Q
+	bool "YunCore AP80Q/AP90Q support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP91_5G
+	bool "ALFA Network AP91-5G support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_AP96
+	bool "Atheros AP96 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_PB42
+	bool "Atheros PB42 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_C55
+	bool "AirTight Networks C-55 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_C60
+	bool "AirTight Networks C-60 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_AW_NR580
+	bool "AzureWave AW-NR580 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_F9K1115V2
+	bool "Belkin AC1750DB board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EPG5000
+	bool "EnGenius EPG5000 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_ESR1750
+	bool "EnGenius ESR1750 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_PQI_AIR_PEN
+	bool "PQI Air Pen"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_SOM9331
+	bool "SOM9331 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_SR3200
+	bool "YunCore SR3200 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_BHR_4GRV2
+	bool "Buffalo BHR-4GRV2 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WHR_HP_G300N
+	bool "Buffalo WHR-HP-G300N board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WLAE_AG300N
+	bool "Buffalo WLAE-AG300N board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WLR8100
+	bool "Sitecom WLR-8100 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WZR_HP_AG300H
+	bool "Buffalo WZR-HP-AG300H board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_HP_G300NH
+	bool "Buffalo WZR-HP-G300NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select RTL8366_SMI
+
+config ATH79_MACH_WZR_HP_G300NH2
+	bool "Buffalo WZR-HP-G300NH2 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_HP_G450H
+	bool "Buffalo WZR-HP-G450H board support"
+	select SOC_AR724X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_450HP2
+	bool "Buffalo WZR-450HP2 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WP543
+	bool "Compex WP543/WPJ543 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select MYLOADER
+
+config ATH79_MACH_WPE72
+	bool "Compex WPE72/WPE72NX board support"
+	select SOC_AR724X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select MYLOADER
+
+config ATH79_MACH_WPJ342
+	bool "Compex WPJ342 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ344
+	bool "Compex WPJ344 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ531
+	bool "Compex WPJ531 board support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ558
+	bool "Compex WPJ558 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ563
+	bool "Compex WPJ563 board support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_XD3200
+	bool "YunCore XD3200 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DGL_5500_A1
+	bool "D-Link DGL-5500 A1 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DHP_1565_A1
+	bool "D-Link DHP-1565 rev. A1 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DIR_505_A1
+	bool "D-Link DIR-505-A1 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DIR_600_A1
+	bool "D-Link DIR-600 A1/DIR-615 E1/DIR-615 E4 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_615_C1
+	bool "D-Link DIR-615 rev. C1 support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_615_I1
+	bool "D-Link DIR-615 rev. I1 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DIR_825_B1
+	bool "D-Link DIR-825 rev. B1 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DIR_825_C1
+	bool "D-Link DIR-825 rev. C1/DIR-835 rev. A1 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DIR_869_A1
+	bool "D-Link DIR-869 rev. A1"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_DLAN_HOTSPOT
+	bool "devolo dLAN Hotspot support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DLAN_PRO_500_WP
+	bool "devolo dLAN pro 500 Wireless+ support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DLAN_PRO_1200_AC
+	bool "devolo dLAN pro 1200+ WiFi ac support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DOMYWIFI_DW33D
+	bool "DomyWifi DW33D support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DR342
+	bool "Wallys DR342 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DR344
+	bool "Wallys DR344 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DR531
+	bool "Wallys DR531 board support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DRAGINO2
+	bool "DRAGINO V2 support"
+	select SOC_AR933X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	select ATH79_DEV_USB
+
+config ATH79_MACH_E1700AC_V2
+	bool "Qxwlan E1700AC v2 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_E2100L
+	bool "Linksys E2100L board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_E600G_V2
+	bool "Qxwlan E600G/E600GAC v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ESR900
+	bool "EnGenius ESR900 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_EW_BALIN
+	bool "embedded wireless Balin Platform support"
+	select SOC_AR934X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	select ATH79_DEV_USB
+	select ATH79_DEV_AP9X_PCI if PCI
+
+config ATH79_MACH_EW_DORIN
+	bool "embedded wireless Dorin Platform support"
+	select SOC_AR933X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+
+config ATH79_MACH_EL_M150
+	bool "EasyLink EL-M150 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EL_MINI
+	bool "EasyLink EL-MINI support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR150
+	bool "GL AR150 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR300
+	bool "GL_AR300 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR300M
+	bool "GL_AR300M support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR750
+	bool "GL.iNet GL-AR750 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR750S
+	bool "GL.iNet GL-AR750S support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_DOMINO
+	bool "DOMINO support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_MIFI
+	bool "GL MIFI support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_INET
+	bool "GL-INET support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_USB150
+	bool "GL.iNet GL-USB150 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EAP120
+	bool "TP-LINK EAP120 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ENS202EXT
+	bool "EnGenius ENS202EXT support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EAP300V2
+	bool "EnGenius EAP300 v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GS_OOLITE_V1
+	bool "GainStrong Oolite/Minibox V1.0 support"
+	select SOC_AR933X
+	select ARH79_DEV_ETH
+	select ARH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GS_OOLITE_V5_2
+	bool "GainStrong Oolite V5.2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_HIVEAP_121
+	bool "Aerohive HiveAP-121 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_HIWIFI_HC6361
+	bool "HiWiFi HC6361 board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_JA76PF
+	bool "jjPlus JA76PF board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_JWAP003
+	bool "jjPlus JWAP003 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_JWAP230
+	bool "jjPlus JWAP230 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WAM250
+	bool "Samsung WAM250 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WIFI_PINEAPPLE_NANO
+	bool "Hak5 WiFi Pineapple NANO support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WRT160NL
+	bool "Linksys WRT160NL board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_WRT400N
+	bool "Linksys WRT400N board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WRTNODE2Q
+	bool "WRTnode2Q board support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_R36A
+	bool "ALFA Network R36A support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_R602N
+	bool "P&W R602N support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_R6100
+	bool "NETGEAR R6100 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MC_MAC1200R
+	bool "MERCURY MAC1200R board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RB4XX
+	bool "MikroTik RouterBOARD 4xx series support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+
+config ATH79_MACH_RB750
+	bool "MikroTik RouterBOARD 750 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB91X
+	bool "MikroTik RouterBOARD 91X support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_SPI
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB922
+	bool "MikroTik RouterBOARD 922 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+	select RLE_DECOMPRESS
+
+config ATH79_MACH_RB95X
+	bool "MikroTik RouterBOARD 95X support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB2011
+	bool "MikroTik RouterBOARD 2011 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RBSPI
+	bool "MikroTik RouterBOARD SPI-NOR support"
+	select SOC_AR934X
+	select SOC_QCA953X
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_ROUTERBOOT
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  MikroTik ROuterBOARD 911-2Hn (911 Lite2)
+	  MikroTik ROuterBOARD 911-5Hn (911 Lite5)
+	  MikroTik RouterBOARD mAP
+	  MikroTik RouterBOARD mAP lite
+	  MikroTik RouterBOARD hAP lite
+	  MikroTik RouterBOARD hAP
+	  MikroTik RouterBOARD hAP ac
+	  MikroTik RouterBOARD hAP ac lite
+	  MikroTik RouterBOARD hEX PoE lite
+	  MikroTik RouterBOARD hEX lite
+	  MikroTik RouterBOARD Powerbox
+	  MikroTik RouterBOARD LHG 5
+	  MikroTik RouterBOARD cAP (EXPERIMENTAL)
+	  MikroTik RouterBOARD wAP
+
+config ATH79_MACH_RBSXTLITE
+	bool "MikroTik RouterBOARD SXT Lite"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_SMART_300
+	bool "NC-LINK SMART-300 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_T830
+	bool "YunCore T830 support"
+	select SOC_QCA953X
+	select ARH79_DEV_ETH
+	select ARH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TELLSTICK_ZNET_LITE
+	bool "TellStick ZNet Lite"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNDAP360
+	bool "NETGEAR WNDAP360 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WNDR3700
+	bool "NETGEAR WNDR3700 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WNDR4300
+	bool "NETGEAR WNDR3700v4/WNDR4300 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNR2000
+	bool "NETGEAR WNR2000 board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNR2000_V3
+	bool "NETGEAR WNR2000 V3/WNR612 v2/WNR1000 v2/WPN824N board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WNR2200
+	bool "NETGEAR WNR2200 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WNR2000_V4
+	bool "NETGEAR WNR2000 V4"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM2P
+	bool "OpenMesh OM2P board support"
+	select SOC_AR724X
+	select SOC_AR933X
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM5P
+	bool "OpenMesh OM5P board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM5P_AC
+	bool "OpenMesh OM5P-AC board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM5P_ACv2
+	bool "OpenMesh OM5P-ACv2 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OMY_G1
+	bool "OMYlink OMY G1 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OMY_X1
+	bool "OMYlink OMY X1 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ONION_OMEGA
+	bool "ONION OMEGA support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR12
+	bool "Meraki MR12 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR16
+	bool "Meraki MR16 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR18
+	bool "Meraki MR18 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select LEDS_NU801
+
+config ATH79_MACH_MR600
+	bool "OpenMesh MR600 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MZK_W04NU
+	bool "Planex MZK-W04NU board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MZK_W300NH
+	bool "Planex MZK-W300NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RE355
+	bool "TP-LINK RE355 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RE450
+	bool "TP-LINK RE450 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RME_EG200
+	bool "eTactica EG200 board supprt"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RUT9XX
+	bool "Teltonika RUT900 series support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select GPIO_PCA953X
+
+config ATH79_MACH_RW2458N
+	bool "Redwave RW2458N board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_CAP324
+	bool "PowerCloud CAP324 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CAP4200AG
+	bool "Senao CAP4200AG support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CR3000
+	bool "PowerCloud CR3000 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CR5000
+	bool "PowerCloud CR5000 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR1750
+	bool "OpenMesh MR1750 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR900
+	bool "OpenMesh MR900 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EAP7660D
+	bool "Senao EAP7660D support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_BSB
+	bool "Smart Electronics Black Swift board"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C25_V1
+	bool "TP-LINK Archer C25 v1 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C58_V1
+	bool "TP-LINK Archer C58 v1 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C59_V1
+	bool "TP-LINK Archer C59 v1 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C60_V1
+	bool "TP-LINK Archer C60 v1 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C60_V2
+	bool "TP-LINK Archer C60 v2 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C7
+	bool "TP-LINK Archer C5/C7/TL-WDR4900 v2 board support"
+	select SOC_QCA955X
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CPE505N
+	bool "P&W CPE505N support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CPE510
+	bool "TP-LINK CPE510 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CPE830
+	bool "YunCore CPE830 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CPE870
+	bool "YunCore CPE870 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR11U
+	bool "TP-LINK TL-MR11U/TL-MR3040 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR13U
+	bool "TP-LINK TL-MR13U support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR3020
+	bool "TP-LINK TL-MR3020 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR3X20
+	bool "TP-LINK TL-MR3220/3420 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_TL_MR6400
+	bool "TP-LINK TL-MR6400 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WAX50RE
+	bool "TP-LINK TL-WA750/850RE support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA701ND_V2
+	bool "TP-LINK TL-WA701ND v2 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA7210N_V2
+	bool "TP-LINK TL-WA7210N v2 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA801ND_V3
+	bool "TP-LINK TL-WA801ND v3 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA830RE_V2
+	bool "TP-LINK TL-WA830RE v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA850RE_V2
+	bool "TP-LINK TL-WA850RE v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA855RE_V1
+	bool "TP-LINK TL-WA855RE V1 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA901ND
+	bool "TP-LINK TL-WA901ND/TL-WA7510N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WA901ND_V2
+	bool "TP-LINK TL-WA901ND v2 support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA901ND_V4
+	bool "TP-LINK TL-WA901ND v4 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR3320_V2
+	bool "TP-LINK TL-WDR3320 v2 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR3500
+	bool "TP-LINK TL-WDR3500 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR4300
+	bool "TP-LINK TL-WDR3600/4300/4310 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR6500_V2
+	bool "TP-LINK TL-WDR6500 v2 board support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR703N
+	bool "TP-LINK TL-WR703N/TL-WR710N/TL-MR10U support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR720N_V3
+	bool "TP-LINK TL-WR720N v3/v4 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR741ND
+	bool "TP-LINK TL-WR741ND support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR741ND_V4
+	bool "TP-LINK TL-WR741ND v4/TL-MR3220 v2 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR802N_V1
+	bool "TP-LINK TL-WR802N v1 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR802N_V2
+	bool "TP-LINK TL-WR802N v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR810N
+	bool "TP-LINK TL-WR810N support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR810N_V2
+	bool "TP-LINK TL-WR810N v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR840N_V2
+	bool "TP-LINK TL-WR840N v2/v3 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR841N_V1
+	bool "TP-LINK TL-WR841N v1 support"
+	select SOC_AR71XX
+	select ATH79_DEV_DSA
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR841N_V8
+	bool "TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR841N_V9
+	bool "TP-LINK TL-WR841N/ND v9/TL-WR842N/ND v3/TL-WR740N/ND v6 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR902AC_V1
+	bool "TP-LINK TL-WR902AC v1 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR941ND
+	bool "TP-LINK TL-WR941ND support"
+	select SOC_AR913X
+	select ATH79_DEV_DSA
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR941ND_V6
+	bool "TP-LINK TL-WR941ND v6 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR940N_V4
+	bool "TP-LINK TL-WR940N v4 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR942N_V1
+	bool "TP-LINK TL-WR942N v1 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_TL_WR1041N_V2
+	bool "TP-LINK TL-WR1041N v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043N_V5
+	bool "TP-LINK TL-WR1043N v5 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043ND
+	bool "TP-LINK TL-WR1043ND support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043ND_V2
+	bool "TP-LINK TL-WR1043ND v2 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043ND_V4
+	bool "TP-LINK TL-WR1043ND v4 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR2543N
+	bool "TP-LINK TL-WR2543N/ND support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_TS_D084
+	bool "PISEN TS-D084 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TEW_632BRP
+	bool "TRENDnet TEW-632BRP support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_TEW_673GRU
+	bool "TRENDnet TEW-673GRU support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_TEW_712BR
+	bool "TRENDnet TEW-712BR support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TEW_732BR
+	bool "TRENDnet TEW-732BR support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TEW_823DRU
+	bool "TRENDnet TEW-823DRU support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_UBNT
+	bool "Ubiquiti AR71xx based boards support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_UBNT_UNIFIAC
+	bool "Ubiquiti UniFi AC (LITE/LR/MESH/PRO) support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WEIO
+	bool "WeIO board"
+	select SOC_AR933X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MYNET_N600
+	bool "WD My Net N600 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_MYNET_N750
+	bool "WD My Net N750 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_MYNET_REXT
+	bool "WD My Net Wi-Fi Range Extender board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_Z1
+	bool "Meraki Z1 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select LEDS_NU801
+
+config ATH79_MACH_ZBT_WE1526
+	bool "Zbtlink ZBT-WE1526 board support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ZCN_1523H
+	bool "Zcomax ZCN-1523H support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_N5Q
+	bool "ALFA Network N5Q support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_NBG460N
+	bool "Zyxel NBG460N/550N/550NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_NBG6716
+	bool "Zyxel NBG6616/NBG6716 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_CARAMBOLA2
+	bool "8devices Carambola2 board"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_LAN_TURTLE
+	bool "Hak5 LAN Turtle and Packet Squirrel support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_LIMA
+	bool "8devices Lima board"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_SPI
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+
+config ATH79_MACH_RAMBUTAN
+	bool "8devices Rambutan board"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E316N_V2
+	bool "COMFAST CF-E316N v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E320N_V2
+	bool "COMFAST CF-E320N v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E355AC
+	bool "COMFAST CF-E355AC v1/v2 support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E375AC
+	bool "COMFAST CF-E375AC support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E380AC_V1
+	bool "COMFAST CF-E380AC v1 support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E380AC_V2
+	bool "COMFAST CF-E380AC v2 support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E520N
+	bool "COMFAST CF-E520N support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E530N
+	bool "COMFAST CF-E530N support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_BHU_BXU2000N2_A
+	bool "BHU BXU2000n-2 rev. A support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_QIHOO_C301
+	bool "Qihoo 360 C301 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+	select ATH79_NVRAM
+
+config ATH79_MACH_DAP_1330_A1
+	bool "D-Link DAP-1330 rev. A1 support"
+	select SOC_QCA953X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DAP_2695_A1
+	bool "D-Link DAP-2695 rev. A1 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_TL_WPA8630
+	bool "TP-Link TL-WPA8630 support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_FRITZ300E
+	bool "AVM FRITZ!WLAN Repeater 300E support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_FRITZ4020
+	bool "AVM FRITZ!Box 4020 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+	select ATH79_DEV_M25P80
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/Makefile b/target/linux/ar71xx/files-4.9/arch/mips/ath79/Makefile
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/Makefile
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/Makefile
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.c
new file mode 100644
index 0000000000..483aed78ed
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.c
@@ -0,0 +1,173 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "pci-ath9k-fixup.h"
+#include "pci.h"
+
+static struct ath9k_platform_data ap9x_wmac0_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data ap9x_wmac1_data = {
+	.led_pin = -1,
+};
+static char ap9x_wmac0_mac[6];
+static char ap9x_wmac1_mac[6];
+
+__init void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.led_pin = pin;
+		break;
+	case 1:
+		ap9x_wmac1_data.led_pin = pin;
+		break;
+	}
+}
+
+__init struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	switch (wmac) {
+	case 0:
+		return &ap9x_wmac0_data;
+
+	case 1:
+		return &ap9x_wmac1_data;
+	}
+
+	return NULL;
+}
+
+__init void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.gpio_mask = mask;
+		ap9x_wmac0_data.gpio_val = val;
+		break;
+	case 1:
+		ap9x_wmac1_data.gpio_mask = mask;
+		ap9x_wmac1_data.gpio_val = val;
+		break;
+	}
+}
+
+__init void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+				     int num_leds)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.leds = leds;
+		ap9x_wmac0_data.num_leds = num_leds;
+		break;
+	case 1:
+		ap9x_wmac1_data.leds = leds;
+		ap9x_wmac1_data.num_leds = num_leds;
+		break;
+	}
+}
+
+__init void ap9x_pci_setup_wmac_btns(unsigned wmac,
+				     struct gpio_keys_button *btns,
+				     unsigned num_btns, unsigned poll_interval)
+{
+	struct ath9k_platform_data *ap9x_wmac_data;
+
+	if (!(ap9x_wmac_data = ap9x_pci_get_wmac_data(wmac)))
+		return;
+
+	ap9x_wmac_data->btns = btns;
+	ap9x_wmac_data->num_btns = num_btns;
+	ap9x_wmac_data->btn_poll_interval = poll_interval;
+}
+
+static int ap91_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap91_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ap9x_wmac0_mac, mac_addr, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap91_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(0, ap9x_wmac0_data.eeprom_data);
+}
+
+__init void ap91_pci_init_simple(void)
+{
+	ap91_pci_init(NULL, NULL);
+	ap9x_wmac0_data.eeprom_name = "pci_wmac0.eeprom";
+}
+
+static int ap94_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &ap9x_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			  u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data0,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (cal_data1)
+		memcpy(ap9x_wmac1_data.eeprom_data, cal_data1,
+		       sizeof(ap9x_wmac1_data.eeprom_data));
+
+	if (mac_addr0) {
+		memcpy(ap9x_wmac0_mac, mac_addr0, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(ap9x_wmac1_mac, mac_addr1, sizeof(ap9x_wmac1_mac));
+		ap9x_wmac1_data.macaddr = ap9x_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap94_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(17, ap9x_wmac0_data.eeprom_data);
+	pci_enable_ath9k_fixup(18, ap9x_wmac1_data.eeprom_data);
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.h
new file mode 100644
index 0000000000..d2a045fc1c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-ap9x-pci.h
@@ -0,0 +1,55 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_AP9X_PCI_H
+#define _ATH79_DEV_AP9X_PCI_H
+
+struct gpio_led;
+struct gpio_keys_button;
+struct ath9k_platform_data;
+
+#if defined(CONFIG_ATH79_DEV_AP9X_PCI)
+void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin);
+void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val);
+void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+			      int num_leds);
+void ap9x_pci_setup_wmac_btns(unsigned wmac, struct gpio_keys_button *btns,
+			      unsigned num_btns, unsigned poll_interval);
+struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac);
+
+void ap91_pci_init(u8 *cal_data, u8 *mac_addr);
+void ap91_pci_init_simple(void);
+void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+		   u8 *cal_data1, u8 *mac_addr1);
+
+#else
+static inline void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin) {}
+static inline void ap9x_pci_setup_wmac_gpio(unsigned wmac,
+					    u32 mask, u32 val) {}
+static inline void ap9x_pci_setup_wmac_leds(unsigned wmac,
+					    struct gpio_led *leds,
+					    int num_leds) {}
+static inline void ap9x_pci_setup_wmac_btns(unsigned wmac,
+					    struct gpio_keys_button *btns,
+					    unsigned num_btns,
+					    unsigned poll_interval) {}
+static inline struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	return NULL;
+}
+
+static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) {}
+static inline void ap91_pci_init_simple(void) {}
+static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				 u8 *cal_data1, u8 *mac_addr1) {}
+#endif
+
+#endif /* _ATH79_DEV_AP9X_PCI_H */
+
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.c
new file mode 100644
index 0000000000..4ade218f7e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.c
@@ -0,0 +1,36 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+
+static struct platform_device ar71xx_dsa_switch_device = {
+	.name		= "dsa",
+	.id		= 0,
+};
+
+void __init ath79_register_dsa(struct device *netdev,
+			       struct device *miidev,
+			       struct dsa_platform_data *d)
+{
+	int i;
+
+	d->netdev = netdev;
+	for (i = 0; i < d->nr_chips; i++)
+		d->chip[i].host_dev = miidev;
+
+	ar71xx_dsa_switch_device.dev.platform_data = d;
+	platform_device_register(&ar71xx_dsa_switch_device);
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.h
new file mode 100644
index 0000000000..3730202e8d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-dsa.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_DSA_H
+#define _ATH79_DEV_DSA_H
+
+#include <net/dsa.h>
+
+void ath79_register_dsa(struct device *netdev,
+			struct device *miidev,
+			struct dsa_platform_data *d);
+
+#endif /* _ATH79_DEV_DSA_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.c
new file mode 100644
index 0000000000..b46bab7886
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.c
@@ -0,0 +1,1248 @@
+/*
+ *  Atheros AR71xx SoC platform devices
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/clk.h>
+#include <linux/sizes.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/irq.h>
+
+#include "common.h"
+#include "dev-eth.h"
+
+unsigned char ath79_mac_base[ETH_ALEN] __initdata;
+
+static struct resource ath79_mdio0_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}
+};
+
+struct ag71xx_mdio_platform_data ath79_mdio0_data;
+
+struct platform_device ath79_mdio0_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 0,
+	.resource	= ath79_mdio0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio0_resources),
+	.dev = {
+		.platform_data = &ath79_mdio0_data,
+	},
+};
+
+static struct resource ath79_mdio1_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}
+};
+
+struct ag71xx_mdio_platform_data ath79_mdio1_data;
+
+struct platform_device ath79_mdio1_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 1,
+	.resource	= ath79_mdio1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio1_resources),
+	.dev = {
+		.platform_data = &ath79_mdio1_data,
+	},
+};
+
+static void ath79_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	t = __raw_readl(base + cfg_reg);
+	t &= ~(3 << shift);
+	t |=  (2 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	__raw_writel(pll_val, base + pll_reg);
+
+	t |= (3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	t &= ~(3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	printk(KERN_DEBUG "ar71xx: pll_reg %#x: %#x\n",
+		(unsigned int)(base + pll_reg), __raw_readl(base + pll_reg));
+
+	iounmap(base);
+}
+
+static void __init ath79_mii_ctrl_set_if(unsigned int reg,
+					  unsigned int mii_if)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_IF_MASK);
+	t |= (mii_if & AR71XX_MII_CTRL_IF_MASK);
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static void ath79_mii_ctrl_set_speed(unsigned int reg, unsigned int speed)
+{
+	void __iomem *base;
+	unsigned int mii_speed;
+	u32 t;
+
+	switch (speed) {
+	case SPEED_10:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_10;
+		break;
+	case SPEED_100:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_100;
+		break;
+	case SPEED_1000:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_SPEED_MASK << AR71XX_MII_CTRL_SPEED_SHIFT);
+	t |= mii_speed  << AR71XX_MII_CTRL_SPEED_SHIFT;
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static unsigned long ar934x_get_mdio_ref_clock(void)
+{
+	void __iomem *base;
+	unsigned long ret;
+	u32 t;
+
+	base = ioremap(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	ret = 0;
+	t = __raw_readl(base + AR934X_PLL_SWITCH_CLOCK_CONTROL_REG);
+	if (t & AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL) {
+		ret = 100 * 1000 * 1000;
+	} else {
+		struct clk *clk;
+
+		clk = clk_get(NULL, "ref");
+		if (!IS_ERR(clk))
+			ret = clk_get_rate(clk);
+	}
+
+	iounmap(base);
+
+	return ret;
+}
+
+void __init ath79_register_mdio(unsigned int id, u32 phy_mask)
+{
+	struct platform_device *mdio_dev;
+	struct ag71xx_mdio_platform_data *mdio_data;
+	unsigned int max_id;
+
+	if (ath79_soc == ATH79_SOC_AR9341 ||
+	    ath79_soc == ATH79_SOC_AR9342 ||
+	    ath79_soc == ATH79_SOC_AR9344 ||
+	    ath79_soc == ATH79_SOC_QCA9556 ||
+	    ath79_soc == ATH79_SOC_QCA9558 ||
+	    ath79_soc == ATH79_SOC_QCA956X)
+		max_id = 1;
+	else
+		max_id = 0;
+
+	if (id > max_id) {
+		printk(KERN_ERR "ar71xx: invalid MDIO id %u\n", id);
+		return;
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_TP9343:
+		mdio_dev = &ath79_mdio1_device;
+		mdio_data = &ath79_mdio1_data;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+	case ATH79_SOC_QCA956X:
+		if (id == 0) {
+			mdio_dev = &ath79_mdio0_device;
+			mdio_data = &ath79_mdio0_data;
+		} else {
+			mdio_dev = &ath79_mdio1_device;
+			mdio_data = &ath79_mdio1_data;
+		}
+		break;
+
+	case ATH79_SOC_AR7242:
+		ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG,
+			       AR7242_PLL_REG_ETH0_INT_CLOCK, 0x62000000,
+			       AR71XX_ETH0_PLL_SHIFT);
+		/* fall through */
+	default:
+		mdio_dev = &ath79_mdio0_device;
+		mdio_data = &ath79_mdio0_data;
+		break;
+	}
+
+	mdio_data->phy_mask = phy_mask;
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7240:
+		mdio_data->is_ar7240 = 1;
+		/* fall through */
+	case ATH79_SOC_AR7241:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+		mdio_data->is_ar9330 = 1;
+		/* fall through */
+	case ATH79_SOC_AR9331:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+		if (id == 1) {
+			mdio_data->builtin_switch = 1;
+			mdio_data->ref_clock = ar934x_get_mdio_ref_clock();
+			mdio_data->mdio_clock = 6250000;
+		}
+		mdio_data->is_ar934x = 1;
+		break;
+
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_TP9343:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+		mdio_data->is_ar934x = 1;
+		break;
+
+	case ATH79_SOC_QCA956X:
+		if (id == 1)
+			mdio_data->builtin_switch = 1;
+		mdio_data->is_ar934x = 1;
+		break;
+
+	default:
+		break;
+	}
+
+	platform_device_register(mdio_dev);
+}
+
+struct ath79_eth_pll_data ath79_eth0_pll_data;
+struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+static u32 ath79_get_eth_pll(unsigned int mac, int speed)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_val;
+
+	switch (mac) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (speed) {
+	case SPEED_10:
+		pll_val = pll_data->pll_10;
+		break;
+	case SPEED_100:
+		pll_val = pll_data->pll_100;
+		break;
+	case SPEED_1000:
+		pll_val = pll_data->pll_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	return pll_val;
+}
+
+static void ath79_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
+			val, AR71XX_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ath79_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR71XX_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar7242_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+	void __iomem *base;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR7242_PLL_REG_ETH0_INT_CLOCK);
+	iounmap(base);
+}
+
+static void ar91xx_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH0_INT_CLOCK,
+			 val, AR913X_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ar91xx_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR913X_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar934x_set_speed_ge0(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR934X_PLL_ETH_XMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void qca955x_set_speed_xmii(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + QCA955X_PLL_ETH_XMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void qca955x_set_speed_sgmii(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + QCA955X_PLL_ETH_SGMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void qca956x_set_speed_sgmii(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + QCA955X_PLL_ETH_SGMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void ath79_set_speed_dummy(int speed)
+{
+}
+
+static void ath79_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(0);
+}
+
+static void ath79_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(1);
+}
+
+static struct resource ath79_eth0_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ(4),
+		.end	= ATH79_CPU_IRQ(4),
+	},
+};
+
+struct ag71xx_platform_data ath79_eth0_data = {
+	.reset_bit	= AR71XX_RESET_GE0_MAC,
+};
+
+struct platform_device ath79_eth0_device = {
+	.name		= "ag71xx",
+	.id		= 0,
+	.resource	= ath79_eth0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth0_resources),
+	.dev = {
+		.platform_data = &ath79_eth0_data,
+	},
+};
+
+static struct resource ath79_eth1_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ(5),
+		.end	= ATH79_CPU_IRQ(5),
+	},
+};
+
+struct ag71xx_platform_data ath79_eth1_data = {
+	.reset_bit	= AR71XX_RESET_GE1_MAC,
+};
+
+struct platform_device ath79_eth1_device = {
+	.name		= "ag71xx",
+	.id		= 1,
+	.resource	= ath79_eth1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth1_resources),
+	.dev = {
+		.platform_data = &ath79_eth1_data,
+	},
+};
+
+struct ag71xx_switch_platform_data ath79_switch_data;
+
+#define AR71XX_PLL_VAL_1000	0x00110000
+#define AR71XX_PLL_VAL_100	0x00001099
+#define AR71XX_PLL_VAL_10	0x00991099
+
+#define AR724X_PLL_VAL_1000	0x00110000
+#define AR724X_PLL_VAL_100	0x00001099
+#define AR724X_PLL_VAL_10	0x00991099
+
+#define AR7242_PLL_VAL_1000	0x16000000
+#define AR7242_PLL_VAL_100	0x00000101
+#define AR7242_PLL_VAL_10	0x00001616
+
+#define AR913X_PLL_VAL_1000	0x1a000000
+#define AR913X_PLL_VAL_100	0x13000a44
+#define AR913X_PLL_VAL_10	0x00441099
+
+#define AR933X_PLL_VAL_1000	0x00110000
+#define AR933X_PLL_VAL_100	0x00001099
+#define AR933X_PLL_VAL_10	0x00991099
+
+#define AR934X_PLL_VAL_1000	0x16000000
+#define AR934X_PLL_VAL_100	0x00000101
+#define AR934X_PLL_VAL_10	0x00001616
+
+#define QCA956X_PLL_VAL_1000	0x03000000
+#define QCA956X_PLL_VAL_100	0x00000101
+#define QCA956X_PLL_VAL_10	0x00001919
+
+static void __init ath79_init_eth_pll_data(unsigned int id)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_10, pll_100, pll_1000;
+
+	switch (id) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		pll_10 = AR71XX_PLL_VAL_10;
+		pll_100 = AR71XX_PLL_VAL_100;
+		pll_1000 = AR71XX_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7240:
+	case ATH79_SOC_AR7241:
+		pll_10 = AR724X_PLL_VAL_10;
+		pll_100 = AR724X_PLL_VAL_100;
+		pll_1000 = AR724X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7242:
+		pll_10 = AR7242_PLL_VAL_10;
+		pll_100 = AR7242_PLL_VAL_100;
+		pll_1000 = AR7242_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9130:
+	case ATH79_SOC_AR9132:
+		pll_10 = AR913X_PLL_VAL_10;
+		pll_100 = AR913X_PLL_VAL_100;
+		pll_1000 = AR913X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		pll_10 = AR933X_PLL_VAL_10;
+		pll_100 = AR933X_PLL_VAL_100;
+		pll_1000 = AR933X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+	case ATH79_SOC_TP9343:
+		pll_10 = AR934X_PLL_VAL_10;
+		pll_100 = AR934X_PLL_VAL_100;
+		pll_1000 = AR934X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_QCA956X:
+		pll_10 = QCA956X_PLL_VAL_10;
+		pll_100 = QCA956X_PLL_VAL_100;
+		pll_1000 = QCA956X_PLL_VAL_1000;
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (!pll_data->pll_10)
+		pll_data->pll_10 = pll_10;
+
+	if (!pll_data->pll_100)
+		pll_data->pll_100 = pll_100;
+
+	if (!pll_data->pll_1000)
+		pll_data->pll_1000 = pll_1000;
+}
+
+static int __init ath79_setup_phy_if_mode(unsigned int id,
+					   struct ag71xx_platform_data *pdata)
+{
+	unsigned int mii_if;
+
+	switch (id) {
+	case 0:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+				mii_if = AR71XX_MII0_CTRL_IF_MII;
+				break;
+			case PHY_INTERFACE_MODE_GMII:
+				mii_if = AR71XX_MII0_CTRL_IF_GMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RGMII;
+				break;
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII0_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_QCA9533:
+		case ATH79_SOC_TP9343:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_MII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_RMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+		case ATH79_SOC_QCA956X:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_SGMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	case 1:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RGMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII1_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_TP9343:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_GMII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+		case ATH79_SOC_QCA9533:
+		case ATH79_SOC_QCA956X:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_SGMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	}
+
+	return 0;
+}
+
+void __init ath79_setup_ar933x_phy4_switch(bool mac, bool mdio)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR933X_GMAC_BASE, AR933X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);
+	t &= ~(AR933X_ETH_CFG_SW_PHY_SWAP | AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);
+	if (mac)
+		t |= AR933X_ETH_CFG_SW_PHY_SWAP;
+	if (mdio)
+		t |= AR933X_ETH_CFG_SW_PHY_ADDR_SWAP;
+	__raw_writel(t, base + AR933X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_ar934x_eth_cfg(u32 mask)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	t &= ~(AR934X_ETH_CFG_RGMII_GMAC0 |
+	       AR934X_ETH_CFG_MII_GMAC0 |
+	       AR934X_ETH_CFG_GMII_GMAC0 |
+	       AR934X_ETH_CFG_SW_ONLY_MODE |
+	       AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	t |= mask;
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+	/* flush write */
+	__raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_ar934x_eth_rx_delay(unsigned int rxd,
+					    unsigned int rxdv)
+{
+	void __iomem *base;
+	u32 t;
+
+	rxd &= AR934X_ETH_CFG_RXD_DELAY_MASK;
+	rxdv &= AR934X_ETH_CFG_RDV_DELAY_MASK;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	t &= ~(AR934X_ETH_CFG_RXD_DELAY_MASK << AR934X_ETH_CFG_RXD_DELAY_SHIFT |
+	       AR934X_ETH_CFG_RDV_DELAY_MASK << AR934X_ETH_CFG_RDV_DELAY_SHIFT);
+
+	t |= (rxd << AR934X_ETH_CFG_RXD_DELAY_SHIFT |
+	      rxdv << AR934X_ETH_CFG_RDV_DELAY_SHIFT);
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+	/* flush write */
+	__raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_qca955x_eth_cfg(u32 mask)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = __raw_readl(base + QCA955X_GMAC_REG_ETH_CFG);
+
+	t &= ~(QCA955X_ETH_CFG_RGMII_EN | QCA955X_ETH_CFG_GE0_SGMII);
+
+	t |= mask;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_qca956x_eth_cfg(u32 mask)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA956X_GMAC_BASE, QCA956X_GMAC_SIZE);
+
+	t = __raw_readl(base + QCA956X_GMAC_REG_ETH_CFG);
+
+	t &= ~(QCA956X_ETH_CFG_SW_ONLY_MODE |
+	       QCA956X_ETH_CFG_SW_PHY_SWAP);
+
+	t |= mask;
+
+	__raw_writel(t, base + QCA956X_GMAC_REG_ETH_CFG);
+	/* flush write */
+	__raw_readl(base + QCA956X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static int ath79_eth_instance __initdata;
+void __init ath79_register_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	if (id > 1) {
+		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
+		return;
+	}
+
+	ath79_init_eth_pll_data(id);
+
+	if (id == 0)
+		pdev = &ath79_eth0_device;
+	else
+		pdev = &ath79_eth1_device;
+
+	pdata = pdev->dev.platform_data;
+
+	pdata->max_frame_len = 1540;
+	pdata->desc_pktlen_mask = 0xfff;
+
+	err = ath79_setup_phy_if_mode(id, pdata);
+	if (err) {
+		printk(KERN_ERR
+		       "ar71xx: invalid PHY interface mode for GE%u\n", id);
+		return;
+	}
+
+	if (id == 0)
+		pdata->ddr_flush = ath79_ddr_flush_ge0;
+	else
+		pdata->ddr_flush = ath79_ddr_flush_ge1;
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+		if (id == 0)
+			pdata->set_speed = ath79_set_speed_ge0;
+		else
+			pdata->set_speed = ath79_set_speed_ge1;
+		break;
+
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		if (id == 0)
+			pdata->set_speed = ath79_set_speed_ge0;
+		else
+			pdata->set_speed = ath79_set_speed_ge1;
+		pdata->has_gbit = 1;
+		break;
+
+	case ATH79_SOC_AR7242:
+		if (id == 0) {
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO |
+					    AR71XX_RESET_GE0_PHY;
+			pdata->set_speed = ar7242_set_speed_ge0;
+		} else {
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO |
+					    AR71XX_RESET_GE1_PHY;
+			pdata->set_speed = ath79_set_speed_dummy;
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		break;
+
+	case ATH79_SOC_AR7241:
+		if (id == 0)
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO;
+		else
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO;
+		/* fall through */
+	case ATH79_SOC_AR7240:
+		if (id == 0) {
+			pdata->reset_bit |= AR71XX_RESET_GE0_PHY;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit |= AR71XX_RESET_GE1_PHY;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+			pdata->use_flow_control = 1;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		if (ath79_soc == ATH79_SOC_AR7240)
+			pdata->is_ar7240 = 1;
+		break;
+
+	case ATH79_SOC_AR9132:
+		pdata->has_gbit = 1;
+		/* fall through */
+	case ATH79_SOC_AR9130:
+		if (id == 0)
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		else
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		pdata->is_ar91xx = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->has_gbit = 1;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+			pdata->use_flow_control = 1;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+
+		pdata->is_ar724x = 1;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9533:
+		if (id == 0) {
+			pdata->reset_bit = AR934X_RESET_GE0_MAC |
+					   AR934X_RESET_GE0_MDIO;
+			pdata->set_speed = ar934x_set_speed_ge0;
+
+			if (ath79_soc == ATH79_SOC_QCA9533)
+				pdata->disable_inline_checksum_engine = 1;
+		} else {
+			pdata->reset_bit = AR934X_RESET_GE1_MAC |
+					   AR934X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->switch_data = &ath79_switch_data;
+
+			/* reset the built-in switch */
+			ath79_device_reset_set(AR934X_RESET_ETH_SWITCH);
+			ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH);
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		pdata->max_frame_len = SZ_16K - 1;
+		pdata->desc_pktlen_mask = SZ_16K - 1;
+		break;
+
+	case ATH79_SOC_TP9343:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			if (!pdata->phy_mask)
+				pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+			pdata->use_flow_control = 1;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		break;
+
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+		if (id == 0) {
+			pdata->reset_bit = QCA955X_RESET_GE0_MAC |
+					   QCA955X_RESET_GE0_MDIO;
+			pdata->set_speed = qca955x_set_speed_xmii;
+		} else {
+			pdata->reset_bit = QCA955X_RESET_GE1_MAC |
+					   QCA955X_RESET_GE1_MDIO;
+			pdata->set_speed = qca955x_set_speed_sgmii;
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		/*
+		 * Limit the maximum frame length to 4095 bytes.
+		 * Although the documentation says that the hardware
+		 * limit is 16383 bytes but that does not work in
+		 * practice. It seems that the hardware only updates
+		 * the lowest 12 bits of the packet length field
+		 * in the RX descriptor.
+		 */
+		pdata->max_frame_len = SZ_4K - 1;
+		pdata->desc_pktlen_mask = SZ_16K - 1;
+		break;
+
+	case ATH79_SOC_QCA956X:
+		if (id == 0) {
+			pdata->reset_bit = QCA955X_RESET_GE0_MAC |
+					   QCA955X_RESET_GE0_MDIO;
+
+			if (pdata->phy_if_mode == PHY_INTERFACE_MODE_SGMII)
+				pdata->set_speed = qca956x_set_speed_sgmii;
+			else
+				pdata->set_speed = ar934x_set_speed_ge0;
+
+			pdata->disable_inline_checksum_engine = 1;
+		} else {
+			pdata->reset_bit = QCA955X_RESET_GE1_MAC |
+					   QCA955X_RESET_GE1_MDIO;
+
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->switch_data = &ath79_switch_data;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->use_flow_control = 1;
+
+			/* reset the built-in switch */
+			ath79_device_reset_set(AR934X_RESET_ETH_SWITCH);
+			ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH);
+		}
+
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		break;
+
+	default:
+		BUG();
+	}
+
+	switch (pdata->phy_if_mode) {
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_SGMII:
+		if (!pdata->has_gbit) {
+			printk(KERN_ERR "ar71xx: no gbit available on eth%d\n",
+					id);
+			return;
+		}
+		/* fallthrough */
+	default:
+		break;
+	}
+
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
+		random_ether_addr(pdata->mac_addr);
+		printk(KERN_DEBUG
+			"ar71xx: using random MAC address for eth%d\n",
+			ath79_eth_instance);
+	}
+
+	if (pdata->mii_bus_dev == NULL) {
+		switch (ath79_soc) {
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+			if (id == 0)
+				pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			else
+				pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_QCA9533:
+		case ATH79_SOC_TP9343:
+			pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+			/* don't assign any MDIO device by default */
+			break;
+
+		case ATH79_SOC_QCA956X:
+			if (pdata->phy_if_mode != PHY_INTERFACE_MODE_SGMII)
+				pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		default:
+			pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			break;
+		}
+	}
+
+	/* Reset the device */
+	ath79_device_reset_set(pdata->reset_bit);
+	msleep(100);
+
+	ath79_device_reset_clear(pdata->reset_bit);
+	msleep(100);
+
+	platform_device_register(pdev);
+	ath79_eth_instance++;
+}
+
+void __init ath79_set_mac_base(unsigned char *mac)
+{
+	memcpy(ath79_mac_base, mac, ETH_ALEN);
+}
+
+void __init ath79_parse_ascii_mac(char *mac_str, u8 *mac)
+{
+	int t;
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx.%02hhx.%02hhx.%02hhx.%02hhx.%02hhx",
+			&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN || !is_valid_ether_addr(mac)) {
+		memset(mac, 0, ETH_ALEN);
+		printk(KERN_DEBUG "ar71xx: invalid mac address \"%s\"\n",
+		       mac_str);
+	}
+}
+
+void __init ath79_extract_mac_reverse(u8 *ptr, u8 *out)
+{
+	int i;
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		out[i] = ptr[ETH_ALEN-i-1];
+	}
+}
+
+static void __init ath79_set_mac_base_ascii(char *str)
+{
+	u8 mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac(str, mac);
+	ath79_set_mac_base(mac);
+}
+
+static int __init ath79_ethaddr_setup(char *str)
+{
+	ath79_set_mac_base_ascii(str);
+	return 1;
+}
+__setup("ethaddr=", ath79_ethaddr_setup);
+
+static int __init ath79_kmac_setup(char *str)
+{
+	ath79_set_mac_base_ascii(str);
+	return 1;
+}
+__setup("kmac=", ath79_kmac_setup);
+
+void __init ath79_init_mac(unsigned char *dst, const unsigned char *src,
+			    int offset)
+{
+	int t;
+
+	if (!dst)
+		return;
+
+	if (!src || !is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
+
+void __init ath79_init_local_mac(unsigned char *dst, const unsigned char *src)
+{
+	int i;
+
+	if (!dst)
+		return;
+
+	if (!src || !is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[i] = src[i];
+	dst[0] |= 0x02;
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.h
new file mode 100644
index 0000000000..4d78260fbe
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-eth.h
@@ -0,0 +1,55 @@
+/*
+ *  Atheros AR71xx SoC device definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_ETH_H
+#define _ATH79_DEV_ETH_H
+
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+struct platform_device;
+
+extern unsigned char ath79_mac_base[] __initdata;
+void ath79_parse_ascii_mac(char *mac_str, u8 *mac);
+void ath79_extract_mac_reverse(u8 *ptr, u8 *out);
+void ath79_init_mac(unsigned char *dst, const unsigned char *src,
+		    int offset);
+void ath79_init_local_mac(unsigned char *dst, const unsigned char *src);
+
+struct ath79_eth_pll_data {
+	u32	pll_10;
+	u32	pll_100;
+	u32	pll_1000;
+};
+
+extern struct ath79_eth_pll_data ath79_eth0_pll_data;
+extern struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+extern struct ag71xx_platform_data ath79_eth0_data;
+extern struct ag71xx_platform_data ath79_eth1_data;
+extern struct platform_device ath79_eth0_device;
+extern struct platform_device ath79_eth1_device;
+void ath79_register_eth(unsigned int id);
+
+extern struct ag71xx_switch_platform_data ath79_switch_data;
+
+extern struct ag71xx_mdio_platform_data ath79_mdio0_data;
+extern struct ag71xx_mdio_platform_data ath79_mdio1_data;
+extern struct platform_device ath79_mdio0_device;
+extern struct platform_device ath79_mdio1_device;
+void ath79_register_mdio(unsigned int id, u32 phy_mask);
+
+void ath79_setup_ar933x_phy4_switch(bool mac, bool mdio);
+void ath79_setup_ar934x_eth_cfg(u32 mask);
+void ath79_setup_ar934x_eth_rx_delay(unsigned int rxd, unsigned int rxdv);
+void ath79_setup_qca955x_eth_cfg(u32 mask);
+void ath79_setup_qca956x_eth_cfg(u32 mask);
+
+#endif /* _ATH79_DEV_ETH_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.c
new file mode 100644
index 0000000000..e53d97dcbf
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.c
@@ -0,0 +1,101 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include "dev-spi.h"
+#include "dev-m25p80.h"
+
+static struct spi_board_info ath79_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz   = 25000000,
+		.modalias	= "m25p80",
+	}
+};
+
+static struct ath79_spi_platform_data ath79_spi_data;
+
+void __init ath79_register_m25p80(struct flash_platform_data *pdata)
+{
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 1;
+	ath79_spi_info[0].platform_data = pdata;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 1);
+}
+
+static struct flash_platform_data *multi_pdata;
+
+static struct mtd_info *concat_devs[2] = { NULL, NULL };
+static struct work_struct mtd_concat_work;
+
+static void mtd_concat_add_work(struct work_struct *work)
+{
+	struct mtd_info *mtd;
+
+	mtd = mtd_concat_create(concat_devs, ARRAY_SIZE(concat_devs), "flash");
+
+	mtd_device_register(mtd, multi_pdata->parts, multi_pdata->nr_parts);
+}
+
+static void mtd_concat_add(struct mtd_info *mtd)
+{
+	static bool registered = false;
+
+	if (registered)
+		return;
+
+	if (!strcmp(mtd->name, "spi0.0"))
+		concat_devs[0] = mtd;
+	else if (!strcmp(mtd->name, "spi0.1"))
+		concat_devs[1] = mtd;
+	else
+		return;
+
+	if (!concat_devs[0] || !concat_devs[1])
+		return;
+
+	registered = true;
+	INIT_WORK(&mtd_concat_work, mtd_concat_add_work);
+	schedule_work(&mtd_concat_work);
+}
+
+static void mtd_concat_remove(struct mtd_info *mtd)
+{
+}
+
+static void add_mtd_concat_notifier(void)
+{
+	static struct mtd_notifier not = {
+		.add = mtd_concat_add,
+		.remove = mtd_concat_remove,
+	};
+
+	register_mtd_user(&not);
+}
+
+void __init ath79_register_m25p80_multi(struct flash_platform_data *pdata)
+{
+	multi_pdata = pdata;
+	add_mtd_concat_notifier();
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 2;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 2);
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.h
new file mode 100644
index 0000000000..637b41a7d8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-m25p80.h
@@ -0,0 +1,17 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_M25P80_H
+#define _ATH79_DEV_M25P80_H
+
+#include <linux/spi/flash.h>
+
+void ath79_register_m25p80(struct flash_platform_data *pdata) __init;
+void ath79_register_m25p80_multi(struct flash_platform_data *pdata) __init;
+
+#endif /* _ATH79_DEV_M25P80_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.c
new file mode 100644
index 0000000000..9b5256ecc2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.c
@@ -0,0 +1,141 @@
+/*
+ *  Atheros AR934X SoCs built-in NAND flash controller support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-nfc.h"
+
+static struct resource ath79_nfc_resources[2];
+static u64 ar934x_nfc_dmamask = DMA_BIT_MASK(32);
+static struct ar934x_nfc_platform_data ath79_nfc_data;
+
+static struct platform_device ath79_nfc_device = {
+	.name		= AR934X_NFC_DRIVER_NAME,
+	.id		= -1,
+	.resource	= ath79_nfc_resources,
+	.num_resources	= ARRAY_SIZE(ath79_nfc_resources),
+	.dev = {
+		.dma_mask = &ar934x_nfc_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &ath79_nfc_data,
+	},
+};
+
+static void __init ath79_nfc_init_resource(struct resource res[2],
+					   unsigned long base,
+					   unsigned long size,
+					   int irq)
+{
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].flags = IORESOURCE_MEM;
+	res[0].start = base;
+	res[0].end = base + size - 1;
+
+	res[1].flags = IORESOURCE_IRQ;
+	res[1].start = irq;
+	res[1].end = irq;
+}
+
+static void ar934x_nfc_hw_reset(bool active)
+{
+	if (active) {
+		ath79_device_reset_set(AR934X_RESET_NANDF);
+		udelay(100);
+
+		ath79_device_reset_set(AR934X_RESET_ETH_SWITCH_ANALOG);
+		udelay(250);
+	} else {
+		ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH_ANALOG);
+		udelay(250);
+
+		ath79_device_reset_clear(AR934X_RESET_NANDF);
+		udelay(100);
+	}
+}
+
+static void ar934x_nfc_setup(void)
+{
+	ath79_nfc_data.hw_reset = ar934x_nfc_hw_reset;
+
+	ath79_nfc_init_resource(ath79_nfc_resources,
+				AR934X_NFC_BASE, AR934X_NFC_SIZE,
+				ATH79_MISC_IRQ(21));
+
+	platform_device_register(&ath79_nfc_device);
+}
+
+static void qca955x_nfc_hw_reset(bool active)
+{
+	if (active) {
+		ath79_device_reset_set(QCA955X_RESET_NANDF);
+		udelay(250);
+	} else {
+		ath79_device_reset_clear(QCA955X_RESET_NANDF);
+		udelay(100);
+	}
+}
+
+static void qca955x_nfc_setup(void)
+{
+	ath79_nfc_data.hw_reset = qca955x_nfc_hw_reset;
+
+	ath79_nfc_init_resource(ath79_nfc_resources,
+				QCA955X_NFC_BASE, QCA955X_NFC_SIZE,
+				ATH79_MISC_IRQ(21));
+
+	platform_device_register(&ath79_nfc_device);
+}
+
+void __init ath79_nfc_set_select_chip(void (*f)(int chip_no))
+{
+	ath79_nfc_data.select_chip = f;
+}
+
+void __init ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd))
+{
+	ath79_nfc_data.scan_fixup = f;
+}
+
+void __init ath79_nfc_set_swap_dma(bool enable)
+{
+	ath79_nfc_data.swap_dma = enable;
+}
+
+void __init ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode)
+{
+	ath79_nfc_data.ecc_mode = mode;
+}
+
+void __init ath79_nfc_set_parts(struct mtd_partition *parts, int nr_parts)
+{
+	ath79_nfc_data.parts = parts;
+	ath79_nfc_data.nr_parts = nr_parts;
+}
+
+void __init ath79_register_nfc(void)
+{
+	if (soc_is_ar934x())
+		ar934x_nfc_setup();
+	else if (soc_is_qca955x())
+		qca955x_nfc_setup();
+	else
+		BUG();
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.h
new file mode 100644
index 0000000000..3a1c88fe98
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/dev-nfc.h
@@ -0,0 +1,34 @@
+/*
+ *  Atheros AR934X SoCs built-in NAND Flash Controller support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_NFC_H
+#define _ATH79_DEV_NFC_H
+
+struct mtd_partition;
+enum ar934x_nfc_ecc_mode;
+
+#ifdef CONFIG_ATH79_DEV_NFC
+void ath79_nfc_set_parts(struct mtd_partition *parts, int nr_parts);
+void ath79_nfc_set_select_chip(void (*f)(int chip_no));
+void ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd));
+void ath79_nfc_set_swap_dma(bool enable);
+void ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode);
+void ath79_register_nfc(void);
+#else
+static inline void ath79_nfc_set_parts(struct mtd_partition *parts,
+				       int nr_parts) {}
+static inline void ath79_nfc_set_select_chip(void (*f)(int chip_no)) {}
+static inline void ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd)) {}
+static inline void ath79_nfc_set_swap_dma(bool enable) {}
+static inline void ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode) {}
+static inline void ath79_register_nfc(void) {}
+#endif
+
+#endif /* _ATH79_DEV_NFC_H */
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-a60.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-a60.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-a60.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-a60.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-ap120c.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap120c.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-alfa-ap120c.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap120c.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap96.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap96.c
new file mode 100644
index 0000000000..531e5fb18e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-ap96.c
@@ -0,0 +1,132 @@
+/*
+ *  ALFA Network AP96 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ALFA_AP96_GPIO_PCIE_RESET	2
+#define ALFA_AP96_GPIO_SIM_DETECT	3
+#define ALFA_AP96_GPIO_MICROSD_CD	4
+#define ALFA_AP96_GPIO_PCIE_W_DISABLE	5
+
+#define ALFA_AP96_GPIO_BUTTON_RESET	11
+
+#define ALFA_AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define ALFA_AP96_KEYS_DEBOUNCE_INTERVAL	(3 * ALFA_AP96_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button alfa_ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_AP96_GPIO_BUTTON_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct mmc_spi_platform_data alfa_ap96_mmc_data = {
+	.flags		= MMC_SPI_USE_CD_GPIO,
+	.cd_gpio	= ALFA_AP96_GPIO_MICROSD_CD,
+	.cd_debounce	= 1,
+	.caps		= MMC_CAP_NEEDS_POLL,
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info alfa_ap96_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &alfa_ap96_mmc_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 6250000,
+		.modalias	= "rtc-pcf2123",
+	},
+};
+
+static struct ath79_spi_platform_data alfa_ap96_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 3,
+};
+
+static void __init alfa_ap96_gpio_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	gpio_request(ALFA_AP96_GPIO_MICROSD_CD, "microSD CD");
+	gpio_direction_input(ALFA_AP96_GPIO_MICROSD_CD);
+	gpio_request(ALFA_AP96_GPIO_PCIE_RESET, "PCIe reset");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_RESET, 1);
+	gpio_request(ALFA_AP96_GPIO_PCIE_W_DISABLE, "PCIe write disable");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_W_DISABLE, 1);
+}
+
+#define ALFA_AP96_WAN_PHYMASK	BIT(4)
+#define ALFA_AP96_LAN_PHYMASK	BIT(5)
+#define ALFA_AP96_MDIO_PHYMASK	(ALFA_AP96_LAN_PHYMASK | ALFA_AP96_WAN_PHYMASK)
+
+static void __init alfa_ap96_init(void)
+{
+	alfa_ap96_gpio_setup();
+
+	ath79_register_mdio(0, ~ALFA_AP96_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ALFA_AP96_WAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = ALFA_AP96_LAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+	ath79_register_spi(&alfa_ap96_spi_data, alfa_ap96_spi_info,
+			   ARRAY_SIZE(alfa_ap96_spi_info));
+
+	ath79_register_gpio_keys_polled(-1, ALFA_AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(alfa_ap96_gpio_keys),
+					 alfa_ap96_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_AP96, "ALFA-AP96", "ALFA Network AP96",
+	     alfa_ap96_init);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-nx.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-nx.c
new file mode 100644
index 0000000000..a515f4f540
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-alfa-nx.c
@@ -0,0 +1,113 @@
+/*
+ *  ALFA Network N2/N5 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define ALFA_NX_GPIO_LED_2		17
+#define ALFA_NX_GPIO_LED_3		16
+#define ALFA_NX_GPIO_LED_5		12
+#define ALFA_NX_GPIO_LED_6		8
+#define ALFA_NX_GPIO_LED_7		6
+#define ALFA_NX_GPIO_LED_8		7
+
+#define ALFA_NX_GPIO_BTN_RESET		11
+
+#define ALFA_NX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALFA_NX_KEYS_DEBOUNCE_INTERVAL (3 * ALFA_NX_KEYS_POLL_INTERVAL)
+
+#define ALFA_NX_MAC0_OFFSET		0
+#define ALFA_NX_MAC1_OFFSET		6
+#define ALFA_NX_CALDATA_OFFSET		0x1000
+
+static struct gpio_keys_button alfa_nx_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_NX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_NX_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led alfa_nx_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:green:led_2",
+		.gpio		= ALFA_NX_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_3",
+		.gpio		= ALFA_NX_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:red:led_5",
+		.gpio		= ALFA_NX_GPIO_LED_5,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:amber:led_6",
+		.gpio		= ALFA_NX_GPIO_LED_6,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_7",
+		.gpio		= ALFA_NX_GPIO_LED_7,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_8",
+		.gpio		= ALFA_NX_GPIO_LED_8,
+		.active_low	= 1,
+	}
+};
+
+static void __init alfa_nx_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(alfa_nx_leds_gpio),
+				 alfa_nx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALFA_NX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(alfa_nx_gpio_keys),
+					alfa_nx_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + ALFA_NX_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + ALFA_NX_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ath79_register_eth(0);
+	/* LAN port */
+	ath79_register_eth(1);
+
+	ap91_pci_init(art + ALFA_NX_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_NX, "ALFA-NX", "ALFA Network N2/N5",
+	     alfa_nx_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0258n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0258n.c
new file mode 100644
index 0000000000..2495bcba79
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0258n.c
@@ -0,0 +1,88 @@
+/*
+ *  Allnet ALL0258N support
+ *
+ *  Copyright (C) 2011 Daniel Golle <dgolle@allnet.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+/* found via /sys/gpio/... try and error */
+#define ALL0258N_GPIO_BTN_RESET		1
+#define ALL0258N_GPIO_LED_RSSIHIGH	13
+#define ALL0258N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0258N_GPIO_LED_RSSILOW	14
+
+/* defaults taken from others machs */
+#define ALL0258N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0258N_KEYS_DEBOUNCE_INTERVAL (3 * ALL0258N_KEYS_POLL_INTERVAL)
+
+/* showed up in the original firmware's bootlog */
+#define ALL0258N_SEC_PHYMASK BIT(3)
+
+static struct gpio_led all0258n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0258n:green:rssihigh",
+		.gpio		= ALL0258N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:yellow:rssimedium",
+		.gpio		= ALL0258N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:red:rssilow",
+		.gpio		= ALL0258N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0258n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0258N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0258N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0258n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7f0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1f7f1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(all0258n_leds_gpio),
+				 all0258n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALL0258N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(all0258n_gpio_keys),
+					all0258n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_eth1_data.phy_mask = ALL0258N_SEC_PHYMASK;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALL0258N, "ALL0258N", "Allnet ALL0258N",
+	     all0258n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0315n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0315n.c
new file mode 100644
index 0000000000..387ee7f9ea
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-all0315n.c
@@ -0,0 +1,85 @@
+/*
+ *  Allnet ALL0315N support
+ *
+ *  Copyright (C) 2012 Daniel Golle <dgolle@allnet.de>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ALL0315N_GPIO_BTN_RESET		0
+#define ALL0315N_GPIO_LED_RSSIHIGH	14
+#define ALL0315N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0315N_GPIO_LED_RSSILOW	16
+
+#define ALL0315N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0315N_KEYS_DEBOUNCE_INTERVAL	(3 * ALL0315N_KEYS_POLL_INTERVAL)
+
+static struct gpio_led all0315n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0315n:green:rssihigh",
+		.gpio		= ALL0315N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0315n:yellow:rssimedium",
+		.gpio		= ALL0315N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0315n:red:rssilow",
+		.gpio		= ALL0315N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0315n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0315N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0315N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0315n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffc0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1ffc1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(all0315n_leds_gpio),
+					all0315n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALL0315N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(all0315n_gpio_keys),
+					all0315n_gpio_keys);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap91_pci_init(ee, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALL0315N, "ALL0315N", "Allnet ALL0315N",
+	     all0315n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s1.c
new file mode 100644
index 0000000000..0a81227b51
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s1.c
@@ -0,0 +1,98 @@
+/*
+ *   Bitmain Antminer S1 board support
+ *
+ *  Copyright (C) 2015 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define ANTMINER_S1_GPIO_BTN_RESET		11
+
+#define ANTMINER_S1_GPIO_LED_SYSTEM		23
+#define ANTMINER_S1_GPIO_LED_WLAN		0
+#define ANTMINER_S1_GPIO_USB_POWER		26
+
+#define ANTMINER_S1_KEYSPOLL_INTERVAL	20	/* msecs */
+#define ANTMINER_S1_KEYSDEBOUNCE_INTERVAL (3 * ANTMINER_S1_KEYSPOLL_INTERVAL)
+
+static const char *ANTMINER_S1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ANTMINER_S1_flash_data = {
+	.part_probes	= ANTMINER_S1_part_probes,
+};
+
+static struct gpio_led ANTMINER_S1_leds_gpio[] __initdata = {
+	{
+		.name		= "antminer-s1:green:system",
+		.gpio		= ANTMINER_S1_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s1:green:wlan",
+		.gpio		= ANTMINER_S1_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ANTMINER_S1_GPIO_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ANTMINER_S1_KEYSDEBOUNCE_INTERVAL,
+		.gpio		= ANTMINER_S1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init antminer_s1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ANTMINER_S1_leds_gpio),
+				 ANTMINER_S1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ANTMINER_S1_KEYSPOLL_INTERVAL,
+					ARRAY_SIZE(ANTMINER_S1_GPIO_keys),
+					ANTMINER_S1_GPIO_keys);
+
+	gpio_request_one(ANTMINER_S1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&ANTMINER_S1_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ANTMINER_S1, "ANTMINER-S1",
+	     "Antminer-S1", antminer_s1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s3.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s3.c
new file mode 100644
index 0000000000..b77a6ccc4e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antminer-s3.c
@@ -0,0 +1,103 @@
+/*
+ *   Bitmain Antminer S3 board support
+ *
+ *  Copyright (C) 2015 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define ANTMINER_S3_GPIO_LED_WLAN		0
+#define ANTMINER_S3_GPIO_LED_SYSTEM		17
+#define ANTMINER_S3_GPIO_LED_LAN		22
+#define ANTMINER_S3_GPIO_USB_POWER		26
+
+#define ANTMINER_S3_GPIO_BTN_RESET		11
+
+#define ANTMINER_S3_KEYSPOLL_INTERVAL	88	/* msecs */
+#define ANTMINER_S3_KEYSDEBOUNCE_INTERVAL (3 * ANTMINER_S3_KEYSPOLL_INTERVAL)
+
+static const char *ANTMINER_S3_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ANTMINER_S3_flash_data = {
+	.part_probes	= ANTMINER_S3_part_probes,
+};
+
+static struct gpio_led ANTMINER_S3_leds_gpio[] __initdata = {
+	{
+		.name		= "antminer-s3:green:wlan",
+		.gpio		= ANTMINER_S3_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s3:green:system",
+		.gpio		= ANTMINER_S3_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s3:yellow:lan",
+		.gpio		= ANTMINER_S3_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ANTMINER_S3_GPIO_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ANTMINER_S3_KEYSDEBOUNCE_INTERVAL,
+		.gpio		= ANTMINER_S3_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init antminer_s3_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ANTMINER_S3_leds_gpio),
+				 ANTMINER_S3_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ANTMINER_S3_KEYSPOLL_INTERVAL,
+					ARRAY_SIZE(ANTMINER_S3_GPIO_keys),
+					ANTMINER_S3_GPIO_keys);
+
+	gpio_request_one(ANTMINER_S3_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&ANTMINER_S3_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ANTMINER_S3, "ANTMINER-S3",
+	     "Antminer-S3", antminer_s3_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antrouter-r1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antrouter-r1.c
new file mode 100644
index 0000000000..a8f7b5d687
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-antrouter-r1.c
@@ -0,0 +1,98 @@
+/*
+ *  Bitmain Antrouter R1 board support
+ *
+ *  Copyright (C) 2015 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define ANTROUTER_R1_GPIO_BTN_RESET		11
+
+#define ANTROUTER_R1_GPIO_LED_WLAN		0
+#define ANTROUTER_R1_GPIO_LED_BTC		22
+#define ANTROUTER_R1_GPIO_USB_POWER		18
+
+#define ANTROUTER_R1_KEYSPOLL_INTERVAL	44	/* msecs */
+#define ANTROUTER_R1_KEYSDEBOUNCE_INTERVAL (4 * ANTROUTER_R1_KEYSPOLL_INTERVAL)
+
+static const char *ANTROUTER_R1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ANTROUTER_R1_flash_data = {
+	.part_probes	= ANTROUTER_R1_part_probes,
+};
+
+static struct gpio_led ANTROUTER_R1_leds_gpio[] __initdata = {
+	{
+		.name		= "antrouter-r1:green:wlan",
+		.gpio		= ANTROUTER_R1_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},{
+		.name		= "antrouter-r1:green:system",
+		.gpio		= ANTROUTER_R1_GPIO_LED_BTC,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ANTROUTER_R1_GPIO_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ANTROUTER_R1_KEYSDEBOUNCE_INTERVAL,
+		.gpio		= ANTROUTER_R1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init antrouter_r1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ANTROUTER_R1_leds_gpio),
+				 ANTROUTER_R1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ANTROUTER_R1_KEYSPOLL_INTERVAL,
+					ARRAY_SIZE(ANTROUTER_R1_GPIO_keys),
+					ANTROUTER_R1_GPIO_keys);
+
+	gpio_request_one(ANTROUTER_R1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&ANTROUTER_R1_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ANTROUTER_R1, "ANTROUTER-R1",
+	     "Antrouter-R1", antrouter_r1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap121f.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap121f.c
new file mode 100644
index 0000000000..955b7faf63
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap121f.c
@@ -0,0 +1,103 @@
+/*
+ * ALFA Network AP121F board support
+ *
+ * Copyright (C) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP121F_GPIO_LED_LAN	17
+#define AP121F_GPIO_LED_VPN	27
+#define AP121F_GPIO_LED_WLAN	0
+
+#define AP121F_GPIO_MICROSD_EN	26
+
+#define AP121F_GPIO_BTN_RESET	12
+#define AP121F_GPIO_BTN_SWITCH	21
+
+#define AP121F_KEYS_POLL_INTERVAL	20
+#define AP121F_KEYS_DEBOUNCE_INTERVAL	(3 * AP121F_KEYS_POLL_INTERVAL)
+
+#define AP121F_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap121f_leds_gpio[] __initdata = {
+	{
+		.name		= "ap121f:green:lan",
+		.gpio		= AP121F_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap121f:green:vpn",
+		.gpio		= AP121F_GPIO_LED_VPN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap121f:green:wlan",
+		.gpio		= AP121F_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap121f_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= AP121F_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= AP121F_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "switch",
+		.type			= EV_KEY,
+		.code			= BTN_0,
+		.debounce_interval	= AP121F_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= AP121F_GPIO_BTN_SWITCH,
+		.active_low		= 0,
+	},
+};
+
+static void __init ap121f_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f040000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* LAN */
+	ath79_register_mdio(0, 0x0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121f_leds_gpio),
+				 ap121f_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP121F_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap121f_gpio_keys),
+					ap121f_gpio_keys);
+
+	gpio_request_one(AP121F_GPIO_MICROSD_EN,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "microSD enable");
+
+	ath79_register_wmac(art + AP121F_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_AP121F, "AP121F", "ALFA Network AP121F", ap121f_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap132.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap132.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap132.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap132.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap143.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap143.c
new file mode 100644
index 0000000000..098420b92f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap143.c
@@ -0,0 +1,142 @@
+/*
+ * Atheros AP143 reference board support
+ *
+ * Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP143_GPIO_LED_WLAN		12
+#define AP143_GPIO_LED_WPS		13
+#define AP143_GPIO_LED_STATUS		13
+
+#define AP143_GPIO_LED_WAN		4
+#define AP143_GPIO_LED_LAN1		16
+#define AP143_GPIO_LED_LAN2		15
+#define AP143_GPIO_LED_LAN3		14
+#define AP143_GPIO_LED_LAN4		11
+
+#define AP143_GPIO_BTN_WPS		17
+
+#define AP143_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP143_KEYS_DEBOUNCE_INTERVAL	(3 * AP143_KEYS_POLL_INTERVAL)
+
+#define AP143_MAC0_OFFSET		0
+#define AP143_MAC1_OFFSET		6
+#define AP143_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap143_leds_gpio[] __initdata = {
+	{
+		.name		= "ap143:green:status",
+		.gpio		= AP143_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap143:green:wlan",
+		.gpio		= AP143_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap143_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP143_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP143_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void __init ap143_gpio_led_setup(void)
+{
+	ath79_gpio_direction_select(AP143_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN1, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN2, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN3, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN4, true);
+
+	ath79_gpio_output_select(AP143_GPIO_LED_WAN,
+			QCA953X_GPIO_OUT_MUX_LED_LINK5);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN1,
+			QCA953X_GPIO_OUT_MUX_LED_LINK1);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN2,
+			QCA953X_GPIO_OUT_MUX_LED_LINK2);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN3,
+			QCA953X_GPIO_OUT_MUX_LED_LINK3);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN4,
+			QCA953X_GPIO_OUT_MUX_LED_LINK4);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap143_leds_gpio),
+			ap143_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP143_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(ap143_gpio_keys),
+			ap143_gpio_keys);
+}
+
+static void __init ap143_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ap143_gpio_led_setup();
+
+	ath79_register_usb();
+
+	ath79_wmac_set_led_pin(AP143_GPIO_LED_WLAN);
+	ath79_register_wmac(art + AP143_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP143_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP143_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP143, "AP143", "Qualcomm Atheros AP143 reference board",
+	     ap143_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap147.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap147.c
new file mode 100644
index 0000000000..7b45da4711
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap147.c
@@ -0,0 +1,125 @@
+/*
+ *  Atheros AP147 reference board support
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2015 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define AP147_GPIO_LED_WAN	4
+#define AP147_GPIO_LED_LAN1	16
+#define AP147_GPIO_LED_LAN2	15
+#define AP147_GPIO_LED_LAN3	14
+#define AP147_GPIO_LED_LAN4	11
+#define AP147_GPIO_LED_STATUS	13
+#define AP147_GPIO_LED_WLAN_2G	12
+
+#define AP147_GPIO_BTN_WPS	17
+
+#define AP147_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP147_KEYS_DEBOUNCE_INTERVAL	(3 * AP147_KEYS_POLL_INTERVAL)
+
+#define AP147_MAC0_OFFSET	0x1000
+
+static struct gpio_led ap147_leds_gpio[] __initdata = {
+	{
+		.name		= "ap147:green:status",
+		.gpio		= AP147_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:wlan-2g",
+		.gpio		= AP147_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan1",
+		.gpio		= AP147_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan2",
+		.gpio		= AP147_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan3",
+		.gpio		= AP147_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan4",
+		.gpio		= AP147_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:wan",
+		.gpio		= AP147_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap147_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP147_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP147_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap147_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap147_leds_gpio),
+				 ap147_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP147_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap147_gpio_keys),
+					ap147_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_pci();
+
+	ath79_register_wmac(art + AP147_MAC0_OFFSET, NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 1);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP147_010, "AP147-010", "Atheros AP147-010 reference board", ap147_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ap152.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap152.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ap152.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap152.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap531b0.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap531b0.c
new file mode 100644
index 0000000000..3cb2697955
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap531b0.c
@@ -0,0 +1,112 @@
+/*
+ * Rockeetech AP531B0 11ng wireless AP board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2016 Shuanglin Liu <roboidler@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+
+#define AP531B0_GPIO_LED_WLAN		12
+#define AP531B0_GPIO_LED_STATUS		11
+
+#define AP531B0_GPIO_RST_BTN		17
+
+#define AP531B0_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP531B0_KEYS_DEBOUNCE_INTERVAL	(3 * AP531B0_KEYS_POLL_INTERVAL)
+
+#define AP531B0_WMAC_CALDATA_OFFSET	0x1000
+
+
+static struct gpio_led ap531b0_leds_gpio[] __initdata = {
+	{
+		.name		= "ap531b0:green:status",
+		.gpio		= AP531B0_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap531b0:green:wlan",
+		.gpio		= AP531B0_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap531b0_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP531B0_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP531B0_GPIO_RST_BTN,
+		.active_low	= 1,
+	},
+};
+
+
+static void __init ap531b0_gpio_led_setup(void)
+{
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap531b0_leds_gpio),
+				 ap531b0_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP531B0_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap531b0_gpio_keys),
+					ap531b0_gpio_keys);
+}
+
+static void __init ap531b0_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *pmac;
+
+	ath79_register_m25p80(NULL);
+	ap531b0_gpio_led_setup();
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_mdio(0, 0x0);
+
+	pmac = art + AP531B0_WMAC_CALDATA_OFFSET + 2;
+	ath79_init_mac(ath79_eth0_data.mac_addr, pmac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, pmac, 2);
+
+	ath79_register_wmac(art + AP531B0_WMAC_CALDATA_OFFSET, pmac);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP531B0, "AP531B0", "Rockeetech AP531B0",
+	     ap531b0_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap90q.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap90q.c
new file mode 100644
index 0000000000..99fceca3a0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap90q.c
@@ -0,0 +1,201 @@
+/*
+ * Support for YunCore boards:
+ * - AP80Q/AP90Q
+ * - CPE830
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* AP90Q */
+#define AP90Q_GPIO_LED_WAN	4
+#define AP90Q_GPIO_LED_WLAN	12
+#define AP90Q_GPIO_LED_LAN	16
+
+#define AP90Q_GPIO_BTN_RESET	17
+
+#define AP90Q_KEYS_POLL_INTERVAL	20
+#define AP90Q_KEYS_DEBOUNCE_INTERVAL	(3 * AP90Q_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ap90q_leds_gpio[] __initdata = {
+	{
+		.name		= "ap90q:green:lan",
+		.gpio		= AP90Q_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap90q:green:wan",
+		.gpio		= AP90Q_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap90q:green:wlan",
+		.gpio		= AP90Q_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap90q_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP90Q_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP90Q_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+/* CPE830 */
+#define CPE830_GPIO_LED_LINK4	0
+#define CPE830_GPIO_LED_LINK1	1
+#define CPE830_GPIO_LED_LINK2	2
+#define CPE830_GPIO_LED_LINK3	3
+#define CPE830_GPIO_LED_WAN	4
+#define CPE830_GPIO_LED_WLAN	12
+#define CPE830_GPIO_LED_LAN	16
+
+#define CPE830_GPIO_BTN_RESET	17
+
+static struct gpio_led cpe830_leds_gpio[] __initdata = {
+	{
+		.name		= "cpe830:green:lan",
+		.gpio		= CPE830_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:wan",
+		.gpio		= CPE830_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:wlan",
+		.gpio		= CPE830_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:link1",
+		.gpio		= CPE830_GPIO_LED_LINK1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:link2",
+		.gpio		= CPE830_GPIO_LED_LINK2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:link3",
+		.gpio		= CPE830_GPIO_LED_LINK3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe830:green:link4",
+		.gpio		= CPE830_GPIO_LED_LINK4,
+		.active_low	= 1,
+	},
+};
+
+static void __init ap90q_cpe830_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art, NULL);
+
+	/* For LED on GPIO4 */
+	ath79_gpio_function_disable(AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_gpio_direction_select(AP90Q_GPIO_LED_LAN, true);
+	ath79_gpio_direction_select(AP90Q_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(AP90Q_GPIO_LED_WLAN, true);
+
+	/* Mute LEDs on boot */
+	gpio_set_value(AP90Q_GPIO_LED_LAN, 1);
+	gpio_set_value(AP90Q_GPIO_LED_WAN, 1);
+
+	ath79_gpio_output_select(AP90Q_GPIO_LED_LAN, 0);
+	ath79_gpio_output_select(AP90Q_GPIO_LED_WAN, 0);
+	ath79_gpio_output_select(AP90Q_GPIO_LED_WLAN, 0);
+
+	ath79_register_gpio_keys_polled(-1, AP90Q_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap90q_gpio_keys),
+					ap90q_gpio_keys);
+}
+
+static void __init ap90q_setup(void)
+{
+	ap90q_cpe830_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap90q_leds_gpio),
+				 ap90q_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP90Q, "AP90Q", "YunCore AP80Q/AP90Q", ap90q_setup);
+
+static void __init cpe830_setup(void)
+{
+	ap90q_cpe830_common_setup();
+
+	ath79_gpio_direction_select(CPE830_GPIO_LED_LINK1, true);
+	ath79_gpio_direction_select(CPE830_GPIO_LED_LINK2, true);
+	ath79_gpio_direction_select(CPE830_GPIO_LED_LINK3, true);
+	ath79_gpio_direction_select(CPE830_GPIO_LED_LINK4, true);
+
+	/* Mute LEDs on boot */
+	gpio_set_value(CPE830_GPIO_LED_LINK1, 1);
+	gpio_set_value(CPE830_GPIO_LED_LINK2, 1);
+	gpio_set_value(CPE830_GPIO_LED_LINK3, 1);
+	gpio_set_value(CPE830_GPIO_LED_LINK4, 1);
+
+	ath79_gpio_output_select(CPE830_GPIO_LED_LINK1, 0);
+	ath79_gpio_output_select(CPE830_GPIO_LED_LINK2, 0);
+	ath79_gpio_output_select(CPE830_GPIO_LED_LINK3, 0);
+	ath79_gpio_output_select(CPE830_GPIO_LED_LINK4, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe830_leds_gpio),
+				 cpe830_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_CPE830, "CPE830", "YunCore CPE830", cpe830_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap91-5g.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap91-5g.c
new file mode 100644
index 0000000000..64b9430381
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap91-5g.c
@@ -0,0 +1,118 @@
+/*
+ * ALFA Network AP91-5G board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define AP91_5G_GPIO_LED_LAN		17
+#define AP91_5G_GPIO_LED_SIGNAL1	12
+#define AP91_5G_GPIO_LED_SIGNAL2	8
+#define AP91_5G_GPIO_LED_SIGNAL3	6
+#define AP91_5G_GPIO_LED_SIGNAL4	7
+
+#define AP91_5G_GPIO_WDT_EN		1
+#define AP91_5G_GPIO_WDT_IN		0
+
+#define AP91_5G_GPIO_BTN_RESET		11
+
+#define AP91_5G_KEYS_POLL_INTERVAL	20
+#define AP91_5G_KEYS_DEBOUNCE_INTERVAL	(3 * AP91_5G_KEYS_POLL_INTERVAL)
+
+#define AP91_5G_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap91_5g_leds_gpio[] __initdata = {
+	{
+		.name		= "ap91-5g:green:lan",
+		.gpio		= AP91_5G_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap91-5g:red:signal1",
+		.gpio		= AP91_5G_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "ap91-5g:orange:signal2",
+		.gpio		= AP91_5G_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "ap91-5g:green:signal3",
+		.gpio		= AP91_5G_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "ap91-5g:green:signal4",
+		.gpio		= AP91_5G_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap91_5g_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= AP91_5G_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= AP91_5G_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static void __init ap91_5g_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	gpio_set_value(AP91_5G_GPIO_LED_LAN, 1);
+	gpio_set_value(AP91_5G_GPIO_LED_SIGNAL3, 1);
+	gpio_set_value(AP91_5G_GPIO_LED_SIGNAL4, 1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap91_5g_leds_gpio),
+				 ap91_5g_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP91_5G_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap91_5g_gpio_keys),
+					ap91_5g_gpio_keys);
+
+	gpio_request_one(AP91_5G_GPIO_WDT_IN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT input");
+
+	gpio_request_one(AP91_5G_GPIO_WDT_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT enable");
+
+	ap91_pci_init(art + AP91_5G_WMAC_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP91_5G, "AP91-5G", "ALFA Network AP91-5G",
+	     ap91_5g_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap96.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap96.c
new file mode 100644
index 0000000000..35120d3e2e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ap96.c
@@ -0,0 +1,142 @@
+/*
+ *  Atheros AP96 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define AP96_GPIO_LED_12_GREEN		0
+#define AP96_GPIO_LED_3_GREEN		1
+#define AP96_GPIO_LED_2_GREEN		2
+#define AP96_GPIO_LED_WPS_GREEN		4
+#define AP96_GPIO_LED_5_GREEN		5
+#define AP96_GPIO_LED_4_ORANGE		6
+
+/* Reset button - next to the power connector */
+#define AP96_GPIO_BTN_RESET		3
+/* WPS button - next to a led on right */
+#define AP96_GPIO_BTN_WPS		8
+
+#define AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP96_KEYS_DEBOUNCE_INTERVAL	(3 * AP96_KEYS_POLL_INTERVAL)
+
+#define AP96_WMAC0_MAC_OFFSET		0x120c
+#define AP96_WMAC1_MAC_OFFSET		0x520c
+#define AP96_CALDATA0_OFFSET		0x1000
+#define AP96_CALDATA1_OFFSET		0x5000
+
+/*
+ * AP96 has 12 unlabeled leds in the front; these are numbered from 1 to 12
+ * below (from left to right on the board). Led 1 seems to be on whenever the
+ * board is powered. Led 11 shows LAN link activity actity. Led 3 is orange;
+ * others are green.
+ *
+ * In addition, there is one led next to a button on the right side for WPS.
+ */
+static struct gpio_led ap96_leds_gpio[] __initdata = {
+	{
+		.name		= "ap96:green:led2",
+		.gpio		= AP96_GPIO_LED_2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led3",
+		.gpio		= AP96_GPIO_LED_3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:orange:led4",
+		.gpio		= AP96_GPIO_LED_4_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led5",
+		.gpio		= AP96_GPIO_LED_5_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led12",
+		.gpio		= AP96_GPIO_LED_12_GREEN,
+		.active_low	= 1,
+	}, { /* next to a button on right */
+		.name		= "ap96:green:wps",
+		.gpio		= AP96_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define AP96_WAN_PHYMASK 0x10
+#define AP96_LAN_PHYMASK 0x0f
+
+static void __init ap96_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, ~(AP96_WAN_PHYMASK | AP96_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = AP96_LAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = AP96_WAN_PHYMASK;
+
+	ath79_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap96_leds_gpio),
+					ap96_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap96_gpio_keys),
+					 ap96_gpio_keys);
+
+	ap94_pci_init(art + AP96_CALDATA0_OFFSET,
+		      art + AP96_WMAC0_MAC_OFFSET,
+		      art + AP96_CALDATA1_OFFSET,
+		      art + AP96_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP96, "AP96", "Atheros AP96", ap96_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c25-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c25-v1.c
new file mode 100644
index 0000000000..c6c6463224
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c25-v1.c
@@ -0,0 +1,227 @@
+/*
+ *  TP-Link Archer C25 v1 board support
+ *
+ *  Copyright (C) 2017 Ludwig Thomeczek <ledesrc@wxorx.net>
+ *  based on mach-archer-c60/C59-v1.c
+ *  Copyright (C) 2016 Henryk Heisig <hyniu@o2.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/gpio.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/74x164.h>
+
+#define ARCHER_C25_GPIO_SHIFT_OE	21 /* OE,   Output Enable */
+#define ARCHER_C25_GPIO_SHIFT_SER	14 /* DS,   Data Serial Input */
+#define ARCHER_C25_GPIO_SHIFT_SRCLK	15 /* SHCP, Shift Reg Clock Input */
+#define ARCHER_C25_GPIO_SHIFT_SRCLR	19 /* MR,   Master Reset */
+#define ARCHER_C25_GPIO_SHIFT_RCLK	16 /* STCP, Storage Reg Clock Input */
+
+#define ARCHER_C25_74HC_GPIO_BASE		32
+#define ARCHER_C25_74HC_GPIO_LED_WAN_AMBER	(ARCHER_C25_74HC_GPIO_BASE + 4)
+#define ARCHER_C25_74HC_GPIO_LED_WAN_GREEN	(ARCHER_C25_74HC_GPIO_BASE + 5)
+#define ARCHER_C25_74HC_GPIO_LED_WLAN2		(ARCHER_C25_74HC_GPIO_BASE + 6)
+#define ARCHER_C25_74HC_GPIO_LED_WLAN5		(ARCHER_C25_74HC_GPIO_BASE + 7)
+#define ARCHER_C25_74HC_GPIO_LED_LAN1		(ARCHER_C25_74HC_GPIO_BASE + 0)
+#define ARCHER_C25_74HC_GPIO_LED_LAN2		(ARCHER_C25_74HC_GPIO_BASE + 1)
+#define ARCHER_C25_74HC_GPIO_LED_LAN3		(ARCHER_C25_74HC_GPIO_BASE + 2)
+#define ARCHER_C25_74HC_GPIO_LED_LAN4		(ARCHER_C25_74HC_GPIO_BASE + 3)
+
+#define ARCHER_C25_V1_SSR_BIT_0			0
+#define ARCHER_C25_V1_SSR_BIT_1			1
+#define ARCHER_C25_V1_SSR_BIT_2			2
+#define ARCHER_C25_V1_SSR_BIT_3			3
+#define ARCHER_C25_V1_SSR_BIT_4			4
+#define ARCHER_C25_V1_SSR_BIT_5			5
+#define ARCHER_C25_V1_SSR_BIT_6			6
+#define ARCHER_C25_V1_SSR_BIT_7			7
+
+
+#define ARCHER_C25_V1_KEYS_POLL_INTERVAL	20
+#define ARCHER_C25_V1_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * ARCHER_C25_V1_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C25_V1_GPIO_BTN_RESET		1
+#define ARCHER_C25_V1_GPIO_BTN_RFKILL		22
+
+#define ARCHER_C25_V1_GPIO_LED_POWER		17
+#define ARCHER_C25_V1_GPIO_LED_WPS		2
+
+#define ARCHER_C25_V1_WMAC_CALDATA_OFFSET	0x1000
+
+static struct spi_gpio_platform_data archer_c25_v1_spi_data = {
+	.sck		= ARCHER_C25_GPIO_SHIFT_SRCLK,
+	.miso		= SPI_GPIO_NO_MISO,
+	.mosi		= ARCHER_C25_GPIO_SHIFT_SER,
+	.num_chipselect	= 1,
+};
+
+static u8 archer_c25_v1_ssr_initdata[] = {
+	BIT(ARCHER_C25_V1_SSR_BIT_7) |
+	BIT(ARCHER_C25_V1_SSR_BIT_6) |
+	BIT(ARCHER_C25_V1_SSR_BIT_5) |
+	BIT(ARCHER_C25_V1_SSR_BIT_4) |
+	BIT(ARCHER_C25_V1_SSR_BIT_3) |
+	BIT(ARCHER_C25_V1_SSR_BIT_2) |
+	BIT(ARCHER_C25_V1_SSR_BIT_1)
+};
+
+static struct gen_74x164_chip_platform_data archer_c25_v1_ssr_data = {
+	.base = ARCHER_C25_74HC_GPIO_BASE,
+	.num_registers = ARRAY_SIZE(archer_c25_v1_ssr_initdata),
+	.init_data = archer_c25_v1_ssr_initdata,
+};
+
+static struct platform_device archer_c25_v1_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &archer_c25_v1_spi_data,
+	},
+};
+
+static struct spi_board_info archer_c25_v1_spi_info[] = {
+	{
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 10000000,
+		.modalias		= "74x164",
+		.platform_data		= &archer_c25_v1_ssr_data,
+		.controller_data	= (void *) ARCHER_C25_GPIO_SHIFT_RCLK,
+	},
+};
+
+static struct gpio_led archer_c25_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c25-v1:green:power",
+		.gpio		= ARCHER_C25_V1_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:wps",
+		.gpio		= ARCHER_C25_V1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:wlan2g",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:wlan5g",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:lan1",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:lan2",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:lan3",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:lan4",
+		.gpio		= ARCHER_C25_74HC_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:green:wan",
+		.gpio		=  ARCHER_C25_74HC_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "archer-c25-v1:amber:wan",
+		.gpio		=  ARCHER_C25_74HC_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c25_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "Reset button",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= ARCHER_C25_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C25_V1_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= ARCHER_C25_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C25_V1_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+};
+
+static void __init archer_c25_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0008);
+	u8 *art = (u8 *) KSEG1ADDR(0x1f7f0000);
+
+	ath79_register_m25p80(NULL);
+
+	spi_register_board_info(archer_c25_v1_spi_info,
+				ARRAY_SIZE(archer_c25_v1_spi_info));
+
+	platform_device_register(&archer_c25_v1_spi_device);
+
+	gpio_request_one(ARCHER_C25_GPIO_SHIFT_OE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "LED control");
+
+	gpio_request_one(ARCHER_C25_GPIO_SHIFT_SRCLR,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LED reset");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c25_v1_leds_gpio),
+				 archer_c25_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ARCHER_C25_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c25_v1_gpio_keys),
+					archer_c25_v1_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + ARCHER_C25_V1_WMAC_CALDATA_OFFSET, mac);
+	ap91_pci_init(NULL, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C25_V1, "ARCHER-C25-V1", "TP-LINK Archer C25 v1",
+	     archer_c25_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c59-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c59-v1.c
new file mode 100644
index 0000000000..c500c91a1a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c59-v1.c
@@ -0,0 +1,289 @@
+/*
+ *  TP-Link Archer C58/C59 v1 board support
+ *
+ *  Copyright (C) 2017 Henryk Heisig <hyniu@o2.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/74x164.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+#define ARCHER_C59_V1_KEYS_POLL_INTERVAL	20
+#define ARCHER_C59_V1_KEYS_DEBOUNCE_INTERVAL	(3 * ARCHER_C59_V1_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C59_V1_GPIO_BTN_RESET		21
+#define ARCHER_C59_V1_GPIO_BTN_RFKILL		2
+#define ARCHER_C59_V1_GPIO_BTN_WPS		1
+
+#define ARCHER_C59_V1_GPIO_USB_POWER		22
+
+#define ARCHER_C59_GPIO_SHIFT_OE		16
+#define ARCHER_C59_GPIO_SHIFT_SER		17
+#define ARCHER_C59_GPIO_SHIFT_SRCLK		18
+#define ARCHER_C59_GPIO_SHIFT_SRCLR		19
+#define ARCHER_C59_GPIO_SHIFT_RCLK		20
+
+#define ARCHER_C59_74HC_GPIO_BASE		32
+#define ARCHER_C59_74HC_GPIO_LED_POWER		(ARCHER_C59_74HC_GPIO_BASE + 0)
+#define ARCHER_C59_74HC_GPIO_LED_WLAN2		(ARCHER_C59_74HC_GPIO_BASE + 1)
+#define ARCHER_C59_74HC_GPIO_LED_WLAN5		(ARCHER_C59_74HC_GPIO_BASE + 2)
+#define ARCHER_C59_74HC_GPIO_LED_LAN		(ARCHER_C59_74HC_GPIO_BASE + 3)
+#define ARCHER_C59_74HC_GPIO_LED_WAN_GREEN	(ARCHER_C59_74HC_GPIO_BASE + 4)
+#define ARCHER_C59_74HC_GPIO_LED_WAN_AMBER	(ARCHER_C59_74HC_GPIO_BASE + 5)
+#define ARCHER_C59_74HC_GPIO_LED_WPS		(ARCHER_C59_74HC_GPIO_BASE + 6)
+#define ARCHER_C59_74HC_GPIO_LED_USB		(ARCHER_C59_74HC_GPIO_BASE + 7)
+
+#define ARCHER_C59_V1_SSR_BIT_0			0
+#define ARCHER_C59_V1_SSR_BIT_1			1
+#define ARCHER_C59_V1_SSR_BIT_2			2
+#define ARCHER_C59_V1_SSR_BIT_3			3
+#define ARCHER_C59_V1_SSR_BIT_4			4
+#define ARCHER_C59_V1_SSR_BIT_5			5
+#define ARCHER_C59_V1_SSR_BIT_6			6
+#define ARCHER_C59_V1_SSR_BIT_7			7
+
+#define ARCHER_C59_V1_WMAC_CALDATA_OFFSET	0x1000
+#define ARCHER_C59_V1_PCI_CALDATA_OFFSET	0x5000
+
+static struct gpio_led archer_c58_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c58-v1:green:power",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:green:wlan2g",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:green:wlan5g",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:green:lan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:green:wan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:amber:wan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c58-v1:green:wps",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led archer_c59_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c59-v1:green:power",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:wlan2g",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:wlan5g",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:lan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:wan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:amber:wan",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:wps",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c59-v1:green:usb",
+		.gpio		= ARCHER_C59_74HC_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c59_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "Reset button",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= ARCHER_C59_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C59_V1_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= ARCHER_C59_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C59_V1_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "WPS button",
+		.type			= EV_KEY,
+		.code			= KEY_WPS_BUTTON,
+		.debounce_interval	= ARCHER_C59_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C59_V1_GPIO_BTN_WPS,
+		.active_low		= 1,
+	},
+};
+
+static struct spi_gpio_platform_data archer_c59_v1_spi_data = {
+	.sck		= ARCHER_C59_GPIO_SHIFT_SRCLK,
+	.miso		= SPI_GPIO_NO_MISO,
+	.mosi		= ARCHER_C59_GPIO_SHIFT_SER,
+	.num_chipselect = 1,
+};
+
+static u8 archer_c59_v1_ssr_initdata[] = {
+	BIT(ARCHER_C59_V1_SSR_BIT_7) |
+	BIT(ARCHER_C59_V1_SSR_BIT_6) |
+	BIT(ARCHER_C59_V1_SSR_BIT_5) |
+	BIT(ARCHER_C59_V1_SSR_BIT_4) |
+	BIT(ARCHER_C59_V1_SSR_BIT_3) |
+	BIT(ARCHER_C59_V1_SSR_BIT_2) |
+	BIT(ARCHER_C59_V1_SSR_BIT_1)
+};
+
+static struct gen_74x164_chip_platform_data archer_c59_v1_ssr_data = {
+	.base = ARCHER_C59_74HC_GPIO_BASE,
+	.num_registers = ARRAY_SIZE(archer_c59_v1_ssr_initdata),
+	.init_data = archer_c59_v1_ssr_initdata,
+};
+
+static struct platform_device archer_c59_v1_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &archer_c59_v1_spi_data,
+	},
+};
+
+static struct spi_board_info archer_c59_v1_spi_info[] = {
+	{
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz	= 10000000,
+		.modalias	= "74x164",
+		.platform_data	=  &archer_c59_v1_ssr_data,
+		.controller_data = (void *) ARCHER_C59_GPIO_SHIFT_RCLK,
+	},
+};
+
+static void __init archer_c5x_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f010008);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	spi_register_board_info(archer_c59_v1_spi_info,
+			   ARRAY_SIZE(archer_c59_v1_spi_info));
+	platform_device_register(&archer_c59_v1_spi_device);
+
+	ath79_register_gpio_keys_polled(-1, ARCHER_C59_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c59_v1_gpio_keys),
+					archer_c59_v1_gpio_keys);
+
+	ath79_setup_qca956x_eth_cfg(QCA956X_ETH_CFG_SW_PHY_SWAP |
+				   QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + ARCHER_C59_V1_WMAC_CALDATA_OFFSET, mac);
+	ap91_pci_init(art + ARCHER_C59_V1_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_register_usb();
+	gpio_request_one(ARCHER_C59_V1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	gpio_request_one(ARCHER_C59_GPIO_SHIFT_OE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "LED control");
+	gpio_request_one(ARCHER_C59_GPIO_SHIFT_SRCLR,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LED reset");
+}
+
+static void __init archer_c58_v1_setup(void)
+{
+	archer_c5x_v1_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c58_v1_leds_gpio),
+				archer_c58_v1_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C58_V1, "ARCHER-C58-V1",
+	"TP-LINK Archer C58 v1", archer_c58_v1_setup);
+
+static void __init archer_c59_v1_setup(void)
+{
+	archer_c5x_v1_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c59_v1_leds_gpio),
+				archer_c59_v1_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C59_V1, "ARCHER-C59-V1",
+	"TP-LINK Archer C59 v1", archer_c59_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c60-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c60-v1.c
new file mode 100644
index 0000000000..88f4f081a3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c60-v1.c
@@ -0,0 +1,225 @@
+/*
+ *  TP-Link Archer C60 v1 board support
+ *
+ *  Copyright (C) 2017 Henryk Heisig <hyniu@o2.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/gpio.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+#define ARCHER_C60_V1_GPIO_LED_LAN		2
+#define ARCHER_C60_V1_GPIO_LED_POWER		16
+#define ARCHER_C60_V1_GPIO_LED_WLAN2		17
+#define ARCHER_C60_V1_GPIO_LED_WLAN5		18
+#define ARCHER_C60_V1_GPIO_LED_WPS		19
+#define ARCHER_C60_V1_GPIO_LED_WAN_GREEN	20
+#define ARCHER_C60_V1_GPIO_LED_WAN_AMBER	22
+
+
+#define ARCHER_C60_V1_KEYS_POLL_INTERVAL	20
+#define ARCHER_C60_V1_KEYS_DEBOUNCE_INTERVAL	(3 * ARCHER_C60_V1_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C60_V1_GPIO_BTN_RESET		21
+#define ARCHER_C60_V1_GPIO_BTN_RFKILL		1
+
+
+
+#define ARCHER_C60_V1_WMAC_CALDATA_OFFSET	0x1000
+#define ARCHER_C60_V1_PCI_CALDATA_OFFSET	0x5000
+
+static struct gpio_led archer_c60_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c60-v1:green:power",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:green:wlan2g",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:green:wlan5g",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:green:lan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:green:wan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:amber:wan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v1:green:wps",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led archer_c60_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "archer-c60-v2:green:power",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:green:wlan2g",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:green:wlan5g",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WLAN5,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:green:lan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:green:wan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:amber:wan",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "archer-c60-v2:green:wps",
+		.gpio		= ARCHER_C60_V1_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c60_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "Reset button",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= ARCHER_C60_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C60_V1_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+	{
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= ARCHER_C60_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= ARCHER_C60_V1_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+};
+
+static void __init archer_c60_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f010008);
+	u8 *art = (u8 *) KSEG1ADDR(0x1f7f0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c60_v1_leds_gpio),
+				archer_c60_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ARCHER_C60_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c60_v1_gpio_keys),
+					archer_c60_v1_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + ARCHER_C60_V1_WMAC_CALDATA_OFFSET, mac);
+	ap91_pci_init(art + ARCHER_C60_V1_PCI_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C60_V1, "ARCHER-C60-V1",
+	"TP-LINK Archer C60 v1", archer_c60_v1_setup);
+
+static void __init archer_c60_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fb08);
+	u8 *art = (u8 *) KSEG1ADDR(0x1f7f0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c60_v2_leds_gpio),
+				archer_c60_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ARCHER_C60_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c60_v1_gpio_keys),
+					archer_c60_v1_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + ARCHER_C60_V1_WMAC_CALDATA_OFFSET, mac);
+	ap91_pci_init(art + ARCHER_C60_V1_PCI_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C60_V2, "ARCHER-C60-V2",
+	"TP-LINK Archer C60 v2", archer_c60_v2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c7-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c7-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c7-v4.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c7-v4.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c7.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c7.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-archer-c7.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-archer-c7.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-arduino-yun.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-arduino-yun.c
new file mode 100644
index 0000000000..5873248edf
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-arduino-yun.c
@@ -0,0 +1,157 @@
+/*
+ *  Arduino Yun support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2015 Hauke Mehrtens <hauke@hauke-m.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <linux/gpio.h>
+#include "common.h"
+
+// Uncomment to have reset on gpio18 instead of gipo7
+#define DS2_B
+
+#define DS_GPIO_LED_WLAN		0
+#define DS_GPIO_LED_USB			1
+
+#define DS_GPIO_OE			21
+#define DS_GPIO_AVR_RESET		18
+
+// Maintained to have the console in the previous version of DS2 working
+#define DS_GPIO_AVR_RESET_DS2		7
+
+#define DS_GPIO_OE2			22
+#define DS_GPIO_UART_ENA		23
+#define DS_GPIO_CONF_BTN		20
+
+#define DS_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DS_KEYS_DEBOUNCE_INTERVAL	(3 * DS_KEYS_POLL_INTERVAL)
+
+#define DS_MAC0_OFFSET			0x0000
+#define DS_MAC1_OFFSET			0x0006
+#define DS_CALDATA_OFFSET		0x1000
+#define DS_WMAC_MAC_OFFSET		0x1002
+
+
+static struct gpio_led ds_leds_gpio[] __initdata = {
+	{
+		.name		= "arduino:white:usb",
+		.gpio		= DS_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "arduino:blue:wlan",
+		.gpio		= DS_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ds_gpio_keys[] __initdata = {
+	{
+		.desc		= "configuration button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DS_GPIO_CONF_BTN,
+		.active_low	= 1,
+	},
+};
+
+static void __init ds_common_setup(void)
+{
+	static u8 mac[6];
+
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	ath79_register_m25p80(NULL);
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DS_CALDATA_OFFSET,
+				    art + DS_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DS_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x08;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	mac[3] &= 0xF7;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+}
+
+static void __init ds_setup(void)
+{
+	u32 t;
+
+	ds_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ds_leds_gpio),
+				 ds_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DS_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ds_gpio_keys),
+					ds_gpio_keys);
+	ath79_register_usb();
+
+	/* use the swtich_led directly form sysfs */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+								AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+								AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+								AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+								AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	//Disable the Function for some pins to have GPIO functionality active
+	// GPIO6-7-8 and GPIO11
+	ath79_gpio_function_setup(AR933X_GPIO_FUNC_JTAG_DISABLE | AR933X_GPIO_FUNC_I2S_MCK_EN, 0);
+
+	ath79_gpio_function2_setup(AR933X_GPIO_FUNC2_JUMPSTART_DISABLE, 0);
+
+	printk("Setting DogStick2 GPIO\n");
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	// Put the avr reset to high 
+	if (gpio_request_one(DS_GPIO_AVR_RESET_DS2,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-1") != 0)
+		printk("Error setting GPIO OE\n");
+	gpio_unexport(DS_GPIO_AVR_RESET_DS2);
+	gpio_free(DS_GPIO_AVR_RESET_DS2);
+
+	// enable OE of level shifter
+	if (gpio_request_one(DS_GPIO_OE,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-1") != 0)
+		printk("Error setting GPIO OE\n");
+
+	if (gpio_request_one(DS_GPIO_UART_ENA,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "UART-ENA") != 0)
+		printk("Error setting GPIO Uart Enable\n");
+
+	// enable OE of level shifter
+	if (gpio_request_one(DS_GPIO_OE2,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-2") != 0)
+		printk("Error setting GPIO OE2\n");
+}
+
+MIPS_MACHINE(ATH79_MACH_ARDUINO_YUN, "Yun", "Arduino Yun", ds_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-aw-nr580.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-aw-nr580.c
new file mode 100644
index 0000000000..281129b787
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-aw-nr580.c
@@ -0,0 +1,107 @@
+/*
+ *  AzureWave AW-NR580 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define AW_NR580_GPIO_LED_READY_RED	0
+#define AW_NR580_GPIO_LED_WLAN		1
+#define AW_NR580_GPIO_LED_READY_GREEN	2
+#define AW_NR580_GPIO_LED_WPS_GREEN	4
+#define AW_NR580_GPIO_LED_WPS_AMBER	5
+
+#define AW_NR580_GPIO_BTN_WPS		3
+#define AW_NR580_GPIO_BTN_RESET		11
+
+#define AW_NR580_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AW_NR580_KEYS_DEBOUNCE_INTERVAL	(3 * AW_NR580_KEYS_POLL_INTERVAL)
+
+static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
+	{
+		.name		= "aw-nr580:red:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:amber:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_AMBER,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wlan",
+		.gpio		= AW_NR580_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button aw_nr580_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static const char *aw_nr580_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data aw_nr580_flash_data = {
+	.part_probes	= aw_nr580_part_probes,
+};
+
+static void __init aw_nr580_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+
+	ath79_register_m25p80(&aw_nr580_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
+				 aw_nr580_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AW_NR580_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(aw_nr580_gpio_keys),
+					aw_nr580_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
+	     aw_nr580_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-bhr-4grv2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhr-4grv2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-bhr-4grv2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhr-4grv2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhu-bxu2000n2-a.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
new file mode 100644
index 0000000000..8d7c6112d7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
@@ -0,0 +1,120 @@
+/*
+ *  BHU BXU2000n-2 A1 board support
+ *
+ *  Copyright (C) 2013 Terry Yang <yangbo@bhunetworks.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define BHU_BXU2000N2_A1_GPIO_LED_WLAN		13
+#define BHU_BXU2000N2_A1_GPIO_LED_WAN		19
+#define BHU_BXU2000N2_A1_GPIO_LED_LAN		21
+#define BHU_BXU2000N2_A1_GPIO_LED_SYSTEM	14
+
+#define BHU_BXU2000N2_A1_GPIO_BTN_RESET		17
+
+#define BHU_BXU2000N2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define BHU_BXU2000N2_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * BHU_BXU2000N2_KEYS_POLL_INTERVAL)
+
+static const char *bhu_bxu2000n2_part_probes[] = {
+	"cmdlinepart",
+	NULL,
+};
+
+static struct flash_platform_data bhu_bxu2000n2_flash_data = {
+	.part_probes	= bhu_bxu2000n2_part_probes,
+};
+
+static struct gpio_led bhu_bxu2000n2_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "bhu:green:status",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:lan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:wan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:wlan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button bhu_bxu2000n2_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = BHU_BXU2000N2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BHU_BXU2000N2_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init bhu_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&bhu_bxu2000n2_flash_data);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch. Only use PHY3 */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.phy_mask = BIT(3);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, ee+2);
+}
+
+static void __init bhu_bxu2000n2_a1_setup(void)
+{
+	bhu_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(bhu_bxu2000n2_a1_leds_gpio),
+				 bhu_bxu2000n2_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, BHU_BXU2000N2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(bhu_bxu2000n2_a1_gpio_keys),
+					bhu_bxu2000n2_a1_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_BHU_BXU2000N2_A1, "BXU2000n-2-A1",
+	     "BHU BXU2000n-2 rev. A1",
+	     bhu_bxu2000n2_a1_setup);
+
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bsb.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bsb.c
new file mode 100644
index 0000000000..9f9be02eb3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-bsb.c
@@ -0,0 +1,83 @@
+/*
+ *  Smart Electronics Black Swift board support
+ *
+ *  Copyright (C) 2014 Dmitriy Zherebkov dzh@black-swift.com
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define BSB_GPIO_LED_SYS		27
+
+#define BSB_GPIO_BTN_RESET		11
+
+#define BSB_KEYS_POLL_INTERVAL		20	/* msecs */
+#define BSB_KEYS_DEBOUNCE_INTERVAL	(3 * BSB_KEYS_POLL_INTERVAL)
+
+#define BSB_MAC_OFFSET			0x0000
+#define BSB_CALDATA_OFFSET		0x1000
+
+static struct gpio_led bsb_leds_gpio[] __initdata = {
+	{
+		.name		= "bsb:red:sys",
+		.gpio		= BSB_GPIO_LED_SYS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button bsb_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = BSB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BSB_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init bsb_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false,false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(bsb_leds_gpio),
+				 bsb_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, BSB_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(bsb_gpio_keys),
+					bsb_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + BSB_MAC_OFFSET, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + BSB_MAC_OFFSET, 2);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + BSB_CALDATA_OFFSET,
+			    art + BSB_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_BSB, "BSB", "Smart Electronics Black Swift board",
+		bsb_setup);
+
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c55.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c55.c
new file mode 100644
index 0000000000..8aa5ecb6a8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c55.c
@@ -0,0 +1,132 @@
+/*
+ *  AirTight Networks C-55 board support
+ *
+ *  Copyright (C) 2014-2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  Based on Senao CAP4200AG board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define C55_GPIO_LED_PWR_GREEN	12
+#define C55_GPIO_LED_PWR_AMBER	13
+#define C55_GPIO_LED_LAN_GREEN	14
+#define C55_GPIO_LED_LAN_AMBER	15
+#define C55_GPIO_LED_WLAN_GREEN	18
+#define C55_GPIO_LED_WLAN_AMBER	19
+
+#define C55_GPIO_BTN_RESET	17
+
+#define C55_KEYS_POLL_INTERVAL	20	/* msecs */
+#define C55_KEYS_DEBOUNCE_INTERVAL (3 * C55_KEYS_POLL_INTERVAL)
+
+#define C55_MAC_OFFSET		0
+#define C55_WMAC_CALDATA_OFFSET	0x1000
+#define C55_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led c55_leds_gpio[] __initdata = {
+	{
+		.name		= "c-55:green:pwr",
+		.gpio		= C55_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-55:amber:pwr",
+		.gpio		= C55_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-55:green:lan",
+		.gpio		= C55_GPIO_LED_LAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-55:amber:lan",
+		.gpio		= C55_GPIO_LED_LAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-55:green:wlan",
+		.gpio		= C55_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "c-55:amber:wlan",
+		.gpio		= C55_GPIO_LED_WLAN_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button c55_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = C55_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= C55_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init c55_setup(void)
+{
+	/* SPI Storage*/
+	ath79_register_m25p80(NULL);
+
+	/* MDIO Interface */
+	ath79_register_mdio(0, 0x0);
+
+	/* AR8035-A Ethernet */
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+	ath79_init_mac(ath79_eth0_data.mac_addr, NULL, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	/* LEDs & GPIO */
+	ath79_gpio_output_select(C55_GPIO_LED_LAN_GREEN,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(C55_GPIO_LED_LAN_AMBER,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(c55_leds_gpio),
+				 c55_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, C55_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(c55_gpio_keys),
+					c55_gpio_keys);
+
+	/* WiFi */
+	ath79_wmac_disable_2ghz();
+	ath79_register_wmac_simple();
+	ap91_pci_init_simple();
+
+}
+MIPS_MACHINE(ATH79_MACH_C55, "C-55", "AirTight Networks C-55",
+	     c55_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-c60.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c60.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-c60.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-c60.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap324.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap324.c
new file mode 100644
index 0000000000..2a6aed5b4c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap324.c
@@ -0,0 +1,133 @@
+/*
+ *  PowerCloud Systems CAP324 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012-2013 PowerCloud Systems
+ *  Copyright (C) 2015 Daniel Dickinson
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CAP324_GPIO_LED_POWER_GREEN	12
+#define CAP324_GPIO_LED_POWER_AMBER	13
+#define CAP324_GPIO_LED_LAN_GREEN	14
+#define CAP324_GPIO_LED_LAN_AMBER	15
+#define CAP324_GPIO_LED_WLAN_GREEN	18
+#define CAP324_GPIO_LED_WLAN_AMBER	19
+
+#define CAP324_GPIO_BTN_RESET	17
+
+#define CAP324_KEYS_POLL_INTERVAL	20	/* msecs */
+#define CAP324_KEYS_DEBOUNCE_INTERVAL (3 * CAP324_KEYS_POLL_INTERVAL)
+
+#define CAP324_MAC_OFFSET		0
+#define CAP324_WMAC_CALDATA_OFFSET	0x1000
+#define CAP324_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led cap324_leds_gpio[] __initdata = {
+	{
+		.name		= "pcs:green:power",
+		.gpio		= CAP324_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:amber:power",
+		.gpio		= CAP324_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:green:lan",
+		.gpio		= CAP324_GPIO_LED_LAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:amber:lan",
+		.gpio		= CAP324_GPIO_LED_LAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:green:wlan",
+		.gpio		= CAP324_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:amber:wlan",
+		.gpio		= CAP324_GPIO_LED_WLAN_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cap324_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CAP324_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CAP324_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init cap324_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_gpio_output_select(CAP324_GPIO_LED_LAN_GREEN,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(CAP324_GPIO_LED_LAN_AMBER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cap324_leds_gpio),
+				 cap324_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CAP324_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cap324_gpio_keys),
+					cap324_gpio_keys);
+
+	ath79_init_mac(mac, art + CAP324_MAC_OFFSET, -1);
+	ath79_wmac_disable_2ghz();
+	ath79_register_wmac(art + CAP324_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(mac, art + CAP324_MAC_OFFSET, -2);
+	ap91_pci_init(art + CAP324_PCIE_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + CAP324_MAC_OFFSET, -2);
+
+	/* GMAC0 is connected to an external PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_CAP324, "CAP324", "PowerCloud CAP324",
+	     cap324_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap4200ag.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap4200ag.c
new file mode 100644
index 0000000000..18944c40fa
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cap4200ag.c
@@ -0,0 +1,131 @@
+/*
+ *  Senao CAP4200AG board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CAP4200AG_GPIO_LED_PWR_GREEN	12
+#define CAP4200AG_GPIO_LED_PWR_AMBER	13
+#define CAP4200AG_GPIO_LED_LAN_GREEN	14
+#define CAP4200AG_GPIO_LED_LAN_AMBER	15
+#define CAP4200AG_GPIO_LED_WLAN_GREEN	18
+#define CAP4200AG_GPIO_LED_WLAN_AMBER	19
+
+#define CAP4200AG_GPIO_BTN_RESET	17
+
+#define CAP4200AG_KEYS_POLL_INTERVAL	20	/* msecs */
+#define CAP4200AG_KEYS_DEBOUNCE_INTERVAL (3 * CAP4200AG_KEYS_POLL_INTERVAL)
+
+#define CAP4200AG_MAC_OFFSET		0
+#define CAP4200AG_WMAC_CALDATA_OFFSET	0x1000
+#define CAP4200AG_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led cap4200ag_leds_gpio[] __initdata = {
+	{
+		.name		= "senao:green:pwr",
+		.gpio		= CAP4200AG_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:pwr",
+		.gpio		= CAP4200AG_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:green:lan",
+		.gpio		= CAP4200AG_GPIO_LED_LAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:lan",
+		.gpio		= CAP4200AG_GPIO_LED_LAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:green:wlan",
+		.gpio		= CAP4200AG_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:wlan",
+		.gpio		= CAP4200AG_GPIO_LED_WLAN_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cap4200ag_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CAP4200AG_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CAP4200AG_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init cap4200ag_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_gpio_output_select(CAP4200AG_GPIO_LED_LAN_GREEN,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(CAP4200AG_GPIO_LED_LAN_AMBER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cap4200ag_leds_gpio),
+				 cap4200ag_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CAP4200AG_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cap4200ag_gpio_keys),
+					cap4200ag_gpio_keys);
+
+	ath79_init_mac(mac, art + CAP4200AG_MAC_OFFSET, -1);
+	ath79_wmac_disable_2ghz();
+	ath79_register_wmac(art + CAP4200AG_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(mac, art + CAP4200AG_MAC_OFFSET, -2);
+	ap91_pci_init(art + CAP4200AG_PCIE_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + CAP4200AG_MAC_OFFSET, -2);
+
+	/* GMAC0 is connected to an external PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_CAP4200AG, "CAP4200AG", "Senao CAP4200AG",
+	     cap4200ag_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-carambola2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-carambola2.c
new file mode 100644
index 0000000000..babe101141
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-carambola2.c
@@ -0,0 +1,105 @@
+/*
+ *  8devices Carambola2 board support
+ *
+ *  Copyright (C) 2013 Darius Augulis <darius@8devices.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CARAMBOLA2_GPIO_LED_WLAN		0
+#define CARAMBOLA2_GPIO_LED_ETH0		14
+#define CARAMBOLA2_GPIO_LED_ETH1		13
+
+#define CARAMBOLA2_GPIO_BTN_JUMPSTART		11
+
+#define CARAMBOLA2_KEYS_POLL_INTERVAL		20	/* msecs */
+#define CARAMBOLA2_KEYS_DEBOUNCE_INTERVAL	(3 * CARAMBOLA2_KEYS_POLL_INTERVAL)
+
+#define CARAMBOLA2_MAC0_OFFSET			0x0000
+#define CARAMBOLA2_MAC1_OFFSET			0x0006
+#define CARAMBOLA2_CALDATA_OFFSET		0x1000
+#define CARAMBOLA2_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led carambola2_leds_gpio[] __initdata = {
+	{
+		.name		= "carambola2:green:wlan",
+		.gpio		= CARAMBOLA2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "carambola2:orange:eth0",
+		.gpio		= CARAMBOLA2_GPIO_LED_ETH0,
+		.active_low	= 0,
+	}, {
+		.name		= "carambola2:orange:eth1",
+		.gpio		= CARAMBOLA2_GPIO_LED_ETH1,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button carambola2_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CARAMBOLA2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CARAMBOLA2_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+};
+
+static void __init carambola2_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + CARAMBOLA2_CALDATA_OFFSET,
+			    art + CARAMBOLA2_WMAC_MAC_OFFSET);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + CARAMBOLA2_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + CARAMBOLA2_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+}
+
+static void __init carambola2_setup(void)
+{
+	carambola2_common_setup();
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(carambola2_leds_gpio),
+				 carambola2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CARAMBOLA2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(carambola2_gpio_keys),
+					carambola2_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_CARAMBOLA2, "CARAMBOLA2", "8devices Carambola2 board",
+		carambola2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cf-e316n-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cf-e316n-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cf-e316n-v2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cf-e316n-v2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe510.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe510.c
new file mode 100644
index 0000000000..d2dbed1fe2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe510.c
@@ -0,0 +1,184 @@
+/*
+ *  TP-LINK CPE210/220/510/520 board support
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define CPE510_GPIO_LED_LAN0	11
+#define CPE510_GPIO_LED_LAN1	12
+#define CPE510_GPIO_LED_L1	13
+#define CPE510_GPIO_LED_L2	14
+#define CPE510_GPIO_LED_L3	15
+#define CPE510_GPIO_LED_L4	16
+
+/* All LEDs/button except for link4 are the same for CPE and WBS series */
+#define WBS510_GPIO_LED_L4	2
+
+#define CPE510_GPIO_EXTERNAL_LNA0	18
+#define CPE510_GPIO_EXTERNAL_LNA1	19
+
+#define CPE510_GPIO_BTN_RESET	4
+
+#define CPE510_KEYS_POLL_INTERVAL	20 /* msecs */
+#define CPE510_KEYS_DEBOUNCE_INTERVAL	(3 * CPE510_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led cpe510_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan0",
+		.gpio		= CPE510_GPIO_LED_LAN0,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan1",
+		.gpio		= CPE510_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link1",
+		.gpio		= CPE510_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link2",
+		.gpio		= CPE510_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link3",
+		.gpio		= CPE510_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link4",
+		.gpio		= CPE510_GPIO_LED_L4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wbs510_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan0",
+		.gpio		= CPE510_GPIO_LED_LAN0,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan1",
+		.gpio		= CPE510_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link1",
+		.gpio		= CPE510_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link2",
+		.gpio		= CPE510_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link3",
+		.gpio		= CPE510_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link4",
+		.gpio		= WBS510_GPIO_LED_L4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cpe510_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CPE510_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CPE510_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init cpe_setup(u8 *mac)
+{
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				  AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_gpio_keys_polled(1, CPE510_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cpe510_gpio_keys),
+					cpe510_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, CPE510_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, CPE510_GPIO_EXTERNAL_LNA1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+}
+
+
+static void __init cpe210_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f830008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe510_leds_gpio),
+				 cpe510_leds_gpio);
+
+	cpe_setup(mac);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init cpe510_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f830008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe510_leds_gpio),
+				 cpe510_leds_gpio);
+
+	cpe_setup(mac);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init wbs_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f830008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wbs510_leds_gpio),
+				 wbs510_leds_gpio);
+
+	cpe_setup(mac);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_CPE210, "CPE210", "TP-LINK CPE210/220",
+	     cpe210_setup);
+
+MIPS_MACHINE(ATH79_MACH_CPE510, "CPE510", "TP-LINK CPE510/520",
+	     cpe510_setup);
+
+MIPS_MACHINE(ATH79_MACH_WBS210, "WBS210", "TP-LINK WBS210",
+	     wbs_setup);
+
+MIPS_MACHINE(ATH79_MACH_WBS510, "WBS510", "TP-LINK WBS510",
+	     wbs_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe870.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe870.c
new file mode 100644
index 0000000000..284cdc71c2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cpe870.c
@@ -0,0 +1,152 @@
+/*
+ * YunCore CPE870 board support
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CPE870_GPIO_LED_LINK1	0
+#define CPE870_GPIO_LED_LINK2	1
+#define CPE870_GPIO_LED_LINK3	2
+#define CPE870_GPIO_LED_LINK4	3
+#define CPE870_GPIO_LED_WLAN	13
+#define CPE870_GPIO_LED_WAN	19
+#define CPE870_GPIO_LED_LAN	20
+
+#define CPE870_GPIO_BTN_RESET	16
+
+#define CPE870_KEYS_POLL_INTERVAL	20
+#define CPE870_KEYS_DEBOUNCE_INTERVAL	(3 * CPE870_KEYS_POLL_INTERVAL)
+
+static struct gpio_led cpe870_leds_gpio[] __initdata = {
+	{
+		.name		= "cpe870:green:lan",
+		.gpio		= CPE870_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:wan",
+		.gpio		= CPE870_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:wlan",
+		.gpio		= CPE870_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:link1",
+		.gpio		= CPE870_GPIO_LED_LINK1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:link2",
+		.gpio		= CPE870_GPIO_LED_LINK2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:link3",
+		.gpio		= CPE870_GPIO_LED_LINK3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "cpe870:green:link4",
+		.gpio		= CPE870_GPIO_LED_LINK4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cpe870_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CPE870_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CPE870_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init cpe870_gpio_setup(void)
+{
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_direction_select(CPE870_GPIO_LED_LINK1, true);
+	ath79_gpio_direction_select(CPE870_GPIO_LED_LINK2, true);
+	ath79_gpio_direction_select(CPE870_GPIO_LED_LINK3, true);
+	ath79_gpio_direction_select(CPE870_GPIO_LED_LINK4, true);
+
+	/* Mute LEDs on boot */
+	gpio_set_value(CPE870_GPIO_LED_LAN, 1);
+	gpio_set_value(CPE870_GPIO_LED_WAN, 1);
+	gpio_set_value(CPE870_GPIO_LED_LINK1, 1);
+	gpio_set_value(CPE870_GPIO_LED_LINK2, 1);
+	gpio_set_value(CPE870_GPIO_LED_LINK3, 1);
+	gpio_set_value(CPE870_GPIO_LED_LINK4, 1);
+
+	ath79_gpio_output_select(CPE870_GPIO_LED_LINK1, 0);
+	ath79_gpio_output_select(CPE870_GPIO_LED_LINK2, 0);
+	ath79_gpio_output_select(CPE870_GPIO_LED_LINK3, 0);
+	ath79_gpio_output_select(CPE870_GPIO_LED_LINK4, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe870_leds_gpio),
+				 cpe870_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, CPE870_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cpe870_gpio_keys),
+					cpe870_gpio_keys);
+}
+
+static void __init cpe870_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	cpe870_gpio_setup();
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_CPE870, "CPE870", "YunCore CPE870", cpe870_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr3000.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr3000.c
new file mode 100644
index 0000000000..b351ae59c5
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr3000.c
@@ -0,0 +1,161 @@
+/*
+ * PowerCloud Systems CR3000 support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2012-2013 PowerCloud Systems
+ * Copyright (c) 2015 Daniel Dickinson <openwrt@daniel.thecshore.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CR3000_GPIO_LED_WLAN_2G		13
+#define CR3000_GPIO_LED_POWER_AMBER	15
+#define CR3000_GPIO_LED_WAN             18
+#define CR3000_GPIO_LED_LAN1            19
+#define CR3000_GPIO_LED_LAN2            20
+#define CR3000_GPIO_LED_LAN3            21
+#define CR3000_GPIO_LED_LAN4            22
+
+#define CR3000_GPIO_BTN_WPS		16
+#define CR3000_GPIO_BTN_RESET		17
+
+#define CR3000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define CR3000_KEYS_DEBOUNCE_INTERVAL	(3 * CR3000_KEYS_POLL_INTERVAL)
+
+#define CR3000_MAC0_OFFSET		0
+#define CR3000_MAC1_OFFSET		6
+#define CR3000_WMAC_CALDATA_OFFSET	0x1000
+#define CR3000_WMAC_MAC_OFFSET	        0x1002
+#define CR3000_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led cr3000_leds_gpio[] __initdata = {
+	{
+		.name		= "pcs:amber:power",
+		.gpio		= CR3000_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:wlan",
+		.gpio		= CR3000_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:wan",
+		.gpio		= CR3000_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:lan1",
+		.gpio		= CR3000_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:lan2",
+		.gpio		= CR3000_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:lan3",
+		.gpio		= CR3000_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "pcs:blue:lan4",
+		.gpio		= CR3000_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cr3000_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CR3000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CR3000_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CR3000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CR3000_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init cr3000_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cr3000_leds_gpio),
+				 cr3000_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, CR3000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cr3000_gpio_keys),
+					cr3000_gpio_keys);
+
+	/* WLAN 2GHz onboard */
+	ath79_register_wmac(art + CR3000_WMAC_CALDATA_OFFSET, art + CR3000_WMAC_MAC_OFFSET);
+	
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	/* Lan 4-port switch attached to GMAC1 internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + CR3000_MAC0_OFFSET, 0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + CR3000_MAC1_OFFSET, 0);
+
+	/* WAN Fast Ethernet interface attached to GMAC0 */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_CR3000, "CR3000", "PowerCloud CR3000",
+	     cr3000_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-cr5000.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr5000.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-cr5000.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-cr5000.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-1330-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-1330-a1.c
new file mode 100644
index 0000000000..9c50bc7e9b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-1330-a1.c
@@ -0,0 +1,146 @@
+/*
+ * D-Link DAP-1330
+ *
+ * Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017 Nicol Veronese <nicveronese@gmail.com>
+ * Copyright (c) 2017 Federico Cappon <dududede371@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#define DAP_1330_GPIO_LED_GREEN_POWER	13
+#define DAP_1330_GPIO_LED_RED_POWER	3
+#define DAP_1330_GPIO_LED_GREEN_WIFI	14
+#define DAP_1330_GPIO_LED_RED_WIFI	11
+#define DAP_1330_GPIO_LED_SIGNAL1	15
+#define DAP_1330_GPIO_LED_SIGNAL2	16
+
+#define DAP_1330_GPIO_BTN_WPS		2
+#define DAP_1330_GPIO_BTN_RESET		17
+
+#define DAP_1330_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DAP_1330_KEYS_DEBOUNCE_INTERVAL	(3 * DAP_1330_KEYS_POLL_INTERVAL)
+
+#define DAP1330_MAC_ADDR		0x1f020001
+
+#define DAP1330_WMAC_CALDATA_ADDR	0x1f010000
+#define DAP_1330_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led dap_1330_leds_gpio[] __initdata = {
+		{
+				.name		= "d-link:green:power",
+				.gpio		= DAP_1330_GPIO_LED_GREEN_POWER,
+				.active_low	= 1,
+		},
+		{
+				.name		= "d-link:red:power",
+				.gpio		= DAP_1330_GPIO_LED_RED_POWER,
+				.active_low	= 1,
+		},
+		{
+				.name		= "d-link:green:wifi",
+				.gpio		= DAP_1330_GPIO_LED_GREEN_WIFI,
+				.active_low	= 1,
+		},
+		{
+				.name		= "d-link:red:wifi",
+				.gpio		= DAP_1330_GPIO_LED_RED_WIFI,
+				.active_low	= 1,
+		},
+		{
+				.name		= "d-link:green:signal1",
+				.gpio		= DAP_1330_GPIO_LED_SIGNAL1,
+				.active_low	= 1,
+		},
+		{
+				.name		= "d-link:green:signal2",
+				.gpio		= DAP_1330_GPIO_LED_SIGNAL2,
+				.active_low	= 1,
+		}
+};
+
+static struct gpio_keys_button dap_1330_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DAP_1330_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DAP_1330_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DAP_1330_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DAP_1330_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init dap_1330_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DAP1330_WMAC_CALDATA_ADDR);
+	u8 *mac_ptr = (u8 *) KSEG1ADDR(DAP1330_MAC_ADDR);
+	u8 mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac((char *) mac_ptr, mac);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dap_1330_leds_gpio),
+		dap_1330_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DAP_1330_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(dap_1330_gpio_keys),
+			dap_1330_gpio_keys);
+
+	ath79_register_wmac(art + DAP_1330_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DAP_1330_A1, "DAP-1330-A1",
+             "D-Link DAP-1330 Rev. A1", dap_1330_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dap-2695-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-2695-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dap-2695-a1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dap-2695-a1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dgl-5500-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dgl-5500-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dgl-5500-a1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dgl-5500-a1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dhp-1565-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dhp-1565-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dhp-1565-a1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dhp-1565-a1.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-505-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-505-a1.c
new file mode 100644
index 0000000000..1367b64a8f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-505-a1.c
@@ -0,0 +1,116 @@
+/*
+ *  DLink DIR-505 A1 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define DIR_505A1_GPIO_BTN_WPS         11 /* verify */
+#define DIR_505A1_GPIO_BTN_RESET       12 /* verify */
+
+#define DIR_505A1_GPIO_LED_RED         26 /* unused, fyi */
+#define DIR_505A1_GPIO_LED_GREEN       27
+
+#define DIR_505A1_GPIO_WAN_LED_ENABLE  1
+
+#define DIR_505A1_KEYS_POLL_INTERVAL   20      /* msecs */
+#define DIR_505A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_505A1_KEYS_POLL_INTERVAL)
+
+#define DIR_505A1_ART_ADDRESS          0x1f010000
+#define DIR_505A1_CALDATA_OFFSET       0x1000
+
+#define DIR_505A1_MAC_PART_ADDRESS	0x1f020000
+#define DIR_505A1_LAN_MAC_OFFSET	0x04
+#define DIR_505A1_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led dir_505_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_505A1_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:red:status",
+		.gpio		= DIR_505A1_GPIO_LED_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dir_505_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_505A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_505A1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_505A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_505A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_505_a1_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DIR_505A1_ART_ADDRESS);
+	u8 *mac = (u8 *) KSEG1ADDR(DIR_505A1_MAC_PART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	gpio_request_one(DIR_505A1_GPIO_WAN_LED_ENABLE,
+		GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_505_a1_leds_gpio),
+		dir_505_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, DIR_505A1_KEYS_POLL_INTERVAL,
+		ARRAY_SIZE(dir_505_a1_gpio_keys),
+		dir_505_a1_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	ath79_parse_ascii_mac(mac + DIR_505A1_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(mac + DIR_505A1_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + DIR_505A1_CALDATA_OFFSET, lan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_505_A1, "DIR-505-A1",
+		"D-Link DIR-505 rev. A1", dir_505_a1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-600-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-600-a1.c
new file mode 100644
index 0000000000..5e6134de7a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-600-a1.c
@@ -0,0 +1,162 @@
+/*
+ *  D-Link DIR-600 rev. A1 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Vadim Girlin <vadimgirlin@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_600_A1_GPIO_LED_WPS			0
+#define DIR_600_A1_GPIO_LED_POWER_AMBER		1
+#define DIR_600_A1_GPIO_LED_POWER_GREEN		6
+#define DIR_600_A1_GPIO_LED_LAN1		13
+#define DIR_600_A1_GPIO_LED_LAN2		14
+#define DIR_600_A1_GPIO_LED_LAN3		15
+#define DIR_600_A1_GPIO_LED_LAN4		16
+#define DIR_600_A1_GPIO_LED_WAN_AMBER		7
+#define DIR_600_A1_GPIO_LED_WAN_GREEN		17
+
+#define DIR_600_A1_GPIO_BTN_RESET		8
+#define DIR_600_A1_GPIO_BTN_WPS			12
+
+#define DIR_600_A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR_600_A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_600_A1_KEYS_POLL_INTERVAL)
+
+#define DIR_600_A1_NVRAM_ADDR	0x1f030000
+#define DIR_600_A1_NVRAM_SIZE	0x10000
+
+static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "d-link:amber:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "d-link:amber:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_AMBER,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan1",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan2",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan3",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan4",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_600_A1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir_600_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_600_a1_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(DIR_600_A1_NVRAM_ADDR);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
+				       "lan_mac=", mac_buff) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac_buff, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac_buff, 1);
+		mac = mac_buff;
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
+				 dir_600_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_600_A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_600_a1_gpio_keys),
+					dir_600_a1_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_600_A1, "DIR-600-A1", "D-Link DIR-600 rev. A1",
+	     dir_600_a1_setup);
+
+MIPS_MACHINE(ATH79_MACH_EBR_2310_C1, "EBR-2310-C1", "D-Link EBR-2310 rev. C1",
+	     dir_600_a1_setup);
+
+static void __init dir_615_e1_setup(void)
+{
+	dir_600_a1_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_E1, "DIR-615-E1", "D-Link DIR-615 rev. E1",
+	     dir_615_e1_setup);
+
+static void __init dir_615_e4_setup(void)
+{
+	dir_600_a1_setup();
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_E4, "DIR-615-E4", "D-Link DIR-615 rev. E4",
+	     dir_615_e4_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-c1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-c1.c
new file mode 100644
index 0000000000..e55a43f9c7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-c1.c
@@ -0,0 +1,135 @@
+/*
+ *  D-Link DIR-615 rev C1 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_615C1_GPIO_LED_ORANGE_STATUS 1	/* ORANGE:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_BLUE_WPS	3	/* BLUE:WPS */
+#define DIR_615C1_GPIO_LED_GREEN_WAN	4       /* GREEN:WAN:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WANCPU	5       /* GREEN:WAN:CPU:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WLAN	6	/* GREEN:WLAN */
+#define DIR_615C1_GPIO_LED_GREEN_STATUS	14	/* GREEN:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_ORANGE_WAN	15	/* ORANGE:WAN:TRICOLOR */
+
+/* buttons may need refinement */
+
+#define DIR_615C1_GPIO_BTN_WPS		12
+#define DIR_615C1_GPIO_BTN_RESET	21
+
+#define DIR_615C1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_615C1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_615C1_KEYS_POLL_INTERVAL)
+
+#define DIR_615C1_CONFIG_ADDR		0x1f020000
+#define DIR_615C1_CONFIG_SIZE		0x10000
+
+#define DIR_615C1_WLAN_MAC_ADDR		0x1f3fffb4
+
+static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:orange:status",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_615C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wancpu",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wlan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:status",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_STATUS,
+		.active_low     = 1,
+	}, {
+		.name		= "d-link:orange:wan",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_WAN,
+		.active_low	= 1,
+	}
+
+};
+
+static struct gpio_keys_button dir_615c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_WPS,
+	}
+};
+
+#define DIR_615C1_LAN_PHYMASK	BIT(0)
+#define DIR_615C1_WAN_PHYMASK	BIT(4)
+#define DIR_615C1_MDIO_MASK	(~(DIR_615C1_LAN_PHYMASK | \
+				   DIR_615C1_WAN_PHYMASK))
+
+static void __init dir_615c1_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(DIR_615C1_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[ETH_ALEN], wlan_mac[ETH_ALEN];
+
+	if (ath79_nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_parse_ascii_mac((char *) KSEG1ADDR(DIR_615C1_WLAN_MAC_ADDR), wlan_mac);
+
+	ath79_register_mdio(0, DIR_615C1_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = DIR_615C1_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
+				 dir_615c1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_615C1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615c1_gpio_keys),
+					dir_615c1_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
+	     dir_615c1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-i1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-i1.c
new file mode 100644
index 0000000000..64fe438dcb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-615-i1.c
@@ -0,0 +1,133 @@
+/*
+ *  D-Link DIR-615 rev. I1 board support
+ *  Copyright (C) 2013-2015 Jaehoon You <teslamint@gmail.com>
+ *
+ *  based on the DIR-600 rev. A1 board support code
+ *    Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *    Copyright (C) 2012 Vadim Girlin <vadimgirlin@gmail.com>
+ *
+ *  based on the TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 board support code
+ *    Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DIR_615_I1_GPIO_LED_WPS				15
+#define DIR_615_I1_GPIO_LED_POWER_AMBER		14
+#define DIR_615_I1_GPIO_LED_POWER_GREEN		4
+#define DIR_615_I1_GPIO_LED_WAN_AMBER		22
+#define DIR_615_I1_GPIO_LED_WAN_GREEN		12
+#define DIR_615_I1_GPIO_LED_WLAN_GREEN		13
+
+#define DIR_615_I1_GPIO_BTN_WPS				16
+#define DIR_615_I1_GPIO_BTN_RESET			17
+
+#define DIR_615_I1_KEYS_POLL_INTERVAL		20 /* msecs */
+#define DIR_615_I1_KEYS_DEBOUNCE_INTERVAL	(3 * DIR_615_I1_KEYS_POLL_INTERVAL)
+
+#define DIR_615_I1_LAN_PHYMASK	BIT(0)
+#define DIR_615_I1_WAN_PHYMASK	BIT(4)
+#define DIR_615_I1_WLAN_MAC_ADDR	0x1fffffb4
+
+static struct gpio_led dir_615_i1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_615_I1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "d-link:amber:power",
+		.gpio		= DIR_615_I1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "d-link:amber:wan",
+		.gpio		= DIR_615_I1_GPIO_LED_WAN_AMBER,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_615_I1_GPIO_LED_WAN_GREEN,
+		.active_low = 1,
+	}, {
+		.name		= "d-link:green:wlan",
+		.gpio		= DIR_615_I1_GPIO_LED_WLAN_GREEN,
+		.active_low = 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_615_I1_GPIO_LED_WPS,
+		.active_low = 1,
+	}
+};
+
+static struct gpio_keys_button dir_615_i1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615_I1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615_I1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615_I1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615_I1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_615_i1_setup(void)
+{
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[ETH_ALEN];
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, ~(DIR_615_I1_WAN_PHYMASK));
+
+	ath79_parse_ascii_mac((char *) KSEG1ADDR(DIR_615_I1_WLAN_MAC_ADDR), mac);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = DIR_615_I1_WAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_mask = DIR_615_I1_LAN_PHYMASK;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_615_i1_leds_gpio),
+					dir_615_i1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_615_I1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615_i1_gpio_keys),
+					dir_615_i1_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_I1, "DIR-615-I1", "D-Link DIR-615 rev. I1",
+		dir_615_i1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-b1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-b1.c
new file mode 100644
index 0000000000..9b82990b13
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-b1.c
@@ -0,0 +1,191 @@
+/*
+ *  D-Link DIR-825 rev. B1 board support
+ *
+ *  Copyright (C) 2009-2011 Lukas Kuna, Evkanet, s.r.o.
+ *
+ *  based on mach-wndr3700.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define DIR825B1_GPIO_LED_BLUE_USB		0
+#define DIR825B1_GPIO_LED_ORANGE_POWER		1
+#define DIR825B1_GPIO_LED_BLUE_POWER		2
+#define DIR825B1_GPIO_LED_BLUE_WPS		4
+#define DIR825B1_GPIO_LED_ORANGE_PLANET		6
+#define DIR825B1_GPIO_LED_BLUE_PLANET		11
+
+#define DIR825B1_GPIO_BTN_RESET			3
+#define DIR825B1_GPIO_BTN_WPS			8
+
+#define DIR825B1_GPIO_RTL8366_SDA		5
+#define DIR825B1_GPIO_RTL8366_SCK		7
+
+#define DIR825B1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825B1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825B1_KEYS_POLL_INTERVAL)
+
+#define DIR825B1_CAL0_OFFSET			0x1000
+#define DIR825B1_CAL1_OFFSET			0x5000
+#define DIR825B1_MAC0_OFFSET			0xffa0
+#define DIR825B1_MAC1_OFFSET			0xffb4
+
+#define DIR825B1_CAL_LOCATION_0			0x1f660000
+#define DIR825B1_CAL_LOCATION_1			0x1f7f0000
+
+static struct gpio_led dir825b1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:blue:usb",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:power",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:power",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:planet",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_PLANET,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:planet",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir825b1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval dir825b1_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda	= DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck	= DIR825B1_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(dir825b1_rtl8366s_initvals),
+	.initvals	= dir825b1_rtl8366s_initvals,
+};
+
+static struct platform_device dir825b1_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &dir825b1_rtl8366s_data,
+	}
+};
+
+static bool __init dir825b1_is_caldata_valid(u8 *p)
+{
+	u16 *magic0, *magic1;
+
+	magic0 = (u16 *)(p + DIR825B1_CAL0_OFFSET);
+	magic1 = (u16 *)(p + DIR825B1_CAL1_OFFSET);
+
+	return (*magic0 == 0xa55a && *magic1 == 0xa55a);
+}
+
+static void __init dir825b1_wlan_init(void)
+{
+	u8 *caldata;
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN], wmac1[ETH_ALEN];
+
+	caldata = (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0);
+	if (!dir825b1_is_caldata_valid(caldata)) {
+		caldata = (u8 *)KSEG1ADDR(DIR825B1_CAL_LOCATION_1);
+		if (!dir825b1_is_caldata_valid(caldata)) {
+			pr_err("no calibration data found\n");
+			return;
+		}
+	}
+
+	ath79_parse_ascii_mac(caldata + DIR825B1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(caldata + DIR825B1_MAC1_OFFSET, mac1);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 0);
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_init_mac(wmac1, mac1, 1);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(caldata + DIR825B1_CAL0_OFFSET, wmac0,
+		      caldata + DIR825B1_CAL1_OFFSET, wmac1);
+}
+
+static void __init dir825b1_setup(void)
+{
+	dir825b1_wlan_init();
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
+				 dir825b1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR825B1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825b1_gpio_keys),
+					dir825b1_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&dir825b1_rtl8366s_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
+	     dir825b1_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-825-c1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-c1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-825-c1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-825-c1.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dir-869-a1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-869-a1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dir-869-a1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dir-869-a1.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-hotspot.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-hotspot.c
new file mode 100644
index 0000000000..3ae46514fc
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-hotspot.c
@@ -0,0 +1,117 @@
+/*
+ *  devolo dLAN Hotspot board support
+ *
+ *  Copyright (C) 2015 Torsten Schnuis <torsten.schnuis@gik.de>
+ *  Copyright (C) 2015 devolo AG
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_HOTSPOT_GPIO_LED_WIFI                0
+
+#define DLAN_HOTSPOT_GPIO_BTN_RESET              11
+#define DLAN_HOTSPOT_GPIO_BTN_PLC_PAIRING        12
+#define DLAN_HOTSPOT_GPIO_BTN_WIFI               21
+
+#define DLAN_HOTSPOT_GPIO_PLC_POWER              22
+#define DLAN_HOTSPOT_GPIO_PLC_RESET              20
+#define DLAN_HOTSPOT_GPIO_PLC_DISABLE_LEDS       18
+
+#define DLAN_HOTSPOT_KEYS_POLL_INTERVAL          20    /* msecs */
+#define DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL      (3 * DLAN_HOTSPOT_KEYS_POLL_INTERVAL)
+
+#define DLAN_HOTSPOT_ART_ADDRESS                 0x1fff0000
+#define DLAN_HOTSPOT_CALDATA_OFFSET              0x00001000
+#define DLAN_HOTSPOT_MAC_ADDRESS_OFFSET          0x00001002
+
+static struct gpio_led dlan_hotspot_leds_gpio[] __initdata = {
+	{
+		.name		= "devolo:green:wifi",
+		.gpio		= DLAN_HOTSPOT_GPIO_LED_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button dlan_hotspot_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_RESET,
+		.active_low     = 0,
+	},
+	{
+		.desc		= "Pairing button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_PLC_PAIRING,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static void __init dlan_hotspot_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_HOTSPOT_ART_ADDRESS);
+	u8 *cal = art + DLAN_HOTSPOT_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_HOTSPOT_MAC_ADDRESS_OFFSET;
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_hotspot_leds_gpio),
+				 dlan_hotspot_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_HOTSPOT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_hotspot_gpio_keys),
+					dlan_hotspot_gpio_keys);
+
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC power");
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_RESET,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC reset");
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_DISABLE_LEDS,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC LEDs");
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, wifi_mac, 2);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(cal, wifi_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_HOTSPOT, "dLAN-Hotspot",
+	     "dLAN Hotspot", dlan_hotspot_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-pro-1200-ac.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-pro-1200-ac.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-pro-1200-ac.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-pro-1200-ac.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-pro-500-wp.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-pro-500-wp.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dlan-pro-500-wp.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dlan-pro-500-wp.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-domywifi-dw33d.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-domywifi-dw33d.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-domywifi-dw33d.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-domywifi-dw33d.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-dr344.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr344.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-dr344.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr344.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr531.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr531.c
new file mode 100644
index 0000000000..b638a9001c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dr531.c
@@ -0,0 +1,155 @@
+/*
+ * Wallys DR531 board support
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * Based on mach-wpj531.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define DR531_GPIO_BUZZER	4
+#define DR531_GPIO_LED_WAN	11
+#define DR531_GPIO_LED_LAN	14
+#define DR531_GPIO_LED_SIG1	12
+#define DR531_GPIO_LED_SIG2	16
+#define DR531_GPIO_LED_SIG3	15
+#define DR531_GPIO_LED_SIG4	13
+
+#define DR531_GPIO_BTN_RESET	17
+
+#define DR531_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DR531_KEYS_DEBOUNCE_INTERVAL	(3 * DR531_KEYS_POLL_INTERVAL)
+
+#define DR531_MAC0_OFFSET		0x0
+#define DR531_MAC1_OFFSET		0x8
+#define DR531_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led dr531_leds_gpio[] __initdata = {
+	{
+		.name		= "dr531:green:wan",
+		.gpio		= DR531_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:green:lan",
+		.gpio		= DR531_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:green:sig1",
+		.gpio		= DR531_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:green:sig2",
+		.gpio		= DR531_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:green:sig3",
+		.gpio		= DR531_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:green:sig4",
+		.gpio		= DR531_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dr531:buzzer",
+		.gpio		= DR531_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button dr531_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DR531_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DR531_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init dr531_gpio_setup(void)
+{
+	ath79_gpio_direction_select(DR531_GPIO_BUZZER, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_LAN, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_SIG1, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_SIG2, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_SIG3, true);
+	ath79_gpio_direction_select(DR531_GPIO_LED_SIG4, true);
+
+	ath79_gpio_output_select(DR531_GPIO_BUZZER, 0);
+	ath79_gpio_output_select(DR531_GPIO_LED_WAN, 0);
+	ath79_gpio_output_select(DR531_GPIO_LED_LAN, 0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dr531_leds_gpio),
+				 dr531_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DR531_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dr531_gpio_keys),
+					dr531_gpio_keys);
+}
+
+static void __init dr531_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f03f810);
+
+	ath79_register_m25p80(NULL);
+
+	dr531_gpio_setup();
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + DR531_MAC1_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + DR531_MAC0_OFFSET, 0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + DR531_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_DR531, "DR531", "Wallys DR531", dr531_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dragino2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dragino2.c
new file mode 100644
index 0000000000..95bd6f41a3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-dragino2.c
@@ -0,0 +1,136 @@
+/*
+ *  DRAGINO V2 board support, based on Atheros AP121 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Elektra Wagenrad <elektra@villagetelco.org>
+ *  Copyright (C) 2014 Vittorio Gambaletta <openwrt@vittgam.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DRAGINO2_GPIO_LED_WLAN		0
+#define DRAGINO2_GPIO_LED_LAN		13
+#define DRAGINO2_GPIO_LED_WAN		17
+
+/*
+ * The following GPIO is named "SYS" on newer revisions of the the board.
+ * It was previously used to indicate USB activity, even though it was
+ * named "Router".
+ */
+
+#define DRAGINO2_GPIO_LED_SYS		28
+#define DRAGINO2_GPIO_BTN_JUMPSTART	11
+#define DRAGINO2_GPIO_BTN_RESET		12
+
+#define DRAGINO2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DRAGINO2_KEYS_DEBOUNCE_INTERVAL	(3 * DRAGINO2_KEYS_POLL_INTERVAL)
+
+#define DRAGINO2_MAC0_OFFSET		0x0000
+#define DRAGINO2_MAC1_OFFSET		0x0006
+#define DRAGINO2_CALDATA_OFFSET		0x1000
+#define DRAGINO2_WMAC_MAC_OFFSET	0x1002
+
+static struct gpio_led dragino2_leds_gpio[] __initdata = {
+	{
+		.name		= "dragino2:red:wlan",
+		.gpio		= DRAGINO2_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "dragino2:red:wan",
+		.gpio		= DRAGINO2_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dragino2:red:lan",
+		.gpio		= DRAGINO2_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dragino2:red:system",
+		.gpio		= DRAGINO2_GPIO_LED_SYS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button dragino2_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DRAGINO2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DRAGINO2_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DRAGINO2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DRAGINO2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init dragino2_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + DRAGINO2_CALDATA_OFFSET,
+			    art + DRAGINO2_WMAC_MAC_OFFSET);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + DRAGINO2_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + DRAGINO2_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* Enable GPIO13, GPIO14, GPIO15, GPIO16 and GPIO17 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	/* LAN port */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	/* Enable GPIO26 and GPIO27 */
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP,
+		       ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP) |
+		       AR933X_BOOTSTRAP_MDIO_GPIO_EN);
+}
+
+static void __init dragino2_setup(void)
+{
+	dragino2_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dragino2_leds_gpio),
+				 dragino2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DRAGINO2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dragino2_gpio_keys),
+					dragino2_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_DRAGINO2, "DRAGINO2", "Dragino Dragino v2",
+	     dragino2_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-e1700ac-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e1700ac-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-e1700ac-v2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e1700ac-v2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e2100l.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e2100l.c
new file mode 100644
index 0000000000..c09083460e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e2100l.c
@@ -0,0 +1,126 @@
+/*
+ *  Linksys E2100L board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "nvram.h"
+#include "machtypes.h"
+
+#define E2100L_GPIO_LED_POWER		14
+#define E2100L_GPIO_LED_WPS_AMBER	9
+#define E2100L_GPIO_LED_WPS_BLUE	8
+#define E2100L_GPIO_LED_WLAN		6
+
+#define E2100L_GPIO_BTN_WPS		7
+#define E2100L_GPIO_BTN_RESET		21
+
+#define E2100L_KEYS_POLL_INTERVAL	20	/* msecs */
+#define E2100L_KEYS_DEBOUNCE_INTERVAL	(3 * E2100L_KEYS_POLL_INTERVAL)
+
+#define E2100L_NVRAM_ADDR	0x1f7e0000
+#define E2100L_NVRAM_SIZE	0x10000
+
+static const char *e2100l_part_probes[] = {
+	"cybertan",
+	NULL,
+};
+
+static struct flash_platform_data e2100l_flash_data = {
+	.part_probes	= e2100l_part_probes,
+};
+
+static struct gpio_led e2100l_leds_gpio[] __initdata = {
+	{
+		.name		= "e2100l:blue:power",
+		.gpio		= E2100L_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "e2100l:amber:wps",
+		.gpio		= E2100L_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "e2100l:blue:wps",
+		.gpio		= E2100L_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "e2100l:blue:wlan",
+		.gpio		= E2100L_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button e2100l_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = E2100L_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= E2100L_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = E2100L_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= E2100L_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init e2100l_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(E2100L_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (ath79_nvram_parse_mac_addr(nvram, E2100L_NVRAM_SIZE,
+				       "lan_hwaddr=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = 0x01;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&e2100l_flash_data);
+
+	ath79_register_usb();
+
+	if (ath79_nvram_parse_mac_addr(nvram, E2100L_NVRAM_SIZE,
+				       "wl0_hwaddr=", mac) == 0)
+		ath79_register_wmac(eeprom, mac);
+	else
+		ath79_register_wmac(eeprom, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(e2100l_leds_gpio),
+				 e2100l_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, E2100L_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(e2100l_gpio_keys),
+					e2100l_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_E2100L, "E2100L", "Linksys E2100L",
+	     e2100l_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e600g-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e600g-v2.c
new file mode 100644
index 0000000000..29411dea86
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-e600g-v2.c
@@ -0,0 +1,184 @@
+/*
+ *  Qxwlan E600G/E600GAC v2 board support
+ *
+ *  Copyright (C) 2017 Peng Zhang <sd20@qxwlan.com>
+ *  Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define E600G_V2_GPIO_LED_LAN		16
+#define E600G_V2_GPIO_LED_SYS		13
+#define E600G_V2_GPIO_LED_WAN_B		4
+#define E600G_V2_GPIO_LED_WAN_G		15
+
+#define E600GAC_V2_GPIO_LED_CTRL_B	14
+#define E600GAC_V2_GPIO_LED_CTRL_G	11
+#define E600GAC_V2_GPIO_LED_CTRL_R	12
+#define E600GAC_V2_GPIO_LED_LAN		16
+#define E600GAC_V2_GPIO_LED_SYS		13
+#define E600GAC_V2_GPIO_LED_WAN_G	15
+#define E600GAC_V2_GPIO_LED_WAN_O	4
+
+#define E600G_V2_GPIO_BTN_RESET		17
+#define E600GAC_V2_GPIO_BTN_WPS		1
+
+#define E600G_V2_KEYS_POLL_INTERVAL	20 /* msecs */
+#define E600G_V2_KEYS_DEBOUNCE_INTERVAL	(3 * E600G_V2_KEYS_POLL_INTERVAL)
+
+static struct gpio_led e600g_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "e600g-v2:blue:system",
+		.gpio		= E600G_V2_GPIO_LED_SYS,
+		.active_low	= 1,
+	}, {
+		.name		= "e600g-v2:blue:wan",
+		.gpio		= E600G_V2_GPIO_LED_WAN_B,
+		.active_low	= 1,
+	}, {
+		.name		= "e600g-v2:green:lan",
+		.gpio		= E600G_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "e600g-v2:green:wan",
+		.gpio		= E600G_V2_GPIO_LED_WAN_G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led e600gac_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "e600gac-v2:blue:control",
+		.gpio		= E600GAC_V2_GPIO_LED_CTRL_B,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:green:control",
+		.gpio		= E600GAC_V2_GPIO_LED_CTRL_G,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:red:control",
+		.gpio		= E600GAC_V2_GPIO_LED_CTRL_R,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:green:system",
+		.gpio		= E600GAC_V2_GPIO_LED_SYS,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:orange:wan",
+		.gpio		= E600GAC_V2_GPIO_LED_WAN_O,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:green:lan",
+		.gpio		= E600GAC_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "e600gac-v2:green:wan",
+		.gpio		= E600GAC_V2_GPIO_LED_WAN_G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button e600g_v2_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= E600G_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= E600G_V2_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_keys_button e600gac_v2_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= E600G_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= E600G_V2_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "wps",
+		.type			= EV_KEY,
+		.code			= KEY_WPS_BUTTON,
+		.debounce_interval	= E600G_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= E600GAC_V2_GPIO_BTN_WPS,
+		.active_low		= 1,
+	},
+};
+
+static void __init e600g_v2_common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f050400);
+	u8 *art = (u8 *) KSEG1ADDR(0x1f061000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xfe;
+
+	/* LAN */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+	ath79_register_usb();
+	ath79_register_wmac(art, NULL);
+}
+
+static void __init e600g_v2_setup(void)
+{
+	e600g_v2_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(e600g_v2_leds_gpio),
+				 e600g_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, E600G_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(e600g_v2_gpio_keys),
+					e600g_v2_gpio_keys);
+}
+
+static void __init e600gac_v2_setup(void)
+{
+	e600g_v2_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(e600gac_v2_leds_gpio),
+				 e600gac_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, E600G_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(e600gac_v2_gpio_keys),
+					e600gac_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_E600G_V2, "E600G-V2", "Qxwlan E600G v2",
+	     e600g_v2_setup);
+
+MIPS_MACHINE(ATH79_MACH_E600GAC_V2, "E600GAC-V2", "Qxwlan E600GAC v2",
+	     e600gac_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap120.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap120.c
new file mode 100644
index 0000000000..130c7706a6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap120.c
@@ -0,0 +1,126 @@
+/*
+ *  TP-LINK EAP120 board support
+ *
+ * Copyright (C) 2016 Henryk Heisig <hyniu@o2.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/mdio-gpio.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define EAP120_GPIO_LED_RED	12
+#define EAP120_GPIO_LED_YEL	13
+#define EAP120_GPIO_LED_GRN	15
+#define EAP120_GPIO_BTN_RESET	4
+
+#define EAP120_KEYS_POLL_INTERVAL	20 /* msecs */
+#define EAP120_KEYS_DEBOUNCE_INTERVAL	(3 * EAP120_KEYS_POLL_INTERVAL)
+
+#define EAP120_GPIO_SMI_MDIO		16
+#define EAP120_GPIO_SMI_MDC		17
+
+#define EAP120_LAN_PHYADDR		4
+
+static struct gpio_led eap120_leds_gpio[] __initdata = {
+	{
+		.name		= "eap120:red:system",
+		.gpio		= EAP120_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "eap120:yellow:system",
+		.gpio		= EAP120_GPIO_LED_YEL,
+		.active_low	= 1,
+	}, {
+		.name		= "eap120:green:system",
+		.gpio		= EAP120_GPIO_LED_GRN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button eap120_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP120_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP120_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct mdio_gpio_platform_data eap120_mdio = {
+	.mdc		= EAP120_GPIO_SMI_MDC,
+	.mdio		= EAP120_GPIO_SMI_MDIO,
+	.phy_mask	= ~BIT(EAP120_LAN_PHYADDR),
+};
+
+static struct at803x_platform_data eap120_ar8035_data = {
+	.disable_smarteee = 0,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 0,
+	.fixup_rgmii_tx_delay = 1,
+};
+
+static struct platform_device eap120_phy_device = {
+	.name	= "mdio-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &eap120_mdio, &eap120_ar8035_data
+	},
+};
+
+static void __init eap_setup(u8 *mac)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap120_leds_gpio),
+				 eap120_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, EAP120_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(eap120_gpio_keys),
+					eap120_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	/* MDIO Interface */
+	platform_device_register(&eap120_phy_device);
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	/* GMAC0 is connected to the RGMII interface to an Atheros AR8035-A */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &eap120_phy_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(EAP120_LAN_PHYADDR);
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000;
+	ath79_eth0_pll_data.pll_100 = 0x00000101;
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+	ath79_register_eth(0);
+}
+
+static void __init eap120_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f030008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	eap_setup(mac);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_EAP120, "EAP120", "TP-LINK EAP120",
+		eap120_setup);
+
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap300v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap300v2.c
new file mode 100644
index 0000000000..ba577e2517
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap300v2.c
@@ -0,0 +1,101 @@
+/*
+ * EnGenius EAP300 v2 board support
+ *
+ * Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define EAP300V2_GPIO_LED_POWER		0
+#define EAP300V2_GPIO_LED_LAN		16
+#define EAP300V2_GPIO_LED_WLAN		17
+
+#define EAP300V2_GPIO_BTN_RESET		1
+
+#define EAP300V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP300V2_KEYS_DEBOUNCE_INTERVAL	(3 * EAP300V2_KEYS_POLL_INTERVAL)
+
+static struct gpio_led eap300v2_leds_gpio[] __initdata = {
+	{
+		.name		= "engenius:blue:power",
+		.gpio		= EAP300V2_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:blue:lan",
+		.gpio		= EAP300V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:blue:wlan",
+		.gpio		= EAP300V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button eap300v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP300V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP300V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define EAP300V2_ART_MAC_OFFSET		2
+
+#define EAP300V2_LAN_PHYMASK		BIT(0)
+
+static void __init eap300v2_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_POWER, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_WLAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap300v2_leds_gpio),
+				 eap300v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EAP300V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(eap300v2_gpio_keys),
+					eap300v2_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art, NULL);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + EAP300V2_ART_MAC_OFFSET, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = EAP300V2_LAN_PHYMASK;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = EAP300V2_LAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_EAP300V2, "EAP300V2", "EnGenius EAP300 v2",
+	     eap300v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap7660d.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap7660d.c
new file mode 100644
index 0000000000..787e6275d6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-eap7660d.c
@@ -0,0 +1,181 @@
+/*
+ *  Senao EAP7660D board support
+ *
+ *  Copyright (C) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath5k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define EAP7660D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP7660D_KEYS_DEBOUNCE_INTERVAL	(3 * EAP7660D_KEYS_POLL_INTERVAL)
+
+#define EAP7660D_GPIO_DS4		7
+#define EAP7660D_GPIO_DS5		2
+#define EAP7660D_GPIO_DS7		0
+#define EAP7660D_GPIO_DS8		4
+#define EAP7660D_GPIO_SW1		3
+#define EAP7660D_GPIO_SW3		8
+#define EAP7660D_PHYMASK		BIT(20)
+#define EAP7660D_BOARDCONFIG		0x1F7F0000
+#define EAP7660D_GBIC_MAC_OFFSET	0x1000
+#define EAP7660D_WMAC0_MAC_OFFSET	0x1010
+#define EAP7660D_WMAC1_MAC_OFFSET	0x1016
+#define EAP7660D_WMAC0_CALDATA_OFFSET	0x2000
+#define EAP7660D_WMAC1_CALDATA_OFFSET	0x3000
+
+#ifdef CONFIG_PCI
+static struct ath5k_platform_data eap7660d_wmac0_data;
+static struct ath5k_platform_data eap7660d_wmac1_data;
+static char eap7660d_wmac0_mac[6];
+static char eap7660d_wmac1_mac[6];
+static u16 eap7660d_wmac0_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+static u16 eap7660d_wmac1_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+
+static int eap7660d_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &eap7660d_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &eap7660d_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			      u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0 && *cal_data0 == 0xa55a) {
+		memcpy(eap7660d_wmac0_eeprom, cal_data0,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac0_data.eeprom_data = eap7660d_wmac0_eeprom;
+	}
+
+	if (cal_data1 && *cal_data1 == 0xa55a) {
+		memcpy(eap7660d_wmac1_eeprom, cal_data1,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac1_data.eeprom_data = eap7660d_wmac1_eeprom;
+	}
+
+	if (mac_addr0) {
+		memcpy(eap7660d_wmac0_mac, mac_addr0,
+			sizeof(eap7660d_wmac0_mac));
+		eap7660d_wmac0_data.macaddr = eap7660d_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(eap7660d_wmac1_mac, mac_addr1,
+			sizeof(eap7660d_wmac1_mac));
+		eap7660d_wmac1_data.macaddr = eap7660d_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(eap7660d_pci_plat_dev_init);
+	ath79_register_pci();
+}
+#else
+static inline void eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				     u8 *cal_data1, u8 *mac_addr1)
+{
+}
+#endif /* CONFIG_PCI */
+
+static struct gpio_led eap7660d_leds_gpio[] __initdata = {
+	{
+		.name		= "eap7660d:green:ds8",
+		.gpio		= EAP7660D_GPIO_DS8,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds5",
+		.gpio		= EAP7660D_GPIO_DS5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds7",
+		.gpio		= EAP7660D_GPIO_DS7,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds4",
+		.gpio		= EAP7660D_GPIO_DS4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button eap7660d_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW3,
+		.active_low	= 1,
+	}
+};
+
+static const char *eap7660d_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data eap7660d_flash_data = {
+	.part_probes	= eap7660d_part_probes,
+};
+
+static void __init eap7660d_setup(void)
+{
+	u8 *boardconfig = (u8 *) KSEG1ADDR(EAP7660D_BOARDCONFIG);
+
+	ath79_register_mdio(0, ~EAP7660D_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			boardconfig + EAP7660D_GBIC_MAC_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = EAP7660D_PHYMASK;
+	ath79_register_eth(0);
+	ath79_register_m25p80(&eap7660d_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap7660d_leds_gpio),
+					eap7660d_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EAP7660D_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(eap7660d_gpio_keys),
+					 eap7660d_gpio_keys);
+	eap7660d_pci_init(boardconfig + EAP7660D_WMAC0_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC0_MAC_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_MAC_OFFSET);
+};
+
+MIPS_MACHINE(ATH79_MACH_EAP7660D, "EAP7660D", "Senao EAP7660D",
+	     eap7660d_setup);
+
+MIPS_MACHINE(ATH79_MACH_ALL0305, "ALL0305", "Allnet ALL0305",
+	     eap7660d_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-m150.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-m150.c
new file mode 100644
index 0000000000..b95d6c2f68
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-m150.c
@@ -0,0 +1,112 @@
+/*
+ *  Easy-Link EL-M150 board support
+ *
+ *  Copyright (C) 2012 huangfc <huangfangcheng@163.com>
+ *  Copyright (C) 2012 HYS <550663898@qq.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define EL_M150_GPIO_BTN6		6
+#define EL_M150_GPIO_BTN7		7
+#define EL_M150_GPIO_BTN_RESET		11
+
+#define EL_M150_GPIO_LED_SYSTEM		27
+#define EL_M150_GPIO_USB_POWER		8
+
+#define EL_M150_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EL_M150_KEYS_DEBOUNCE_INTERVAL (3 * EL_M150_KEYS_POLL_INTERVAL)
+
+static const char *EL_M150_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data EL_M150_flash_data = {
+	.part_probes	= EL_M150_part_probes,
+};
+
+static struct gpio_led EL_M150_leds_gpio[] __initdata = {
+	{
+		.name		= "easylink:green:system",
+		.gpio		= EL_M150_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button EL_M150_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "BTN_6",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN6,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "BTN_7",
+		.type		= EV_KEY,
+		.code		= BTN_7,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN7,
+		.active_low	= 1,
+	},
+};
+
+static void __init el_m150_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(EL_M150_leds_gpio),
+				 EL_M150_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, EL_M150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(EL_M150_gpio_keys),
+					EL_M150_gpio_keys);
+
+	gpio_request_one(EL_M150_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&EL_M150_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_EL_M150, "EL-M150",
+	     "EasyLink EL-M150", el_m150_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-mini.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-mini.c
new file mode 100644
index 0000000000..9879b18f7c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-el-mini.c
@@ -0,0 +1,86 @@
+/*
+ *  Easy-Link EL-MINI board support
+ *
+ *  Copyright (C) 2012 huangfc <huangfangcheng@163.com>
+ *  Copyright (C) 2011 hys <550663898@qq.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MINI_GPIO_LED_SYSTEM	27
+#define MINI_GPIO_BTN_RESET	11
+
+#define MINI_GPIO_USB_POWER	8
+
+#define MINI_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MINI_KEYS_DEBOUNCE_INTERVAL	(3 * MINI_KEYS_POLL_INTERVAL)
+
+static const char *mini_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data mini_flash_data = {
+	.part_probes	= mini_part_probes,
+};
+
+static struct gpio_led mini_leds_gpio[] __initdata = {
+	{
+		.name		= "easylink:green:system",
+		.gpio		= MINI_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mini_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MINI_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MINI_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init el_mini_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&mini_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mini_leds_gpio),
+				 mini_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MINI_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mini_gpio_keys),
+					mini_gpio_keys);
+
+	gpio_request_one(MINI_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_EL_MINI, "EL-MINI", "EasyLink EL-MINI",
+	     el_mini_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ens202ext.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ens202ext.c
new file mode 100644
index 0000000000..07dbc2e69d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ens202ext.c
@@ -0,0 +1,124 @@
+/*
+ * EnGenius ENS202EXT board support
+ *
+ * Copyright (C) 2017 Marty Plummer <netz.kernel@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define ENS202_GPIO_LED_WLAN4		0
+#define ENS202_GPIO_LED_POWER		14
+#define ENS202_GPIO_LED_WLAN2		16
+#define ENS202_GPIO_LED_WLAN3		17
+#define ENS202_GPIO_LED_WLAN1		18
+
+#define ENS202_GPIO_BTN_RESET		1
+
+#define ENS202_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ENS202_KEYS_DEBOUNCE_INTERVAL	(3 * ENS202_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ens202_leds_gpio[] __initdata = {
+	{
+		.name		= "engenius:amber:wlan1",
+		.gpio		= ENS202_GPIO_LED_WLAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:red:wlan2",
+		.gpio		= ENS202_GPIO_LED_WLAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:amber:wlan3",
+		.gpio		= ENS202_GPIO_LED_WLAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:green:wlan4",
+		.gpio		= ENS202_GPIO_LED_WLAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:amber:power",
+		.gpio		= ENS202_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ens202_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ENS202_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ENS202_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init ens202_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(0x1f040000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	if (ath79_nvram_parse_mac_addr(nvram, 0x10000,
+				       "ethaddr=", mac_buff) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac_buff, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac_buff, 1);
+		mac = mac_buff;
+	}
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_output_select(ENS202_GPIO_LED_POWER, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(ENS202_GPIO_LED_WLAN1, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(ENS202_GPIO_LED_WLAN2, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(ENS202_GPIO_LED_WLAN3, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(ENS202_GPIO_LED_WLAN4, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ens202_leds_gpio),
+				 ens202_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ENS202_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ens202_gpio_keys),
+					ens202_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_wmac(art + 0x1000, NULL);
+
+	ath79_register_mdio(1, 0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_ENS202EXT, "ENS202EXT", "EnGenius ENS202EXT",
+	     ens202_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-epg5000.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-epg5000.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-epg5000.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-epg5000.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-esr1750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-esr1750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-esr1750.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-esr1750.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-esr900.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-esr900.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-esr900.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-esr900.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-balin.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-balin.c
new file mode 100644
index 0000000000..2e82ffdaa1
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-balin.c
@@ -0,0 +1,110 @@
+/*
+ * EW Balin board support
+ * (based on Atheros DB120 reference board support)
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2017 Embedded Wireless GmbH    www.80211.de
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define BALIN_GPIO_LED_STATUS	14
+
+#define BALIN_GPIO_BTN_WPS		18
+
+#define BALIN_KEYS_POLL_INTERVAL	20	/* msecs */
+#define BALIN_KEYS_DEBOUNCE_INTERVAL	(3 * BALIN_KEYS_POLL_INTERVAL)
+
+#define BALIN_CALDATA_OFFSET		0x1000
+#define BALIN_WMAC_MAC_OFFSET		(BALIN_CALDATA_OFFSET + 0x02)
+
+static struct gpio_led balin_leds_gpio[] __initdata = {
+	{
+		.name		= "balin:green:status",
+		.gpio		= BALIN_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button balin_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = BALIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BALIN_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+};
+
+
+static void __init balin_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(balin_leds_gpio),
+				 balin_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, BALIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(balin_gpio_keys),
+					balin_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + BALIN_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC1 is connected to the internal switch */
+	memcpy(mac, art + BALIN_WMAC_MAC_OFFSET, sizeof(mac));
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_BALIN, "EW-BALIN", "EmbWir-Balin",
+	     balin_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-dorin.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-dorin.c
new file mode 100644
index 0000000000..575a976aec
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ew-dorin.c
@@ -0,0 +1,138 @@
+/*
+ *  EW Dorin board support
+ *  (based on Atheros Ref. Design AP121)
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012-2017 Embedded Wireless GmbH    www.80211.de
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DORIN_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DORIN_KEYS_DEBOUNCE_INTERVAL	(3 * DORIN_KEYS_POLL_INTERVAL)
+
+#define DORIN_CALDATA_OFFSET		0x1000
+#define DORIN_WMAC_MAC_OFFSET		0x1002
+
+#define DORIN_GPIO_LED_STATUS		21
+
+#define DORIN_GPIO_BTN_JUMPSTART	11
+#define DORIN_GPIO_BTN_RESET		6
+
+static struct gpio_led dorin_leds_gpio[] __initdata = {
+	{
+		.name		= "dorin:green:status",
+		.gpio		= DORIN_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dorin_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init ew_dorin_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DORIN_CALDATA_OFFSET,
+				    art + DORIN_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DORIN_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dorin_leds_gpio),
+				 dorin_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DORIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dorin_gpio_keys),
+					dorin_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_DORIN, "EW-DORIN", "EmbWir-Dorin",
+	     ew_dorin_setup);
+
+
+static void __init ew_dorin_router_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DORIN_CALDATA_OFFSET,
+				    art + DORIN_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DORIN_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	mac[3] &= 0x3F;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dorin_leds_gpio),
+				 dorin_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DORIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dorin_gpio_keys),
+					dorin_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_DORIN_ROUTER, "EW-DORIN-ROUTER",
+	     "EmbWir-Dorin-Router", ew_dorin_router_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-f9k1115v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-f9k1115v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-f9k1115v2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-f9k1115v2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz300e.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz300e.c
new file mode 100644
index 0000000000..43af71a0a8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz300e.c
@@ -0,0 +1,132 @@
+/*
+ *  AVM FRITZ!WLAN Repeater 300E board support
+ *
+ *  Copyright (C) 2017 Mathias Kresin <dev@kresin.me>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define FRITZ300E_KEYS_POLL_INTERVAL	 	20 /* msecs */
+#define FRITZ300E_KEYS_DEBOUNCE_INTERVAL	(3 * FRITZ300E_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition fritz300e_flash_partitions[] = {
+	{
+		.name		= "urloader",
+		.offset		= 0,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0020000,
+		.size		= 0x0ee0000,
+	}, {
+		.name		= "tffs (1)",
+		.offset		= 0x0f00000,
+		.size		= 0x0080000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name           = "tffs (2)",
+		.offset         = 0x0f80000,
+		.size           = 0x0080000,
+		.mask_flags     = MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data fritz300e_flash_data = {
+	.parts		= fritz300e_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(fritz300e_flash_partitions),
+};
+
+static struct gpio_led fritz300e_leds_gpio[] __initdata = {
+	{
+		.name		= "fritz300e:green:power",
+		.gpio		= 13,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:lan",
+		.gpio		= 15,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:wlan",
+		.gpio		= 16,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led fritz300e_wmac_leds_gpio[] = {
+	{
+		.name		= "fritz300e:green:rssi0",
+		.gpio		= 10,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:rssi1",
+		.gpio		= 4,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:rssi2",
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:rssi3",
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz300e:green:rssi4",
+		.gpio		= 5,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button fritz300e_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = FRITZ300E_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	},
+};
+
+static void __init fritz300e_setup(void)
+{
+	/* get the Lantiq PEF7071V phy out of reset */
+	gpio_request_one(11, GPIOF_OUT_INIT_HIGH, "phy reset");
+
+	ath79_register_m25p80(&fritz300e_flash_data);
+
+	ath79_register_mdio(0, ~(BIT(0)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(fritz300e_leds_gpio),
+				 fritz300e_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, FRITZ300E_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(fritz300e_gpio_keys),
+					fritz300e_gpio_keys);
+
+	ap9x_pci_setup_wmac_leds(0, fritz300e_wmac_leds_gpio,
+				 ARRAY_SIZE(fritz300e_wmac_leds_gpio));
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_FRITZ300E, "FRITZ300E",
+	     "AVM FRITZ!WLAN Repeater 300E", fritz300e_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz4020.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz4020.c
new file mode 100644
index 0000000000..ed7f9a8b3e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-fritz4020.c
@@ -0,0 +1,242 @@
+/*
+ *  AVM FRITZ!Box 4020 board support
+ *
+ *  Copyright (C) 2018 David Bauer <mail@david-bauer.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_data/mdio-gpio.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/74x164.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define FRITZ4020_GPIO_SHIFT_SER			19   /* DS,   Data Serial Input */
+#define FRITZ4020_GPIO_SHIFT_SRCLK			20 /* SHCP, Shift Reg Clock Input */
+
+#define FRITZ4020_SSR_BIT_0				0
+#define FRITZ4020_SSR_BIT_1				1
+#define FRITZ4020_SSR_BIT_2				2
+#define FRITZ4020_SSR_BIT_3				3
+#define FRITZ4020_SSR_BIT_4				4
+#define FRITZ4020_SSR_BIT_5				5
+#define FRITZ4020_SSR_BIT_6				6
+#define FRITZ4020_SSR_BIT_7				7
+
+#define FRITZ4020_74HC_GPIO_BASE			32
+#define FRITZ4020_74HC_GPIO_LED_LAN			(FRITZ4020_74HC_GPIO_BASE + 0)
+#define FRITZ4020_74HC_GPIO_LED_INFO_RED		(FRITZ4020_74HC_GPIO_BASE + 1)
+#define FRITZ4020_74HC_GPIO_LED_POWER			(FRITZ4020_74HC_GPIO_BASE + 2)
+#define FRITZ4020_74HC_GPIO_LED_WLAN			(FRITZ4020_74HC_GPIO_BASE + 3)
+#define FRITZ4020_74HC_GPIO_LED_WAN			(FRITZ4020_74HC_GPIO_BASE + 4)
+#define FRITZ4020_74HC_GPIO_USB_RST			(FRITZ4020_74HC_GPIO_BASE + 5)
+#define FRITZ4020_74HC_GPIO_LED_INFO			(FRITZ4020_74HC_GPIO_BASE + 6)
+
+
+#define FRITZ4020_GPIO_BTN_WPS				2
+#define FRITZ4020_GPIO_BTN_WLAN				21
+#define FRITZ4020_KEYS_POLL_INTERVAL			20 /* msecs */
+#define FRITZ4020_KEYS_DEBOUNCE_INTERVAL		(3 * FRITZ4020_KEYS_POLL_INTERVAL)
+
+#define FRTIZ4020_OFFSET_URLADER_WIFI_MAC_REVERSE	0x1979
+
+
+static struct spi_gpio_platform_data fritz4020_spi_data = {
+	.sck		= FRITZ4020_GPIO_SHIFT_SRCLK,
+	.miso		= SPI_GPIO_NO_MISO,
+	.mosi		= FRITZ4020_GPIO_SHIFT_SER,
+	.num_chipselect	= 1,
+};
+
+static u8 fritz4020_ssr_initdata[] = {
+	BIT(FRITZ4020_SSR_BIT_7) |
+	BIT(FRITZ4020_SSR_BIT_6) |
+	BIT(FRITZ4020_SSR_BIT_5) |
+	BIT(FRITZ4020_SSR_BIT_4) |
+	BIT(FRITZ4020_SSR_BIT_3) |
+	BIT(FRITZ4020_SSR_BIT_2) |
+	BIT(FRITZ4020_SSR_BIT_1)
+};
+
+static struct gen_74x164_chip_platform_data fritz4020_ssr_data = {
+	.base = FRITZ4020_74HC_GPIO_BASE,
+	.num_registers = ARRAY_SIZE(fritz4020_ssr_initdata),
+	.init_data = fritz4020_ssr_initdata,
+};
+
+static struct platform_device fritz4020_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &fritz4020_spi_data,
+	},
+};
+
+static struct spi_board_info fritz4020_spi_info[] = {
+	{
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 10000000,
+		.modalias		= "74x164",
+		.platform_data		= &fritz4020_ssr_data,
+		.controller_data	= (void *) 0x0,
+	},
+};
+
+static struct mtd_partition fritz4020_flash_partitions[] = {
+	{
+		.name		= "urlader",
+		.offset		= 0,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0020000,
+		.size		= 0x0EE0000,
+	}, {
+		.name		= "tffs (1)",
+		.offset		= 0x0f00000,
+		.size		= 0x0080000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "tffs (2)",
+		.offset		= 0x0f80000,
+		.size		= 0x0080000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data fritz4020_flash_data = {
+	.parts		= fritz4020_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(fritz4020_flash_partitions),
+};
+
+static struct gpio_led fritz4020_leds_gpio[] __initdata = {
+	{
+		.name		= "fritz4020:green:lan",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz4020:green:info",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_INFO,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz4020:red:info",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_INFO_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz4020:green:power",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz4020:green:wlan",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "fritz4020:green:wan",
+		.gpio		= FRITZ4020_74HC_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button fritz4020_gpio_keys[] __initdata = {
+	{
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= FRITZ4020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= FRITZ4020_GPIO_BTN_WLAN,
+		.active_low		= 0,
+	},
+	{
+		.desc			= "WPS button",
+		.type			= EV_KEY,
+		.code			= KEY_WPS_BUTTON,
+		.debounce_interval	= FRITZ4020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= FRITZ4020_GPIO_BTN_WPS,
+		.active_low		= 0,
+	},
+};
+
+static void __init fritz4020_setup(void) {
+	u8 *urlader = (u8 *) KSEG1ADDR(0x1f000000);
+	u8 wifi_mac[ETH_ALEN];
+
+	ath79_register_m25p80(&fritz4020_flash_data);
+
+	/* Initialize ethernet */
+	ath79_extract_mac_reverse(urlader + FRTIZ4020_OFFSET_URLADER_WIFI_MAC_REVERSE, wifi_mac);
+	ath79_setup_qca956x_eth_cfg(QCA956X_ETH_CFG_SW_PHY_SWAP |
+				    QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, wifi_mac, -2);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	/* Initialize 2.4GHz WiFi */
+	ath79_register_wmac_simple();
+
+	/* Activate USB Power */
+	gpio_request_one(FRITZ4020_74HC_GPIO_USB_RST,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	/* Initialize USB port */
+	ath79_register_usb();
+
+	/* Register LED shift-register */
+	spi_register_board_info(fritz4020_spi_info,
+				ARRAY_SIZE(fritz4020_spi_info));
+	platform_device_register(&fritz4020_spi_device);
+
+	/* Register GPIO buttons */
+	ath79_register_gpio_keys_polled(-1, FRITZ4020_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(fritz4020_gpio_keys),
+					fritz4020_gpio_keys);
+
+	/* Register LEDs */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(fritz4020_leds_gpio),
+				 fritz4020_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_FRITZ4020, "FRITZ4020",
+	     "AVM FRITZ!Box 4020", fritz4020_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar150.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar150.c
new file mode 100644
index 0000000000..9febc7a839
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar150.c
@@ -0,0 +1,125 @@
+/*
+ *  GL_ar150 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR150_GPIO_LED_WLAN		   0
+#define GL_AR150_GPIO_LED_LAN		   13
+#define GL_AR150_GPIO_LED_WAN		   15 
+
+#define GL_AR150_GPIO_BIN_USB         6
+#define GL_AR150_GPIO_BTN_MANUAL      7
+#define GL_AR150_GPIO_BTN_AUTO	   	   8
+#define GL_AR150_GPIO_BTN_RESET	   11
+
+#define GL_AR150_KEYS_POLL_INTERVAL   20	/* msecs */
+#define GL_AR150_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR150_KEYS_POLL_INTERVAL)
+
+#define GL_AR150_MAC0_OFFSET	0x0000
+#define GL_AR150_MAC1_OFFSET	0x0000
+#define GL_AR150_CALDATA_OFFSET	0x1000
+#define GL_AR150_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar150_leds_gpio[] __initdata = {
+	{
+		.name = "gl-ar150:orange:wlan",
+		.gpio = GL_AR150_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-ar150:green:lan",
+		.gpio = GL_AR150_GPIO_LED_LAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-ar150:green:wan",
+		.gpio = GL_AR150_GPIO_LED_WAN,
+		.active_low = 0,
+ 		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar150_gpio_keys[] __initdata = {
+	{
+		.desc = "BTN_7",
+		.type = EV_KEY,
+		.code = BTN_7,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_MANUAL,
+		.active_low = 0,
+	},
+	{
+		.desc = "BTN_8",
+		.type = EV_KEY,
+		.code = BTN_8,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_AUTO,
+		.active_low = 0,
+	},
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_ar150_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar150_leds_gpio),
+				 gl_ar150_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar150_gpio_keys),
+					gl_ar150_gpio_keys);
+
+	/* enable usb */
+	gpio_request_one(GL_AR150_GPIO_BIN_USB,
+				 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+	 			 "USB power");
+	ath79_register_usb();
+	
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR150_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR150_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR150_CALDATA_OFFSET, art + GL_AR150_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR150, "GL-AR150", "GL.iNet GL-AR150", gl_ar150_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300.c
new file mode 100644
index 0000000000..1708d696b8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300.c
@@ -0,0 +1,103 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR300_GPIO_LED_WLAN	13
+#define GL_AR300_GPIO_LED_WAN	14
+#define GL_AR300_GPIO_BTN_RESET	16
+
+
+#define GL_AR300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_AR300_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR300_KEYS_POLL_INTERVAL)
+
+#define GL_AR300_MAC0_OFFSET	0x0000
+#define	GL_AR300_MAC1_OFFSET	0x0000
+#define GL_AR300_CALDATA_OFFSET	0x1000
+#define GL_AR300_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar300_leds_gpio[] __initdata = {
+	{
+		.name = "gl-ar300:wlan",
+		.gpio = GL_AR300_GPIO_LED_WLAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl-ar300:wan",
+		.gpio = GL_AR300_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar300_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300_GPIO_BTN_RESET,
+		.active_low = 1,
+	},
+};
+
+static void __init gl_ar300_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar300_leds_gpio),
+				 gl_ar300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar300_gpio_keys),
+					gl_ar300_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+	ath79_register_mdio(1, 0x0);
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR300_MAC0_OFFSET, 0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR300_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR300_CALDATA_OFFSET, art + GL_AR300_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR300, "GL-AR300", "GL.iNet GL-AR300", gl_ar300_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300m.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300m.c
new file mode 100644
index 0000000000..2a2d2702bc
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar300m.c
@@ -0,0 +1,165 @@
+/*
+ *  GLI AR300M(D) board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/pci.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define GL_AR300M_GPIO_LED_USB		2
+#define GL_AR300M_GPIO_LED_WLAN		14
+#define GL_AR300M_GPIO_LED_LAN		13
+#define GL_AR300M_GPIO_LED_SYSTEM	12
+#define GL_AR300M_GPIO_BTN_RESET	3
+#define GL_AR300M_GPIO_BTN_LEFT		0
+#define GL_AR300M_GPIO_BTN_RIGHT	1
+
+#define GL_AR300M_KEYS_POLL_INTERVAL		20	/* msecs */
+#define GL_AR300M_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR300M_KEYS_POLL_INTERVAL)
+
+#define GL_AR300M_MAC0_OFFSET	0
+#define GL_AR300M_MAC1_OFFSET	6
+#define GL_AR300M_WMAC_CALDATA_OFFSET	0x1000
+#define GL_AR300M_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led gl_ar300m_leds_gpio[] __initdata = {
+	{
+		.name = "gl-ar300m:green:usb",
+		.gpio = GL_AR300M_GPIO_LED_USB,
+		.active_low = 0,
+		.default_state = 1,
+	},
+	{
+		.name = "gl-ar300m:green:wlan",
+		.gpio = GL_AR300M_GPIO_LED_WLAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl-ar300m:green:lan",
+		.gpio = GL_AR300M_GPIO_LED_LAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl-ar300m:green:system",
+		.gpio = GL_AR300M_GPIO_LED_SYSTEM,
+		.active_low = 1,
+		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar300m_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300M_GPIO_BTN_RESET,
+		.active_low = 1,
+	},
+	{
+		.desc = "button right",
+		.type = EV_KEY,
+		.code = BTN_0,
+		.debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300M_GPIO_BTN_LEFT,
+		.active_low = 0,
+	},
+	{
+		.desc = "button left",
+		.type = EV_KEY,
+		.code = BTN_1,
+		.debounce_interval = GL_AR300M_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300M_GPIO_BTN_RIGHT,
+		.active_low = 0,
+	},
+};
+
+static struct spi_board_info gl_ar300m_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= NULL,
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "ath79-spinand",
+		.platform_data	= NULL,
+	}
+};
+
+static struct ath79_spi_platform_data gl_ar300m_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 2,
+};
+
+static void __init gl_ar300m_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+	ath79_register_spi(&gl_ar300m_spi_data, gl_ar300m_spi_info, 2);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar300m_leds_gpio),
+				 gl_ar300m_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR300M_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar300m_gpio_keys),
+					gl_ar300m_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + GL_AR300M_MAC0_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + GL_AR300M_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_init_mac(tmpmac, art + GL_AR300M_WMAC_CALDATA_OFFSET + 2, 0);
+	ath79_register_wmac(art + GL_AR300M_WMAC_CALDATA_OFFSET, tmpmac);
+
+	/* enable usb */
+	ath79_register_usb();
+	/* enable pci */
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR300M, "GL-AR300M", "GL.iNet GL-AR300M", gl_ar300m_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750.c
new file mode 100644
index 0000000000..9ee6e29c02
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750.c
@@ -0,0 +1,146 @@
+/*
+ * GL.iNet GL-AR750 board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR750_GPIO_LED_POWER		12
+#define GL_AR750_GPIO_LED_WLAN2G	14
+#define GL_AR750_GPIO_LED_WLAN5G	13
+
+#define GL_AR750_GPIO_BTN_RESET		3
+#define GL_AR750_GPIO_BTN_SW1		0
+
+#define GL_AR750_GPIO_I2C_SCL		16
+#define GL_AR750_GPIO_I2C_SDA		17
+
+#define GL_AR750_GPIO_USB_POWER		2
+
+#define GL_AR750_KEYS_POLL_INTERVAL	20
+#define GL_AR750_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR750_KEYS_POLL_INTERVAL)
+
+#define GL_AR750_MAC0_OFFSET		0
+#define GL_AR750_WMAC2G_CALDATA_OFFSET	0x1000
+#define GL_AR750_WMAC5G_CALDATA_OFFSET	0x5000
+
+static struct gpio_led gl_ar750_leds_gpio[] __initdata = {
+	{
+		.name		= "gl-ar750:white:power",
+		.gpio		= GL_AR750_GPIO_LED_POWER,
+		.default_state	= LEDS_GPIO_DEFSTATE_KEEP,
+		.active_low	= 1,
+	}, {
+		.name		= "gl-ar750:white:wlan2g",
+		.gpio		= GL_AR750_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	}, {
+		.name		= "gl-ar750:white:wlan5g",
+		.gpio		= GL_AR750_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar750_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GL_AR750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GL_AR750_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw1",
+		.type			= EV_KEY,
+		.code			= BTN_0,
+		.debounce_interval	= GL_AR750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GL_AR750_GPIO_BTN_SW1,
+		.active_low		= 1,
+	},
+};
+
+static struct i2c_gpio_platform_data gl_ar750_i2c_gpio_data = {
+	.sda_pin = GL_AR750_GPIO_I2C_SDA,
+	.scl_pin = GL_AR750_GPIO_I2C_SCL,
+};
+
+static struct platform_device gl_ar750_i2c_gpio = {
+	.name	= "i2c-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &gl_ar750_i2c_gpio_data,
+	},
+};
+
+static void __init gl_ar750_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f050000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xfc;
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + GL_AR750_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + GL_AR750_MAC0_OFFSET, 1);
+	ath79_register_eth(1);
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar750_leds_gpio),
+				 gl_ar750_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GL_AR750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar750_gpio_keys),
+					gl_ar750_gpio_keys);
+
+	gpio_request_one(GL_AR750_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	platform_device_register(&gl_ar750_i2c_gpio);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + GL_AR750_WMAC2G_CALDATA_OFFSET, NULL);
+
+	ap91_pci_init(art + GL_AR750_WMAC5G_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR750, "GL-AR750", "GL.iNet GL-AR750",
+	     gl_ar750_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750s.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-ar750s.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-domino.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-domino.c
new file mode 100644
index 0000000000..4ff8ff637e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-domino.c
@@ -0,0 +1,136 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DOMINO_GPIO_LED_WLAN		0
+#define DOMINO_GPIO_LED_WAN			17
+#define DOMINO_GPIO_LED_USB			1
+#define DOMINO_GPIO_LED_LAN1		13
+#define DOMINO_GPIO_LED_LAN2		14
+#define DOMINO_GPIO_LED_LAN3		15
+#define DOMINO_GPIO_LED_LAN4		16
+#define DOMINO_GPIO_LED_SYS			27
+#define DOMINO_GPIO_LED_WPS			26
+#define DOMINO_GPIO_USB_POWER		6
+
+#define DOMINO_GPIO_BTN_RESET		11
+#define DOMINO_GPIO_BTN_WPS			20
+
+#define DOMINO_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DOMINO_KEYS_DEBOUNCE_INTERVAL	(3 * DOMINO_KEYS_POLL_INTERVAL)
+
+#define DOMINO_MAC0_OFFSET	0x0000
+#define	DOMINO_MAC1_OFFSET	0x0000
+#define DOMINO_CALDATA_OFFSET	0x1000
+#define DOMINO_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led domino_leds_gpio[] __initdata = {
+	{
+		.name = "gl-domino:blue:wlan",
+		.gpio = DOMINO_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-domino:red:wan",
+		.gpio = DOMINO_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl-domino:white:usb",
+		.gpio = DOMINO_GPIO_LED_USB,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-domino:green:lan1",
+		.gpio = DOMINO_GPIO_LED_LAN1,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-domino:yellow:wps",
+		.gpio = DOMINO_GPIO_LED_WPS,
+		.active_low = 1,
+	},
+	{
+		.name = "gl-domino:orange:sys",
+		.gpio = DOMINO_GPIO_LED_SYS,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button domino_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+	{
+		.desc = "wps",
+		.type = EV_KEY,
+		.code = KEY_WPS_BUTTON,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_WPS,
+		.active_low = 0,
+	}
+};
+
+static void __init domino_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(domino_leds_gpio),
+				 domino_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DOMINO_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(domino_gpio_keys),
+					domino_gpio_keys);
+
+	gpio_request_one(DOMINO_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+DOMINO_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+DOMINO_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + DOMINO_CALDATA_OFFSET, art + DOMINO_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_DOMINO, "DOMINO", "Domino Pi", domino_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-inet.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-inet.c
new file mode 100644
index 0000000000..6f603d9579
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-inet.c
@@ -0,0 +1,104 @@
+/*
+ *  GL-CONNECT iNet board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_INET_GPIO_LED_WLAN		0
+#define GL_INET_GPIO_LED_LAN		13
+#define GL_INET_GPIO_BTN_RESET		11
+
+#define GL_INET_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_INET_KEYS_DEBOUNCE_INTERVAL	(3 * GL_INET_KEYS_POLL_INTERVAL)
+
+static const char * gl_inet_part_probes[] = {
+	"tp-link", /* dont change, this will use tplink parser */
+	NULL ,
+};
+
+static struct flash_platform_data gl_inet_flash_data = {
+	.part_probes = gl_inet_part_probes,
+};
+
+static struct gpio_led gl_inet_leds_gpio[] __initdata = {
+	{
+		.name = "gl-inet:red:wlan",
+		.gpio = GL_INET_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-inet:green:lan",
+		.gpio = GL_INET_GPIO_LED_LAN,
+		.active_low = 0,
+		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_inet_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_INET_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_INET_GPIO_BTN_RESET,
+		.active_low = 0,
+	}
+};
+
+static void __init gl_inet_setup(void)
+{
+	/* get the mac address which is stored in the 1st 64k uboot MTD */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	/* get the art address, which is the last 64K. By using
+	   0x1fff1000, it doesn't matter it is 4M, 8M or 16M flash */
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. MTD will use tp-link parser to parser MTD */
+	ath79_register_m25p80(&gl_inet_flash_data);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_inet_leds_gpio),
+				 gl_inet_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_INET_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_inet_gpio_keys),
+					gl_inet_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_INET, "GL-INET", "GL-CONNECT INET v1",
+	     gl_inet_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-mifi.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-mifi.c
new file mode 100644
index 0000000000..a5c68ed65a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-mifi.c
@@ -0,0 +1,114 @@
+/*
+ *  Mifi board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_MIFI_GPIO_LED_WAN		27
+#define GL_MIFI_GPIO_LED_LAN		16
+#define GL_MIFI_GPIO_LED_WLAN		1
+#define GL_MIFI_GPIO_LED_NET		0
+#define GL_MIFI_GPIO_LED_3GCONTROL	7
+
+#define GL_MIFI_GPIO_BTN_RESET    11
+
+#define GL_MIFI_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_MIFI_KEYS_DEBOUNCE_INTERVAL	(3 * GL_MIFI_KEYS_POLL_INTERVAL)
+
+#define GL_MIFI_MAC0_OFFSET	    0x0000
+#define GL_MIFI_MAC1_OFFSET	    0x0000
+#define GL_MIFI_CALDATA_OFFSET	0x1000
+#define GL_MIFI_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_mifi_leds_gpio[] __initdata = {
+	{
+		.name = "gl-mifi:green:wan",
+		.gpio = GL_MIFI_GPIO_LED_WAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-mifi:green:lan",
+		.gpio = GL_MIFI_GPIO_LED_LAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-mifi:green:wlan",
+		.gpio = GL_MIFI_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-mifi:green:net",
+		.gpio = GL_MIFI_GPIO_LED_NET,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-mifi:green:3gcontrol",
+		.gpio = GL_MIFI_GPIO_LED_3GCONTROL,
+		.active_low = 0,
+	}
+};
+
+static struct gpio_keys_button gl_mifi_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_MIFI_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_MIFI_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_mifi_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_mifi_leds_gpio),
+				 gl_mifi_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_MIFI_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_mifi_gpio_keys),
+					gl_mifi_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_MIFI_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_MIFI_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_MIFI_CALDATA_OFFSET, art + GL_MIFI_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_MIFI, "GL-MIFI", "GL.iNet GL-MIFI", gl_mifi_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-usb150.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-usb150.c
new file mode 100644
index 0000000000..6cc27e1ada
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gl-usb150.c
@@ -0,0 +1,87 @@
+/*
+ * GL.iNet GL-USB150 board support
+ *
+ * Copyright (C) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_USB150_GPIO_LED_POWER	13
+#define GL_USB150_GPIO_LED_WLAN		0
+#define GL_USB150_GPIO_LAN_RESET	7
+#define GL_USB150_GPIO_BTN_RESET	11
+
+#define GL_USB150_KEYS_POLL_INTERVAL		20
+#define GL_USB150_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * GL_USB150_KEYS_POLL_INTERVAL)
+
+#define GL_USB150_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led gl_usb150_leds_gpio[] __initdata = {
+	{
+		.name		= "gl-usb150:green:power",
+		.gpio		= GL_USB150_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "gl-usb150:green:wlan",
+		.gpio		= GL_USB150_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button gl_usb150_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GL_USB150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GL_USB150_GPIO_BTN_RESET,
+		.active_low		= 0,
+	},
+};
+
+static void __init gl_usb150_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* LAN (PHY4 connected with Realtek RTL8152B) */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_usb150_leds_gpio),
+				 gl_usb150_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GL_USB150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_usb150_gpio_keys),
+					gl_usb150_gpio_keys);
+
+	gpio_request_one(GL_USB150_GPIO_LAN_RESET,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "LAN reset");
+
+	ath79_register_wmac(art + GL_USB150_WMAC_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_USB150, "GL-USB150", "GL.iNet GL-USB150",
+	     gl_usb150_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v1.c
new file mode 100644
index 0000000000..d424e0f111
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v1.c
@@ -0,0 +1,143 @@
+/*
+ *  GainStrong Oolite/MiniBox V1.0 boards support
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define GS_MINIBOX_V1_GPIO_BTN_RESET	11
+#define GS_MINIBOX_V1_GPIO_LED_SYSTEM	1
+
+#define GS_OOLITE_V1_GPIO_BTN6		6
+#define GS_OOLITE_V1_GPIO_BTN7		7
+#define GS_OOLITE_V1_GPIO_BTN_RESET	11
+#define GS_OOLITE_V1_GPIO_LED_SYSTEM	27
+
+#define GS_KEYS_POLL_INTERVAL		20 /* msecs */
+#define GS_KEYS_DEBOUNCE_INTERVAL	(3 * GS_KEYS_POLL_INTERVAL)
+
+static const char *gs_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data gs_flash_data = {
+	.part_probes	= gs_part_probes,
+};
+
+static struct gpio_led gs_minibox_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "minibox-v1:green:system",
+		.gpio		= GS_MINIBOX_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led gs_oolite_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "oolite-v1:red:system",
+		.gpio		= GS_OOLITE_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button gs_minibox_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GS_MINIBOX_V1_GPIO_BTN_RESET,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_keys_button gs_oolite_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GS_OOLITE_V1_GPIO_BTN_RESET,
+		.active_low		= 0,
+	}, {
+		.desc			= "BTN_6",
+		.type			= EV_KEY,
+		.code			= BTN_6,
+		.debounce_interval	= GS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GS_OOLITE_V1_GPIO_BTN6,
+		.active_low		= 0,
+	}, {
+		.desc			= "BTN_7",
+		.type			= EV_KEY,
+		.code			= BTN_7,
+		.debounce_interval	= GS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GS_OOLITE_V1_GPIO_BTN7,
+		.active_low		= 0,
+	},
+};
+
+static void __init gs_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&gs_flash_data);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art, mac);
+}
+
+static void __init gs_minibox_v1_setup(void)
+{
+	gs_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gs_minibox_v1_leds_gpio),
+				 gs_minibox_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GS_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gs_minibox_v1_gpio_keys),
+					gs_minibox_v1_gpio_keys);
+}
+
+static void __init gs_oolite_v1_setup(void)
+{
+	gs_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gs_oolite_v1_leds_gpio),
+				 gs_oolite_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GS_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gs_oolite_v1_gpio_keys),
+					gs_oolite_v1_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_GS_MINIBOX_V1, "MINIBOX-V1", "GainStrong MiniBox V1.0",
+	     gs_minibox_v1_setup);
+
+MIPS_MACHINE(ATH79_MACH_GS_OOLITE_V1, "OOLITE-V1", "GainStrong Oolite V1.0",
+	     gs_oolite_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v5-2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v5-2.c
new file mode 100644
index 0000000000..64dc4f3345
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-gs-oolite-v5-2.c
@@ -0,0 +1,111 @@
+/*
+ * GainStrong Oolite V5.2 module and development board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define GS_OOLITE_V5_2_DEV_GPIO_BTN_RESET	17
+#define GS_OOLITE_V5_2_DEV_GPIO_LED_SYSTEM	13
+
+#define GS_KEYS_POLL_INTERVAL		20 /* msec */
+#define GS_KEYS_DEBOUNCE_INTERVAL	(3 * GS_KEYS_POLL_INTERVAL)
+
+#define GS_OOLITE_V5_2_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *gs_oolite_v5_2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data gs_oolite_v5_2_flash_data = {
+	.part_probes = gs_oolite_v5_2_part_probes,
+};
+
+static struct gpio_led gs_oolite_v5_2_dev_gpio_leds[] __initdata = {
+	{
+		.name		= "oolite-v5.2-dev:blue:system",
+		.gpio		= GS_OOLITE_V5_2_DEV_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button gs_oolite_v5_2_dev_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GS_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GS_OOLITE_V5_2_DEV_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static void __init gs_oolite_v5_2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&gs_oolite_v5_2_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + 6, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+	ath79_register_usb();
+	ath79_register_wmac(art + GS_OOLITE_V5_2_WMAC_CALDATA_OFFSET, NULL);
+}
+
+static void __init gs_oolite_v5_2_dev_setup(void)
+{
+	gs_oolite_v5_2_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gs_oolite_v5_2_dev_gpio_leds),
+				 gs_oolite_v5_2_dev_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, GS_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gs_oolite_v5_2_dev_gpio_keys),
+					gs_oolite_v5_2_dev_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_GS_OOLITE_V5_2, "OOLITE-V5-2",
+	     "GainStrong Oolite V5.2", gs_oolite_v5_2_setup);
+
+MIPS_MACHINE(ATH79_MACH_GS_OOLITE_V5_2_DEV, "OOLITE-V5-2-DEV",
+	     "GainStrong Oolite V5.2-Dev", gs_oolite_v5_2_dev_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiveap-121.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiveap-121.c
new file mode 100644
index 0000000000..363d73dd53
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiveap-121.c
@@ -0,0 +1,153 @@
+/*
+ *  Aerohive HiveAP 121 board support
+ *
+ *  Copyright (C) 2017 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform/ar934x_nfc.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "dev-ap9x-pci.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define HIVEAP_121_GPIO_LED_ORANGE	14
+#define HIVEAP_121_GPIO_LED_WHITE	21
+#define HIVEAP_121_GPIO_I2C_SCL		12
+#define HIVEAP_121_GPIO_I2C_SDA		13
+#define HIVEAP_121_GPIO_XLNA0		20
+#define HIVEAP_121_GPIO_XLNA1		19
+#define HIVEAP_121_GPIO_USB_POWER	15
+
+#define HIVEAP_121_GPIO_BTN_RESET		4
+#define HIVEAP_121_KEYS_POLL_INTERVAL		20 /* msecs */
+#define HIVEAP_121_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * HIVEAP_121_KEYS_POLL_INTERVAL)
+
+#define HIVEAP_121_MAC_OFFSET	0x90000
+
+#define HIVEAP_121_LAN_PHYADDR	0
+
+static struct gpio_led hiveap_121_leds_gpio[] __initdata = {
+	{
+		.name		= "hiveap-121:orange:power",
+		.gpio		= HIVEAP_121_GPIO_LED_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "hiveap-121:white:power",
+		.gpio		= HIVEAP_121_GPIO_LED_WHITE,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button hiveap_121_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = HIVEAP_121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = HIVEAP_121_GPIO_BTN_RESET,
+		.active_low  = 1,
+	},
+};
+
+static struct i2c_gpio_platform_data hiveap_121_i2c_gpio_data = {
+	.sda_pin = HIVEAP_121_GPIO_I2C_SDA,
+	.scl_pin = HIVEAP_121_GPIO_I2C_SCL,
+};
+
+static struct platform_device hiveap_121_i2c_gpio_device = {
+	.name	= "i2c-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &hiveap_121_i2c_gpio_data,
+	}
+};
+
+static struct i2c_board_info tpm_i2c_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("tpm_i2c_atmel", 0x29),
+	}
+};
+
+static void __init hiveap_121_setup(void)
+{
+	u8 *base = (u8 *) KSEG1ADDR(0x1f000000);
+	u8 wlan0_mac[ETH_ALEN];
+	u8 wlan1_mac[ETH_ALEN];
+
+	/* NAND */
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	/* SPI */
+	ath79_register_m25p80(NULL);
+
+	/* MDIO Interface */
+	ath79_register_mdio(0, 0x0);
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_RDV_DELAY);
+
+	/* GMAC0 is connected to the RGMII interface to an Atheros AR8035-A */
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       base + HIVEAP_121_MAC_OFFSET, 0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(HIVEAP_121_LAN_PHYADDR);
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000;
+	ath79_eth0_pll_data.pll_100 = 0x00000101;
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+	ath79_register_eth(0);
+
+	/* i2c */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+	platform_device_register(&hiveap_121_i2c_gpio_device);
+
+	/* TPM */
+	i2c_register_board_info(0, tpm_i2c_info, ARRAY_SIZE(tpm_i2c_info));
+
+	/* LEDs and Buttons */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hiveap_121_leds_gpio),
+				 hiveap_121_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HIVEAP_121_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(hiveap_121_gpio_keys),
+					hiveap_121_gpio_keys);
+
+	/* USB */
+	gpio_request_one(HIVEAP_121_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	/* XLNA - SoC Wireless */
+	ath79_wmac_set_ext_lna_gpio(0, HIVEAP_121_GPIO_XLNA0);
+	ath79_wmac_set_ext_lna_gpio(1, HIVEAP_121_GPIO_XLNA1);
+
+	/* SoC Wireless */
+	ath79_init_mac(wlan0_mac, base + HIVEAP_121_MAC_OFFSET, 1);
+	ath79_register_wmac(NULL, wlan0_mac); /* Caldata in OTP */
+
+	/* PCIe Wireless */
+	ath79_init_mac(wlan1_mac, base + HIVEAP_121_MAC_OFFSET, 2);
+	ap91_pci_init(NULL, wlan1_mac); /* Caldata in OTP */
+}
+
+MIPS_MACHINE(ATH79_MACH_HIVEAP_121, "HiveAP-121", "Aerohive HiveAP-121",
+	     hiveap_121_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiwifi-hc6361.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiwifi-hc6361.c
new file mode 100644
index 0000000000..6600595c05
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hiwifi-hc6361.c
@@ -0,0 +1,115 @@
+/*
+ *  HiWiFi HC6361 board support
+ *
+ *  Copyright (C) 2012-2013 eric
+ *  Copyright (C) 2014 Yousong Zhou <yszhou4tech@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define HIWIFI_HC6361_GPIO_LED_WLAN_2P4		0	/* 2.4G WLAN LED */
+#define HIWIFI_HC6361_GPIO_LED_SYSTEM		1	/* System LED */
+#define HIWIFI_HC6361_GPIO_LED_INTERNET		27	/* Internet LED */
+
+#define HIWIFI_HC6361_GPIO_USBPOWER		20	/* USB power control */
+#define HIWIFI_HC6361_GPIO_BTN_RST		11	/* Reset button */
+
+#define HIWIFI_HC6361_KEYS_POLL_INTERVAL	20	/* msecs */
+#define HIWIFI_HC6361_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * HIWIFI_HC6361_KEYS_POLL_INTERVAL)
+
+static struct gpio_led hiwifi_leds_gpio[] __initdata = {
+	{
+		.name		= "hiwifi:blue:wlan-2p4",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_WLAN_2P4,
+		.active_low	= 1,
+	}, {
+		.name		= "hiwifi:blue:system",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "hiwifi:blue:internet",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button hiwifi_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = HIWIFI_HC6361_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HIWIFI_HC6361_GPIO_BTN_RST,
+		.active_low	= 1,
+	}
+};
+
+static void __init get_mac_from_bdinfo(u8 *mac, void *bdinfo)
+{
+	if (sscanf(bdinfo, "fac_mac = %2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx",
+				&mac[0], &mac[1], &mac[2], &mac[3],
+				&mac[4], &mac[5]) == 6) {
+		return;
+	}
+
+	printk(KERN_WARNING "Parsing MAC address failed.\n");
+	memcpy(mac, "\x00\xba\xbe\x00\x00\x00", 6);
+}
+
+static void __init hiwifi_hc6361_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(NULL);
+	ath79_gpio_function_enable(
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hiwifi_leds_gpio),
+			hiwifi_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HIWIFI_HC6361_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(hiwifi_gpio_keys),
+			hiwifi_gpio_keys);
+	gpio_request_one(HIWIFI_HC6361_GPIO_USBPOWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	get_mac_from_bdinfo(mac, (void *) KSEG1ADDR(0x1f010180));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_HIWIFI_HC6361, "HiWiFi-HC6361",
+		"HiWiFi HC6361", hiwifi_hc6361_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hornet-ub.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hornet-ub.c
new file mode 100644
index 0000000000..1d21424585
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-hornet-ub.c
@@ -0,0 +1,142 @@
+/*
+ *  ALFA NETWORK Hornet-UB board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define HORNET_UB_GPIO_LED_WLAN		0
+#define HORNET_UB_GPIO_LED_USB		1
+#define HORNET_UB_GPIO_LED_LAN		13
+#define HORNET_UB_GPIO_LED_WAN		17
+#define HORNET_UB_GPIO_LED_WPS		27
+#define HORNET_UB_GPIO_EXT_LNA		28
+
+#define HORNET_UB_GPIO_BTN_RESET	12
+#define HORNET_UB_GPIO_BTN_WPS		11
+
+#define HORNET_UB_GPIO_USB_POWER	26
+
+#define HORNET_UB_KEYS_POLL_INTERVAL	20	/* msecs */
+#define HORNET_UB_KEYS_DEBOUNCE_INTERVAL	(3 * HORNET_UB_KEYS_POLL_INTERVAL)
+
+#define HORNET_UB_MAC0_OFFSET		0x0000
+#define HORNET_UB_MAC1_OFFSET		0x0006
+#define HORNET_UB_CALDATA_OFFSET	0x1000
+
+static struct gpio_led hornet_ub_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:blue:lan",
+		.gpio		= HORNET_UB_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:usb",
+		.gpio		= HORNET_UB_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wan",
+		.gpio		= HORNET_UB_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:blue:wlan",
+		.gpio		= HORNET_UB_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wps",
+		.gpio		= HORNET_UB_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button hornet_ub_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init hornet_ub_gpio_setup(void)
+{
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	gpio_request_one(HORNET_UB_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	gpio_request_one(HORNET_UB_GPIO_EXT_LNA,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"external LNA0");
+
+}
+
+static void __init hornet_ub_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	hornet_ub_gpio_setup();
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hornet_ub_leds_gpio),
+					hornet_ub_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HORNET_UB_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(hornet_ub_gpio_keys),
+					 hornet_ub_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + HORNET_UB_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			art + HORNET_UB_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + HORNET_UB_CALDATA_OFFSET, NULL);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_HORNET_UB, "HORNET-UB", "ALFA NETWORK Hornet-UB",
+	     hornet_ub_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ja76pf.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ja76pf.c
new file mode 100644
index 0000000000..d1fe0f8a26
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ja76pf.c
@@ -0,0 +1,190 @@
+/*
+ *  jjPlus JA76PF board support
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JA76PF_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JA76PF_KEYS_DEBOUNCE_INTERVAL	(3 * JA76PF_KEYS_POLL_INTERVAL)
+
+#define JA76PF_GPIO_I2C_SCL		0
+#define JA76PF_GPIO_I2C_SDA		1
+#define JA76PF_GPIO_LED_1		5
+#define JA76PF_GPIO_LED_2		4
+#define JA76PF_GPIO_LED_3		3
+#define JA76PF_GPIO_BTN_RESET		11
+
+static struct gpio_led ja76pf_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF_GPIO_LED_3,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ja76pf_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data ja76pf_i2c_gpio_data = {
+	.sda_pin	= JA76PF_GPIO_I2C_SDA,
+	.scl_pin	= JA76PF_GPIO_I2C_SCL,
+};
+
+static struct platform_device ja76pf_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &ja76pf_i2c_gpio_data,
+	}
+};
+
+static const char *ja76pf_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ja76pf_flash_data = {
+	.part_probes	= ja76pf_part_probes,
+};
+
+#define JA76PF_WAN_PHYMASK	(1 << 4)
+#define JA76PF_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 < 3))
+#define JA76PF_MDIO_PHYMASK	(JA76PF_LAN_PHYMASK | JA76PF_WAN_PHYMASK)
+
+static void __init ja76pf_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = JA76PF_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = JA76PF_WAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&ja76pf_i2c_gpio_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf_leds_gpio),
+					ja76pf_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ja76pf_gpio_keys),
+					 ja76pf_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF, "JA76PF", "jjPlus JA76PF", ja76pf_init);
+
+#define JA76PF2_GPIO_LED_D2		5
+#define JA76PF2_GPIO_LED_D3		4
+#define JA76PF2_GPIO_LED_D4		3
+#define JA76PF2_GPIO_BTN_RESET		7
+#define JA76PF2_GPIO_BTN_WPS		8
+
+static struct gpio_led ja76pf2_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF2_GPIO_LED_D2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF2_GPIO_LED_D3,
+		.active_low	= 0,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF2_GPIO_LED_D4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ja76pf2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+#define JA76PF2_LAN_PHYMASK	BIT(0)
+#define JA76PF2_WAN_PHYMASK	BIT(4)
+#define JA76PF2_MDIO_PHYMASK	(JA76PF2_LAN_PHYMASK | JA76PF2_WAN_PHYMASK)
+
+static void __init ja76pf2_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF2_MDIO_PHYMASK);
+
+	/* MAC0 is connected to the CPU port of the AR8316 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	/* MAC1 is connected to the PHY4 of the AR8316 switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf2_leds_gpio),
+				 ja76pf2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ja76pf2_gpio_keys),
+					ja76pf2_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF2, "JA76PF2", "jjPlus JA76PF2", ja76pf2_init);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap003.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap003.c
new file mode 100644
index 0000000000..a3c93ccd90
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap003.c
@@ -0,0 +1,95 @@
+/*
+ *  jjPlus JWAP003 board support
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JWAP003_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JWAP003_KEYS_DEBOUNCE_INTERVAL	(3 * JWAP003_KEYS_POLL_INTERVAL)
+
+#define JWAP003_GPIO_WPS	11
+#define JWAP003_GPIO_I2C_SCL	0
+#define JWAP003_GPIO_I2C_SDA	1
+
+static struct gpio_keys_button jwap003_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JWAP003_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JWAP003_GPIO_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data jwap003_i2c_gpio_data = {
+	.sda_pin	= JWAP003_GPIO_I2C_SDA,
+	.scl_pin	= JWAP003_GPIO_I2C_SCL,
+};
+
+static struct platform_device jwap003_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &jwap003_i2c_gpio_data,
+	}
+};
+
+static const char *jwap003_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data jwap003_flash_data = {
+	.part_probes	= jwap003_part_probes,
+};
+
+#define JWAP003_WAN_PHYMASK	BIT(0)
+#define JWAP003_LAN_PHYMASK	BIT(4)
+
+static void __init jwap003_init(void)
+{
+	ath79_register_m25p80(&jwap003_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = JWAP003_WAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = JWAP003_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&jwap003_i2c_gpio_device);
+
+	ath79_register_usb();
+
+	ath79_register_gpio_keys_polled(-1, JWAP003_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(jwap003_gpio_keys),
+					 jwap003_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JWAP003, "JWAP003", "jjPlus JWAP003", jwap003_init);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-jwap230.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap230.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-jwap230.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-jwap230.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lan-turtle.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lan-turtle.c
new file mode 100644
index 0000000000..d2faa2c740
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lan-turtle.c
@@ -0,0 +1,178 @@
+/*
+ *  Hak5 LAN Turtle and Packet Squirrel boards support
+ *
+ *  Copyright (C) 2018 Sebastian Kinne <seb@hak5.org>
+ *  Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define LAN_TURTLE_GPIO_BTN_RESET	11
+#define LAN_TURTLE_GPIO_LED_SYS		13
+
+#define PACKET_SQUIRREL_GPIO_BTN_SW1	18
+#define PACKET_SQUIRREL_GPIO_BTN_SW2	20
+#define PACKET_SQUIRREL_GPIO_BTN_SW3	21
+#define PACKET_SQUIRREL_GPIO_BTN_SW4	24
+#define PACKET_SQUIRREL_GPIO_BTN_RESET	11
+#define PACKET_SQUIRREL_GPIO_LED_B	23
+#define PACKET_SQUIRREL_GPIO_LED_G	22
+#define PACKET_SQUIRREL_GPIO_LED_R	19
+
+#define HAK5_KEYS_POLL_INTERVAL		20 /* msecs */
+#define HAK5_KEYS_DEBOUNCE_INTERVAL	(3 * HAK5_KEYS_POLL_INTERVAL)
+
+static const char *hak5_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data hak5_flash_data = {
+	.part_probes = hak5_part_probes,
+};
+
+/* LAN Turtle */
+static struct gpio_led lan_turtle_leds_gpio[] __initdata = {
+	{
+		.name		= "lan-turtle:orange:system",
+		.gpio		= LAN_TURTLE_GPIO_LED_SYS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button lan_turtle_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= LAN_TURTLE_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+/* Packet Squirrel */
+static struct gpio_led packet_squirrel_leds_gpio[] __initdata = {
+	{
+		.name		= "packet-squirrel:blue:system",
+		.gpio		= PACKET_SQUIRREL_GPIO_LED_B,
+		.active_low	= 1,
+	}, {
+		.name		= "packet-squirrel:green:system",
+		.gpio		= PACKET_SQUIRREL_GPIO_LED_G,
+		.active_low	= 1,
+	}, {
+		.name		= "packet-squirrel:red:system",
+		.gpio		= PACKET_SQUIRREL_GPIO_LED_R,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button packet_squirrel_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= PACKET_SQUIRREL_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw1",
+		.type			= EV_KEY,
+		.code			= BTN_0,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= PACKET_SQUIRREL_GPIO_BTN_SW1,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw2",
+		.type			= EV_KEY,
+		.code			= BTN_1,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= PACKET_SQUIRREL_GPIO_BTN_SW2,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw3",
+		.type			= EV_KEY,
+		.code			= BTN_2,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= PACKET_SQUIRREL_GPIO_BTN_SW3,
+		.active_low		= 1,
+	}, {
+		.desc			= "sw4",
+		.type			= EV_KEY,
+		.code			= BTN_3,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= PACKET_SQUIRREL_GPIO_BTN_SW4,
+		.active_low		= 1,
+	},
+};
+
+static void __init hak5_common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ath79_register_m25p80(&hak5_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy_poll_mask = 0xfe;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	/* GPIO11/12 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_UART_RTS_CTS_EN);
+}
+
+static void __init lan_turtle_setup(void)
+{
+	hak5_common_setup();
+
+	/* GPIO13 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(lan_turtle_leds_gpio),
+				 lan_turtle_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, HAK5_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(lan_turtle_gpio_keys),
+					lan_turtle_gpio_keys);
+}
+
+static void __init packet_squirrel_setup(void)
+{
+	hak5_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(packet_squirrel_leds_gpio),
+				 packet_squirrel_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, HAK5_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(packet_squirrel_gpio_keys),
+					packet_squirrel_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_LAN_TURTLE, "LAN-TURTLE",
+	     "Hak5 LAN Turtle", lan_turtle_setup);
+
+MIPS_MACHINE(ATH79_MACH_PACKET_SQUIRREL, "PACKET-SQUIRREL",
+	     "Hak5 Packet Squirrel", packet_squirrel_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lima.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lima.c
new file mode 100644
index 0000000000..9c784f7921
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-lima.c
@@ -0,0 +1,88 @@
+/*
+ *  8devices Lima board support
+ *
+ *  Copyright (C) 2016 Mantas Pucka <mantas@8devices.com>
+ *  Copyright (C) 2017 Karol Dudek <karoiz@sli.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define LIMA_GPIO_BTN_1_DEFAULT		16
+#define LIMA_KEYS_POLL_INTERVAL		20	/* msecs */
+#define LIMA_KEYS_DEBOUNCE_INTERVAL	(3 * LIMA_KEYS_POLL_INTERVAL)
+
+#define LIMA_ETH_PHYS		(BIT(0) | BIT(1))
+
+#define LIMA_MAC0_OFFSET	0x0000
+#define LIMA_MAC1_OFFSET	0x0006
+
+#define LIMA_CALDATA_OFFSET	0x1000
+#define LIMA_WMAC_MAC_OFFSET	0x0800
+
+static struct gpio_keys_button lima_gpio_keys[] __initdata = {
+	{
+		.desc		= "button1",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = LIMA_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= LIMA_GPIO_BTN_1_DEFAULT,
+		.active_low	= 1,
+	}
+};
+
+static void __init lima_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f080000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_gpio_keys_polled(-1, LIMA_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(lima_gpio_keys),
+					lima_gpio_keys);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + LIMA_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + LIMA_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, ~LIMA_ETH_PHYS);
+
+	ath79_switch_data.phy4_mii_en = 1;
+
+	ath79_switch_data.phy_poll_mask |= BIT(0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_mask = BIT(1);
+	ath79_register_eth(1);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + LIMA_CALDATA_OFFSET,
+			art + LIMA_WMAC_MAC_OFFSET);
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_LIMA, "LIMA", "8devices Lima board", lima_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mc-mac1200r.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mc-mac1200r.c
new file mode 100644
index 0000000000..70051cff47
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mc-mac1200r.c
@@ -0,0 +1,155 @@
+/*
+ *  MERCURY MAC1200R board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Gui Iribarren <gui@altermundi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MAC1200R_GPIO_LED_WLAN2G	13
+#define MAC1200R_GPIO_LED_WLAN5G	17
+#define MAC1200R_GPIO_LED_SYSTEM	14
+#define MAC1200R_GPIO_LED_WPS		11
+#define MAC1200R_GPIO_LED_WAN		12
+#define MAC1200R_GPIO_LED_LAN1		15
+#define MAC1200R_GPIO_LED_LAN2		21
+#define MAC1200R_GPIO_LED_LAN3		22
+#define MAC1200R_GPIO_LED_LAN4		20
+
+#define MAC1200R_GPIO_BTN_WPS		16
+
+#define MAC1200R_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MAC1200R_KEYS_DEBOUNCE_INTERVAL	(3 * MAC1200R_KEYS_POLL_INTERVAL)
+
+#define MAC1200R_MAC0_OFFSET		0
+#define MAC1200R_MAC1_OFFSET		6
+#define MAC1200R_WMAC_CALDATA_OFFSET	0x1000
+#define MAC1200R_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *mac1200r_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data mac1200r_flash_data = {
+	.part_probes	= mac1200r_part_probes,
+};
+
+static struct gpio_led mac1200r_leds_gpio[] __initdata = {
+	{
+		.name		= "mercury:green:wps",
+		.gpio		= MAC1200R_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:system",
+		.gpio		= MAC1200R_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:wlan2g",
+		.gpio		= MAC1200R_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:wlan5g",
+		.gpio		= MAC1200R_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mac1200r_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MAC1200R_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MAC1200R_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+static void __init mac1200r_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&mac1200r_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mac1200r_leds_gpio),
+					mac1200r_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MAC1200R_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mac1200r_gpio_keys),
+					mac1200r_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_wmac_disable_5ghz();
+	ath79_register_wmac(art + MAC1200R_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 1);
+	ap91_pci_init(art + MAC1200R_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 2);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_MC_MAC1200R, "MC-MAC1200R",
+	     "MERCURY MAC1200R",
+	     mac1200r_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr12.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr12.c
new file mode 100644
index 0000000000..5a337e5c9f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr12.c
@@ -0,0 +1,114 @@
+/*
+ *  Cisco Meraki MR12 board support
+ *
+ *  Copyright (C) 2014-2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  Based on Atheros AP96 board support configuration
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define MR12_GPIO_LED_W4_GREEN		14
+#define MR12_GPIO_LED_W3_GREEN		13
+#define MR12_GPIO_LED_W2_GREEN		12
+#define MR12_GPIO_LED_W1_GREEN		11
+
+#define MR12_GPIO_LED_WAN		15
+
+#define MR12_GPIO_LED_POWER_ORANGE		16
+#define MR12_GPIO_LED_POWER_GREEN		17
+
+#define MR12_GPIO_BTN_RESET		8
+#define MR12_KEYS_POLL_INTERVAL		20	/* msecs */
+#define MR12_KEYS_DEBOUNCE_INTERVAL	(3 * MR12_KEYS_POLL_INTERVAL)
+
+#define MR12_WAN_PHYMASK    BIT(4)
+
+#define MR12_CALDATA0_OFFSET            0x21000
+
+static struct gpio_led MR12_leds_gpio[] __initdata = {
+	{
+		.name		= "mr12:green:wan",
+		.gpio		= MR12_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:orange:power",
+		.gpio		= MR12_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:power",
+		.gpio		= MR12_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi4",
+		.gpio		= MR12_GPIO_LED_W4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi3",
+		.gpio		= MR12_GPIO_LED_W3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi2",
+		.gpio		= MR12_GPIO_LED_W2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi1",
+		.gpio		= MR12_GPIO_LED_W1_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button MR12_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR12_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR12_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init MR12_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0xbffd0000);
+	u8 wlan_mac[ETH_ALEN];
+
+	ath79_register_mdio(0,0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = MR12_WAN_PHYMASK;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(MR12_leds_gpio),
+					MR12_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR12_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(MR12_gpio_keys),
+					MR12_gpio_keys);
+
+	ath79_init_mac(wlan_mac, mac, 1);
+	ap91_pci_init(mac + MR12_CALDATA0_OFFSET, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR12, "MR12", "Meraki MR12", MR12_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr16.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr16.c
new file mode 100644
index 0000000000..9da21eab5a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr16.c
@@ -0,0 +1,118 @@
+/*
+ *  Cisco Meraki MR16 board support
+ *
+ *  Copyright (C) 2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  Based on Atheros AP96 board support configuration
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define MR16_GPIO_LED_W4_GREEN		3
+#define MR16_GPIO_LED_W3_GREEN		2
+#define MR16_GPIO_LED_W2_GREEN		1
+#define MR16_GPIO_LED_W1_GREEN		0
+
+#define MR16_GPIO_LED_WAN		4
+
+#define MR16_GPIO_LED_POWER_ORANGE		5
+#define MR16_GPIO_LED_POWER_GREEN		6
+
+#define MR16_GPIO_BTN_RESET		7
+#define MR16_KEYS_POLL_INTERVAL		20	/* msecs */
+#define MR16_KEYS_DEBOUNCE_INTERVAL	(3 * MR16_KEYS_POLL_INTERVAL)
+
+#define MR16_WAN_PHYMASK    BIT(0)
+
+#define MR16_CALDATA0_OFFSET		0x21000
+#define MR16_CALDATA1_OFFSET		0x25000
+
+static struct gpio_led MR16_leds_gpio[] __initdata = {
+	{
+		.name		= "mr16:green:wan",
+		.gpio		= MR16_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:orange:power",
+		.gpio		= MR16_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:power",
+		.gpio		= MR16_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi4",
+		.gpio		= MR16_GPIO_LED_W4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi3",
+		.gpio		= MR16_GPIO_LED_W3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi2",
+		.gpio		= MR16_GPIO_LED_W2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi1",
+		.gpio		= MR16_GPIO_LED_W1_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button MR16_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR16_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR16_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init MR16_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0xbffd0000);
+	u8 wlan0_mac[ETH_ALEN];
+	u8 wlan1_mac[ETH_ALEN];
+
+	ath79_register_mdio(0,0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = MR16_WAN_PHYMASK;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(MR16_leds_gpio),
+					MR16_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR16_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(MR16_gpio_keys),
+					MR16_gpio_keys);
+
+	ath79_init_mac(wlan0_mac, mac, 1);
+	ath79_init_mac(wlan1_mac, mac, 2);
+	ap94_pci_init(mac + MR16_CALDATA0_OFFSET, wlan0_mac,
+		    mac + MR16_CALDATA1_OFFSET, wlan1_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR16, "MR16", "Meraki MR16", MR16_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr1750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr1750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr1750.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr1750.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr18.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr18.c
new file mode 100644
index 0000000000..2d2fb6e84c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr18.c
@@ -0,0 +1,286 @@
+/*
+ *  Cisco Meraki MR18 board support
+ *
+ *  Copyright (C) 2015 Chris Blake <chrisrblake93@gmail.com>
+ *  Copyright (C) 2015 Christian Lamparter <chunkeey@googlemail.com>
+ *  Copyright (C) 2015 Thomas Hebb <tommyhebb@gmail.com>
+ *
+ *  Based on Cisco Meraki GPL Release r23-20150601 MR18 Device Config
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform/ar934x_nfc.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/leds-nu801.h>
+#include <linux/pci.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MR18_GPIO_LED_POWER_WHITE    18
+#define MR18_GPIO_LED_POWER_ORANGE    21
+
+#define MR18_GPIO_BTN_RESET    17
+#define MR18_KEYS_POLL_INTERVAL    20  /* msecs */
+#define MR18_KEYS_DEBOUNCE_INTERVAL  (3 * MR18_KEYS_POLL_INTERVAL)
+
+#define MR18_WAN_PHYADDR    3
+
+/* used for eth calibration */
+#define MR18_OTP_BASE			(AR71XX_APB_BASE + 0x130000)
+#define MR18_OTP_SIZE			(0x2000) /* just a guess */
+#define MR18_OTP_MEM_0_REG		(0x0000)
+#define MR18_OTP_INTF2_REG		(0x1008)
+#define MR18_OTP_STATUS0_REG		(0x1018)
+#define MR18_OTP_STATUS0_EFUSE_VALID	BIT(2)
+
+#define MR18_OTP_STATUS1_REG		(0x101c)
+#define MR18_OTP_LDO_CTRL_REG		(0x1024)
+#define MR18_OTP_LDO_STATUS_REG		(0x102c)
+#define MR18_OTP_LDO_STATUS_POWER_ON	BIT(0)
+
+static struct gpio_led MR18_leds_gpio[] __initdata = {
+	{
+		.name = "mr18:white:power",
+		.gpio = MR18_GPIO_LED_POWER_WHITE,
+		.active_low  = 1,
+	}, {
+		.name = "mr18:orange:power",
+		.gpio = MR18_GPIO_LED_POWER_ORANGE,
+		.active_low  = 0,
+	},
+};
+
+static struct gpio_keys_button MR18_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = MR18_KEYS_DEBOUNCE_INTERVAL,
+		.gpio    = MR18_GPIO_BTN_RESET,
+		.active_low  = 1,
+	},
+};
+
+static struct led_nu801_template tricolor_led_template = {
+	.device_name = "mr18",
+	.name = "tricolor",
+	.num_leds = 1,
+	.cki = 11,
+	.sdi = 12,
+	.lei = -1,
+	.ndelay = 500,
+	.init_brightness = {
+		LED_OFF,
+		LED_OFF,
+		LED_OFF,
+	},
+	.default_trigger = "none",
+	.led_colors = { "red", "green", "blue" },
+};
+
+static struct led_nu801_platform_data tricolor_led_data = {
+	.num_controllers = 1,
+	.template = &tricolor_led_template,
+};
+
+static struct platform_device tricolor_leds = {
+	.name = "leds-nu801",
+	.id = -1,
+	.dev.platform_data = &tricolor_led_data,
+};
+
+static int mr18_extract_sgmii_res_cal(void)
+{
+	void __iomem *base;
+	unsigned int reversed_sgmii_value;
+
+	unsigned int otp_value, otp_per_val, rbias_per, read_data;
+	unsigned int rbias_pos_or_neg;
+	unsigned int sgmii_res_cal_value;
+	int res_cal_val;
+
+	base = ioremap_nocache(MR18_OTP_BASE, MR18_OTP_SIZE);
+	if (!base)
+		return -EIO;
+
+	__raw_writel(0x7d, base + MR18_OTP_INTF2_REG);
+	__raw_writel(0x00, base + MR18_OTP_LDO_CTRL_REG);
+
+	while (__raw_readl(base + MR18_OTP_LDO_STATUS_REG) &
+		MR18_OTP_LDO_STATUS_POWER_ON);
+
+	__raw_readl(base + MR18_OTP_MEM_0_REG + 4);
+
+	while (!(__raw_readl(base + MR18_OTP_STATUS0_REG) &
+		MR18_OTP_STATUS0_EFUSE_VALID));
+
+	read_data = __raw_readl(base + MR18_OTP_STATUS1_REG);
+
+	iounmap(base);
+
+	if (!(read_data & 0x1fff))
+		return -ENODEV;
+
+	if (read_data & 0x00001000)
+		otp_value = (read_data & 0xfc0) >> 6;
+	else
+		otp_value = read_data & 0x3f;
+
+	if (otp_value > 31) {
+		otp_per_val = 63 - otp_value;
+		rbias_pos_or_neg = 1;
+	} else {
+		otp_per_val = otp_value;
+		rbias_pos_or_neg = 0;
+	}
+
+	rbias_per = otp_per_val * 15;
+
+	if (rbias_pos_or_neg == 1)
+		res_cal_val = (rbias_per + 34) / 21;
+	else if (rbias_per > 34)
+		res_cal_val = -((rbias_per - 34) / 21);
+	else
+		res_cal_val = (34 - rbias_per) / 21;
+
+	sgmii_res_cal_value = (8 + res_cal_val) & 0xf;
+
+	reversed_sgmii_value  = (sgmii_res_cal_value & 8) >> 3;
+	reversed_sgmii_value |= (sgmii_res_cal_value & 4) >> 1;
+	reversed_sgmii_value |= (sgmii_res_cal_value & 2) << 1;
+	reversed_sgmii_value |= (sgmii_res_cal_value & 1) << 3;
+	printk(KERN_INFO "SGMII cal value = 0x%x\n", reversed_sgmii_value);
+	return reversed_sgmii_value;
+}
+
+static void mr18_setup_qca955x_eth_serdes_cal(unsigned int sgmii_value)
+{
+	void __iomem *ethbase, *pllbase;
+	u32 t;
+
+	ethbase = ioremap_nocache(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+	pllbase = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	/* To Check the locking of the SGMII PLL */
+	t = __raw_readl(ethbase + QCA955X_GMAC_REG_SGMII_SERDES);
+	t &= ~(QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK <<
+	       QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT);
+	t |= (sgmii_value & QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK) <<
+	     QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT;
+	__raw_writel(t, ethbase + QCA955X_GMAC_REG_SGMII_SERDES);
+
+	__raw_writel(QCA955X_PLL_ETH_SGMII_SERDES_LOCK_DETECT |
+		     QCA955X_PLL_ETH_SGMII_SERDES_PLL_REFCLK |
+		     QCA955X_PLL_ETH_SGMII_SERDES_EN_PLL,
+		     pllbase + QCA955X_PLL_ETH_SGMII_SERDES_REG);
+
+	ath79_device_reset_clear(QCA955X_RESET_SGMII_ANALOG);
+	ath79_device_reset_clear(QCA955X_RESET_SGMII);
+
+	while (!(__raw_readl(ethbase + QCA955X_GMAC_REG_SGMII_SERDES) &
+		QCA955X_SGMII_SERDES_LOCK_DETECT_STATUS));
+
+	iounmap(ethbase);
+	iounmap(pllbase);
+}
+
+static struct ath9k_platform_data pci_main_wifi_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data pci_scan_wifi_data = {
+	.led_pin = -1,
+};
+
+static int mr18_dual_pci_plat_dev_init(struct pci_dev *dev)
+{
+	/* The PCIE devices are attached to different busses but they
+	 * both share the same slot number. Checking the PCI_SLOT vals
+	 * does not work.
+	 */
+	switch (dev->bus->number) {
+	case 0:
+		dev->dev.platform_data = &pci_main_wifi_data;
+		break;
+	case 1:
+		dev->dev.platform_data = &pci_scan_wifi_data;
+		break;
+	}
+
+	return 0;
+}
+
+static void __init mr18_setup(void)
+{
+	int res;
+
+	/* NAND */
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_SOFT_BCH);
+	ath79_register_nfc();
+
+	/* even though, the PHY is connected via RGMII,
+	 * the SGMII/SERDES PLLs need to be calibrated and locked.
+	 * Or else, the PHY won't be working for this platfrom.
+	 *
+	 * Figuring this out took such a long time, that we want to
+	 * point this quirk out, before someone wants to remove it.
+	 */
+	res = mr18_extract_sgmii_res_cal();
+	if (res >= 0) {
+		/* Setup SoC Eth Config */
+		ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN |
+			(3 << QCA955X_ETH_CFG_RXD_DELAY_SHIFT) |
+			(3 << QCA955X_ETH_CFG_RDV_DELAY_SHIFT));
+
+		/* MDIO Interface */
+		ath79_register_mdio(0, 0x0);
+
+		mr18_setup_qca955x_eth_serdes_cal(res);
+
+		/* GMAC0 is connected to an Atheros AR8035-A */
+		ath79_init_mac(ath79_eth0_data.mac_addr, NULL, 0);
+		ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+		ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+		ath79_eth0_data.phy_mask = BIT(MR18_WAN_PHYADDR);
+		ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+		ath79_eth0_pll_data.pll_100 = 0xa0000101;
+		ath79_eth0_pll_data.pll_10 = 0x80001313;
+		ath79_register_eth(0);
+	} else {
+		printk(KERN_ERR "failed to read EFUSE for ethernet cal\n");
+	}
+
+	/* LEDs and Buttons */
+	platform_device_register(&tricolor_leds);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(MR18_leds_gpio),
+				 MR18_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR18_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(MR18_gpio_keys),
+					MR18_gpio_keys);
+
+	/* Clear RTC reset (Needed by SoC WiFi) */
+	ath79_device_reset_clear(QCA955X_RESET_RTC);
+
+	/* WiFi */
+	ath79_register_wmac_simple();
+
+	pci_main_wifi_data.eeprom_name = "pci_wmac0.eeprom";
+	pci_scan_wifi_data.eeprom_name = "pci_wmac1.eeprom";
+	ath79_pci_set_plat_dev_init(mr18_dual_pci_plat_dev_init);
+	ath79_register_pci();
+}
+MIPS_MACHINE(ATH79_MACH_MR18, "MR18", "Meraki MR18", mr18_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr600.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr600.c
new file mode 100644
index 0000000000..701330cebd
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr600.c
@@ -0,0 +1,177 @@
+/*
+ * OpenMesh OM2P board support
+ *
+ * Copyright (C) 2012 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MR600_GPIO_LED_WLAN58		12
+#define MR600_GPIO_LED_WPS			13
+#define MR600_GPIO_LED_POWER			14
+
+#define MR600V2_GPIO_LED_WLAN58_RED		12
+#define MR600V2_GPIO_LED_WPS			13
+#define MR600V2_GPIO_LED_POWER			14
+#define MR600V2_GPIO_LED_WLAN24_GREEN		18
+#define MR600V2_GPIO_LED_WLAN24_YELLOW		19
+#define MR600V2_GPIO_LED_WLAN24_RED		20
+#define MR600V2_GPIO_LED_WLAN58_GREEN		21
+#define MR600V2_GPIO_LED_WLAN58_YELLOW		22
+
+#define MR600_GPIO_BTN_RESET		17
+
+#define MR600_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR600_KEYS_DEBOUNCE_INTERVAL (3 * MR600_KEYS_POLL_INTERVAL)
+
+#define MR600_MAC_OFFSET		0
+#define MR600_WMAC_CALDATA_OFFSET	0x1000
+#define MR600_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led mr600_leds_gpio[] __initdata = {
+	{
+		.name		= "mr600:orange:power",
+		.gpio		= MR600_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:blue:wps",
+		.gpio		= MR600_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan58",
+		.gpio		= MR600_GPIO_LED_WLAN58,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led mr600v2_leds_gpio[] __initdata = {
+	{
+		.name		= "mr600:blue:power",
+		.gpio		= MR600V2_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:blue:wps",
+		.gpio		= MR600V2_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:red:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:yellow:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_YELLOW,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:red:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:yellow:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_YELLOW,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_GREEN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr600_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR600_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init mr600_base_setup(unsigned num_leds, struct gpio_led *leds)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, num_leds, leds);
+	ath79_register_gpio_keys_polled(-1, MR600_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr600_gpio_keys),
+					mr600_gpio_keys);
+
+	ath79_init_mac(mac, art + MR600_MAC_OFFSET, 1);
+	ath79_register_wmac(art + MR600_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(mac, art + MR600_MAC_OFFSET, 8);
+	ap91_pci_init(art + MR600_PCIE_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR600_MAC_OFFSET, 0);
+
+	/* GMAC0 is connected to an external PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+static void __init mr600_setup(void)
+{
+	mr600_base_setup(ARRAY_SIZE(mr600_leds_gpio), mr600_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR600, "MR600", "OpenMesh MR600", mr600_setup);
+
+static void __init mr600v2_setup(void)
+{
+	mr600_base_setup(ARRAY_SIZE(mr600v2_leds_gpio), mr600v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR600V2, "MR600v2", "OpenMesh MR600v2", mr600v2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mr900.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr900.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mr900.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mr900.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n600.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n600.c
new file mode 100644
index 0000000000..a87413d201
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n600.c
@@ -0,0 +1,202 @@
+/*
+ *  WD My Net N600 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_N600_GPIO_LED_WIFI	0
+#define MYNET_N600_GPIO_LED_POWER	11
+#define MYNET_N600_GPIO_LED_INTERNET	12
+#define MYNET_N600_GPIO_LED_WPS		13
+
+#define MYNET_N600_GPIO_LED_LAN1	4
+#define MYNET_N600_GPIO_LED_LAN2	3
+#define MYNET_N600_GPIO_LED_LAN3	2
+#define MYNET_N600_GPIO_LED_LAN4	1
+
+#define MYNET_N600_GPIO_BTN_RESET	16
+#define MYNET_N600_GPIO_BTN_WPS		17
+
+#define MYNET_N600_GPIO_EXTERNAL_LNA0	14
+#define MYNET_N600_GPIO_EXTERNAL_LNA1	15
+
+#define MYNET_N600_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N600_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N600_KEYS_POLL_INTERVAL)
+
+#define MYNET_N600_MAC0_OFFSET		0
+#define MYNET_N600_MAC1_OFFSET		6
+#define MYNET_N600_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N600_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N600_NVRAM_ADDR		0x1f058010
+#define MYNET_N600_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n600_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N600_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N600_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N600_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N600_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:green:lan1",
+		.gpio		= MYNET_N600_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan2",
+		.gpio		= MYNET_N600_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan3",
+		.gpio		= MYNET_N600_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan4",
+		.gpio		= MYNET_N600_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_n600_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void mynet_n600_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N600_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N600_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+#define MYNET_N600_WAN_PHY_MASK	BIT(0)
+
+static void __init mynet_n600_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_INTERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n600_leds_gpio),
+				 mynet_n600_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_N600_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n600_gpio_keys),
+					mynet_n600_gpio_keys);
+
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N600_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N600_GPIO_EXTERNAL_LNA1);
+
+	mynet_n600_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N600_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n600_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N600_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE |
+				   AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	mynet_n600_get_mac("lanmac=", ath79_eth1_data.mac_addr);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	mynet_n600_get_mac("wanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = MYNET_N600_WAN_PHY_MASK;
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = MYNET_N600_WAN_PHY_MASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N600, "MYNET-N600", "WD My Net N600",
+	     mynet_n600_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-n750.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-rext.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mynet-rext.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w04nu.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w04nu.c
new file mode 100644
index 0000000000..c2460ce33c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w04nu.c
@@ -0,0 +1,124 @@
+/*
+ *  Planex MZK-W04NU board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W04NU_GPIO_LED_USB		0
+#define MZK_W04NU_GPIO_LED_STATUS	1
+#define MZK_W04NU_GPIO_LED_WPS		3
+#define MZK_W04NU_GPIO_LED_WLAN		6
+#define MZK_W04NU_GPIO_LED_AP		15
+#define MZK_W04NU_GPIO_LED_ROUTER	16
+
+#define MZK_W04NU_GPIO_BTN_APROUTER	5
+#define MZK_W04NU_GPIO_BTN_WPS		12
+#define MZK_W04NU_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W04NU_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W04NU_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W04NU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:usb",
+		.gpio		= MZK_W04NU_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:ap",
+		.gpio		= MZK_W04NU_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:router",
+		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button mzk_w04nu_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W04NU_WAN_PHYMASK	BIT(4)
+#define MZK_W04NU_MDIO_MASK	(~MZK_W04NU_WAN_PHYMASK)
+
+static void __init mzk_w04nu_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W04NU_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
+				 mzk_w04nu_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W04NU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w04nu_gpio_keys),
+					mzk_w04nu_gpio_keys);
+	ath79_register_usb();
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
+	     mzk_w04nu_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w300nh.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w300nh.c
new file mode 100644
index 0000000000..8c40365283
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-mzk-w300nh.c
@@ -0,0 +1,115 @@
+/*
+ *  Planex MZK-W300NH board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W300NH_GPIO_LED_STATUS	1
+#define MZK_W300NH_GPIO_LED_WPS		3
+#define MZK_W300NH_GPIO_LED_WLAN	6
+#define MZK_W300NH_GPIO_LED_AP_GREEN	15
+#define MZK_W300NH_GPIO_LED_AP_AMBER	16
+
+#define MZK_W300NH_GPIO_BTN_APROUTER	5
+#define MZK_W300NH_GPIO_BTN_WPS		12
+#define MZK_W300NH_GPIO_BTN_RESET	21
+
+#define MZK_W300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W300NH_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W300NH_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W300NH_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_GREEN,
+	}, {
+		.name		= "planex:amber:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_AMBER,
+	}
+};
+
+static struct gpio_keys_button mzk_w300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W300NH_WAN_PHYMASK	BIT(4)
+#define MZK_W300NH_MDIO_MASK	(~MZK_W300NH_WAN_PHYMASK)
+
+static void __init mzk_w300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W300NH_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
+				 mzk_w300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W300NH_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w300nh_gpio_keys),
+					mzk_w300nh_gpio_keys);
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
+	     mzk_w300nh_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-n5q.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-n5q.c
new file mode 100644
index 0000000000..895fc32933
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-n5q.c
@@ -0,0 +1,132 @@
+/*
+ * ALFA Network N5Q board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define N5Q_GPIO_LED_LAN	19
+#define N5Q_GPIO_LED_SIGNAL1	0
+#define N5Q_GPIO_LED_SIGNAL2	1
+#define N5Q_GPIO_LED_SIGNAL3	2
+#define N5Q_GPIO_LED_SIGNAL4	3
+#define N5Q_GPIO_LED_WAN	18
+#define N5Q_GPIO_LED_WLAN	12
+
+#define N5Q_GPIO_WDT_EN		16
+#define N5Q_GPIO_WDT_IN		17
+
+#define N5Q_GPIO_BTN_RESET	11
+
+#define N5Q_MAC0_OFFSET		0
+#define N5Q_MAC1_OFFSET		6
+#define N5Q_WMAC_CALDATA_OFFSET	0x1000
+
+#define N5Q_KEYS_POLL_INTERVAL		20
+#define N5Q_KEYS_DEBOUNCE_INTERVAL	(3 * N5Q_KEYS_POLL_INTERVAL)
+
+static struct gpio_led n5q_leds_gpio[] __initdata = {
+	{
+		.name		= "n5q:green:lan",
+		.gpio		= N5Q_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:red:signal1",
+		.gpio		= N5Q_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:orange:signal2",
+		.gpio		= N5Q_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:green:signal3",
+		.gpio		= N5Q_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:green:signal4",
+		.gpio		= N5Q_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:green:wan",
+		.gpio		= N5Q_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "n5q:green:wlan",
+		.gpio		= N5Q_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button n5q_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= N5Q_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= N5Q_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static void __init n5q_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f070000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xf7;
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + N5Q_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + N5Q_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(n5q_leds_gpio),
+				 n5q_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, N5Q_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(n5q_gpio_keys),
+					n5q_gpio_keys);
+
+	gpio_request_one(N5Q_GPIO_WDT_IN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT input");
+
+	gpio_request_one(N5Q_GPIO_WDT_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT enable");
+
+	ath79_register_wmac(art + N5Q_WMAC_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_N5Q, "N5Q", "ALFA Network N5Q", n5q_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg460n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg460n.c
new file mode 100644
index 0000000000..ca007779ec
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg460n.c
@@ -0,0 +1,220 @@
+/*
+ *  Zyxel NBG 460N/550N/550NH board support
+ *
+ *  Copyright (C) 2010 Michael Kurz <michi.kurz@googlemail.com>
+ *
+ *  based on mach-tl-wr1043nd.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* LEDs */
+#define NBG460N_GPIO_LED_WPS		3
+#define NBG460N_GPIO_LED_WAN		6
+#define NBG460N_GPIO_LED_POWER		14
+#define NBG460N_GPIO_LED_WLAN		15
+
+/* Buttons */
+#define NBG460N_GPIO_BTN_WPS		12
+#define NBG460N_GPIO_BTN_RESET		21
+
+#define NBG460N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG460N_KEYS_DEBOUNCE_INTERVAL	(3 * NBG460N_KEYS_POLL_INTERVAL)
+
+/* RTC chip PCF8563 I2C interface */
+#define NBG460N_GPIO_PCF8563_SDA	8
+#define NBG460N_GPIO_PCF8563_SCK	7
+
+/* Switch configuration I2C interface */
+#define NBG460N_GPIO_RTL8366_SDA	16
+#define NBG460N_GPIO_RTL8366_SCK	18
+
+static struct mtd_partition nbg460n_partitions[] = {
+	{
+		.name		= "Bootbase",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "U-Boot Config",
+		.offset		= 0x010000,
+		.size		= 0x030000,
+	}, {
+		.name		= "U-Boot",
+		.offset		= 0x040000,
+		.size		= 0x030000,
+	}, {
+		.name		= "linux",
+		.offset		= 0x070000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x150000,
+		.size		= 0x2a0000,
+	}, {
+		.name		= "CalibData",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x070000,
+		.size		= 0x380000,
+	}
+};
+
+static struct flash_platform_data nbg460n_flash_data = {
+	.parts		= nbg460n_partitions,
+	.nr_parts       = ARRAY_SIZE(nbg460n_partitions),
+};
+
+static struct gpio_led nbg460n_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg460n:green:power",
+		.gpio		= NBG460N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "nbg460n:green:wps",
+		.gpio		= NBG460N_GPIO_LED_WPS,
+		.active_low	= 0,
+	}, {
+		.name		= "nbg460n:green:wlan",
+		.gpio		= NBG460N_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* Not really for controlling the LED,
+		   when set low the LED blinks uncontrollable  */
+		.name		= "nbg460n:green:wan",
+		.gpio		= NBG460N_GPIO_LED_WAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button nbg460n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data nbg460n_i2c_device_platdata = {
+	.sda_pin	= NBG460N_GPIO_PCF8563_SDA,
+	.scl_pin	= NBG460N_GPIO_PCF8563_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device nbg460n_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+	.dev		= {
+		.platform_data	= &nbg460n_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info nbg460n_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	},
+};
+
+static void nbg460n_i2c_init(void)
+{
+	/* The gpio interface */
+	platform_device_register(&nbg460n_i2c_device);
+	/* I2C devices */
+	i2c_register_board_info(0, nbg460n_i2c_devs,
+				ARRAY_SIZE(nbg460n_i2c_devs));
+}
+
+
+static struct rtl8366_platform_data nbg460n_rtl8366s_data = {
+	.gpio_sda	= NBG460N_GPIO_RTL8366_SDA,
+	.gpio_sck	= NBG460N_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device nbg460n_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &nbg460n_rtl8366s_data,
+	}
+};
+
+static void __init nbg460n_setup(void)
+{
+	/* end of bootloader sector contains mac address */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fc0fff8);
+	/* last sector contains wlan calib data */
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* LAN Port */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	/* WAN Port */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_eth1_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register the switch phy */
+	platform_device_register(&nbg460n_rtl8366s_device);
+
+	/* register flash */
+	ath79_register_m25p80(&nbg460n_flash_data);
+
+	ath79_register_wmac(eeprom, mac);
+
+	/* register RTC chip */
+	nbg460n_i2c_init();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(nbg460n_leds_gpio),
+				 nbg460n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, NBG460N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(nbg460n_gpio_keys),
+					nbg460n_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_NBG460N, "NBG460N", "Zyxel NBG460N/550N/550NH",
+	     nbg460n_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-nbg6716.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg6716.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-nbg6716.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-nbg6716.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om2p.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om2p.c
new file mode 100644
index 0000000000..c888f7d1a8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om2p.c
@@ -0,0 +1,320 @@
+/*
+ *  OpenMesh OM2P support
+ *
+ *  Copyright (C) 2011 Marek Lindner <marek@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OM2P_GPIO_LED_POWER	0
+#define OM2P_GPIO_LED_GREEN	13
+#define OM2P_GPIO_LED_RED	14
+#define OM2P_GPIO_LED_YELLOW	15
+#define OM2P_GPIO_LED_LAN	16
+#define OM2P_GPIO_LED_WAN	17
+#define OM2P_GPIO_BTN_RESET	1
+
+#define OM2P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM2P_KEYS_DEBOUNCE_INTERVAL	(3 * OM2P_KEYS_POLL_INTERVAL)
+
+#define OM2P_WAN_PHYMASK	BIT(4)
+
+#define OM2P_LC_GPIO_LED_POWER	1
+#define OM2P_LC_GPIO_LED_GREEN	15
+#define OM2P_LC_GPIO_LED_RED	16
+#define OM2P_LC_GPIO_LED_YELLOW	0
+#define OM2P_LC_GPIO_LED_LAN	13
+#define OM2P_LC_GPIO_LED_WAN	17
+#define OM2P_LC_GPIO_BTN_RESET	12
+
+#define OM2Pv4_GPIO_LED_POWER	0
+#define OM2Pv4_GPIO_LED_GREEN	2
+#define OM2Pv4_GPIO_LED_RED	4
+#define OM2Pv4_GPIO_LED_YELLOW	3
+#define OM2Pv4_GPIO_LED_LAN	14
+#define OM2Pv4_GPIO_LED_WAN	13
+#define OM2Pv4_GPIO_BTN_RESET	1
+
+#define OM2P_WMAC_CALDATA_OFFSET	0x1000
+
+static struct flash_platform_data om2p_flash_data = {
+	.type = "s25sl12800",
+	.name = "ar7240-nor0",
+};
+
+static struct gpio_led om2p_leds_gpio[] __initdata = {
+	{
+		.name		= "om2p:blue:power",
+		.gpio		= OM2P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:red:wifi",
+		.gpio		= OM2P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:yellow:wifi",
+		.gpio		= OM2P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:green:wifi",
+		.gpio		= OM2P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:lan",
+		.gpio		= OM2P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:wan",
+		.gpio		= OM2P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om2p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM2P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM2P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init om2p_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *ee = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(&om2p_flash_data);
+
+	ath79_register_mdio(0, ~OM2P_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P, "OM2P", "OpenMesh OM2P", om2p_setup);
+
+
+static struct flash_platform_data om2p_lc_flash_data = {
+	.type = "s25sl12800",
+};
+
+static void __init om2p_lc_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc1000);
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_register_m25p80(&om2p_lc_flash_data);
+
+	om2p_leds_gpio[0].gpio = OM2P_LC_GPIO_LED_POWER;
+	om2p_leds_gpio[1].gpio = OM2P_LC_GPIO_LED_RED;
+	om2p_leds_gpio[2].gpio = OM2P_LC_GPIO_LED_YELLOW;
+	om2p_leds_gpio[3].gpio = OM2P_LC_GPIO_LED_GREEN;
+	om2p_leds_gpio[4].gpio = OM2P_LC_GPIO_LED_LAN;
+	om2p_leds_gpio[5].gpio = OM2P_LC_GPIO_LED_WAN;
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	om2p_gpio_keys[0].gpio = OM2P_LC_GPIO_BTN_RESET;
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P_LC, "OM2P-LC", "OpenMesh OM2P LC", om2p_lc_setup);
+MIPS_MACHINE(ATH79_MACH_OM2Pv2, "OM2Pv2", "OpenMesh OM2Pv2", om2p_lc_setup);
+
+static void __init om2p_hs_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM2P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM2P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	/* enable reset button */
+	ath79_gpio_output_select(OM2P_GPIO_BTN_RESET, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	om2p_leds_gpio[4].gpio = OM2P_GPIO_LED_WAN;
+	om2p_leds_gpio[5].gpio = OM2P_GPIO_LED_LAN;
+
+	ath79_register_m25p80(&om2p_lc_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+
+	ath79_register_wmac(art, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P_HS, "OM2P-HS", "OpenMesh OM2P HS", om2p_hs_setup);
+MIPS_MACHINE(ATH79_MACH_OM2P_HSv2, "OM2P-HSv2", "OpenMesh OM2P HSv2", om2p_hs_setup);
+MIPS_MACHINE(ATH79_MACH_OM2P_HSv3, "OM2P-HSv3", "OpenMesh OM2P HSv3", om2p_hs_setup);
+
+static struct flash_platform_data om2pv4_flash_data = {
+	.type = "s25sl12800",
+};
+
+static struct gpio_led om2pv4_leds_gpio[] __initdata = {
+	{
+		.name		= "om2p:blue:power",
+		.gpio		= OM2Pv4_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:red:wifi",
+		.gpio		= OM2Pv4_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:yellow:wifi",
+		.gpio		= OM2Pv4_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:green:wifi",
+		.gpio		= OM2Pv4_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:lan",
+		.gpio		= OM2Pv4_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:wan",
+		.gpio		= OM2Pv4_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om2pv4_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM2P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM2Pv4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init om2pv4_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 wmac[6];
+
+	ath79_register_m25p80(&om2pv4_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2pv4_leds_gpio),
+				 om2pv4_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2pv4_gpio_keys),
+					om2pv4_gpio_keys);
+
+	ath79_init_mac(wmac, art, 0x02);
+	ath79_register_wmac(art + OM2P_WMAC_CALDATA_OFFSET, wmac);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2Pv4, "OM2Pv4", "OpenMesh OM2Pv4", om2pv4_setup);
+MIPS_MACHINE(ATH79_MACH_OM2P_HSv4, "OM2P-HSv4", "OpenMesh OM2P HSv4", om2pv4_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-om5p.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5p.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-om5p.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5p.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-om5pac.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5pac.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-om5pac.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5pac.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-om5pacv2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5pacv2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-om5pacv2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-om5pacv2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-g1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-g1.c
new file mode 100644
index 0000000000..25ca27cba8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-g1.c
@@ -0,0 +1,123 @@
+/*
+ *  OMYlink OMY-G1 board support
+ *
+ *  Copyright (C) 2016 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OMY_G1_GPIO_LED_WLAN	13
+#define OMY_G1_GPIO_LED_WAN	18
+#define OMY_G1_GPIO_LED_LAN	19
+
+#define OMY_G1_GPIO_USB_POWER	4
+
+#define OMY_G1_GPIO_BTN_RESET	17
+
+#define OMY_G1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define OMY_G1_KEYS_DEBOUNCE_INTERVAL (3 * OMY_G1_KEYS_POLL_INTERVAL)
+
+static const char *omy_g1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data omy_g1_flash_data = {
+	.part_probes	= omy_g1_part_probes,
+};
+
+static struct gpio_led omy_g1_leds_gpio[] __initdata = {
+	{
+		.name		= "omy:green:wlan",
+		.gpio		= OMY_G1_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},{
+		.name		= "omy:green:wan",
+		.gpio		= OMY_G1_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "omy:green:lan",
+		.gpio		= OMY_G1_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button omy_g1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OMY_G1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OMY_G1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init omy_g1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_m25p80(&omy_g1_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(omy_g1_leds_gpio),
+				omy_g1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, OMY_G1_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(omy_g1_gpio_keys),
+				omy_g1_gpio_keys);
+
+	ath79_gpio_output_select(OMY_G1_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+	ath79_gpio_output_select(OMY_G1_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	gpio_request_one(OMY_G1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_OMY_G1, "OMY-G1", "OMYlink OMY-G1",
+	     omy_g1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-x1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-x1.c
new file mode 100644
index 0000000000..c99e3d7457
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-omy-x1.c
@@ -0,0 +1,106 @@
+/*
+ *  OMYlink OMY-X1 board support
+ *
+ *  Copyright (C) 2016 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+
+#define OMY_X1_GPIO_LED_POWER	19
+#define OMY_X1_GPIO_LED_WAN	22
+
+#define OMY_X1_GPIO_BTN_RESET	17
+
+#define OMY_X1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define OMY_X1_KEYS_DEBOUNCE_INTERVAL (3 * OMY_X1_KEYS_POLL_INTERVAL)
+
+static const char *omy_x1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data omy_x1_flash_data = {
+	.part_probes	= omy_x1_part_probes,
+};
+
+static struct gpio_led omy_x1_leds_gpio[] __initdata = {
+	{
+		.name		= "omy:green:wan",
+		.gpio		= OMY_X1_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "omy:green:power",
+		.gpio		= OMY_X1_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button omy_x1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OMY_X1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OMY_X1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init omy_x1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_m25p80(&omy_x1_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(omy_x1_leds_gpio),
+				omy_x1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, OMY_X1_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(omy_x1_gpio_keys),
+				omy_x1_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_OMY_X1, "OMY-X1", "OMYlink OMY-X1",
+	     omy_x1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-onion-omega.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-onion-omega.c
new file mode 100644
index 0000000000..c739840377
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-onion-omega.c
@@ -0,0 +1,84 @@
+/*
+ *  Onion Omega board support
+ *
+ *  Copyright (C) 2015 Boken Lin <bl@onion.io>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OMEGA_GPIO_LED_SYSTEM	27
+#define OMEGA_GPIO_BTN_RESET	11
+
+#define OMEGA_GPIO_USB_POWER	8
+
+#define OMEGA_KEYS_POLL_INTERVAL	20  /* msecs */
+#define OMEGA_KEYS_DEBOUNCE_INTERVAL	(3 * OMEGA_KEYS_POLL_INTERVAL)
+
+static const char *omega_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data omega_flash_data = {
+	.part_probes    = omega_part_probes,
+};
+
+static struct gpio_led omega_leds_gpio[] __initdata = {
+	{
+		.name       = "onion:amber:system",
+		.gpio       = OMEGA_GPIO_LED_SYSTEM,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button omega_gpio_keys[] __initdata = {
+	{
+		.desc       = "reset",
+		.type       = EV_KEY,
+		.code       = KEY_RESTART,
+		.debounce_interval = OMEGA_KEYS_DEBOUNCE_INTERVAL,
+		.gpio       = OMEGA_GPIO_BTN_RESET,
+		.active_low = 0,
+	}
+};
+
+static void __init onion_omega_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&omega_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(omega_leds_gpio),
+				omega_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OMEGA_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(omega_gpio_keys),
+					omega_gpio_keys);
+
+	gpio_request_one(OMEGA_GPIO_USB_POWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ONION_OMEGA, "ONION-OMEGA", "Onion Omega", onion_omega_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pb42.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pb42.c
new file mode 100644
index 0000000000..3a350e90a1
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pb42.c
@@ -0,0 +1,83 @@
+/*
+ *  Atheros PB42 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define PB42_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB42_KEYS_DEBOUNCE_INTERVAL	(3 * PB42_KEYS_POLL_INTERVAL)
+
+#define PB42_GPIO_BTN_SW4	8
+#define PB42_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb42_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static const char *pb42_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data pb42_flash_data = {
+	.part_probes	= pb42_part_probes,
+};
+
+#define PB42_WAN_PHYMASK	BIT(20)
+#define PB42_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+#define PB42_MDIO_PHYMASK	(PB42_LAN_PHYMASK | PB42_WAN_PHYMASK)
+
+static void __init pb42_init(void)
+{
+	ath79_register_m25p80(&pb42_flash_data);
+
+	ath79_register_mdio(0, ~PB42_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = PB42_WAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_gpio_keys_polled(-1, PB42_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(pb42_gpio_keys),
+					pb42_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_PB42, "PB42", "Atheros PB42", pb42_init);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pqi-air-pen.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pqi-air-pen.c
new file mode 100644
index 0000000000..56769bfb61
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-pqi-air-pen.c
@@ -0,0 +1,99 @@
+/*
+ *  PQI Air Pen stick support
+ *
+ *  Copyright (C) 2016 YuheiOKAWA <tochiro.srchack@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define PQI_AIR_PEN_GPIO_LED_WLAN		0
+#define PQI_AIR_PEN_GPIO_LED_WPS		23
+
+#define PQI_AIR_PEN_GPIO_BTN_WPS		22
+#define PQI_AIR_PEN_GPIO_BTN_RESET		12
+
+#define PQI_AIR_PEN_KEYS_POLL_INTERVAL		20 /* msecs */
+#define PQI_AIR_PEN_KEYS_DEBOUNCE_INTERVAL	(3 * PQI_AIR_PEN_KEYS_POLL_INTERVAL)
+
+#define PQI_AIR_PEN_WMAC_CALDATA_OFFSET		0x1000
+#define PQI_AIR_PEN_LAN_MAC_OFFSET		0x1002
+#define PQI_AIR_PEN_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led pqi_air_pen_leds_gpio[] __initdata = {
+	{
+		.name = "pqi-air-pen:blue:wlan",
+		.gpio = PQI_AIR_PEN_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "pqi-air-pen:blue:wps",
+		.gpio = PQI_AIR_PEN_GPIO_LED_WPS,
+		.active_low = 0,
+	},
+};
+
+static struct gpio_keys_button pqi_air_pen_gpio_keys[] __initdata = {
+	{
+		.desc = "wps",
+		.type = EV_KEY,
+		.code = KEY_WPS_BUTTON,
+		.debounce_interval = PQI_AIR_PEN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = PQI_AIR_PEN_GPIO_BTN_WPS,
+		.active_low = 0,
+	},
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = PQI_AIR_PEN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = PQI_AIR_PEN_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init pqi_air_pen_setup(void)
+{
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x9f050000);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + PQI_AIR_PEN_WMAC_CALDATA_OFFSET, art + PQI_AIR_PEN_WMAC_MAC_OFFSET);
+
+	/* false PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(pqi_air_pen_leds_gpio),
+				 pqi_air_pen_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, PQI_AIR_PEN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(pqi_air_pen_gpio_keys),
+					pqi_air_pen_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+	
+	/* register eth0 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + PQI_AIR_PEN_LAN_MAC_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_PQI_AIR_PEN, "PQI-AIR-PEN", "PQI Air Pen",pqi_air_pen_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-qihoo-c301.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-qihoo-c301.c
new file mode 100644
index 0000000000..a682f35e2c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-qihoo-c301.c
@@ -0,0 +1,166 @@
+/*
+ *  Qihoo 360 C301 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define QIHOO_C301_GPIO_LED_STATUS_GREEN	0
+#define QIHOO_C301_GPIO_LED_STATUS_RED		11
+
+#define QIHOO_C301_GPIO_LED_WAN			1
+#define QIHOO_C301_GPIO_LED_LAN1		2
+#define QIHOO_C301_GPIO_LED_LAN2		3
+#define QIHOO_C301_GPIO_ETH_LEN_EN		18
+
+#define QIHOO_C301_GPIO_BTN_RESET		16
+
+#define QIHOO_C301_GPIO_USB_POWER		19
+
+#define QIHOO_C301_GPIO_SPI_CS1			12
+
+#define QIHOO_C301_GPIO_EXTERNAL_LNA0		14
+#define QIHOO_C301_GPIO_EXTERNAL_LNA1		15
+
+#define QIHOO_C301_KEYS_POLL_INTERVAL		20	/* msecs */
+#define QIHOO_C301_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * QIHOO_C301_KEYS_POLL_INTERVAL)
+
+#define QIHOO_C301_WMAC_CALDATA_OFFSET		0x1000
+
+#define QIHOO_C301_NVRAM_ADDR			0x1f058010
+#define QIHOO_C301_NVRAM_SIZE			0x7ff0
+
+static struct gpio_led qihoo_c301_leds_gpio[] __initdata = {
+	{
+		.name		= "qihoo:green:status",
+		.gpio		= QIHOO_C301_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "qihoo:red:status",
+		.gpio		= QIHOO_C301_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button qihoo_c301_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = QIHOO_C301_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= QIHOO_C301_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct flash_platform_data flash __initdata = {NULL, NULL, 0};
+
+static void qihoo_c301_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(QIHOO_C301_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, QIHOO_C301_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init qihoo_c301_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80_multi(&flash);
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+
+	ath79_gpio_output_select(QIHOO_C301_GPIO_SPI_CS1,
+				 AR934X_GPIO_OUT_SPI_CS1);
+
+	gpio_request_one(QIHOO_C301_GPIO_ETH_LEN_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "Ethernet LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(qihoo_c301_leds_gpio),
+				 qihoo_c301_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, QIHOO_C301_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(qihoo_c301_gpio_keys),
+					qihoo_c301_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, QIHOO_C301_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, QIHOO_C301_GPIO_EXTERNAL_LNA1);
+
+	qihoo_c301_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + QIHOO_C301_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_pci();
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE |
+				   AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	qihoo_c301_get_mac("lanmac=", ath79_eth1_data.mac_addr);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	qihoo_c301_get_mac("wanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	gpio_request_one(QIHOO_C301_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_QIHOO_C301, "QIHOO-C301", "Qihoo 360 C301",
+	     qihoo_c301_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r36a.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r36a.c
new file mode 100644
index 0000000000..b3493e2c42
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r36a.c
@@ -0,0 +1,140 @@
+/*
+ * ALFA Network R36A board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define R36A_GPIO_LED_LAN	4
+#define R36A_GPIO_LED_STATUS	14
+#define R36A_GPIO_LED_USB	12
+#define R36A_GPIO_LED_WAN	16
+#define R36A_GPIO_LED_WLAN	15
+
+#define R36A_GPIO_WDT_EN	1
+#define R36A_GPIO_WDT_IN	0
+#define R36A_GPIO_USB_PWR	3
+
+#define R36A_GPIO_BTN_RESET	2
+#define R36A_GPIO_BTN_RFKILL	17
+
+#define R36A_KEYS_POLL_INTERVAL		20
+#define R36A_KEYS_DEBOUNCE_INTERVAL	(3 * R36A_KEYS_POLL_INTERVAL)
+
+#define R36A_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led r36a_leds_gpio[] __initdata = {
+	{
+		.name		= "r36a:blue:lan",
+		.gpio		= R36A_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "r36a:blue:status",
+		.gpio		= R36A_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "r36a:blue:usb",
+		.gpio		= R36A_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "r36a:blue:wan",
+		.gpio		= R36A_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "r36a:blue:wlan",
+		.gpio		= R36A_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button r36a_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= R36A_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= R36A_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "rfkill",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= R36A_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= R36A_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+};
+
+static void __init r36a_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f070000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xf7;
+
+	/* LAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+	ath79_register_eth(1);
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(r36a_leds_gpio),
+				 r36a_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, R36A_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(r36a_gpio_keys),
+					r36a_gpio_keys);
+
+	gpio_request_one(R36A_GPIO_WDT_IN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT input");
+
+	gpio_request_one(R36A_GPIO_WDT_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT enable");
+
+	gpio_request_one(R36A_GPIO_USB_PWR,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_wmac(art + R36A_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_R36A, "R36A", "ALFA Network R36A", r36a_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r602n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r602n.c
new file mode 100644
index 0000000000..4aef0a932a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r602n.c
@@ -0,0 +1,213 @@
+/*
+ * P&W (Shenzhen Progress&Win Technologies) R602N and CPE505N boards support
+ *
+ * Copyright (C) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * Based on mach-zbt-we1526.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define PW_GPIO_BTN_RESET	17
+
+#define PW_KEYS_POLL_INTERVAL		20 /* msecs */
+#define PW_KEYS_DEBOUNCE_INTERVAL	(3 * PW_KEYS_POLL_INTERVAL)
+
+#define PW_MAC0_OFFSET		0x0
+#define PW_MAC1_OFFSET		0x6
+#define PW_WMAC_CALDATA_OFFSET	0x1000
+
+/* CPE505N GPIO LEDs */
+#define CPE505N_GPIO_LED_DIAG	12
+#define CPE505N_GPIO_LED_LAN	11
+#define CPE505N_GPIO_LED_STATUS	14
+#define CPE505N_GPIO_LED_WAN	4
+#define CPE505N_GPIO_LED_WLAN	15
+
+static struct gpio_led cpe505n_leds_gpio[] __initdata = {
+	{
+		.name		= "cpe505n:red:diag",
+		.gpio		= CPE505N_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "cpe505n:green:lan",
+		.gpio		= CPE505N_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "cpe505n:green:status",
+		.gpio		= CPE505N_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "cpe505n:green:wan",
+		.gpio		= CPE505N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "cpe505n:blue:wlan",
+		.gpio		= CPE505N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init cpe505n_gpio_setup(void)
+{
+	/* For LED on GPIO4 */
+	ath79_gpio_function_disable(AR934X_GPIO_FUNC_CLK_OBS4_EN);
+	ath79_gpio_output_select(CPE505N_GPIO_LED_WAN, 0);
+
+	ath79_gpio_direction_select(CPE505N_GPIO_LED_DIAG, true);
+	ath79_gpio_direction_select(CPE505N_GPIO_LED_LAN, true);
+	ath79_gpio_direction_select(CPE505N_GPIO_LED_STATUS, true);
+	ath79_gpio_direction_select(CPE505N_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(CPE505N_GPIO_LED_WLAN, true);
+
+	/* Mute LEDs */
+	gpio_set_value(CPE505N_GPIO_LED_DIAG, 1);
+	gpio_set_value(CPE505N_GPIO_LED_LAN, 1);
+	gpio_set_value(CPE505N_GPIO_LED_STATUS, 1);
+	gpio_set_value(CPE505N_GPIO_LED_WAN, 1);
+	gpio_set_value(CPE505N_GPIO_LED_WLAN, 1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe505n_leds_gpio),
+				 cpe505n_leds_gpio);
+}
+
+/* R602N GPIO LEDs */
+#define R602N_GPIO_LED_LAN1	16
+#define R602N_GPIO_LED_LAN2	15
+#define R602N_GPIO_LED_LAN3	14
+#define R602N_GPIO_LED_LAN4	11
+#define R602N_GPIO_LED_WAN	4
+#define R602N_GPIO_LED_WLAN	12
+
+static struct gpio_led r602n_leds_gpio[] __initdata = {
+	{
+		.name		= "r602n:green:lan1",
+		.gpio		= R602N_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "r602n:green:lan2",
+		.gpio		= R602N_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "r602n:green:lan3",
+		.gpio		= R602N_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "r602n:green:lan4",
+		.gpio		= R602N_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "r602n:green:wan",
+		.gpio		= R602N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "r602n:green:wlan",
+		.gpio		= R602N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init r602n_gpio_setup(void)
+{
+	/* For LED on GPIO4 */
+	ath79_gpio_function_disable(AR934X_GPIO_FUNC_CLK_OBS4_EN);
+	ath79_gpio_output_select(R602N_GPIO_LED_WAN, 0);
+
+	ath79_gpio_direction_select(R602N_GPIO_LED_LAN1, true);
+	ath79_gpio_direction_select(R602N_GPIO_LED_LAN2, true);
+	ath79_gpio_direction_select(R602N_GPIO_LED_LAN3, true);
+	ath79_gpio_direction_select(R602N_GPIO_LED_LAN4, true);
+	ath79_gpio_direction_select(R602N_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(R602N_GPIO_LED_WLAN, true);
+
+	/* Mute LEDs */
+	gpio_set_value(R602N_GPIO_LED_LAN1, 1);
+	gpio_set_value(R602N_GPIO_LED_LAN2, 1);
+	gpio_set_value(R602N_GPIO_LED_LAN3, 1);
+	gpio_set_value(R602N_GPIO_LED_LAN4, 1);
+	gpio_set_value(R602N_GPIO_LED_WAN, 1);
+	gpio_set_value(R602N_GPIO_LED_WLAN, 1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(r602n_leds_gpio),
+				 r602n_leds_gpio);
+}
+
+static struct gpio_keys_button pw_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = PW_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PW_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init r602n_cpe505n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + PW_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + PW_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + PW_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_gpio_keys_polled(-1, PW_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(pw_gpio_keys),
+					pw_gpio_keys);
+}
+
+static void __init cpe505n_setup(void)
+{
+	r602n_cpe505n_setup();
+
+	cpe505n_gpio_setup();
+}
+
+static void __init r602n_setup(void)
+{
+	r602n_cpe505n_setup();
+
+	r602n_gpio_setup();
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_CPE505N, "CPE505N", "P&W CPE505N", cpe505n_setup);
+MIPS_MACHINE(ATH79_MACH_R602N, "R602N", "P&W R602N", r602n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r6100.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r6100.c
new file mode 100644
index 0000000000..c1f0e2c400
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-r6100.c
@@ -0,0 +1,146 @@
+/*
+ *  NETGEAR R6100 board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define R6100_GPIO_LED_WLAN		0
+#define R6100_GPIO_LED_USB		11
+#define R6100_GPIO_LED_WAN_GREEN	13
+#define R6100_GPIO_LED_POWER_AMBER	14
+#define R6100_GPIO_LED_WAN_AMBER	15
+#define R6100_GPIO_LED_POWER_GREEN	17
+
+#define R6100_GPIO_BTN_WIRELESS		1
+#define R6100_GPIO_BTN_WPS		3
+#define R6100_GPIO_BTN_RESET		12
+
+#define R6100_GPIO_USB_POWER		16
+
+#define R6100_KEYS_POLL_INTERVAL	20	/* msecs */
+#define R6100_KEYS_DEBOUNCE_INTERVAL	(3 * R6100_KEYS_POLL_INTERVAL)
+
+static struct gpio_led r6100_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= R6100_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:power",
+		.gpio		= R6100_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= R6100_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= R6100_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:usb",
+		.gpio		= R6100_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan",
+		.gpio		= R6100_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button r6100_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_WIRELESS,
+		.active_low	= 0,
+	},
+};
+
+static void __init r6100_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(r6100_leds_gpio),
+				 r6100_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, R6100_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(r6100_gpio_keys),
+					r6100_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	gpio_request_one(R6100_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	ath79_register_usb();
+
+	ath79_register_wmac_simple();
+
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_R6100, "R6100", "NETGEAR R6100",
+	     r6100_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rambutan.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rambutan.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rambutan.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rambutan.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb2011.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb2011.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb2011.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb2011.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb4xx.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb4xx.c
new file mode 100644
index 0000000000..722993ff9b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb4xx.c
@@ -0,0 +1,465 @@
+/*
+ *  MikroTik RouterBOARD 4xx series support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/platform_data/mdio-gpio.h> 
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RB4XX_GPIO_USER_LED	4
+#define RB4XX_GPIO_RESET_SWITCH	7
+
+#define RB4XX_GPIO_CPLD_BASE	32
+#define RB4XX_GPIO_CPLD_LED1	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED1)
+#define RB4XX_GPIO_CPLD_LED2	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED2)
+#define RB4XX_GPIO_CPLD_LED3	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED3)
+#define RB4XX_GPIO_CPLD_LED4	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED4)
+#define RB4XX_GPIO_CPLD_LED5	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED5)
+
+#define RB4XX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB4XX_KEYS_DEBOUNCE_INTERVAL	(3 * RB4XX_KEYS_POLL_INTERVAL)
+
+static struct gpio_led rb4xx_leds_gpio[] __initdata = {
+	{
+		.name		= "rb4xx:yellow:user",
+		.gpio		= RB4XX_GPIO_USER_LED,
+		.active_low	= 0,
+	}, {
+		.name		= "rb4xx:green:led1",
+		.gpio		= RB4XX_GPIO_CPLD_LED1,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led2",
+		.gpio		= RB4XX_GPIO_CPLD_LED2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led3",
+		.gpio		= RB4XX_GPIO_CPLD_LED3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led4",
+		.gpio		= RB4XX_GPIO_CPLD_LED4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led5",
+		.gpio		= RB4XX_GPIO_CPLD_LED5,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button rb4xx_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset_switch",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB4XX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB4XX_GPIO_RESET_SWITCH,
+		.active_low	= 1,
+	}
+};
+
+static struct platform_device rb4xx_nand_device = {
+	.name	= "rb4xx-nand",
+	.id	= -1,
+};
+
+static struct ath79_pci_irq rb4xx_pci_irqs[] __initdata = {
+	{
+		.slot	= 17,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 18,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 18,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 20,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 20,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 21,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 22,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 22,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 23,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 23,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(0),
+	}
+};
+
+static struct mtd_partition rb4xx_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= 0,
+		.size		= 0x0b000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.offset		= 0x0b000,
+		.size		= 0x01000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= 0x0d000,
+		.size		= 0x02000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.offset		= 0x0f000,
+		.size		= 0x01000,
+	}
+};
+
+static struct flash_platform_data rb4xx_flash_data = {
+	.type		= "pm25lv512",
+	.parts		= rb4xx_partitions,
+	.nr_parts	= ARRAY_SIZE(rb4xx_partitions),
+};
+
+static struct rb4xx_cpld_platform_data rb4xx_cpld_data = {
+	.gpio_base	= RB4XX_GPIO_CPLD_BASE,
+};
+
+static struct mmc_spi_platform_data rb4xx_mmc_data = {
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info rb4xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb4xx_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-rb4xx-cpld",
+		.platform_data	= &rb4xx_cpld_data,
+	}
+};
+
+static struct spi_board_info rb4xx_microsd_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb4xx_mmc_data,
+	}
+};
+
+
+static struct resource rb4xx_spi_resources[] = {
+	{
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device rb4xx_spi_device = {
+	.name		= "rb4xx-spi",
+	.id		= -1,
+	.resource	= rb4xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(rb4xx_spi_resources),
+};
+
+static void __init rb4xx_generic_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+					rb4xx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RB4XX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rb4xx_gpio_keys),
+					rb4xx_gpio_keys);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+}
+
+static void __init rb411_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, 0xfffffffc);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00000003;
+
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411, "411", "MikroTik RouterBOARD 411/A/AH",
+	     rb411_setup);
+
+static void __init rb411u_setup(void)
+{
+	rb411_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
+	     rb411u_setup);
+
+#define RB433_LAN_PHYMASK	BIT(0)
+#define RB433_WAN_PHYMASK	BIT(4)
+#define RB433_MDIO_PHYMASK	(RB433_LAN_PHYMASK | RB433_WAN_PHYMASK)
+
+static void __init rb433_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, ~RB433_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433, "433", "MikroTik RouterBOARD 433/AH",
+	     rb433_setup);
+
+static void __init rb433u_setup(void)
+{
+	rb433_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
+	     rb433u_setup);
+
+static void __init rb435g_setup(void)
+{
+	rb4xx_generic_setup();
+
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, ~RB433_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_435G, "435G", "MikroTik RouterBOARD 435G",
+	     rb435g_setup);
+
+#define RB450_LAN_PHYMASK	BIT(0)
+#define RB450_WAN_PHYMASK	BIT(4)
+#define RB450_MDIO_PHYMASK	(RB450_LAN_PHYMASK | RB450_WAN_PHYMASK)
+
+static void __init rb450_generic_setup(int gige)
+{
+	rb4xx_generic_setup();
+	ath79_register_mdio(0, ~RB450_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB450_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB450_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+}
+
+static void __init rb450_setup(void)
+{
+	rb450_generic_setup(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
+	     rb450_setup);
+
+static void __init rb450g_setup(void)
+{
+	rb450_generic_setup(1);
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
+	     rb450g_setup);
+
+static void __init rb493_setup(void)
+{
+	rb4xx_generic_setup();
+
+	ath79_register_mdio(0, 0x3fffff00);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x00000001;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
+	     rb493_setup);
+
+#define RB493G_GPIO_MDIO_MDC		7
+#define RB493G_GPIO_MDIO_DATA		8
+
+#define RB493G_MDIO_PHYMASK		BIT(0)
+
+static struct mdio_gpio_platform_data rb493g_mdio_data = {
+	.mdc		= RB493G_GPIO_MDIO_MDC,
+	.mdio		= RB493G_GPIO_MDIO_DATA,
+
+	.phy_mask	= ~RB493G_MDIO_PHYMASK,
+};
+
+static struct platform_device rb493g_mdio_device = {
+	.name 		= "mdio-gpio",
+	.id 		= -1,
+	.dev 		= {
+		.platform_data	= &rb493g_mdio_data,
+	},
+};
+
+static void __init rb493g_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+				    rb4xx_leds_gpio);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+
+	ath79_register_mdio(0, ~RB493G_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.mii_bus_dev = &rb493g_mdio_device.dev;
+	ath79_eth1_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	platform_device_register(&rb493g_mdio_device);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493G, "493G", "MikroTik RouterBOARD 493G",
+	     rb493g_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb750.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb750.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb91x.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb91x.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb91x.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb91x.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb922.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb922.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb922.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb922.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rb95x.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb95x.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rb95x.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rb95x.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-rbspi.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbspi.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-rbspi.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbspi.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbsxtlite.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbsxtlite.c
new file mode 100644
index 0000000000..d2edfc9c71
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rbsxtlite.c
@@ -0,0 +1,297 @@
+/*
+ *  MikroTik RouterBOARD SXT Lite support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Vyacheslav Adamanov <adamanov@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "sxtlite: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/rle.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "routerboot.h"
+#include <linux/ar8216_platform.h>
+
+#define SXTLITE_GPIO_NAND_NCE  14
+#define SXTLITE_GPIO_LED_USER 3
+#define SXTLITE_GPIO_LED_1 13
+#define SXTLITE_GPIO_LED_2 12
+#define SXTLITE_GPIO_LED_3 4
+#define SXTLITE_GPIO_LED_4 21
+#define SXTLITE_GPIO_LED_5 18
+#define SXTLITE_GPIO_LED_POWER 11
+
+#define SXTLITE_GPIO_BUZZER 19
+
+#define SXTLITE_GPIO_BTN_RESET 15
+
+#define SXTLITE_KEYS_POLL_INTERVAL 20
+#define SXTLITE_KEYS_DEBOUNCE_INTERVAL (3 * SXTLITE_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition rbsxtlite_nand_partitions[] = {
+	{
+		.name   = "booter",
+		.offset = 0,
+		.size   = (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name   = "kernel",
+		.offset = (256 * 1024),
+		.size   = (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name   = "ubi",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = MTDPART_SIZ_FULL,
+	},
+};
+
+static struct gpio_led rbsxtlite_leds_gpio[] __initdata = {
+	{
+		.name		=	"rb:green:user",
+		.gpio		=	SXTLITE_GPIO_LED_USER,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led1",
+		.gpio		=	SXTLITE_GPIO_LED_1,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led2",
+		.gpio		=	SXTLITE_GPIO_LED_2,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led3",
+		.gpio		=	SXTLITE_GPIO_LED_3,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led4",
+		.gpio		=	SXTLITE_GPIO_LED_4,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led5",
+		.gpio		=	SXTLITE_GPIO_LED_5,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:power",
+		.gpio		=	SXTLITE_GPIO_LED_POWER,
+		.default_state	=	LEDS_GPIO_DEFSTATE_KEEP,
+	},
+};
+
+static struct gpio_keys_button rbsxtlite_gpio_keys[] __initdata = {
+	{
+		.desc		=	"Reset button",
+		.type		=	EV_KEY,
+		.code		=	KEY_RESTART,
+		.debounce_interval	=	SXTLITE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		=	SXTLITE_GPIO_BTN_RESET,
+		.active_low	=	0,
+	},
+};
+
+static int __init rbsxtlite_rbinfo_init(void)
+{
+	const struct rb_info *info;
+
+	info = rb_init_info((void *)(KSEG1ADDR(AR71XX_SPI_BASE)), 0x10000);
+	if (!info)
+		return -EINVAL;
+	return 0;
+
+}
+
+void __init rbsxtlite_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 1);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rbsxtlite_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(SXTLITE_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(SXTLITE_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout rbsxtlite_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos	 = { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rbsxtlite_ooblayout_ecc(struct mtd_info *mtd, int section,
+				   struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rbsxtlite_ooblayout_free(struct mtd_info *mtd, int section,
+				    struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rbsxtlite_nand_ecclayout_ops = {
+	.ecc = rbsxtlite_ooblayout_ecc,
+	.free = rbsxtlite_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int rbsxtlite_nand_scan_fixup(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct nand_chip *chip = mtd->priv;
+#endif
+
+	if (mtd->writesize == 512) {
+		/*
+		* Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		* will not be able to find the kernel that we load.
+		*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		chip->ecc.layout = &rbsxtlite_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rbsxtlite_nand_ecclayout_ops);
+#endif
+	}
+
+	return 0;
+}
+
+void __init rbsxtlite_gpio_init(void)
+{
+	gpio_request_one(SXTLITE_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+}
+
+void __init rbsxtlite_nand_init(void)
+{
+	ath79_nfc_set_scan_fixup(rbsxtlite_nand_scan_fixup);
+	ath79_nfc_set_parts(rbsxtlite_nand_partitions,
+			   ARRAY_SIZE(rbsxtlite_nand_partitions));
+	ath79_nfc_set_select_chip(rbsxtlite_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+
+static void __init rbsxtlite_setup(void)
+{
+	if(rbsxtlite_rbinfo_init())
+		return;
+	rbsxtlite_nand_init();
+	rbsxtlite_wlan_init();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbsxtlite_leds_gpio),
+				 rbsxtlite_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, SXTLITE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rbsxtlite_gpio_keys),
+					rbsxtlite_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is left unused */
+
+	/* GMAC1 is connected to MAC0 on the internal switch */
+	/* The ethernet port connects to PHY P0, which connects to MAC1
+	   on the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+
+}
+
+
+MIPS_MACHINE(ATH79_MACH_RB_SXTLITE2ND, "sxt2n", "MikroTik RouterBOARD SXT Lite2",
+	    rbsxtlite_setup);
+
+MIPS_MACHINE(ATH79_MACH_RB_SXTLITE5ND, "sxt5n", "MikroTik RouterBOARD SXT Lite5",
+	    rbsxtlite_setup);
+
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-re450.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-re450.c
new file mode 100644
index 0000000000..991aa1c9a9
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-re450.c
@@ -0,0 +1,239 @@
+/*
+ * TP-LINK RE355/RE450 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2016 Tal Keren <kooolk@gmail.com>
+ * Copyright (c) 2018 Henryk Heisig <hyniu@o2.pl>
+ * 
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/mdio-gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RE450_GPIO_LED_SYSTEM		12
+#define RE450_GPIO_LED_WLAN2G		13
+#define RE450_GPIO_LED_WLAN5G		14
+#define RE450_GPIO_LED_LAN_DATA		17
+#define RE450_GPIO_LED_JUMPSTART	21
+#define RE450_GPIO_LED_JUMPSTART_RED	22
+#define RE450_GPIO_LED_LAN_LINK		23
+
+#define RE450_GPIO_BTN_RESET		18
+#define RE450_GPIO_BTN_LED		19
+#define RE450_GPIO_BTN_JUMPSTART	20
+
+#define RE450_GPIO_SMI_MDIO		1
+#define RE450_GPIO_SMI_MDC		3
+
+#define RE450_LAN_PHYADDR		4
+
+#define RE450_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RE450_KEYS_DEBOUNCE_INTERVAL (3 * RE450_KEYS_POLL_INTERVAL)
+
+#define RE450_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *tl_re450_part_probes[] = {
+	"cmdlinepart",
+	NULL,
+};
+
+static struct flash_platform_data tl_re450_flash_data = {
+	.part_probes	= tl_re450_part_probes,
+};
+
+static struct gpio_led re355_leds_gpio[] __initdata = {
+	{
+		.name		= "re355:blue:power",
+		.gpio		= RE450_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re355:blue:wlan2g",
+		.gpio		= RE450_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re355:blue:wlan5g",
+		.gpio		= RE450_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re355:blue:wps",
+		.gpio		= RE450_GPIO_LED_JUMPSTART,
+	},
+	{
+		.name		= "re355:red:wps",
+		.gpio		= RE450_GPIO_LED_JUMPSTART_RED,
+	},
+	{
+		.name		= "re355:green:lan_data",
+		.gpio		= RE450_GPIO_LED_LAN_DATA,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re355:green:lan_link",
+		.gpio		= RE450_GPIO_LED_LAN_LINK,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led re450_leds_gpio[] __initdata = {
+	{
+		.name		= "re450:blue:power",
+		.gpio		= RE450_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re450:blue:wlan2g",
+		.gpio		= RE450_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re450:blue:wlan5g",
+		.gpio		= RE450_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re450:blue:wps",
+		.gpio		= RE450_GPIO_LED_JUMPSTART,
+	},
+	{
+		.name		= "re450:red:wps",
+		.gpio		= RE450_GPIO_LED_JUMPSTART_RED,
+	},
+	{
+		.name		= "re450:green:lan_data",
+		.gpio		= RE450_GPIO_LED_LAN_DATA,
+		.active_low	= 1,
+	},
+	{
+		.name		= "re450:green:lan_link",
+		.gpio		= RE450_GPIO_LED_LAN_LINK,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button re450_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = RE450_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RE450_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RE450_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RE450_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Control LED button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = RE450_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RE450_GPIO_BTN_LED,
+		.active_low	= 1,
+	},
+};
+
+static struct mdio_gpio_platform_data re450_mdio = {
+	.mdc		= RE450_GPIO_SMI_MDC,
+	.mdio		= RE450_GPIO_SMI_MDIO,
+	.phy_mask	= ~BIT(RE450_LAN_PHYADDR),
+};
+
+static struct platform_device re450_phy_device = {
+	.name	= "mdio-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &re450_mdio,
+	},
+};
+
+static void __init rex5x_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f610008);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_re450_flash_data);
+	ath79_register_gpio_keys_polled(-1, RE450_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(re450_gpio_keys),
+					re450_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + RE450_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_pci();
+
+	/* MDIO Interface */
+	platform_device_register(&re450_phy_device);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RGMII interface to an Atheros AR8035-A */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &re450_phy_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(RE450_LAN_PHYADDR);
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth0_pll_data.pll_100 = 0xa0000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+	ath79_register_eth(0);
+}
+
+static void __init re355_setup(void)
+{
+	rex5x_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(re355_leds_gpio),
+				 re355_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_RE355, "RE355", "TP-LINK RE355",
+	     re355_setup)
+
+static void __init re450_setup(void)
+{
+	rex5x_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(re450_leds_gpio),
+				 re450_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_RE450, "RE450", "TP-LINK RE450",
+	     re450_setup)
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rme-eg200.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rme-eg200.c
new file mode 100644
index 0000000000..332b0780d0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rme-eg200.c
@@ -0,0 +1,99 @@
+/*
+ * eTactica EG-200 board, based on 8devices Carambola2 module
+ *
+ * Copyright (C) 2015 Karl Palsson <karlp@etactica.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define RME_EG200_GPIO_LED_WLAN			0
+#define RME_EG200_GPIO_LED_ETH0			13
+#define RME_EG200_GPIO_LED_ETACTICA		15
+#define RME_EG200_GPIO_LED_MODBUS		16
+
+#define RME_EG200_GPIO_BTN_RESTORE		11
+
+#define RME_EG200_KEYS_POLL_INTERVAL		20	/* msecs */
+#define RME_EG200_KEYS_DEBOUNCE_INTERVAL	(3 * RME_EG200_KEYS_POLL_INTERVAL)
+
+#define RME_EG200_MAC0_OFFSET			0x0000
+#define RME_EG200_CALDATA_OFFSET		0x1000
+#define RME_EG200_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led rme_eg200_leds_gpio[] __initdata = {
+	{
+		.name		= "eg200:red:wlan",
+		.gpio		= RME_EG200_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "eg200:red:eth0",
+		.gpio		= RME_EG200_GPIO_LED_ETH0,
+		.active_low	= 1,
+	}, {
+		.name		= "eg200:red:etactica",
+		.gpio		= RME_EG200_GPIO_LED_ETACTICA,
+		.active_low	= 0,
+	}, {
+		.name		= "eg200:red:modbus",
+		.gpio		= RME_EG200_GPIO_LED_MODBUS,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button rme_eg200_keys[] __initdata = {
+	{
+		.desc		= "restore button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = RME_EG200_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RME_EG200_GPIO_BTN_RESTORE,
+		.active_low	= 1,
+	},
+};
+
+static void __init rme_eg200_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + RME_EG200_CALDATA_OFFSET,
+			    art + RME_EG200_WMAC_MAC_OFFSET);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + RME_EG200_MAC0_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rme_eg200_leds_gpio),
+				 rme_eg200_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, RME_EG200_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rme_eg200_keys),
+					rme_eg200_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RME_EG200, "RME-EG200", "eTactica EG-200",
+		rme_eg200_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rut9xx.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rut9xx.c
new file mode 100644
index 0000000000..43a2a78c67
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rut9xx.c
@@ -0,0 +1,191 @@
+/*
+ * Teltonika RUT900 series boards support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define RUT9XX_GPIO_LED_LAN1		14
+#define RUT9XX_GPIO_LED_LAN2		13
+#define RUT9XX_GPIO_LED_LAN3		22
+#define RUT9XX_GPIO_LED_WAN		1
+
+#define RUT9XX_PCA9539_GPIO_BASE	32
+#define RUT9XX_PCA9539_GPIO_SIGNAL1	(0 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_SIGNAL2	(1 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_SIGNAL3	(2 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_SIGNAL4	(3 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_SIGNAL5	(4 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_STATUS_R	(5 + RUT9XX_PCA9539_GPIO_BASE)
+#define RUT9XX_PCA9539_GPIO_STATUS_G	(6 + RUT9XX_PCA9539_GPIO_BASE)
+
+#define RUT9XX_GPIO_BTN_RESET		15
+
+#define RUT9XX_GPIO_I2C_SCK		16
+#define RUT9XX_GPIO_I2C_SDA		17
+
+#define RUT9XX_GPIO_EXT_LNA0		2
+
+#define RUT9XX_WMAC_CALDATA_OFFSET	0x1000
+
+#define RUT9XX_KEYS_POLL_INTERVAL	20
+#define RUT9XX_KEYS_DEBOUNCE_INTERVAL	(3 * RUT9XX_KEYS_POLL_INTERVAL)
+
+static struct gpio_led rut900_leds_gpio[] __initdata = {
+	{
+		.name		= "rut900:green:lan1",
+		.gpio		= RUT9XX_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "rut900:green:lan2",
+		.gpio		= RUT9XX_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "rut900:green:lan3",
+		.gpio		= RUT9XX_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "rut900:green:signal1",
+		.gpio		= RUT9XX_PCA9539_GPIO_SIGNAL1,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:signal2",
+		.gpio		= RUT9XX_PCA9539_GPIO_SIGNAL2,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:signal3",
+		.gpio		= RUT9XX_PCA9539_GPIO_SIGNAL3,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:signal4",
+		.gpio		= RUT9XX_PCA9539_GPIO_SIGNAL4,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:signal5",
+		.gpio		= RUT9XX_PCA9539_GPIO_SIGNAL5,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:status",
+		.gpio		= RUT9XX_PCA9539_GPIO_STATUS_G,
+		.active_low	= 0,
+	}, {
+		.name		= "rut900:green:wan",
+		.gpio		= RUT9XX_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "rut900:red:status",
+		.gpio		= RUT9XX_PCA9539_GPIO_STATUS_R,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button rut900_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= RUT9XX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= RUT9XX_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static struct i2c_gpio_platform_data rut900_i2c_gpio_data = {
+	.sda_pin	= RUT9XX_GPIO_I2C_SDA,
+	.scl_pin	= RUT9XX_GPIO_I2C_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device rut900_i2c_device = {
+	.name	= "i2c-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &rut900_i2c_gpio_data,
+	},
+};
+
+static struct pca953x_platform_data rut9xx_pca9539_data = {
+	.gpio_base	= RUT9XX_PCA9539_GPIO_BASE,
+	.irq_base	= -1,
+};
+
+static struct i2c_board_info rut900_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pca9539", 0x74),
+		.platform_data = &rut9xx_pca9539_data,
+	},
+};
+
+static void __init rut900_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f030000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f020000);
+	u8  wlan_mac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xf1;
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	platform_device_register(&rut900_i2c_device);
+	i2c_register_board_info(0, rut900_i2c_devs,
+				ARRAY_SIZE(rut900_i2c_devs));
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rut900_leds_gpio),
+				 rut900_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RUT9XX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rut900_gpio_keys),
+					rut900_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, RUT9XX_GPIO_EXT_LNA0);
+
+	ath79_init_mac(wlan_mac, mac, 2);
+	ath79_register_wmac(art + RUT9XX_WMAC_CALDATA_OFFSET, wlan_mac);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RUT9XX, "RUT900", "Teltonika RUT900", rut900_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rw2458n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rw2458n.c
new file mode 100644
index 0000000000..bb7c2475bd
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-rw2458n.c
@@ -0,0 +1,91 @@
+/*
+ *  Redwave RW2458N support
+ *
+ *  Copyright (C) 2011-2013 Cezary Jackiewicz <cezary@eko.one.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RW2458N_GPIO_LED_D3	1
+#define RW2458N_GPIO_LED_D4	0
+#define RW2458N_GPIO_LED_D5	11
+#define RW2458N_GPIO_LED_D6	7
+#define RW2458N_GPIO_BTN_RESET	12
+
+#define RW2458N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RW2458N_KEYS_DEBOUNCE_INTERVAL	(3 * RW2458N_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button rw2458n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RW2458N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RW2458N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define RW2458N_WAN_PHYMASK	BIT(4)
+
+static struct gpio_led rw2458n_leds_gpio[] __initdata = {
+	{
+		.name		= "rw2458n:green:d3",
+		.gpio		= RW2458N_GPIO_LED_D3,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d4",
+		.gpio		= RW2458N_GPIO_LED_D4,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d5",
+		.gpio		= RW2458N_GPIO_LED_D5,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d6",
+		.gpio		= RW2458N_GPIO_LED_D6,
+		.active_low	= 1,
+	}
+};
+
+static void __init rw2458n_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~RW2458N_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rw2458n_leds_gpio),
+				 rw2458n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RW2458N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rw2458n_gpio_keys),
+					rw2458n_gpio_keys);
+	ath79_register_usb();
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RW2458N, "RW2458N", "Redwave RW2458N",
+	    rw2458n_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-sc1750.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc1750.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-sc1750.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc1750.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-sc300m.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc300m.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-sc300m.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc300m.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-sc450.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc450.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-sc450.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sc450.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-smart-300.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-smart-300.c
new file mode 100644
index 0000000000..2520e960d3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-smart-300.c
@@ -0,0 +1,135 @@
+/*
+ *  NC-LINK SMART-300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SMART_300_GPIO_LED_WLAN		13
+#define SMART_300_GPIO_LED_WAN		18
+#define SMART_300_GPIO_LED_LAN4		19
+#define SMART_300_GPIO_LED_LAN3		12
+#define SMART_300_GPIO_LED_LAN2		21
+#define SMART_300_GPIO_LED_LAN1		20
+#define SMART_300_GPIO_LED_SYSTEM	15
+#define SMART_300_GPIO_LED_POWER	14
+
+#define SMART_300_GPIO_BTN_RESET	17
+#define SMART_300_GPIO_SW_RFKILL	16
+
+#define SMART_300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define SMART_300_KEYS_DEBOUNCE_INTERVAL (3 * SMART_300_KEYS_POLL_INTERVAL)
+
+#define SMART_300_GPIO_MASK        0x007fffff
+
+static const char *smart_300_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data smart_300_flash_data = {
+	.part_probes	= smart_300_part_probes,
+};
+
+static struct gpio_led smart_300_leds_gpio[] __initdata = {
+	{
+		.name		= "nc-link:green:lan1",
+		.gpio		= SMART_300_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan2",
+		.gpio		= SMART_300_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan3",
+		.gpio		= SMART_300_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan4",
+		.gpio		= SMART_300_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:system",
+		.gpio		= SMART_300_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:wan",
+		.gpio		= SMART_300_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:wlan",
+		.gpio		= SMART_300_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button smart_300_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SMART_300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SMART_300_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init smart_300_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(smart_300_leds_gpio),
+				 smart_300_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, SMART_300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(smart_300_gpio_keys),
+					smart_300_gpio_keys);
+
+	ath79_register_m25p80(&smart_300_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+	gpio_request(SMART_300_GPIO_LED_POWER, "power");
+	gpio_direction_output(SMART_300_GPIO_LED_POWER, GPIOF_OUT_INIT_LOW);
+}
+
+MIPS_MACHINE(ATH79_MACH_SMART_300, "SMART-300", "NC-LINK SMART-300",
+	     smart_300_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-som9331.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-som9331.c
new file mode 100644
index 0000000000..eef5bcedc2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-som9331.c
@@ -0,0 +1,125 @@
+/*
+ *  OpenEmbed SOM9331 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  5/27/2016 - Modified by Allan Nick Pedrana <nik9993@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SOM9331_GPIO_LED_WLAN   27
+#define SOM9331_GPIO_LED_SYSTEM 0
+#define SOM9331_GPIO_LED_2  13
+#define SOM9331_GPIO_LED_3  14
+#define SOM9331_GPIO_LED_5  16
+#define SOM9331_GPIO_LED_WAN    SOM9331_GPIO_LED_2
+#define SOM9331_GPIO_LED_LAN1   SOM9331_GPIO_LED_3
+#define SOM9331_GPIO_LED_LAN2   SOM9331_GPIO_LED_5
+#define SOM9331_GPIO_BTN_RESET  11
+
+#define SOM9331_KEYS_POLL_INTERVAL  20  /* msecs */
+#define SOM9331_KEYS_DEBOUNCE_INTERVAL  (3 * SOM9331_KEYS_POLL_INTERVAL)
+
+static const char *som9331_part_probes[] = {
+    "tp-link",
+    NULL,
+};
+
+static struct flash_platform_data som9331_flash_data = {
+    .part_probes    = som9331_part_probes,
+};
+
+static struct gpio_led som9331_leds_gpio[] __initdata = {
+    {
+        .name       = "som9331:red:wlan",
+        .gpio       = SOM9331_GPIO_LED_WLAN,
+        .active_low = 1,
+    },
+    {
+        .name       = "som9331:orange:wan",
+        .gpio       = SOM9331_GPIO_LED_WAN,
+        .active_low = 0,
+    },
+    {
+        .name       = "som9331:orange:lan1",
+        .gpio       = SOM9331_GPIO_LED_LAN1,
+        .active_low = 0,
+    },
+    {
+        .name       = "som9331:orange:lan2",
+        .gpio       = SOM9331_GPIO_LED_LAN2,
+        .active_low = 0,
+    },
+    {
+        .name       = "som9331:blue:system",
+        .gpio       = SOM9331_GPIO_LED_SYSTEM,
+        .active_low = 0,
+    },
+};
+
+static struct gpio_keys_button som9331_gpio_keys[] __initdata = {
+    {
+        .desc       = "reset",
+        .type       = EV_KEY,
+        .code       = KEY_RESTART,
+        .debounce_interval = SOM9331_KEYS_DEBOUNCE_INTERVAL,
+        .gpio       = SOM9331_GPIO_BTN_RESET,
+        .active_low = 0,
+    }
+};
+
+static void __init som9331_setup(void)
+{
+    u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+    u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+    ath79_setup_ar933x_phy4_switch(true, true);
+
+    ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+                    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+                    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+                    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+                    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+    ath79_register_m25p80(&som9331_flash_data);
+    ath79_register_leds_gpio(-1, ARRAY_SIZE(som9331_leds_gpio),
+                 som9331_leds_gpio);
+    ath79_register_gpio_keys_polled(-1, SOM9331_KEYS_POLL_INTERVAL,
+                    ARRAY_SIZE(som9331_gpio_keys),
+                    som9331_gpio_keys);
+
+    ath79_register_usb();
+
+    ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+    ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+    ath79_register_mdio(0, 0x0);
+
+    /* LAN ports */
+    ath79_register_eth(1);
+
+    /* WAN port */
+    ath79_register_eth(0);
+
+    ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_SOM9331, "SOM9331", "OpenEmbed SOM9331", som9331_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-sr3200.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sr3200.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-sr3200.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-sr3200.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-t830.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-t830.c
new file mode 100644
index 0000000000..ffdb2ca533
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-t830.c
@@ -0,0 +1,127 @@
+/*
+ * YunCore T830 board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define T830_GPIO_LED_LAN1	16
+#define T830_GPIO_LED_LAN2	15
+#define T830_GPIO_LED_LAN3	14
+#define T830_GPIO_LED_LAN4	11
+#define T830_GPIO_LED_USB	13
+#define T830_GPIO_LED_WAN	4
+#define T830_GPIO_LED_WLAN	12
+
+#define T830_GPIO_BTN_RESET	17
+
+#define T830_KEYS_POLL_INTERVAL		20 /* msec */
+#define T830_KEYS_DEBOUNCE_INTERVAL	(3 * T830_KEYS_POLL_INTERVAL)
+
+#define T830_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led t830_gpio_leds[] __initdata = {
+	{
+		.name		= "t830:green:lan1",
+		.gpio		= T830_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "t830:green:lan2",
+		.gpio		= T830_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "t830:green:lan3",
+		.gpio		= T830_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "t830:green:lan4",
+		.gpio		= T830_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "t830:green:usb",
+		.gpio		= T830_GPIO_LED_USB,
+		.active_low	= 1,
+		.default_state	= LEDS_GPIO_DEFSTATE_KEEP,
+	}, {
+		.name		= "t830:green:wan",
+		.gpio		= T830_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "t830:green:wlan",
+		.gpio		= T830_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button t830_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= T830_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= T830_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+static void __init t830_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + 6, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				  AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(t830_gpio_leds),
+				 t830_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, T830_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(t830_gpio_keys),
+					t830_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_T830, "T830", "YunCore T830", t830_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tellstick-znet-lite.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tellstick-znet-lite.c
new file mode 100644
index 0000000000..0950d9a99d
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tellstick-znet-lite.c
@@ -0,0 +1,129 @@
+/*
+ *  Telldus TellStick ZNet Lite board support
+ *
+ *  Copyright (C) 2016 Micke Prag <micke.prag@telldus.se>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TELLSTICK_GPIO_LED_SYSTEM	27
+#define TELLSTICK_GPIO_LED_BLUE	0
+#define TELLSTICK_GPIO_LED_RED	14
+#define TELLSTICK_GPIO_LED_GREEN	15
+#define TELLSTICK_GPIO_LED_LAN_GREEN	16
+#define TELLSTICK_GPIO_LED_LAN_ORANGE	17
+
+#define TELLSTICK_GPIO_BTN_RESET	11
+
+#define TELLSTICK_GPIO_RF433_RESET	13
+
+#define TELLSTICK_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TELLSTICK_KEYS_DEBOUNCE_INTERVAL	(3 * TELLSTICK_KEYS_POLL_INTERVAL)
+
+static const char *tellstick_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tellstick_flash_data = {
+	.part_probes	= tellstick_part_probes,
+};
+
+static struct gpio_led tellstick_leds_gpio[] __initdata = {
+	{
+		.name		= "tellstick:white:system",
+		.gpio		= TELLSTICK_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tellstick:blue:status",
+		.gpio		= TELLSTICK_GPIO_LED_BLUE,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tellstick:red:status",
+		.gpio		= TELLSTICK_GPIO_LED_RED,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tellstick:green:status",
+		.gpio		= TELLSTICK_GPIO_LED_GREEN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tellstick:green:lan",
+		.gpio		= TELLSTICK_GPIO_LED_LAN_GREEN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tellstick:orange:lan",
+		.gpio		= TELLSTICK_GPIO_LED_LAN_ORANGE,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tellstick_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TELLSTICK_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TELLSTICK_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init tellstick_znet_lite_setup(void)
+{
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[ETH_ALEN];
+	memcpy(&mac, (u8 *) KSEG1ADDR(0x1f01fc00), sizeof(mac));
+
+	ath79_gpio_function_disable(
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN
+	);
+
+	ath79_register_m25p80(&tellstick_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tellstick_leds_gpio),
+				 tellstick_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TELLSTICK_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tellstick_gpio_keys),
+					tellstick_gpio_keys);
+
+	gpio_request_one(TELLSTICK_GPIO_RF433_RESET,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "rf433 reset");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, (u8 *)mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	// wlan0 mac needs to be different then eth0
+	mac[3] += 1;
+	ath79_register_wmac(ee, (u8 *)mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TELLSTICK_ZNET_LITE, "TELLSTICK-ZNET-LITE", "Telldus TellStick ZNet Lite",
+	     tellstick_znet_lite_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-632brp.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-632brp.c
new file mode 100644
index 0000000000..855664e562
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-632brp.c
@@ -0,0 +1,111 @@
+/*
+ *  TrendNET TEW-632BRP board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define TEW_632BRP_GPIO_LED_STATUS	1
+#define TEW_632BRP_GPIO_LED_WPS		3
+#define TEW_632BRP_GPIO_LED_WLAN	6
+#define TEW_632BRP_GPIO_BTN_WPS		12
+#define TEW_632BRP_GPIO_BTN_RESET	21
+
+#define TEW_632BRP_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_632BRP_KEYS_DEBOUNCE_INTERVAL (3 * TEW_632BRP_KEYS_POLL_INTERVAL)
+
+#define TEW_632BRP_CONFIG_ADDR	0x1f020000
+#define TEW_632BRP_CONFIG_SIZE	0x10000
+
+static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
+	{
+		.name		= "tew-632brp:green:status",
+		.gpio		= TEW_632BRP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:blue:wps",
+		.gpio		= TEW_632BRP_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:green:wlan",
+		.gpio		= TEW_632BRP_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew_632brp_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define TEW_632BRP_LAN_PHYMASK	BIT(0)
+#define TEW_632BRP_WAN_PHYMASK	BIT(4)
+#define TEW_632BRP_MDIO_MASK	(~(TEW_632BRP_LAN_PHYMASK | \
+				   TEW_632BRP_WAN_PHYMASK))
+
+static void __init tew_632brp_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(TEW_632BRP_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ath79_register_mdio(0, TEW_632BRP_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = TEW_632BRP_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
+				 tew_632brp_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW_632BRP_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_632brp_gpio_keys),
+					tew_632brp_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
+	     tew_632brp_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-673gru.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-673gru.c
new file mode 100644
index 0000000000..80a5443c70
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-673gru.c
@@ -0,0 +1,198 @@
+/*
+ *  TRENDnet TEW-673GRU board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TEW673GRU_GPIO_LCD_SCK		0
+#define TEW673GRU_GPIO_LCD_MOSI		1
+#define TEW673GRU_GPIO_LCD_MISO		2
+#define TEW673GRU_GPIO_LCD_CS		6
+
+#define TEW673GRU_GPIO_LED_WPS		9
+
+#define TEW673GRU_GPIO_BTN_RESET	3
+#define TEW673GRU_GPIO_BTN_WPS		8
+
+#define TEW673GRU_GPIO_RTL8366_SDA	5
+#define TEW673GRU_GPIO_RTL8366_SCK	7
+
+#define TEW673GRU_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TEW673GRU_KEYS_DEBOUNCE_INTERVAL (3 * TEW673GRU_KEYS_POLL_INTERVAL)
+
+#define TEW673GRU_CAL0_OFFSET		0x1000
+#define TEW673GRU_CAL1_OFFSET		0x5000
+#define TEW673GRU_MAC0_OFFSET		0xffa0
+#define TEW673GRU_MAC1_OFFSET		0xffb4
+
+#define TEW673GRU_CAL_LOCATION_0	0x1f660000
+#define TEW673GRU_CAL_LOCATION_1	0x1f7f0000
+
+static struct gpio_led tew673gru_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:blue:wps",
+		.gpio		= TEW673GRU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew673gru_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval tew673gru_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data tew673gru_rtl8366s_data = {
+	.gpio_sda	= TEW673GRU_GPIO_RTL8366_SDA,
+	.gpio_sck	= TEW673GRU_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(tew673gru_rtl8366s_initvals),
+	.initvals	= tew673gru_rtl8366s_initvals,
+};
+
+static struct platform_device tew673gru_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tew673gru_rtl8366s_data,
+	}
+};
+
+static struct spi_board_info tew673gru_spi_info[] = {
+	{
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz	= 400000,
+		.modalias	= "spidev",
+		.mode		= SPI_MODE_2,
+		.controller_data = (void *) TEW673GRU_GPIO_LCD_CS,
+	},
+};
+
+static struct spi_gpio_platform_data tew673gru_spi_data = {
+	.sck		= TEW673GRU_GPIO_LCD_SCK,
+	.miso		= TEW673GRU_GPIO_LCD_MISO,
+	.mosi		= TEW673GRU_GPIO_LCD_MOSI,
+	.num_chipselect = 1,
+};
+
+static struct platform_device tew673gru_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &tew673gru_spi_data,
+	},
+};
+
+static bool __init tew673gru_is_caldata_valid(u8 *p)
+{
+	u16 *magic0, *magic1;
+
+	magic0 = (u16 *)(p + TEW673GRU_CAL0_OFFSET);
+	magic1 = (u16 *)(p + TEW673GRU_CAL1_OFFSET);
+
+	return (*magic0 == 0xa55a && *magic1 == 0xa55a);
+}
+
+static void __init tew673gru_wlan_init(void)
+{
+	u8 mac1[ETH_ALEN], mac2[ETH_ALEN];
+	u8 *caldata;
+
+	caldata = (u8 *) KSEG1ADDR(TEW673GRU_CAL_LOCATION_0);
+	if (!tew673gru_is_caldata_valid(caldata)) {
+		caldata = (u8 *)KSEG1ADDR(TEW673GRU_CAL_LOCATION_1);
+		if (!tew673gru_is_caldata_valid(caldata)) {
+			pr_err("no calibration data found\n");
+			return;
+		}
+	}
+
+	ath79_parse_ascii_mac(caldata + TEW673GRU_MAC0_OFFSET, mac1);
+	ath79_parse_ascii_mac(caldata + TEW673GRU_MAC1_OFFSET, mac2);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 2);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 3);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(caldata + TEW673GRU_CAL0_OFFSET, mac1,
+		      caldata + TEW673GRU_CAL1_OFFSET, mac2);
+}
+
+static void __init tew673gru_setup(void)
+{
+	tew673gru_wlan_init();
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_eth1_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew673gru_leds_gpio),
+				 tew673gru_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW673GRU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew673gru_gpio_keys),
+					tew673gru_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&tew673gru_rtl8366s_device);
+
+	spi_register_board_info(tew673gru_spi_info,
+				ARRAY_SIZE(tew673gru_spi_info));
+	platform_device_register(&tew673gru_spi_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_673GRU, "TEW-673GRU", "TRENDnet TEW-673GRU",
+	     tew673gru_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-712br.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-712br.c
new file mode 100644
index 0000000000..304b994887
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-712br.c
@@ -0,0 +1,153 @@
+/*
+ *  TRENDnet TEW-712BR board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TEW_712BR_GPIO_BTN_WPS		11
+#define TEW_712BR_GPIO_BTN_RESET	12
+
+#define TEW_712BR_GPIO_LED_LAN1		13
+#define TEW_712BR_GPIO_LED_LAN2		14
+#define TEW_712BR_GPIO_LED_LAN3		15
+#define TEW_712BR_GPIO_LED_LAN4		16
+#define TEW_712BR_GPIO_LED_POWER_GREEN	20
+#define TEW_712BR_GPIO_LED_POWER_ORANGE	27
+#define TEW_712BR_GPIO_LED_WAN_GREEN	17
+#define TEW_712BR_GPIO_LED_WAN_ORANGE	23
+#define TEW_712BR_GPIO_LED_WLAN		0
+#define TEW_712BR_GPIO_LED_WPS		26
+
+#define TEW_712BR_GPIO_WAN_LED_ENABLE	1
+
+#define TEW_712BR_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_712BR_KEYS_DEBOUNCE_INTERVAL (3 * TEW_712BR_KEYS_POLL_INTERVAL)
+
+#define TEW_712BR_ART_ADDRESS		0x1f010000
+#define TEW_712BR_CALDATA_OFFSET	0x1000
+
+#define TEW_712BR_MAC_PART_ADDRESS	0x1f020000
+#define TEW_712BR_LAN_MAC_OFFSET	0x04
+#define TEW_712BR_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led tew_712br_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:green:lan1",
+		.gpio		= TEW_712BR_GPIO_LED_LAN1,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan2",
+		.gpio		= TEW_712BR_GPIO_LED_LAN2,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan3",
+		.gpio		= TEW_712BR_GPIO_LED_LAN3,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan4",
+		.gpio		= TEW_712BR_GPIO_LED_LAN4,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:blue:wps",
+		.gpio		= TEW_712BR_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "trendnet:green:power",
+		.gpio		= TEW_712BR_GPIO_LED_POWER_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:orange:power",
+		.gpio		= TEW_712BR_GPIO_LED_POWER_ORANGE,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:wan",
+		.gpio		= TEW_712BR_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "trendnet:orange:wan",
+		.gpio		= TEW_712BR_GPIO_LED_WAN_ORANGE,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:wlan",
+		.gpio		= TEW_712BR_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tew_712br_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_712BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_712BR_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_712BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_712BR_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tew_712br_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TEW_712BR_ART_ADDRESS);
+	u8 *mac = (u8 *) KSEG1ADDR(TEW_712BR_MAC_PART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	gpio_request_one(TEW_712BR_GPIO_WAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_712br_leds_gpio),
+				 tew_712br_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TEW_712BR_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_712br_gpio_keys),
+					tew_712br_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_parse_ascii_mac(mac + TEW_712BR_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(mac + TEW_712BR_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + TEW_712BR_CALDATA_OFFSET, wan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_712BR, "TEW-712BR",
+	     "TRENDnet TEW-712BR", tew_712br_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-732br.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-732br.c
new file mode 100644
index 0000000000..1f26f6f4b0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-732br.c
@@ -0,0 +1,127 @@
+/*
+ *  TRENDnet TEW-732BR board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TEW_732BR_GPIO_BTN_WPS		16
+#define TEW_732BR_GPIO_BTN_RESET	17
+
+#define TEW_732BR_GPIO_LED_POWER_GREEN	4
+#define TEW_732BR_GPIO_LED_POWER_AMBER	14
+#define TEW_732BR_GPIO_LED_PLANET_GREEN	12
+#define TEW_732BR_GPIO_LED_PLANET_AMBER 22
+
+#define TEW_732BR_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_732BR_KEYS_DEBOUNCE_INTERVAL (3 * TEW_732BR_KEYS_POLL_INTERVAL)
+
+#define TEW_732BR_ART_ADDRESS		0x1fff0000
+#define TEW_732BR_CALDATA_OFFSET	0x1000
+#define TEW_732BR_LAN_MAC_OFFSET	0xffa0
+#define TEW_732BR_WAN_MAC_OFFSET	0xffb4
+
+static struct gpio_led tew_732br_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:green:power",
+		.gpio		= TEW_732BR_GPIO_LED_POWER_GREEN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "trendnet:amber:power",
+		.gpio		= TEW_732BR_GPIO_LED_POWER_AMBER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "trendnet:green:wan",
+		.gpio		= TEW_732BR_GPIO_LED_PLANET_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "trendnet:amber:wan",
+		.gpio		= TEW_732BR_GPIO_LED_PLANET_AMBER,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tew_732br_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_732BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_732BR_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_732BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_732BR_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void __init tew_732br_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TEW_732BR_ART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_732br_leds_gpio),
+				 tew_732br_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TEW_732BR_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_732br_gpio_keys),
+					tew_732br_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_parse_ascii_mac(art + TEW_732BR_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(art + TEW_732BR_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_register_wmac(art + TEW_732BR_CALDATA_OFFSET, lan_mac);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* LAN: GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN: GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_732BR, "TEW-732BR", "TRENDnet TEW-732BR",
+	     tew_732br_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tew-823dru.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-823dru.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tew-823dru.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tew-823dru.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr11u.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr11u.c
new file mode 100644
index 0000000000..74ccf639e0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr11u.c
@@ -0,0 +1,183 @@
+/*
+ *  TP-LINK TL-MR11U/TL-MR3040 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR11U_GPIO_LED_3G		27
+#define TL_MR11U_GPIO_LED_WLAN		26
+#define TL_MR11U_GPIO_LED_LAN		17
+
+#define TL_MR11U_GPIO_BTN_WPS		20
+#define TL_MR11U_GPIO_BTN_RESET		11
+
+#define TL_MR11U_GPIO_USB_POWER		8
+#define TL_MR3040_GPIO_USB_POWER	18
+
+#define TL_MR3040_V2_GPIO_BTN_SW1	19
+#define TL_MR3040_V2_GPIO_BTN_SW2	20
+
+#define TL_MR11U_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR11U_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR11U_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr11u_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr11u_flash_data = {
+	.part_probes	= tl_mr11u_part_probes,
+};
+
+static struct gpio_led tl_mr11u_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR11U_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR11U_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR11U_GPIO_LED_LAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr11u_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_mr3040_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_SW,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3040_V2_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_SW,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3040_V2_GPIO_BTN_SW2,
+		.active_low	= 0,
+	}
+};
+
+static void __init common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable hardware control LAN1 and LAN2 LEDs, enabling GPIO14 and GPIO15 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr11u_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr11u_leds_gpio),
+				 tl_mr11u_leds_gpio);
+
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_mr11u_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr11u_gpio_keys),
+					tl_mr11u_gpio_keys);
+	gpio_request_one(TL_MR11U_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR11U, "TL-MR11U", "TP-LINK TL-MR11U",
+	     tl_mr11u_setup);
+
+static void __init tl_mr3040_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					1, tl_mr11u_gpio_keys);
+	gpio_request_one(TL_MR3040_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3040, "TL-MR3040", "TP-LINK TL-MR3040",
+	     tl_mr3040_setup);
+
+static void __init tl_mr3040_v2_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3040_v2_gpio_keys),
+					tl_mr3040_v2_gpio_keys);
+	gpio_request_one(TL_MR3040_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3040_V2, "TL-MR3040-v2", "TP-LINK TL-MR3040 v2",
+	     tl_mr3040_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr13u.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr13u.c
new file mode 100644
index 0000000000..84b6937849
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr13u.c
@@ -0,0 +1,107 @@
+/*
+ *  TP-LINK TL-MR13U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR13U_GPIO_LED_SYSTEM	27
+
+#define TL_MR13U_GPIO_BTN_RESET		11
+#define TL_MR13U_GPIO_BTN_SW1		6
+#define TL_MR13U_GPIO_BTN_SW2		7
+
+#define TL_MR13U_GPIO_USB_POWER		18
+
+#define TL_MR13U_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR13U_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR13U_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr13u_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr13u_flash_data = {
+	.part_probes	= tl_mr13u_part_probes,
+};
+
+static struct gpio_led tl_mr13u_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_MR13U_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_mr13u_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_SW2,
+		.active_low	= 0,
+	},
+};
+
+static void __init tl_mr13u_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr13u_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr13u_leds_gpio),
+				 tl_mr13u_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR13U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr13u_gpio_keys),
+					tl_mr13u_gpio_keys);
+
+	gpio_request_one(TL_MR13U_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR13U, "TL-MR13U", "TP-LINK TL-MR13U v1",
+	     tl_mr13u_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3020.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3020.c
new file mode 100644
index 0000000000..0a9dfbc8a0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3020.c
@@ -0,0 +1,126 @@
+/*
+ *  TP-LINK TL-MR3020 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR3020_GPIO_LED_3G		27
+#define TL_MR3020_GPIO_LED_WLAN		0
+#define TL_MR3020_GPIO_LED_LAN		17
+#define TL_MR3020_GPIO_LED_WPS		26
+
+#define TL_MR3020_GPIO_BTN_WPS		11
+#define TL_MR3020_GPIO_BTN_SW1		18
+#define TL_MR3020_GPIO_BTN_SW2		20
+
+#define TL_MR3020_GPIO_USB_POWER	8
+
+#define TL_MR3020_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3020_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR3020_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3020_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3020_flash_data = {
+	.part_probes	= tl_mr3020_part_probes,
+};
+
+static struct gpio_led tl_mr3020_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3020_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR3020_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR3020_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_MR3020_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_mr3020_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW2,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_mr3020_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr3020_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3020_leds_gpio),
+				 tl_mr3020_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR3020_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3020_gpio_keys),
+					tl_mr3020_gpio_keys);
+
+	gpio_request_one(TL_MR3020_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3020, "TL-MR3020", "TP-LINK TL-MR3020",
+	     tl_mr3020_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3x20.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3x20.c
new file mode 100644
index 0000000000..5924ac5048
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr3x20.c
@@ -0,0 +1,147 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3X20_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR3X20_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3x20_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.part_probes	= tl_mr3x20_part_probes,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr3x20_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_ap99_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_mr3x20_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, TL_MR3X20_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_mr3x20_gpio_keys),
+					 tl_mr3x20_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3x20_usb_setup(void)
+{
+	/* enable power for the USB port */
+	gpio_request_one(TL_MR3X20_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
+
+static void __init tl_wr841n_v7_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio) - 1,
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V7, "TL-WR841N-v7",
+	     "TP-LINK TL-WR841N/ND v7", tl_wr841n_v7_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr6400.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr6400.c
new file mode 100644
index 0000000000..be49c89cab
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-mr6400.c
@@ -0,0 +1,151 @@
+/*
+ * TP-LINK TL-MR6400 board support
+ *
+ *  Copyright (C) 2017 Filip Moc <lede@moc6.cz>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * The name of the author may not be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR6400_GPIO_LTE_POWER	4
+#define TL_MR6400_GPIO_BTN_RESET	12	/* SW2 */
+#define TL_MR6400_GPIO_BTN_RFKILL	14	/* SW3 */
+#define TL_MR6400_GPIO_LED_WAN		0	/* D12 */
+#define TL_MR6400_GPIO_LED_4G		1	/* D11 */
+#define TL_MR6400_GPIO_LED_WPS		3	/* D5  */
+#define TL_MR6400_GPIO_LED_WLAN		11	/* D3  */
+#define TL_MR6400_GPIO_LED_POWER	13	/* D2  */
+#define TL_MR6400_GPIO_LED_LAN		16	/* D4  */
+
+#define TL_MR6400_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TL_MR6400_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR6400_KEYS_POLL_INTERVAL)
+
+#define TL_MR6400_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *tl_mr6400_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr6400_flash_data = {
+	.part_probes	= tl_mr6400_part_probes,
+	.type		= "w25q64",
+};
+
+static struct gpio_led tl_mr6400_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:white:wan",
+		.gpio		= TL_MR6400_GPIO_LED_WAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:white:4g",
+		.gpio		= TL_MR6400_GPIO_LED_4G,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:white:wps",
+		.gpio		= TL_MR6400_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:white:wlan",
+		.gpio		= TL_MR6400_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:white:power",
+		.gpio		= TL_MR6400_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:white:lan",
+		.gpio		= TL_MR6400_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_mr6400_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR6400_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR6400_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "rfkill",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_MR6400_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR6400_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static void __init tl_mr6400_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&tl_mr6400_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN1, LAN2, LAN3 */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(0);
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+	ath79_register_eth(1);
+
+	/* LAN4 / WAN */
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + TL_MR6400_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_register_leds_gpio(-1,
+				 ARRAY_SIZE(tl_mr6400_leds_gpio),
+				 tl_mr6400_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1,
+					TL_MR6400_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr6400_gpio_keys),
+					tl_mr6400_gpio_keys);
+
+	gpio_request_one(TL_MR6400_GPIO_LTE_POWER,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED | GPIOF_ACTIVE_LOW,
+			 "LTE power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR6400, "TL-MR6400", "TP-LINK TL-MR6400",
+	     tl_mr6400_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa701nd-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa701nd-v2.c
new file mode 100644
index 0000000000..aab92b30d4
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa701nd-v2.c
@@ -0,0 +1,116 @@
+/*
+ *  TP-LINK TL-WA701ND v2 board support
+ *
+ *  Copyright (C) 2015 Luigi Tarenga <luigi.tarenga@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA701NDV2_GPIO_LED_WLAN	0
+#define TL_WA701NDV2_GPIO_LED_QSS	1
+#define TL_WA701NDV2_GPIO_LED_LAN	17
+#define TL_WA701NDV2_GPIO_LED_SYSTEM	27
+
+#define TL_WA701NDV2_GPIO_BTN_RESET	11
+#define TL_WA701NDV2_GPIO_BTN_QSS	26
+
+#define TL_WA701NDV2_GPIO_USB_POWER	8
+
+#define TL_WA701NDV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WA701NDV2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa701ndv2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa701ndv2_flash_data = {
+	.part_probes	= tl_wa701ndv2_part_probes,
+};
+
+static struct gpio_led tl_wa701ndv2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA701NDV2_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA701NDV2_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA701NDV2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA701NDV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+        }
+};
+
+static struct gpio_keys_button tl_wa701ndv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA701NDV2_GPIO_BTN_RESET,
+		.active_low	= 0,
+	} , {
+                .desc		= "qss",
+                .type		= EV_KEY,
+                .code		= KEY_WPS_BUTTON,
+                .debounce_interval = TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL,
+                .gpio		= TL_WA701NDV2_GPIO_BTN_QSS,
+                .active_low	= 0,
+        }
+
+};
+
+static void __init tl_wa701ndv2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa701ndv2_leds_gpio),
+				 tl_wa701ndv2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA701NDV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa701ndv2_gpio_keys),
+					tl_wa701ndv2_gpio_keys);
+
+	gpio_request_one(TL_WA701NDV2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&tl_wa701ndv2_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	/* ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1); */
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA701ND_V2, "TL-WA701ND-v2",
+	     "TP-LINK TL-WA701ND v2", tl_wa701ndv2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa7210n-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa7210n-v2.c
new file mode 100644
index 0000000000..276353a6c3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa7210n-v2.c
@@ -0,0 +1,125 @@
+/*
+ *  TP-LINK TL-WA7210N v2.1 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Nicolas Braud-Santoni <nicolas@braud-santoni.eu>
+ *  Copyright (C) 2014 Alexander List <alex@graz.funkfeuer.at>
+ *  Copyright (C) 2015 Hendrik Frenzel <hfrenzel@scunc.net>
+ *
+ *  rebased on TL-WA7510Nv1 support,
+ *    Copyright (C) 2012 Stefan Helmert <helst_listen@aol.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#include "common.h"
+
+#define TL_WA7210N_V2_GPIO_BTN_RESET    11
+#define TL_WA7210N_V2_KEYS_POLL_INT     20
+#define TL_WA7210N_V2_KEYS_DEBOUNCE_INT (3 * TL_WA7210N_V2_KEYS_POLL_INT)
+
+#define TL_WA7210N_V2_GPIO_LED_LAN  17
+#define TL_WA7210N_V2_GPIO_LED_SIG1 0
+#define TL_WA7210N_V2_GPIO_LED_SIG2 1
+#define TL_WA7210N_V2_GPIO_LED_SIG3 27
+#define TL_WA7210N_V2_GPIO_LED_SIG4 26
+
+#define  TL_WA7210N_V2_GPIO_LNA_EN 28
+
+static const char *tl_wa7210n_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct gpio_keys_button tl_wa7210n_v2_gpio_keys[] __initdata = {
+	{
+		.desc              = "reset",
+		.type              = EV_KEY,
+		.code              = KEY_RESTART,
+		.debounce_interval = TL_WA7210N_V2_KEYS_DEBOUNCE_INT,
+		.gpio              = TL_WA7210N_V2_GPIO_BTN_RESET,
+		.active_low        = 0,
+	},
+};
+
+static struct gpio_led tl_wa7210n_v2_leds_gpio[] __initdata = {
+	{
+		.name       = "tp-link:green:lan",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_LAN,
+		.active_low = 1,
+	}, {
+		.name       = "tp-link:green:signal1",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG1,
+		.active_low = 0,
+	}, {
+		.name       = "tp-link:green:signal2",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG2,
+		.active_low = 0,
+	}, {
+		.name       = "tp-link:green:signal3",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG3,
+		.active_low = 1,
+	}, {
+		.name       = "tp-link:green:signal4",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG4,
+		.active_low = 1,
+	},
+};
+
+static struct flash_platform_data tl_wa7210n_v2_flash_data = {
+	.part_probes    = tl_wa7210n_v2_part_probes,
+};
+
+static void __init tl_wa7210n_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA7210N_V2_KEYS_POLL_INT,
+			ARRAY_SIZE(tl_wa7210n_v2_gpio_keys),
+			tl_wa7210n_v2_gpio_keys);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa7210n_v2_leds_gpio),
+			tl_wa7210n_v2_leds_gpio);
+
+	ath79_gpio_function_enable(TL_WA7210N_V2_GPIO_LNA_EN);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_wmac(ee, mac);
+
+	ath79_register_m25p80(&tl_wa7210n_v2_flash_data);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA7210N_V2, "TL-WA7210N-v2", "TP-LINK TL-WA7210N v2",
+	tl_wa7210n_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa801nd-v3.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa801nd-v3.c
new file mode 100644
index 0000000000..054c14ee73
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa801nd-v3.c
@@ -0,0 +1,136 @@
+/*
+ *  TP-LINK TL-WA801ND v3 adapted from TP-LINK TL-WR841N/ND v9
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2016 Tiziano Bacocco <tizbac2@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA801NDV3_GPIO_LED_WLAN	12
+#define TL_WA801NDV3_GPIO_LED_SYSTEM	13
+#define TL_WA801NDV3_GPIO_LED_SECURITY_RED 11
+#define TL_WA801NDV3_GPIO_LED_SECURITY_GREEN 15
+#define TL_WA801NDV3_GPIO_LED_LAN 3
+
+#define TL_WA801NDV3_GPIO_BTN_RESET	2
+#define TL_WA801NDV3_GPIO_BTN_WIFI	1
+
+#define TL_WA801NDV3_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA801NDV3_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA801NDV3_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa801n_v3_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa801n_v3_flash_data = {
+	.part_probes	= tl_wa801n_v3_part_probes,
+};
+
+static struct gpio_led tl_wa801n_v3_leds_gpio[] __initdata = {
+  {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA801NDV3_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA801NDV3_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA801NDV3_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:security",
+		.gpio		= TL_WA801NDV3_GPIO_LED_SECURITY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:security",
+		.gpio		= TL_WA801NDV3_GPIO_LED_SECURITY_GREEN,
+		.active_low	= 0,
+	}
+
+};
+
+static struct gpio_keys_button tl_wa801n_v3_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA801NDV3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA801NDV3_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WA801NDV3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA801NDV3_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+
+static void __init tl_ap143_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wa801n_v3_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(ee, tmpmac);
+}
+
+static void __init tl_wa801n_v3_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa801n_v3_leds_gpio),
+				 tl_wa801n_v3_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WA801NDV3_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa801n_v3_gpio_keys),
+					tl_wa801n_v3_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA801ND_V3, "TL-WA801ND-v3", "TP-LINK TL-WA801ND v3",
+	     tl_wa801n_v3_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa830re-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa830re-v2.c
new file mode 100644
index 0000000000..1c74fed98e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa830re-v2.c
@@ -0,0 +1,132 @@
+/*
+ *  TP-LINK TL-WA830RE v2 board support
+ *
+ *  Copyright (C) 2014 Fredrik Jonson <fredrik@famjonson.se>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA830REV2_GPIO_LED_WLAN	13
+#define TL_WA830REV2_GPIO_LED_QSS	15
+#define TL_WA830REV2_GPIO_LED_LAN	18
+#define TL_WA830REV2_GPIO_LED_SYSTEM	14
+
+#define TL_WA830REV2_GPIO_BTN_RESET	17
+#define TL_WA830REV2_GPIO_SW_RFKILL	16	/* WPS for MR3420 v2 */
+
+#define TL_WA830REV2_GPIO_USB_POWER	4
+
+#define TL_WA830REV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA830REV2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa830re_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa830re_v2_flash_data = {
+	.part_probes	= tl_wa830re_v2_part_probes,
+};
+
+static struct gpio_led tl_wa830re_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA830REV2_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA830REV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA830REV2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA830REV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wa830re_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA830REV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA830REV2_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	/* config gpio4 as normal gpio function */
+	ath79_gpio_output_select(TL_WA830REV2_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&tl_wa830re_v2_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wa830re_v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa830re_v2_leds_gpio) - 1,
+				 tl_wa830re_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WA830REV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa830re_v2_gpio_keys),
+					tl_wa830re_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA830RE_V2, "TL-WA830RE-v2", "TP-LINK TL-WA830RE v2",
+	     tl_wa830re_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v2.c
new file mode 100644
index 0000000000..b4fb2a9f91
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v2.c
@@ -0,0 +1,104 @@
+/*
+ *  TP-LINK TL-WA901N/ND v2 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2011 Jonathan Bennett <jbscience87@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA901ND_V2_GPIO_LED_QSS		4
+#define TL_WA901ND_V2_GPIO_LED_SYSTEM		2
+#define TL_WA901ND_V2_GPIO_LED_WLAN		9
+
+#define TL_WA901ND_V2_GPIO_BTN_RESET		3
+#define TL_WA901ND_V2_GPIO_BTN_QSS		7
+
+#define TL_WA901ND_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WA901ND_V2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_v2_flash_data = {
+	.part_probes	= tl_wa901nd_v2_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_QSS,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00001000;
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(&tl_wa901nd_v2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_v2_leds_gpio),
+				 tl_wa901nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_v2_gpio_keys),
+					tl_wa901nd_v2_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V2, "TL-WA901ND-v2",
+	     "TP-LINK TL-WA901ND v2", tl_wa901nd_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v4.c
new file mode 100644
index 0000000000..ffbcd6fe42
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd-v4.c
@@ -0,0 +1,115 @@
+/*
+ *  TP-LINK TL-WA901ND v4, v5 board
+ *
+ *  Copyright (C) 2015 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2016 Tiziano Bacocco <tizbac2@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define TL_WA901ND_V4_GPIO_LED_QSS		3
+#define TL_WA901ND_V4_GPIO_LED_LAN		7
+#define TL_WA901ND_V4_GPIO_LED_WLAN		8
+#define TL_WA901ND_V4_GPIO_LED_SYSTEM		18
+
+#define TL_WA901ND_V4_GPIO_BTN_RESET		1
+
+#define TL_WA901ND_V4_KEYS_POLL_INTERVAL	20
+#define TL_WA901ND_V4_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WA901ND_V4_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led TL_WA901ND_V4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_V4_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA901ND_V4_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA901ND_V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_V4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button TL_WA901ND_V4_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+
+static const char *tl_wa901nd_v4_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_v4_flash_data = {
+	.part_probes	= tl_wa901nd_v4_part_probes,
+};
+
+
+static void __init TL_WA901ND_V4_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wa901nd_v4_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(TL_WA901ND_V4_leds_gpio),
+				 TL_WA901ND_V4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_V4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(TL_WA901ND_V4_gpio_keys),
+					TL_WA901ND_V4_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V4, "TL-WA901ND-v4", "TP-LINK TL-WA901ND v4",
+	     TL_WA901ND_V4_setup);
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V5, "TL-WA901ND-v5", "TP-LINK TL-WA901ND v5",
+	     TL_WA901ND_V4_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd.c
new file mode 100644
index 0000000000..957b92cba6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wa901nd.c
@@ -0,0 +1,127 @@
+/*
+ *  TP-LINK TL-WA901N/ND v1, TL-WA7510N v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2012 Stefan Helmert <helst_listen@aol.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WA901ND_GPIO_LED_QSS		0
+#define TL_WA901ND_GPIO_LED_SYSTEM	1
+#define TL_WA901ND_GPIO_LED_LAN		13
+
+#define TL_WA901ND_GPIO_BTN_RESET	11
+#define TL_WA901ND_GPIO_BTN_QSS		12
+
+#define TL_WA901ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA901ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_flash_data = {
+	.part_probes	= tl_wa901nd_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA901ND_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	/*
+	 * ath79_eth0 would be the WAN port, but is not connected.
+	 * ath79_eth1 connects to the internal switch chip, however
+	 * we have a single LAN port only.
+	 */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&tl_wa901nd_flash_data);
+}
+
+static void __init tl_wa901nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_leds_gpio),
+				 tl_wa901nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_gpio_keys),
+					tl_wa901nd_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND, "TL-WA901ND", "TP-LINK TL-WA901ND",
+	     tl_wa901nd_setup);
+
+static void __init tl_wa7510n_v1_setup(void)
+{
+	common_setup();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA7510N_V1, "TL-WA7510N", "TP-LINK TL-WA7510N v1",
+	     tl_wa7510n_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wax50re.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wax50re.c
new file mode 100644
index 0000000000..955628fecb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wax50re.c
@@ -0,0 +1,445 @@
+/*
+ *  Support for TP-Link boards:
+ *  - TL-WA750RE v1
+ *  - TL-WA801ND v2
+ *  - TL-WA850RE v1/v2
+ *  - TL-WA855RE v1
+ *  - TL-WA901ND v3
+ *
+ *  Copyright (C) 2013 Martijn Zilverschoon <thefriedzombie@gmail.com>
+ *  Copyright (C) 2013 Jiri Pirko <jiri@resnulli.us>
+ *  Copyright (C) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *  Copyright (C) 2017 Federico Cappon <dududede371@gmail.com>
+ *  Copyright (C) 2017 Nicol Veronese <nicveronese@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WAX50RE_GPIO_LED_LAN		20
+#define TL_WAX50RE_GPIO_LED_WLAN	13
+#define TL_WAX50RE_GPIO_LED_RE		15
+#define TL_WAX50RE_GPIO_LED_SIGNAL1	0
+#define TL_WAX50RE_GPIO_LED_SIGNAL2	1
+#define TL_WAX50RE_GPIO_LED_SIGNAL3	2
+#define TL_WAX50RE_GPIO_LED_SIGNAL4	3
+#define TL_WAX50RE_GPIO_LED_SIGNAL5	4
+
+#define TL_WA850RE_V2_GPIO_LED_LAN	14
+#define TL_WA850RE_V2_GPIO_LED_RE	12
+#define TL_WA850RE_V2_GPIO_LED_SIGNAL1	0
+#define TL_WA850RE_V2_GPIO_LED_SIGNAL2	1
+#define TL_WA850RE_V2_GPIO_LED_SIGNAL3	2
+#define TL_WA850RE_V2_GPIO_LED_SIGNAL4	3
+#define TL_WA850RE_V2_GPIO_LED_SIGNAL5	4
+#define TL_WA850RE_V2_GPIO_LED_WLAN	13
+
+#define TL_WA850RE_V2_GPIO_ENABLE_LEDS	15
+
+#define TL_WA855REV1_GPIO_LED_RED	11
+#define TL_WA855REV1_GPIO_LED_GREEN	12
+
+#define TL_WA860RE_GPIO_LED_WLAN_ORANGE	0
+#define TL_WA860RE_GPIO_LED_WLAN_GREEN	2
+#define TL_WA860RE_GPIO_LED_POWER_ORANGE	12
+#define TL_WA860RE_GPIO_LED_POWER_GREEN	14
+#define TL_WA860RE_GPIO_LED_LAN		20
+
+#define TL_WA801ND_V2_GPIO_LED_LAN	18
+#define TL_WA801ND_V2_GPIO_LED_SYSTEM	14
+
+#define TL_WAX50RE_GPIO_BTN_RESET	17
+#define TL_WAX50RE_GPIO_BTN_WPS		16
+
+#define TL_WA860RE_GPIO_BTN_RESET	17
+#define TL_WA860RE_GPIO_BTN_WPS		16
+#define TL_WA860RE_GPIO_BTN_ONOFF	11
+
+#define TL_WAX50RE_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL (3 * TL_WAX50RE_KEYS_POLL_INTERVAL)
+
+static const char *tl_wax50re_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wax50re_flash_data = {
+	.part_probes	= tl_wax50re_part_probes,
+};
+
+static struct gpio_led tl_wa750re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:orange:lan",
+		.gpio		= TL_WAX50RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:re",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal1",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal2",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal3",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal4",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal5",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL5,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wa850re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:lan",
+		.gpio		= TL_WAX50RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:re",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal1",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal2",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal3",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal4",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal5",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL5,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wa850re_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:lan",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:re",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal1",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal2",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal3",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal4",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal5",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_SIGNAL5,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WA850RE_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wa855re_v1_leds_gpio[] __initdata = {
+	 {
+		.name		= "tp-link:green:power",
+		.gpio		= TL_WA855REV1_GPIO_LED_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:red:power",
+		.gpio		= TL_WA855REV1_GPIO_LED_RED,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_led tl_wa860re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA860RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:power",
+		.gpio		= TL_WA860RE_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:power",
+		.gpio		= TL_WA860RE_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA860RE_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:wlan",
+		.gpio		= TL_WA860RE_GPIO_LED_WLAN_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_keys_button tl_wax50re_gpio_keys[] __initdata = {
+	{
+		.desc		   = "Reset button",
+		.type		   = EV_KEY,
+		.code		   = KEY_RESTART,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WAX50RE_GPIO_BTN_RESET,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "WPS",
+		.type		   = EV_KEY,
+		.code		   = KEY_WPS_BUTTON,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WAX50RE_GPIO_BTN_WPS,
+		.active_low	   = 1,
+	},
+};
+
+static struct gpio_keys_button tl_wa860re_gpio_keys[] __initdata = {
+	{
+		.desc		   = "Reset button",
+		.type		   = EV_KEY,
+		.code		   = KEY_RESTART,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_RESET,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "WPS",
+		.type		   = EV_KEY,
+		.code		   = KEY_WPS_BUTTON,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_WPS,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "ONOFF",
+		.type		   = EV_KEY,
+		.code		   = BTN_1,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_ONOFF,
+		.active_low	   = 1,
+	},
+};
+
+static struct gpio_led tl_wa801nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA801ND_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA801ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wax50re_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_ap143_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f3c0008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -2);
+	ath79_register_eth(0);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(ee, mac);
+}
+
+static void  __init tl_wa750re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa750re_leds_gpio),
+				 tl_wa750re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA750RE, "TL-WA750RE", "TP-LINK TL-WA750RE",
+	     tl_wa750re_setup);
+
+static void __init tl_wa801nd_v2_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa801nd_v2_leds_gpio),
+			tl_wa801nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA801ND_V2, "TL-WA801ND-v2", "TP-LINK TL-WA801ND v2",
+	     tl_wa801nd_v2_setup);
+
+static void  __init tl_wa850re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa850re_leds_gpio),
+				 tl_wa850re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA850RE, "TL-WA850RE", "TP-LINK TL-WA850RE",
+	     tl_wa850re_setup);
+
+static void  __init tl_wa850re_v2_setup(void)
+{
+	tl_ap143_setup();
+
+	/* For GPIO 0~4 */
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				  AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	/* Allow to enable/disable all LEDs from userspace */
+	gpio_request_one(TL_WA850RE_V2_GPIO_ENABLE_LEDS,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LEDs enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa850re_v2_leds_gpio),
+				 tl_wa850re_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA850RE_V2, "TL-WA850RE-V2",
+	     "TP-LINK TL-WA850RE v2", tl_wa850re_v2_setup);
+
+static void __init tl_wa855re_v1_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa855re_v1_leds_gpio),
+				 tl_wa855re_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA855RE_V1, "TL-WA855RE-v1", "TP-LINK TL-WA855RE v1",
+	     tl_wa855re_v1_setup);
+
+static void  __init tl_wa860re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa860re_leds_gpio),
+				 tl_wa860re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa860re_gpio_keys),
+					tl_wa860re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA860RE, "TL-WA860RE", "TP-LINK TL-WA860RE",
+	     tl_wa860re_setup);
+
+static void __init tl_wa901nd_v3_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa801nd_v2_leds_gpio),
+			tl_wa801nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys) - 1,
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V3, "TL-WA901ND-v3", "TP-LINK TL-WA901ND v3",
+	     tl_wa901nd_v3_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3320-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3320-v2.c
new file mode 100644
index 0000000000..3e452f2a4a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3320-v2.c
@@ -0,0 +1,146 @@
+/*
+ *  TP-LINK TL-WDR3320 v2 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2015 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR3320_GPIO_LED_WLAN5G		12
+#define WDR3320_GPIO_LED_SYSTEM		14
+#define WDR3320_GPIO_LED_QSS		15
+#define WDR3320_GPIO_LED_WAN		4
+#define WDR3320_GPIO_LED_LAN1		18
+#define WDR3320_GPIO_LED_LAN2		20
+#define WDR3320_GPIO_LED_LAN3		21
+#define WDR3320_GPIO_LED_LAN4		22
+
+#define WDR3320_GPIO_BTN_RESET		16
+
+#define WDR3320_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR3320_KEYS_DEBOUNCE_INTERVAL	(3 * WDR3320_KEYS_POLL_INTERVAL)
+
+#define WDR3320_WMAC_CALDATA_OFFSET	0x1000
+#define WDR3320_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr3320_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr3320_flash_data = {
+	.part_probes	= wdr3320_part_probes,
+};
+
+static struct gpio_led wdr3320_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= WDR3320_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= WDR3320_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan5g",
+		.gpio		= WDR3320_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr3320_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WDR3320_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3320_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init wdr3320_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr3320_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr3320_leds_gpio),
+				 wdr3320_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR3320_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr3320_gpio_keys),
+					wdr3320_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(art + WDR3320_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR3320_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR3320_V2, "TL-WDR3320-v2",
+	     "TP-LINK TL-WDR3320 v2",
+	     wdr3320_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3500.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3500.c
new file mode 100644
index 0000000000..452c20b777
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr3500.c
@@ -0,0 +1,169 @@
+/*
+ *  TP-LINK TL-WDR3500 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Gui Iribarren <gui@altermundi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR3500_GPIO_LED_USB		11
+#define WDR3500_GPIO_LED_WLAN2G		13
+#define WDR3500_GPIO_LED_SYSTEM		14
+#define WDR3500_GPIO_LED_QSS		15
+#define WDR3500_GPIO_LED_WAN		18
+#define WDR3500_GPIO_LED_LAN1		19
+#define WDR3500_GPIO_LED_LAN2		20
+#define WDR3500_GPIO_LED_LAN3		21
+#define WDR3500_GPIO_LED_LAN4		22
+
+#define WDR3500_GPIO_BTN_WPS		16
+#define WDR3500_GPIO_BTN_RFKILL		17
+
+#define WDR3500_GPIO_USB_POWER		12
+
+#define WDR3500_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR3500_KEYS_DEBOUNCE_INTERVAL	(3 * WDR3500_KEYS_POLL_INTERVAL)
+
+#define WDR3500_MAC0_OFFSET		0
+#define WDR3500_MAC1_OFFSET		6
+#define WDR3500_WMAC_CALDATA_OFFSET	0x1000
+#define WDR3500_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr3500_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr3500_flash_data = {
+	.part_probes	= wdr3500_part_probes,
+};
+
+static struct gpio_led wdr3500_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= WDR3500_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= WDR3500_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= WDR3500_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan2g",
+		.gpio		= WDR3500_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr3500_gpio_keys[] __initdata = {
+	{
+		.desc		= "QSS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WDR3500_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3500_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WDR3500_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3500_GPIO_BTN_RFKILL,
+	},
+};
+
+
+static void __init wdr3500_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr3500_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr3500_leds_gpio),
+				 wdr3500_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR3500_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr3500_gpio_keys),
+					wdr3500_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(art + WDR3500_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 1);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR3500_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 2);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	gpio_request_one(WDR3500_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR3500, "TL-WDR3500",
+	     "TP-LINK TL-WDR3500",
+	     wdr3500_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr4300.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr4300.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wdr4300.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr4300.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr6500-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr6500-v2.c
new file mode 100644
index 0000000000..1e72477646
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wdr6500-v2.c
@@ -0,0 +1,142 @@
+/*
+ *  TP-LINK TL-WDR6500 v2
+ *
+ *  Copyright (C) 2015 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WDR6500_V2_GPIO_LED_SYS	21
+#define TL_WDR6500_V2_GPIO_LED_WAN	18
+#define TL_WDR6500_V2_GPIO_LED_LAN1	17
+#define TL_WDR6500_V2_GPIO_LED_LAN2	16
+#define TL_WDR6500_V2_GPIO_LED_LAN3	15
+#define TL_WDR6500_V2_GPIO_LED_LAN4	14
+
+#define TL_WDR6500_V2_GPIO_BTN_RESET	1
+
+#define TL_WDR6500_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WDR6500_V2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WDR6500_V2_KEYS_POLL_INTERVAL)
+
+#define TL_WDR6500_V2_WMAC_CALDATA_OFFSET	0x1000
+#define TL_WDR6500_V2_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *tl_wdr6500_v2_part_probes[] = {
+	"tp-link-64k",
+	NULL,
+};
+
+static struct flash_platform_data tl_wdr6500_v2_flash_data = {
+	.part_probes	= tl_wdr6500_v2_part_probes,
+};
+
+static struct gpio_led tl_wdr6500_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:white:system",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_SYS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wdr6500_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WDR6500_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WDR6500_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+
+static void __init tl_ap151_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f00fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wdr6500_v2_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(ee + TL_WDR6500_V2_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+static void __init tl_wdr6500_v2_setup(void)
+{
+	tl_ap151_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wdr6500_v2_leds_gpio),
+				 tl_wdr6500_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WDR6500_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wdr6500_v2_gpio_keys),
+					tl_wdr6500_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR6500_V2, "TL-WDR6500-v2", "TP-LINK TL-WDR6500 v2",
+	     tl_wdr6500_v2_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wpa8630.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wpa8630.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wpa8630.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wpa8630.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1041n-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1041n-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1041n-v2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1041n-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd-v2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd-v2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd-v2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd-v2.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd-v4.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-tl-wr1043nd-v4.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd-v4.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd.c
new file mode 100644
index 0000000000..4e4b85d736
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr1043nd.c
@@ -0,0 +1,141 @@
+/*
+ *  TP-LINK TL-WR1043N/ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1043ND_GPIO_LED_USB        1
+#define TL_WR1043ND_GPIO_LED_SYSTEM     2
+#define TL_WR1043ND_GPIO_LED_QSS        5
+#define TL_WR1043ND_GPIO_LED_WLAN       9
+
+#define TL_WR1043ND_GPIO_BTN_RESET      3
+#define TL_WR1043ND_GPIO_BTN_QSS        7
+
+#define TL_WR1043ND_GPIO_RTL8366_SDA	18
+#define TL_WR1043ND_GPIO_RTL8366_SCK	19
+
+#define TL_WR1043ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr1043nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1043nd_flash_data = {
+	.part_probes	= tl_wr1043nd_part_probes,
+};
+
+static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043ND_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1043nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void tl_wr1043nd_rtl8366rb_hw_reset(struct rtl8366_smi *smi, bool active)
+{
+	if (active)
+		ath79_device_reset_set(AR71XX_RESET_GE0_PHY);
+	else
+		ath79_device_reset_clear(AR71XX_RESET_GE0_PHY);
+}
+
+static struct rtl8366_platform_data tl_wr1043nd_rtl8366rb_data = {
+	.gpio_sda	= TL_WR1043ND_GPIO_RTL8366_SDA,
+	.gpio_sck	= TL_WR1043ND_GPIO_RTL8366_SCK,
+	.hw_reset	= tl_wr1043nd_rtl8366rb_hw_reset,
+};
+
+static struct platform_device tl_wr1043nd_rtl8366rb_device = {
+	.name		= RTL8366RB_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr1043nd_rtl8366rb_data,
+	}
+};
+
+static void __init tl_wr1043nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	tl_wr1043nd_rtl8366rb_hw_reset(NULL, true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&tl_wr1043nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_leds_gpio),
+				 tl_wr1043nd_leds_gpio);
+
+	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR1043ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043nd_gpio_keys),
+					tl_wr1043nd_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
+	     tl_wr1043nd_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr2543n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr2543n.c
new file mode 100644
index 0000000000..141914aa29
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr2543n.c
@@ -0,0 +1,150 @@
+/*
+ *  TP-LINK TL-WR2543N/ND board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8367.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_WR2543N_GPIO_LED_WPS        0
+#define TL_WR2543N_GPIO_LED_USB        8
+
+/* The WLAN LEDs use GPIOs on the discrete AR9380 wmac */
+#define TL_WR2543N_GPIO_WMAC_LED_WLAN2G 0
+#define TL_WR2543N_GPIO_WMAC_LED_WLAN5G 1
+
+#define TL_WR2543N_GPIO_BTN_RESET      11
+#define TL_WR2543N_GPIO_BTN_WPS        12
+
+#define TL_WR2543N_GPIO_RTL8367_SDA	1
+#define TL_WR2543N_GPIO_RTL8367_SCK	6
+
+#define TL_WR2543N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR2543N_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR2543N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr2543n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr2543n_flash_data = {
+	.part_probes	= tl_wr2543n_part_probes,
+};
+
+static struct gpio_led tl_wr2543n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR2543N_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR2543N_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr2543n_wmac_leds_gpio[] = {
+	{
+		.name		= "tp-link:green:wlan2g",
+		.gpio		= TL_WR2543N_GPIO_WMAC_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan5g",
+		.gpio		= TL_WR2543N_GPIO_WMAC_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr2543n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8367_extif_config tl_wr2543n_rtl8367_extif0_cfg = {
+	.mode = RTL8367_EXTIF_MODE_RGMII,
+	.txdelay = 1,
+	.rxdelay = 0,
+	.ability = {
+		.force_mode = 1,
+		.txpause = 1,
+		.rxpause = 1,
+		.link = 1,
+		.duplex = 1,
+		.speed = RTL8367_PORT_SPEED_1000,
+	},
+};
+
+static struct rtl8367_platform_data tl_wr2543n_rtl8367_data = {
+	.gpio_sda	= TL_WR2543N_GPIO_RTL8367_SDA,
+	.gpio_sck	= TL_WR2543N_GPIO_RTL8367_SCK,
+	.extif0_cfg	= &tl_wr2543n_rtl8367_extif0_cfg,
+};
+
+static struct platform_device tl_wr2543n_rtl8367_device = {
+	.name		= RTL8367_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr2543n_rtl8367_data,
+	}
+};
+
+static void __init tl_wr2543n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr2543n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr2543n_leds_gpio),
+				 tl_wr2543n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR2543N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr2543n_gpio_keys),
+					tl_wr2543n_gpio_keys);
+	ath79_register_usb();
+
+	ap9x_pci_setup_wmac_leds(0, tl_wr2543n_wmac_leds_gpio,
+				 ARRAY_SIZE(tl_wr2543n_wmac_leds_gpio));
+	ap91_pci_init(eeprom, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_eth0_data.mii_bus_dev = &tl_wr2543n_rtl8367_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	platform_device_register(&tl_wr2543n_rtl8367_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR2543N, "TL-WR2543N", "TP-LINK TL-WR2543N/ND",
+	     tl_wr2543n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr703n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr703n.c
new file mode 100644
index 0000000000..1d8d01cc63
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr703n.c
@@ -0,0 +1,118 @@
+/*
+ *  TP-LINK TL-WR703N/TL-MR10U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR703N_GPIO_LED_SYSTEM	27
+#define TL_WR703N_GPIO_BTN_RESET	11
+
+#define TL_WR703N_GPIO_USB_POWER	8
+
+#define TL_MR10U_GPIO_USB_POWER		18
+
+#define TL_WR703N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR703N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR703N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr703n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr703n_flash_data = {
+	.part_probes	= tl_wr703n_part_probes,
+};
+
+static struct gpio_led tl_wr703n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR703N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr703n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR703N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR703N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init common_setup(unsigned usb_power_gpio, bool sec_ethernet)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_wr703n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr703n_leds_gpio),
+				 tl_wr703n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR703N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr703n_gpio_keys),
+					tl_wr703n_gpio_keys);
+
+	gpio_request_one(usb_power_gpio,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	if (sec_ethernet)
+	{
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+		ath79_register_eth(1);
+	}
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_mr10u_setup(void)
+{
+	common_setup(TL_MR10U_GPIO_USB_POWER, false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR10U, "TL-MR10U", "TP-LINK TL-MR10U",
+	     tl_mr10u_setup);
+
+static void __init tl_wr703n_setup(void)
+{
+	common_setup(TL_WR703N_GPIO_USB_POWER, false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR703N, "TL-WR703N", "TP-LINK TL-WR703N v1",
+	     tl_wr703n_setup);
+
+static void __init tl_wr710n_setup(void)
+{
+	common_setup(TL_WR703N_GPIO_USB_POWER, true);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR710N, "TL-WR710N", "TP-LINK TL-WR710N v1",
+	     tl_wr710n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr720n-v3.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr720n-v3.c
new file mode 100644
index 0000000000..2bb3b44a71
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr720n-v3.c
@@ -0,0 +1,108 @@
+/*
+ *  TP-LINK TL-WR720N board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 yousong <yszhou4tech@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR720N_GPIO_LED_SYSTEM	27
+#define TL_WR720N_GPIO_BTN_RESET	11
+#define TL_WR720N_GPIO_BTN_SW1		18
+#define TL_WR720N_GPIO_BTN_SW2		20
+
+#define TL_WR720N_GPIO_USB_POWER	8
+
+#define TL_WR720N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR720N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR720N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr720n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr720n_flash_data = {
+	.part_probes	= tl_wr720n_part_probes,
+};
+
+static struct gpio_led tl_wr720n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR720N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr720n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_SW1,
+		.active_low = 0,
+	}, {
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_SW2,
+		.active_low = 0,
+	}
+};
+
+static void __init tl_wr720n_v3_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_wr720n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr720n_leds_gpio),
+					tl_wr720n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR720N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr720n_gpio_keys),
+					tl_wr720n_gpio_keys);
+
+	gpio_request_one(TL_WR720N_GPIO_USB_POWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR720N_V3, "TL-WR720N-v3", "TP-LINK TL-WR720N v3/v4",
+		tl_wr720n_v3_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd-v4.c
new file mode 100644
index 0000000000..851b7624ff
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd-v4.c
@@ -0,0 +1,187 @@
+/*
+ *  TP-LINK TL-WR741ND v4/TL-MR3220 v2 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR741NDV4_GPIO_BTN_RESET	11
+#define TL_WR741NDV4_GPIO_BTN_WPS	26
+
+#define TL_WR741NDV4_GPIO_LED_WLAN	0
+#define TL_WR741NDV4_GPIO_LED_QSS	1
+#define TL_WR741NDV4_GPIO_LED_WAN	13
+#define TL_WR741NDV4_GPIO_LED_LAN1	14
+#define TL_WR741NDV4_GPIO_LED_LAN2	15
+#define TL_WR741NDV4_GPIO_LED_LAN3	16
+#define TL_WR741NDV4_GPIO_LED_LAN4	17
+#define TL_WR741NDV4_GPIO_LED_SYSTEM	27
+
+#define TL_MR3220V2_GPIO_BTN_WPS	11
+#define TL_MR3220V2_GPIO_BTN_WIFI	24
+
+#define TL_MR3220V2_GPIO_LED_3G		26
+#define TL_MR3220V2_GPIO_USB_POWER	8
+
+#define TL_WR741NDV4_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741NDV4_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741ndv4_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741ndv4_flash_data = {
+	.part_probes	= tl_wr741ndv4_part_probes,
+};
+
+static struct gpio_led tl_wr741ndv4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN1,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN2,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN3,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741NDV4_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741NDV4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* the 3G LED is only present on the MR3220 v2 */
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3220V2_GPIO_LED_3G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wr741ndv4_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_WPS,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button tl_mr3220v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3220V2_GPIO_BTN_WPS,
+		.active_low	= 0,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3220V2_GPIO_BTN_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_ap121_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(&tl_wr741ndv4_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wr741ndv4_setup(void)
+{
+	tl_ap121_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio) - 1,
+				 tl_wr741ndv4_leds_gpio);
+	ath79_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741ndv4_gpio_keys),
+					tl_wr741ndv4_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND_V4, "TL-WR741ND-v4",
+	     "TP-LINK TL-WR741ND v4", tl_wr741ndv4_setup);
+
+static void __init tl_mr3220v2_setup(void)
+{
+	tl_ap121_setup();
+
+	gpio_request_one(TL_MR3220V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio),
+				 tl_wr741ndv4_leds_gpio);
+	ath79_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3220v2_gpio_keys),
+					tl_mr3220v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3220_V2, "TL-MR3220-v2",
+	     "TP-LINK TL-MR3220 v2", tl_mr3220v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd.c
new file mode 100644
index 0000000000..5931654bbd
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr741nd.c
@@ -0,0 +1,130 @@
+/*
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define TL_WR741ND_GPIO_LED_QSS		0
+#define TL_WR741ND_GPIO_LED_SYSTEM	1
+#define TL_WR741ND_GPIO_LED_LAN1	13
+#define TL_WR741ND_GPIO_LED_LAN2	14
+#define TL_WR741ND_GPIO_LED_LAN3	15
+#define TL_WR741ND_GPIO_LED_LAN4	16
+#define TL_WR741ND_GPIO_LED_WAN		17
+
+#define TL_WR741ND_GPIO_BTN_RESET	11
+#define TL_WR741ND_GPIO_BTN_QSS		12
+
+#define TL_WR741ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741nd_flash_data = {
+	.part_probes	= tl_wr741nd_part_probes,
+};
+
+static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741ND_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr741nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr741nd_flash_data);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
+				 tl_wr741nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR741ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741nd_gpio_keys),
+					tl_wr741nd_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap91_pci_init(ee, mac);
+}
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
+	     tl_wr741nd_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr802n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr802n.c
new file mode 100644
index 0000000000..ece38f900f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr802n.c
@@ -0,0 +1,117 @@
+/*
+ *  TP-LINK TL-WR802N v1, v2
+ *
+ *  Copyright (C) 2015 Rick Pannen <pannen@gmail.com <mailto:pannen@gmail.com>>
+ *  Copyright (C) 2016 Thomas Roberts <tom.p.roberts@gmail.com <mailto:tom.p.roberts@gmail.com>>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR802N_GPIO_LED_SYSTEM	13
+#define TL_WR802N_GPIO_BTN_RESET	11
+
+#define TL_WR802N_KEYS_POLL_INTERVAL		20 /* msecs */
+#define TL_WR802N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR802N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr802n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr802n_flash_data = {
+	.part_probes	= tl_wr802n_part_probes,
+};
+
+static struct gpio_led tl_wr802n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR802N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wr802n_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr802n-v2:green:system",
+		.gpio		= TL_WR802N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr802n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR802N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR802N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_ap143_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wr802n_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(ee, tmpmac);
+
+	ath79_register_gpio_keys_polled(1, TL_WR802N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr802n_gpio_keys),
+					tl_wr802n_gpio_keys);
+}
+
+static void __init tl_wr802n_v1_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr802n_v1_leds_gpio),
+				 tl_wr802n_v1_leds_gpio);
+}
+
+static void __init tl_wr802n_v2_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr802n_v2_leds_gpio),
+				 tl_wr802n_v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR802N_V1, "TL-WR802N-v1", "TP-LINK TL-WR802N v1",
+		tl_wr802n_v1_setup);
+
+MIPS_MACHINE(ATH79_MACH_TL_WR802N_V2, "TL-WR802N-v2", "TP-LINK TL-WR802N v2",
+		tl_wr802n_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr810n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr810n.c
new file mode 100644
index 0000000000..588bb9d861
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr810n.c
@@ -0,0 +1,149 @@
+/*
+ * TP-LINK TL-WR810N board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2016 Jens Steinhauser <jens.steinhauser@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR810N_GPIO_SWITCH_B1	0
+#define TL_WR810N_GPIO_SWITCH_B0	1
+#define TL_WR810N_GPIO_USB_POWER	11
+#define TL_WR810N_GPIO_BTN_RESET	12
+#define TL_WR810N_GPIO_LED_SYSTEM	13
+
+#define TL_WR810N_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TL_WR810N_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR810N_KEYS_POLL_INTERVAL)
+
+#define TL_WR810N_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *tl_wr810n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr810n_flash_data = {
+	.part_probes = tl_wr810n_part_probes,
+};
+
+static struct gpio_led tl_wr810n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR810N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr810n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR810N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR810N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "switch_b0",
+		.type		= EV_SW,
+		.code		= BTN_0,
+		.debounce_interval = TL_WR810N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR810N_GPIO_SWITCH_B0,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "switch_b1",
+		.type		= EV_SW,
+		.code		= BTN_1,
+		.debounce_interval = TL_WR810N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR810N_GPIO_SWITCH_B1,
+		.active_low	= 0,
+	},
+};
+
+static void __init tl_ap143_setup(int lan_mac_offset)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&tl_wr810n_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* WAN */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, lan_mac_offset);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + TL_WR810N_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_register_leds_gpio(-1,
+				 ARRAY_SIZE(tl_wr810n_leds_gpio),
+				 tl_wr810n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1,
+					TL_WR810N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr810n_gpio_keys),
+					tl_wr810n_gpio_keys);
+}
+
+static void __init tl_wr810n_setup(void)
+{
+	tl_ap143_setup(-1);
+
+	gpio_request_one(TL_WR810N_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+}
+
+static void __init tl_wr810n_v2_setup(void)
+{
+	tl_ap143_setup(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR810N, "TL-WR810N", "TP-LINK TL-WR810N",
+	     tl_wr810n_setup);
+
+MIPS_MACHINE(ATH79_MACH_TL_WR810N_V2, "TL-WR810N-v2", "TP-LINK TL-WR810N v2",
+	     tl_wr810n_v2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v8.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v8.c
new file mode 100644
index 0000000000..73cfdd9cc6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v8.c
@@ -0,0 +1,286 @@
+/*
+ *  TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR841NV8_GPIO_LED_WLAN	13
+#define TL_WR841NV8_GPIO_LED_QSS	15
+#define TL_WR841NV8_GPIO_LED_WAN	18
+#define TL_WR841NV8_GPIO_LED_LAN1	19
+#define TL_WR841NV8_GPIO_LED_LAN2	20
+#define TL_WR841NV8_GPIO_LED_LAN3	21
+#define TL_WR841NV8_GPIO_LED_LAN4	12
+#define TL_WR841NV8_GPIO_LED_SYSTEM	14
+
+#define TL_WR841NV8_GPIO_BTN_RESET	17
+#define TL_WR841NV8_GPIO_SW_RFKILL	16	/* WPS for MR3420 v2 */
+
+#define TL_MR3420V2_GPIO_LED_3G	11
+#define TL_MR3420V2_GPIO_USB_POWER	4
+
+#define TL_WR941NDV5_GPIO_LED_WLAN	13
+#define TL_WR941NDV5_GPIO_LED_QSS	15
+#define TL_WR941NDV5_GPIO_LED_WAN	18
+#define TL_WR941NDV5_GPIO_LED_LAN1	19
+#define TL_WR941NDV5_GPIO_LED_LAN2	20
+#define TL_WR941NDV5_GPIO_LED_LAN3	2
+#define TL_WR941NDV5_GPIO_LED_LAN4	3
+#define TL_WR941NDV5_GPIO_LED_SYSTEM	14
+
+#define TL_WR841NV8_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR841NV8_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr841n_v8_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr841n_v8_flash_data = {
+	.part_probes	= tl_wr841n_v8_part_probes,
+};
+
+static struct gpio_led tl_wr841n_v8_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841NV8_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841NV8_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR841NV8_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR841NV8_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		/* the 3G LED is only present on the MR3420 v2 */
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3420V2_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr841n_v8_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button tl_mr3420v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led tl_wr941nd_v5_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR941NDV5_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR941NDV5_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR941NDV5_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941NDV5_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	/* config gpio4 as normal gpio function */
+	ath79_gpio_output_select(TL_MR3420V2_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&tl_wr841n_v8_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wr841n_v8_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio) - 1,
+				 tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V8, "TL-WR841N-v8", "TP-LINK TL-WR841N/ND v8",
+	     tl_wr841n_v8_setup);
+
+
+static void __init tl_wr842n_v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio),
+				 tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+
+	gpio_request_one(TL_MR3420V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR842N_V2, "TL-WR842N-v2", "TP-LINK TL-WR842N/ND v2",
+	     tl_wr842n_v2_setup);
+
+static void __init tl_mr3420v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio),
+				tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(tl_mr3420v2_gpio_keys),
+				tl_mr3420v2_gpio_keys);
+
+	/* enable power for the USB port */
+	gpio_request_one(TL_MR3420V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3420_V2, "TL-MR3420-v2", "TP-LINK TL-MR3420 v2",
+	     tl_mr3420v2_setup);
+
+
+static void __init tl_wr941nd_v5_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_v5_leds_gpio),
+				 tl_wr941nd_v5_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND_V5, "TL-WR941ND-v5", "TP-LINK TL-WR941N/ND v5",
+	     tl_wr941nd_v5_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v9.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v9.c
new file mode 100644
index 0000000000..304d8ff6e9
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n-v9.c
@@ -0,0 +1,457 @@
+/*
+ *  TP-LINK TL-WR840N v2/v3 / TL-WR841N/ND v9/v11 / TL-WR842N/ND v3
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2016 Cezary Jackiewicz <cezary@eko.one.pl>
+ *  Copyright (C) 2016 Stijn Segers <francesco.borromini@gmail.com>
+ *  Copyright (C) 2017 Vaclav Svoboda <svoboda@neng.cz>
+ *  Copyright (C) 2017 Andrey Polischuk <androld.b@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR840NV2_GPIO_LED_SYSTEM	15
+#define TL_WR840NV2_GPIO_LED_WLAN	13
+#define TL_WR840NV2_GPIO_LED_WPS	3
+#define TL_WR840NV2_GPIO_LED_WAN	4
+#define TL_WR840NV2_GPIO_LED_LAN	16
+
+#define TL_WR840NV2_GPIO_BTN_RESET	12
+
+#define TL_WR841NV9_GPIO_LED_WLAN	13
+#define TL_WR841NV9_GPIO_LED_QSS	3
+#define TL_WR841NV9_GPIO_LED_WAN	4
+#define TL_WR841NV9_GPIO_LED_LAN1	16
+#define TL_WR841NV9_GPIO_LED_LAN2	15
+#define TL_WR841NV9_GPIO_LED_LAN3	14
+#define TL_WR841NV9_GPIO_LED_LAN4	11
+
+#define TL_WR841NV9_GPIO_BTN_RESET	12
+#define TL_WR841NV9_GPIO_BTN_WIFI	17
+
+#define TL_WR841NV11_GPIO_LED_SYSTEM	1
+#define TL_WR841NV11_GPIO_LED_QSS	3
+#define TL_WR841NV11_GPIO_LED_WAN	4
+#define TL_WR841NV11_GPIO_LED_WAN_STATUS	2
+#define TL_WR841NV11_GPIO_LED_WLAN	13
+#define TL_WR841NV11_GPIO_LED_LAN1	16
+#define TL_WR841NV11_GPIO_LED_LAN2	15
+#define TL_WR841NV11_GPIO_LED_LAN3	14
+#define TL_WR841NV11_GPIO_LED_LAN4	11
+
+#define TL_WR841NV11_GPIO_BTN_RESET	12
+#define TL_WR841NV11_GPIO_BTN_WIFI	17
+
+#define TL_WR842NV3_GPIO_LED_SYSTEM	2
+#define TL_WR842NV3_GPIO_LED_WLAN	3
+#define TL_WR842NV3_GPIO_LED_WAN_RED	4
+#define TL_WR842NV3_GPIO_LED_WAN_GREEN	11
+#define TL_WR842NV3_GPIO_LED_LAN1	12
+#define TL_WR842NV3_GPIO_LED_LAN2	13
+#define TL_WR842NV3_GPIO_LED_LAN3	14
+#define TL_WR842NV3_GPIO_LED_LAN4	15
+#define TL_WR842NV3_GPIO_LED_3G		16
+#define TL_WR842NV3_GPIO_LED_WPS	17
+
+#define TL_WR842NV3_GPIO_BTN_RESET	1
+#define TL_WR842NV3_GPIO_BTN_WIFI	0
+
+#define TL_WR740NV6_GPIO_LED_SYSTEM	1
+#define TL_WR740NV6_GPIO_LED_QSS	3
+#define TL_WR740NV6_GPIO_LED_WAN_ORANGE	2
+#define TL_WR740NV6_GPIO_LED_WAN_GREEN	4
+#define TL_WR740NV6_GPIO_LED_LAN1	16
+#define TL_WR740NV6_GPIO_LED_LAN2	15
+#define TL_WR740NV6_GPIO_LED_LAN3	14
+#define TL_WR740NV6_GPIO_LED_LAN4	11
+#define TL_WR740NV6_GPIO_LED_WLAN	13
+
+#define TL_WR740NV6_GPIO_BTN_RESET	12
+#define TL_WR740NV6_GPIO_BTN_WIFI	17
+
+#define TL_WR841NV9_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR841NV9_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr841n_v9_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr841n_v9_flash_data = {
+	.part_probes	= tl_wr841n_v9_part_probes,
+};
+
+static struct gpio_led tl_wr840n_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR840NV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WR840NV2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR840NV2_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR840NV2_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR840NV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr840n_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR840NV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr841n_v9_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841NV9_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr841n_v9_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV9_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV9_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr841n_v11_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841NV9_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841NV11_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan_status",
+		.gpio		= TL_WR841NV11_GPIO_LED_WAN_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wr842n_v3_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR842NV3_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR842NV3_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR842NV3_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR842NV3_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR842NV3_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:wan",
+		.gpio		= TL_WR842NV3_GPIO_LED_WAN_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR842NV3_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR842NV3_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_WR842NV3_GPIO_LED_3G,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR842NV3_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr842n_v3_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR842NV3_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR842NV3_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr740n_v6_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR740NV6_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR740NV6_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR740NV6_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR740NV6_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR740NV6_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR740NV6_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR740NV6_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:wan",
+		.gpio		= TL_WR740NV6_GPIO_LED_WAN_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR740NV6_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr740n_v6_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR740NV6_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR740NV6_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_ap143_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wr841n_v9_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(ee, tmpmac);
+}
+
+
+static void __init tl_wr840n_v2_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr840n_v2_leds_gpio),
+				 tl_wr840n_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr840n_v2_gpio_keys),
+					tl_wr840n_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR840N_V2, "TL-WR840N-v2", "TP-LINK TL-WR840N v2",
+	     tl_wr840n_v2_setup);
+
+MIPS_MACHINE(ATH79_MACH_TL_WR840N_V3, "TL-WR840N-v3", "TP-LINK TL-WR840N v3",
+	     tl_wr840n_v2_setup);
+
+static void __init tl_wr841n_v9_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v9_leds_gpio),
+				 tl_wr841n_v9_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v9_gpio_keys),
+					tl_wr841n_v9_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V9, "TL-WR841N-v9", "TP-LINK TL-WR841N/ND v9",
+	     tl_wr841n_v9_setup);
+
+static void __init tl_wr841n_v11_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v11_leds_gpio),
+				 tl_wr841n_v11_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v9_gpio_keys),
+					tl_wr841n_v9_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V11, "TL-WR841N-v11", "TP-LINK TL-WR841N/ND v11",
+	     tl_wr841n_v11_setup);
+
+static void __init tl_wr842n_v3_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr842n_v3_leds_gpio),
+				 tl_wr842n_v3_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr842n_v3_gpio_keys),
+					tl_wr842n_v3_gpio_keys);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR842N_V3, "TL-WR842N-v3", "TP-LINK TL-WR842N/ND v3",
+	     tl_wr842n_v3_setup);
+
+static void __init tl_wr740n_v6_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr740n_v6_leds_gpio),
+				 tl_wr740n_v6_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr740n_v6_gpio_keys),
+					tl_wr740n_v6_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR740N_V6, "TL-WR740N-v6", "TP-LINK TL-WR740N/ND v6",
+	     tl_wr740n_v6_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n.c
new file mode 100644
index 0000000000..11f853f057
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr841n.c
@@ -0,0 +1,140 @@
+/*
+ *  TP-LINK TL-WR841N/ND v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WR841ND_V1_GPIO_LED_SYSTEM		2
+#define TL_WR841ND_V1_GPIO_LED_QSS_GREEN	4
+#define TL_WR841ND_V1_GPIO_LED_QSS_RED		5
+
+#define TL_WR841ND_V1_GPIO_BTN_RESET		3
+#define TL_WR841ND_V1_GPIO_BTN_QSS		7
+
+#define TL_WR841ND_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL \
+				(3 * TL_WR841ND_V1_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition tl_wr841n_v1_partitions[] = {
+	{
+		.name		= "redboot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x280000,
+	}, {
+		.name		= "config",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3c0000,
+	}
+};
+
+static struct flash_platform_data tl_wr841n_v1_flash_data = {
+	.parts		= tl_wr841n_v1_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr841n_v1_partitions),
+};
+
+static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_keys_button tl_wr841n_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr841n_v1_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr841n_v1_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr841n_v1_dsa_chip,
+};
+
+static void __init tl_wr841n_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr841n_v1_dsa_data);
+
+	ath79_register_m25p80(&tl_wr841n_v1_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
+				 tl_wr841n_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR841ND_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v1_gpio_keys),
+					tl_wr841n_v1_gpio_keys);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V1, "TL-WR841N-v1.5", "TP-LINK TL-WR841N v1",
+	     tl_wr841n_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr902ac-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr902ac-v1.c
new file mode 100644
index 0000000000..8d2cea828a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr902ac-v1.c
@@ -0,0 +1,145 @@
+/*
+ * TP-Link TL-WR902AC v1 board support
+ *
+ * Copyright (C) 2017 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define TL_WR902AC_V1_GPIO_LED_INTERNET	12
+#define TL_WR902AC_V1_GPIO_LED_LAN	15
+#define TL_WR902AC_V1_GPIO_LED_POWER	13
+#define TL_WR902AC_V1_GPIO_LED_USB	4
+#define TL_WR902AC_V1_GPIO_LED_WLAN2G	11
+#define TL_WR902AC_V1_GPIO_LED_WPS	0
+
+#define TL_WR902AC_V1_GPIO_BTN_RESET	3
+#define TL_WR902AC_V1_GPIO_BTN_SW1	17
+#define TL_WR902AC_V1_GPIO_BTN_SW2	14
+#define TL_WR902AC_V1_GPIO_BTN_WPS	2
+
+#define TL_WR902AC_V1_GPIO_USB_POWER	1
+
+#define TL_WR902AC_V1_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TL_WR902AC_V1_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * TL_WR902AC_V1_KEYS_POLL_INTERVAL)
+
+static struct gpio_led tl_wr902ac_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr902ac-v1:green:internet",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr902ac-v1:green:lan",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_LAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tl-wr902ac-v1:green:power",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "tl-wr902ac-v1:green:usb",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_USB,
+		.active_low	= 0,
+	}, {
+		.name		= "tl-wr902ac-v1:green:wlan2g",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr902ac-v1:green:wps",
+		.gpio		= TL_WR902AC_V1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr902ac_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR902AC_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR902AC_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WR902AC_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR902AC_V1_GPIO_BTN_SW1,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WR902AC_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR902AC_V1_GPIO_BTN_SW2,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR902AC_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR902AC_V1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr902ac_v1_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f7f0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f750008);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr902ac_v1_leds_gpio),
+				 tl_wr902ac_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR902AC_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr902ac_v1_gpio_keys),
+					tl_wr902ac_v1_gpio_keys);
+
+	gpio_request_one(TL_WR902AC_V1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + 0x1000, mac);
+
+	ap91_pci_init(art + 0x5000, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR902AC_V1, "TL-WR902AC-V1", "TP-LINK TL-WR902AC v1",
+	     tl_wr902ac_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr940n-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr940n-v4.c
new file mode 100644
index 0000000000..b530622d9f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr940n-v4.c
@@ -0,0 +1,184 @@
+/*
+ *  TP-LINK TL-WR940N v4 and v6 board support
+ *
+ *  Copyright (C) 2016 David Lutz <kpanic@ff3l.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define TL_WR940N_V4_GPIO_LED_QSS		3
+#define TL_WR940N_V4_GPIO_LED_WAN		14
+#define TL_WR940N_V4_GPIO_LED_WAN_RED		15
+#define TL_WR940N_V4_GPIO_LED_LAN4		4
+#define TL_WR940N_V4_GPIO_LED_LAN3		18
+#define TL_WR940N_V4_GPIO_LED_LAN2		6
+#define TL_WR940N_V4_GPIO_LED_LAN1		8
+#define TL_WR940N_V4_GPIO_LED_WLAN		7
+#define TL_WR940N_V4_GPIO_LED_SYSTEM		5
+/* WR940N v6 specific GPIO*/
+#define TL_WR940N_V6_GPIO_LED_DIAG_ORANGE	15
+#define TL_WR940N_V6_GPIO_LED_WAN_BLUE		14
+
+#define TL_WR940N_V4_GPIO_BTN_RESET		1
+#define TL_WR940N_V4_GPIO_BTN_RFKILL		2
+
+#define TL_WR940N_KEYS_POLL_INTERVAL		20
+#define TL_WR940N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR940N_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led tl_wr940n_v4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= TL_WR940N_V4_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wan",
+		.gpio		= TL_WR940N_V4_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:red:wan",
+		.gpio		= TL_WR940N_V4_GPIO_LED_WAN_RED,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:blue:lan1",
+		.gpio		= TL_WR940N_V4_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan2",
+		.gpio		= TL_WR940N_V4_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan3",
+		.gpio		= TL_WR940N_V4_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan4",
+		.gpio		= TL_WR940N_V4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WR940N_V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR940N_V4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr940n_v4_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR940N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR940N_V4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR940N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR940N_V4_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr940n_v6_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:wan",
+		.gpio		= TL_WR940N_V6_GPIO_LED_WAN_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:orange:diag",
+		.gpio		= TL_WR940N_V6_GPIO_LED_DIAG_ORANGE,
+		.active_low	= 0,
+	},
+};
+
+
+static const char *tl_wr940n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr940n_flash_data = {
+	.part_probes	= tl_wr940n_part_probes,
+};
+
+
+static void __init tl_wr940n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr940n_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+}
+
+static void __init tl_wr940n_v4_setup(void)
+{
+	tl_wr940n_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr940n_v4_leds_gpio),
+				 tl_wr940n_v4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR940N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr940n_v4_gpio_keys),
+					tl_wr940n_v4_gpio_keys);
+}
+
+static void __init tl_wr940n_v6_setup(void)
+{
+	tl_wr940n_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr940n_v6_leds_gpio),
+				 tl_wr940n_v6_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR940N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr940n_v4_gpio_keys),
+					tl_wr940n_v4_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR940N_V4, "TL-WR940N-v4", "TP-LINK TL-WR940N v4",
+	     tl_wr940n_v4_setup);
+MIPS_MACHINE(ATH79_MACH_TL_WR940N_V6, "TL-WR940N-v6", "TP-LINK TL-WR940N v6",
+	     tl_wr940n_v6_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd-v6.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd-v6.c
new file mode 100644
index 0000000000..8c788e2841
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd-v6.c
@@ -0,0 +1,149 @@
+/*
+ *  TP-LINK TL-WR941N/ND v6 board support
+ *
+ *  Copyright (C) 2015 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define TL_WR941ND_V6_GPIO_LED_QSS		3
+#define TL_WR941ND_V6_GPIO_LED_WAN		14
+#define TL_WR941ND_V6_GPIO_LED_WAN_RED		15
+#define TL_WR941ND_V6_GPIO_LED_LAN1		7
+#define TL_WR941ND_V6_GPIO_LED_LAN2		6
+#define TL_WR941ND_V6_GPIO_LED_LAN3		5
+#define TL_WR941ND_V6_GPIO_LED_LAN4		4
+#define TL_WR941ND_V6_GPIO_LED_WLAN		8
+#define TL_WR941ND_V6_GPIO_LED_SYSTEM		18
+
+#define TL_WR941ND_V6_GPIO_BTN_RESET		1
+#define TL_WR941ND_V6_GPIO_BTN_RFKILL		2
+
+#define TL_WR941ND_V6_KEYS_POLL_INTERVAL	20
+#define TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR941ND_V6_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led tl_wr941nd_v6_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:red:wan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WAN_RED,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:blue:lan1",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan2",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan3",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan4",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr941nd_v6_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_V6_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_V6_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	}
+};
+
+
+static const char *tl_wr941n_v6_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr941n_v6_flash_data = {
+	.part_probes	= tl_wr941n_v6_part_probes,
+};
+
+
+static void __init tl_wr941nd_v6_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr941n_v6_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_v6_leds_gpio),
+				 tl_wr941nd_v6_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR941ND_V6_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_v6_gpio_keys),
+					tl_wr941nd_v6_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND_V6, "TL-WR941ND-v6", "TP-LINK TL-WR941N/ND v6",
+	     tl_wr941nd_v6_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd.c
new file mode 100644
index 0000000000..1ddeec730e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr941nd.c
@@ -0,0 +1,121 @@
+/*
+ *  TP-LINK TL-WR941ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR941ND_GPIO_LED_SYSTEM	2
+#define TL_WR941ND_GPIO_LED_QSS_RED	4
+#define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+#define TL_WR941ND_GPIO_LED_WLAN	9
+
+#define TL_WR941ND_GPIO_BTN_RESET	3
+#define TL_WR941ND_GPIO_BTN_QSS		7
+
+#define TL_WR941ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR941ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR941ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr941nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr941nd_flash_data = {
+	.part_probes	= tl_wr941nd_part_probes,
+};
+
+static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr941nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr941nd_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr941nd_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr941nd_dsa_chip,
+};
+
+static void __init tl_wr941nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr941nd_dsa_data);
+
+	ath79_register_m25p80(&tl_wr941nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
+				 tl_wr941nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR941ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_gpio_keys),
+					tl_wr941nd_gpio_keys);
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
+	     tl_wr941nd_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr942n-v1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr942n-v1.c
new file mode 100644
index 0000000000..32e2bc9521
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tl-wr942n-v1.c
@@ -0,0 +1,279 @@
+/*
+ *  TP-Link TL-WR942N(RU) v1 board support
+ *
+ *  Copyright (C) 2017 Sergey Studzinski <serguzhg@gmail.com>
+ *  Thanks to Henryk Heisig <hyniu@o2.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/74x164.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "nvram.h"
+
+#define TL_WR942N_V1_KEYS_POLL_INTERVAL		20
+#define TL_WR942N_V1_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WR942N_V1_KEYS_POLL_INTERVAL)
+
+#define TL_WR942N_V1_GPIO_BTN_RESET		1
+#define TL_WR942N_V1_GPIO_BTN_RFKILL		2
+
+#define TL_WR942N_V1_GPIO_UART_TX		4
+#define TL_WR942N_V1_GPIO_UART_RX		5
+
+#define TL_WR942N_V1_GPIO_LED_USB2		14
+#define TL_WR942N_V1_GPIO_LED_USB1		15
+
+#define TL_WR942N_V1_GPIO_SHIFT_OE		16
+#define TL_WR942N_V1_GPIO_SHIFT_SER		17
+#define TL_WR942N_V1_GPIO_SHIFT_SRCLK		18
+#define TL_WR942N_V1_GPIO_SHIFT_SRCLR		19
+#define TL_WR942N_V1_GPIO_SHIFT_RCLK		20
+#define TL_WR942N_V1_GPIO_LED_WPS		21
+#define TL_WR942N_V1_GPIO_LED_STATUS		22
+
+#define TL_WR942N_V1_74HC_GPIO_BASE		32
+#define TL_WR942N_V1_74HC_GPIO_LED_LAN4		(TL_WR942N_V1_74HC_GPIO_BASE + 0)
+#define TL_WR942N_V1_74HC_GPIO_LED_LAN3		(TL_WR942N_V1_74HC_GPIO_BASE + 1)
+#define TL_WR942N_V1_74HC_GPIO_LED_LAN2		(TL_WR942N_V1_74HC_GPIO_BASE + 2)
+#define TL_WR942N_V1_74HC_GPIO_LED_LAN1		(TL_WR942N_V1_74HC_GPIO_BASE + 3)
+#define TL_WR942N_V1_74HC_GPIO_LED_WAN_GREEN	(TL_WR942N_V1_74HC_GPIO_BASE + 4)
+#define TL_WR942N_V1_74HC_GPIO_LED_WAN_AMBER	(TL_WR942N_V1_74HC_GPIO_BASE + 5)
+#define TL_WR942N_V1_74HC_GPIO_LED_WLAN		(TL_WR942N_V1_74HC_GPIO_BASE + 6)
+#define TL_WR942N_V1_74HC_GPIO_HUB_RESET	(TL_WR942N_V1_74HC_GPIO_BASE + 7) /* from u-boot sources */
+
+#define TL_WR942N_V1_SSR_BIT_0			0
+#define TL_WR942N_V1_SSR_BIT_1			1
+#define TL_WR942N_V1_SSR_BIT_2			2
+#define TL_WR942N_V1_SSR_BIT_3			3
+#define TL_WR942N_V1_SSR_BIT_4			4
+#define TL_WR942N_V1_SSR_BIT_5			5
+#define TL_WR942N_V1_SSR_BIT_6			6
+#define TL_WR942N_V1_SSR_BIT_7			7
+
+#define TL_WR942N_V1_WMAC_CALDATA_OFFSET	0x1000
+#define TL_WR942N_V1_DEFAULT_MAC_ADDR		0x1fe40008
+#define TL_WR942N_V1_DEFAULT_MAC_SIZE		0x200
+
+#define GPIO_IN_ENABLE0_UART_SIN_LSB		8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK		0x0000ff00
+
+static struct gpio_led tl_wr942n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr942n-v1:green:status",
+		.gpio		= TL_WR942N_V1_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:wlan",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:lan1",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:lan2",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:lan3",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:lan4",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:wan",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:amber:wan",
+		.gpio		= TL_WR942N_V1_74HC_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:wps",
+		.gpio		= TL_WR942N_V1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:usb1",
+		.gpio		= TL_WR942N_V1_GPIO_LED_USB1,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr942n-v1:green:usb2",
+		.gpio		= TL_WR942N_V1_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr942n_v1_gpio_keys[] __initdata = {
+	{
+		.desc			= "Reset button",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= TL_WR942N_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WR942N_V1_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "RFKILL button",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= TL_WR942N_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= TL_WR942N_V1_GPIO_BTN_RFKILL,
+		.active_low		= 1,
+	},
+};
+
+static struct spi_gpio_platform_data tl_wr942n_v1_spi_data = {
+	.sck		= TL_WR942N_V1_GPIO_SHIFT_SRCLK,
+	.miso		= SPI_GPIO_NO_MISO,
+	.mosi		= TL_WR942N_V1_GPIO_SHIFT_SER,
+	.num_chipselect	= 1,
+};
+
+static u8 tl_wr942n_v1_ssr_initdata[] = {
+	BIT(TL_WR942N_V1_SSR_BIT_7) |
+	BIT(TL_WR942N_V1_SSR_BIT_6) |
+	BIT(TL_WR942N_V1_SSR_BIT_5) |
+	BIT(TL_WR942N_V1_SSR_BIT_4) |
+	BIT(TL_WR942N_V1_SSR_BIT_3) |
+	BIT(TL_WR942N_V1_SSR_BIT_2) |
+	BIT(TL_WR942N_V1_SSR_BIT_1) |
+	BIT(TL_WR942N_V1_SSR_BIT_0)
+};
+
+static struct gen_74x164_chip_platform_data tl_wr942n_v1_ssr_data = {
+	.base		= TL_WR942N_V1_74HC_GPIO_BASE,
+	.num_registers	= ARRAY_SIZE(tl_wr942n_v1_ssr_initdata),
+	.init_data	= tl_wr942n_v1_ssr_initdata,
+};
+
+static struct platform_device tl_wr942n_v1_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &tl_wr942n_v1_spi_data,
+	},
+};
+
+static struct spi_board_info tl_wr942n_v1_spi_info[] = {
+	{
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 10000000,
+		.modalias		= "74x164",
+		.platform_data		= &tl_wr942n_v1_ssr_data,
+		.controller_data	= (void *) TL_WR942N_V1_GPIO_SHIFT_RCLK,
+	},
+};
+
+static void tl_wr942n_v1_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(TL_WR942N_V1_DEFAULT_MAC_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, TL_WR942N_V1_DEFAULT_MAC_SIZE,
+					 name, mac);
+
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init tl_wr942n_v1_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+	void __iomem *base;
+	u32 t;
+
+	ath79_register_m25p80(NULL);
+
+	spi_register_board_info(tl_wr942n_v1_spi_info,
+				ARRAY_SIZE(tl_wr942n_v1_spi_info));
+	platform_device_register(&tl_wr942n_v1_spi_device);
+
+	/* Check inherited UART RX GPIO definition */
+	base = ioremap(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+
+	t = __raw_readl(base + QCA956X_GPIO_REG_IN_ENABLE0);
+	if (((t & GPIO_IN_ENABLE0_UART_SIN_MASK)
+	     >> GPIO_IN_ENABLE0_UART_SIN_LSB) == TL_WR942N_V1_GPIO_LED_USB1) {
+		pr_warn("Active UART detected on USBLED's GPIOs!\n");
+
+		tl_wr942n_v1_leds_gpio[9].gpio = TL_WR942N_V1_GPIO_UART_TX;
+		tl_wr942n_v1_leds_gpio[10].gpio = TL_WR942N_V1_GPIO_UART_RX;
+	}
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr942n_v1_leds_gpio),
+				 tl_wr942n_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR942N_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr942n_v1_gpio_keys),
+					tl_wr942n_v1_gpio_keys);
+
+	tl_wr942n_v1_get_mac("MAC:", tmpmac);
+
+	/* swap PHYs */
+	ath79_setup_qca956x_eth_cfg(QCA956X_ETH_CFG_SW_PHY_SWAP |
+				    QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	/* WAN port */
+	ath79_init_mac(ath79_eth0_data.mac_addr, tmpmac, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	/* swaped PHYs */
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, tmpmac, 0);
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	/* swaped PHYs */
+	ath79_switch_data.phy_poll_mask |= BIT(0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + TL_WR942N_V1_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_usb();
+
+	gpio_request_one(TL_WR942N_V1_74HC_GPIO_HUB_RESET,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	gpio_request_one(TL_WR942N_V1_GPIO_SHIFT_OE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "LED control");
+
+	gpio_request_one(TL_WR942N_V1_GPIO_SHIFT_SRCLR,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "LED reset");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR942N_V1, "TL-WR942N-V1", "TP-LINK TL-WR942N v1",
+	     tl_wr942n_v1_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ts-d084.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ts-d084.c
new file mode 100644
index 0000000000..38786fdeda
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ts-d084.c
@@ -0,0 +1,86 @@
+/*
+ *  PISEN TS-D084 board support
+ *  Based on TP-LINK TL-WR703N/TL-MR10U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TS_D084_GPIO_LED_SYSTEM	0
+#define TS_D084_GPIO_BTN_RESET	12
+
+
+#define TS_D084_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TS_D084_KEYS_DEBOUNCE_INTERVAL	(3 * TS_D084_KEYS_POLL_INTERVAL)
+
+static const char *ts_d084_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ts_d084_flash_data = {
+	.part_probes	= ts_d084_part_probes,
+};
+
+static struct gpio_led ts_d084_leds_gpio[] __initdata = {
+	{
+		.name		= "ts-d084:blue:system",
+		.gpio		= TS_D084_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ts_d084_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TS_D084_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TS_D084_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init ts_d084_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&ts_d084_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ts_d084_leds_gpio),
+				 ts_d084_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TS_D084_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ts_d084_gpio_keys),
+					ts_d084_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TS_D084, "TS-D084", "PISEN TS-D084",
+	     ts_d084_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tube2h.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tube2h.c
new file mode 100644
index 0000000000..06b3616536
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-tube2h.c
@@ -0,0 +1,129 @@
+/*
+ *  ALFA NETWORK Tube2H board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TUBE2H_GPIO_LED_SIGNAL4		0
+#define TUBE2H_GPIO_LED_SIGNAL3		1
+#define TUBE2H_GPIO_LED_SIGNAL2		13
+#define TUBE2H_GPIO_LED_LAN		17
+#define TUBE2H_GPIO_LED_SIGNAL1		27
+#define TUBE2H_GPIO_EXT_LNA		28
+
+#define TUBE2H_GPIO_WDT_EN		22
+#define TUBE2H_GPIO_WDT_IN		18
+
+#define TUBE2H_GPIO_BTN_RESET		12
+
+#define TUBE2H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TUBE2H_KEYS_DEBOUNCE_INTERVAL	(3 * TUBE2H_KEYS_POLL_INTERVAL)
+
+#define TUBE2H_ART_ADDRESS		0x1fff0000
+#define TUBE2H_LAN_MAC_OFFSET		0x06
+#define TUBE2H_CALDATA_OFFSET		0x1000
+
+static struct gpio_led tube2h_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:blue:lan",
+		.gpio		= TUBE2H_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:red:signal1",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:orange:signal2",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL2,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:green:signal3",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL3,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:green:signal4",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL4,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tube2h_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TUBE2H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TUBE2H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init tube2h_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TUBE2H_ART_ADDRESS);
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_JTAG_DISABLE |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	/* Ensure that GPIO26 and GPIO27 are controllable by software */
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	gpio_request_one(TUBE2H_GPIO_EXT_LNA,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"external LNA0");
+
+	gpio_request_one(TUBE2H_GPIO_WDT_IN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT input");
+
+	gpio_request_one(TUBE2H_GPIO_WDT_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "WDT enable");
+
+	ath79_register_wmac(art + TUBE2H_CALDATA_OFFSET, NULL);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tube2h_leds_gpio),
+				 tube2h_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TUBE2H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tube2h_gpio_keys),
+					tube2h_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + TUBE2H_LAN_MAC_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TUBE2H, "TUBE2H", "ALFA NETWORK Tube2H",
+	     tube2h_setup);
+
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt-unifiac.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt-unifiac.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt-unifiac.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt-unifiac.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt-xm.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt-xm.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-ubnt-xm.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt-xm.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt.c
new file mode 100644
index 0000000000..e49ac23fd1
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-ubnt.c
@@ -0,0 +1,205 @@
+/*
+ *  Ubiquiti RouterStation support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008 Ubiquiti <support@ubnt.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define UBNT_RS_GPIO_LED_RF	2
+#define UBNT_RS_GPIO_SW4	8
+
+#define UBNT_LS_SR71_GPIO_LED_D25	0
+#define UBNT_LS_SR71_GPIO_LED_D26	1
+#define UBNT_LS_SR71_GPIO_LED_D24	2
+#define UBNT_LS_SR71_GPIO_LED_D23	4
+#define UBNT_LS_SR71_GPIO_LED_D22	5
+#define UBNT_LS_SR71_GPIO_LED_D27	6
+#define UBNT_LS_SR71_GPIO_LED_D28	7
+
+#define UBNT_KEYS_POLL_INTERVAL		20	/* msecs */
+#define UBNT_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:rf",
+		.gpio		= UBNT_RS_GPIO_LED_RF,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_ls_sr71_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:d22",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D22,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d23",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D23,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d24",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D24,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d25",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D25,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d26",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D26,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d27",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D27,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d28",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D28,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ubnt_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= UBNT_RS_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static const char *ubnt_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ubnt_flash_data = {
+	.part_probes	= ubnt_part_probes,
+};
+
+static void __init ubnt_generic_setup(void)
+{
+	ath79_register_m25p80(&ubnt_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_gpio_keys),
+					ubnt_gpio_keys);
+	ath79_register_pci();
+}
+
+#define UBNT_RS_WAN_PHYMASK	BIT(20)
+#define UBNT_RS_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+
+static void __init ubnt_rs_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
+	     ubnt_rs_setup);
+
+#define UBNT_RSPRO_WAN_PHYMASK	BIT(4)
+#define UBNT_RSPRO_LAN_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_rspro_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RSPRO_WAN_PHYMASK |
+				 UBNT_RSPRO_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RSPRO, "UBNT-RSPRO", "Ubiquiti RouterStation Pro",
+	     ubnt_rspro_setup);
+
+static void __init ubnt_lsx_setup(void)
+{
+	ubnt_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
+
+#define UBNT_LSSR71_PHY_MASK	BIT(1)
+
+static void __init ubnt_lssr71_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~UBNT_LSSR71_PHY_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
+
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_ls_sr71_leds_gpio),
+				 ubnt_ls_sr71_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
+	     ubnt_lssr71_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wam250.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wam250.c
new file mode 100644
index 0000000000..31817bddf2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wam250.c
@@ -0,0 +1,122 @@
+/*
+ * Samsung WAM250 board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WAM250_GPIO_LED_LAN		13
+#define WAM250_GPIO_LED_POWER		15
+#define WAM250_GPIO_LED_REPEATER	14
+#define WAM250_GPIO_LED_WLAN		12
+
+#define WAM250_GPIO_BTN_RESET		17
+#define WAM250_GPIO_BTN_SPKADD		1
+
+#define WAM250_GPIO_EXT_LNA		19
+
+#define WAM250_MAC_OFFSET		2
+
+#define WAM250_KEYS_POLL_INTERVAL	20
+#define WAM250_KEYS_DEBOUNCE_INTERVAL	(3 * WAM250_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wam250_leds_gpio[] __initdata = {
+	{
+		.name		= "wam250:white:lan",
+		.gpio		= WAM250_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wam250:white:power",
+		.gpio		= WAM250_GPIO_LED_POWER,
+		.default_state	= LEDS_GPIO_DEFSTATE_KEEP,
+		.active_low	= 1,
+	}, {
+		.name		= "wam250:white:repeater",
+		.gpio		= WAM250_GPIO_LED_REPEATER,
+		.active_low	= 1,
+	}, {
+		.name		= "wam250:white:wlan",
+		.gpio		= WAM250_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wam250_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= WAM250_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WAM250_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "wps",
+		.type			= EV_KEY,
+		.code			= KEY_WPS_BUTTON,
+		.debounce_interval	= WAM250_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WAM250_GPIO_BTN_SPKADD,
+		.active_low		= 1,
+	},
+};
+
+static void __init wam250_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = 0xfd;
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.phy_mask = BIT(1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + WAM250_MAC_OFFSET, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WAM250_MAC_OFFSET, 1);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wam250_leds_gpio),
+				 wam250_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WAM250_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wam250_gpio_keys),
+					wam250_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, WAM250_GPIO_EXT_LNA);
+
+	ath79_register_usb();
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WAM250, "WAM250", "Samsung WAM250", wam250_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-weio.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-weio.c
new file mode 100644
index 0000000000..3973ada7c3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-weio.c
@@ -0,0 +1,140 @@
+/**
+ * WEIO Web Of Things Platform
+ *
+ * Copyright (C) 2013 Drasko DRASKOVIC and Uros PETREVSKI
+ *
+ *              ##      ## ######## ####  #######  
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ######    ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *               ###  ###  ######## ####  #######
+ *
+ *                   Web Of Things Platform
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors : 
+ * Drasko DRASKOVIC <drasko.draskovic@gmail.com>
+ * Uros PETREVSKI <uros@nodesign.net>
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WEIO_GPIO_LED_STA		1
+#define WEIO_GPIO_LED_AP		16
+
+#define WEIO_GPIO_BTN_AP		20
+#define WEIO_GPIO_BTN_RESET		23
+
+#define WEIO_KEYS_POLL_INTERVAL		20	/* msecs */
+#define WEIO_KEYS_DEBOUNCE_INTERVAL	(3 * WEIO_KEYS_POLL_INTERVAL)
+
+#define WEIO_MAC0_OFFSET			0x0000
+#define WEIO_MAC1_OFFSET			0x0006
+#define WEIO_CALDATA_OFFSET			0x1000
+#define WEIO_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led weio_leds_gpio[] __initdata = {
+	{
+		.name		= "weio:green:sta",
+		.gpio		= WEIO_GPIO_LED_STA,
+		.active_low	= 1,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	},
+	{
+		.name		= "weio:green:ap",
+		.gpio		= WEIO_GPIO_LED_AP,
+		.active_low	= 1,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	}
+};
+
+static struct gpio_keys_button weio_gpio_keys[] __initdata = {
+	{
+		.desc		= "ap button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WEIO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WEIO_GPIO_BTN_AP,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "soft-reset button",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = WEIO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WEIO_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data weio_i2c_gpio_data = {
+	.sda_pin        = 18,
+	.scl_pin        = 19,
+};
+
+static struct platform_device weio_i2c_gpio = {
+	.name           = "i2c-gpio",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &weio_i2c_gpio_data,
+	},
+};
+
+static void __init weio_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + WEIO_CALDATA_OFFSET, art + WEIO_WMAC_MAC_OFFSET);
+}
+
+static void __init weio_setup(void)
+{
+	weio_common_setup();
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	platform_device_register(&weio_i2c_gpio);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(weio_leds_gpio),
+				weio_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WEIO_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(weio_gpio_keys),
+				weio_gpio_keys);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WEIO, "WEIO", "WeIO board", weio_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-whr-hp-g300n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-whr-hp-g300n.c
new file mode 100644
index 0000000000..48f49ad0f7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-whr-hp-g300n.c
@@ -0,0 +1,155 @@
+/*
+ *  Buffalo WHR-HP-G300N board support
+ *
+ *  based on ...
+ *
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WHRHPG300N_GPIO_LED_SECURITY		0
+#define WHRHPG300N_GPIO_LED_DIAG		1
+#define WHRHPG300N_GPIO_LED_ROUTER		6
+
+#define WHRHPG300N_GPIO_BTN_ROUTER_ON		7
+#define WHRHPG300N_GPIO_BTN_ROUTER_AUTO		8
+#define WHRHPG300N_GPIO_BTN_RESET		11
+#define WHRHPG300N_GPIO_BTN_AOSS		12
+#define WHRHPG300N_GPIO_LED_LAN1		13
+#define WHRHPG300N_GPIO_LED_LAN2		14
+#define WHRHPG300N_GPIO_LED_LAN3		15
+#define WHRHPG300N_GPIO_LED_LAN4		16
+#define WHRHPG300N_GPIO_LED_WAN			17
+
+#define	WHRHPG300N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WHRHPG300N_KEYS_DEBOUNCE_INTERVAL (3 * WHRHPG300N_KEYS_POLL_INTERVAL)
+
+#define WHRHPG300N_MAC_OFFSET		0x20c
+
+static struct gpio_led whrhpg300n_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WHRHPG300N_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WHRHPG300N_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WHRHPG300N_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wan",
+		.gpio		= WHRHPG300N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan1",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan2",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan3",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan4",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button whrhpg300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WHRHPG300N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss/wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.gpio		= WHRHPG300N_GPIO_BTN_AOSS,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_ON,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_AUTO,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}
+};
+
+static void __init whrhpg300n_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(ee + WHRHPG300N_MAC_OFFSET);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(whrhpg300n_leds_gpio),
+				 whrhpg300n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WHRHPG300N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(whrhpg300n_gpio_keys),
+					whrhpg300n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_G300N, "WHR-HP-G300N", "Buffalo WHR-HP-G300N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_G301N, "WHR-G301N", "Buffalo WHR-G301N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_GN, "WHR-HP-GN", "Buffalo WHR-HP-GN",
+	     whrhpg300n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wi2a-ac200i.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wi2a-ac200i.c
new file mode 100644
index 0000000000..85e0c8fea3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wi2a-ac200i.c
@@ -0,0 +1,217 @@
+/*
+ * Nokia WI2A-AC200i support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2017 Felix Fietkau <nbd@nbd.name>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/fw/fw.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AC200I_GPIO_BTN_RESET		17
+
+#define AC200I_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AC200I_KEYS_DEBOUNCE_INTERVAL	(3 * AC200I_KEYS_POLL_INTERVAL)
+
+#define AC200I_MAC_ADDR			0x1f040249
+#define AC200I_MAC1_OFFSET		6
+#define AC200I_WMAC_CALDATA_ADDR	0x1f061000
+
+static struct gpio_led ac200i_leds_gpio[] __initdata = {
+	{
+		.name		= "nokia:red:wlan-2g",
+		.gpio		= 0,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:green:power",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:green:wlan-2g",
+		.gpio		= 2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:green:ctrl",
+		.gpio		= 3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:green:eth",
+		.gpio		= 4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:red:power",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:red:eth",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:red:wlan-5g",
+		.gpio		= 18,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:green:wlan-5g",
+		.gpio		= 19,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nokia:red:ctrl",
+		.gpio		= 20,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ac200i_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AC200I_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AC200I_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct mtd_partition ac200i_nand_partitions[] = {
+	{
+		.name	= "cfg",
+		.offset	= 0x0100000,
+		.size	= 0x1800000,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= 0x2000000,
+		.size	= 0x0400000,
+	},
+	{
+		.name	= "ubi",
+		.offset	= 0x2400000,
+		.size	= 0x2000000,
+	},
+	{
+		.name	= "kernel",
+		.offset	= 0x5000000,
+		.size	= 0x0400000,
+	},
+	{
+		.name	= "ubi",
+		.offset	= 0x5400000,
+		.size	= 0x2000000,
+	},
+};
+
+static const char *boot_getenv(const char *key)
+{
+	const char *start = (const char *) KSEG1ADDR(0x1f070000);
+	const char *end = start + 0x20000;
+	const char *addr;
+
+	for (addr = start + 4;
+	     *addr && *addr != 0xff && addr < end &&
+	     strnlen(addr, end - addr) < end - addr;
+	     addr += strnlen(addr, end - addr) + 1) {
+		const char *val;
+
+		val = strchr(addr, '=');
+		if (!val)
+			continue;
+
+		if (strncmp(addr, key, val - addr))
+			continue;
+
+		return val + 1;
+	}
+	return NULL;
+}
+
+static void __init ac200i_setup(void)
+{
+	const char *img;
+	u8 *wmac = (u8 *) KSEG1ADDR(AC200I_WMAC_CALDATA_ADDR);
+	u8 *mac_addr = (u8 *) KSEG1ADDR(AC200I_MAC_ADDR);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ac200i_leds_gpio),
+				 ac200i_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AC200I_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ac200i_gpio_keys),
+					ac200i_gpio_keys);
+
+	ath79_register_usb();
+	ath79_nfc_set_parts(ac200i_nand_partitions,
+			    ARRAY_SIZE(ac200i_nand_partitions));
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	ath79_register_wmac(wmac, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac_addr, 0);
+
+	/* GMAC0 is connected to the SGMII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x03000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+
+	img = boot_getenv("dualPartition");
+	if (img && !strcmp(img, "imgA")) {
+		ac200i_nand_partitions[3].name = "kernel_alt";
+		ac200i_nand_partitions[4].name = "ubi_alt";
+	} else {
+		ac200i_nand_partitions[1].name = "kernel_alt";
+		ac200i_nand_partitions[2].name = "ubi_alt";
+	}
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_WI2A_AC200I, "WI2A-AC200i",
+	     "Nokia WI2A-AC200i",
+	     ac200i_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wifi-pineapple-nano.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wifi-pineapple-nano.c
new file mode 100644
index 0000000000..645f367f6c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wifi-pineapple-nano.c
@@ -0,0 +1,107 @@
+/*
+ *  Hak5 WiFi Pineapple NANO board support
+ *
+ *  Copyright (C) 2018 Sebastian Kinne <seb@hak5.org>
+ *  Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WIFI_PINEAPPLE_NANO_GPIO_LED_SYSTEM	18
+
+#define WIFI_PINEAPPLE_NANO_GPIO_BTN_RESET	12
+#define WIFI_PINEAPPLE_NANO_GPIO_SD_DET		19
+#define WIFI_PINEAPPLE_NANO_GPIO_USB_ALARM	20
+#define WIFI_PINEAPPLE_NANO_GPIO_USB_POWER	23
+
+#define HAK5_KEYS_POLL_INTERVAL			20 /* msecs */
+#define HAK5_KEYS_DEBOUNCE_INTERVAL		(3 * HAK5_KEYS_POLL_INTERVAL)
+
+#define WIFI_PINEAPPLE_NANO_MAC1_OFFSET		0x0006
+#define WIFI_PINEAPPLE_NANO_CALDATA_OFFSET	0x1000
+
+static const char *hak5_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data hak5_flash_data = {
+	.part_probes = hak5_part_probes,
+};
+
+static struct gpio_led wifi_pineapple_nano_leds_gpio[] __initdata = {
+	{
+		.name		= "wifi-pineapple-nano:blue:system",
+		.gpio		= WIFI_PINEAPPLE_NANO_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wifi_pineapple_nano_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= HAK5_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WIFI_PINEAPPLE_NANO_GPIO_BTN_RESET,
+		.active_low		= 1,
+	}
+};
+
+static void __init wifi_pineapple_nano_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&hak5_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + WIFI_PINEAPPLE_NANO_MAC1_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* GPIO11/12 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_UART_RTS_CTS_EN);
+
+	gpio_request_one(WIFI_PINEAPPLE_NANO_GPIO_SD_DET,
+			 GPIOF_IN | GPIOF_EXPORT_DIR_FIXED | GPIOF_ACTIVE_LOW,
+			 "SD card present");
+
+	gpio_request_one(WIFI_PINEAPPLE_NANO_GPIO_USB_ALARM,
+			 GPIOF_IN | GPIOF_EXPORT_DIR_FIXED | GPIOF_ACTIVE_LOW,
+			 "USB alarm");
+
+	gpio_request_one(WIFI_PINEAPPLE_NANO_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED |
+			 GPIOF_ACTIVE_LOW, "USB power");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wifi_pineapple_nano_leds_gpio),
+				 wifi_pineapple_nano_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, HAK5_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wifi_pineapple_nano_gpio_keys),
+					wifi_pineapple_nano_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_wmac(art + WIFI_PINEAPPLE_NANO_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WIFI_PINEAPPLE_NANO, "WIFI-PINEAPPLE-NANO",
+	     "Hak5 WiFi Pineapple NANO", wifi_pineapple_nano_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlae-ag300n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlae-ag300n.c
new file mode 100644
index 0000000000..11006fd1bc
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlae-ag300n.c
@@ -0,0 +1,114 @@
+/*
+ *  Buffalo WLAE-AG300N board support
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WLAEAG300N_MAC_OFFSET		0x20c
+#define WLAEAG300N_KEYS_POLL_INTERVAL	20      /* msecs */
+#define WLAEAG300N_KEYS_DEBOUNCE_INTERVAL (3 * WLAEAG300N_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led wlaeag300n_leds_gpio[] __initdata = {
+	/*
+	 * Note: Writing 1 into GPIO 13 will power down the device.
+	 */
+	{
+		.name		= "buffalo:green:wireless",
+		.gpio		= 14,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:wireless",
+		.gpio		= 15,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:status",
+		.gpio		= 16,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:status",
+		.gpio		= 17,
+		.active_low	= 1,
+	}
+};
+
+
+static struct gpio_keys_button wlaeag300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "function",
+		.type		= EV_KEY,
+		.code		= KEY_MODE,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 0,
+		.active_low	= 1,
+	}, {
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "power",
+		.type		= EV_KEY,
+		.code		= KEY_POWER,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init wlaeag300n_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac1 = eeprom1 + WLAEAG300N_MAC_OFFSET;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 1);
+
+	ath79_register_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wlaeag300n_leds_gpio),
+					wlaeag300n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WLAEAG300N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wlaeag300n_gpio_keys),
+					 wlaeag300n_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ap91_pci_init(eeprom1, mac1);
+}
+
+MIPS_MACHINE(ATH79_MACH_WLAE_AG300N, "WLAE-AG300N",
+	     "Buffalo WLAE-AG300N", wlaeag300n_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wlr8100.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlr8100.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wlr8100.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wlr8100.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndap360.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndap360.c
new file mode 100644
index 0000000000..eae1c383ee
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndap360.c
@@ -0,0 +1,105 @@
+/*
+ *  Netgear WNDAP360 board support (proper leds / button support missing)
+ *
+ *  Based on AP96
+ *  Copyright (C) 2013 Jacek Kikiewicz
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WNDAP360_GPIO_LED_POWER_ORANGE		0
+#define WNDAP360_GPIO_LED_POWER_GREEN		2
+
+/* Reset button - next to the power connector */
+#define WNDAP360_GPIO_BTN_RESET			8
+
+#define WNDAP360_KEYS_POLL_INTERVAL		20	/* msecs */
+#define WNDAP360_KEYS_DEBOUNCE_INTERVAL	(3 * WNDAP360_KEYS_POLL_INTERVAL)
+
+#define WNDAP360_WMAC0_MAC_OFFSET		0x120c
+#define WNDAP360_WMAC1_MAC_OFFSET		0x520c
+#define WNDAP360_CALDATA0_OFFSET		0x1000
+#define WNDAP360_CALDATA1_OFFSET		0x5000
+
+/*
+ * WNDAP360 this still uses leds definitions from AP96
+ *
+ */
+static struct gpio_led wndap360_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDAP360_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:power",
+		.gpio		= WNDAP360_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+        }
+};
+
+static struct gpio_keys_button wndap360_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDAP360_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDAP360_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define WNDAP360_LAN_PHYMASK 0x0f
+
+static void __init wndap360_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, ~(WNDAP360_LAN_PHYMASK));
+
+	/* Reusing wifi MAC with offset of 1 as eth0 MAC */
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + WNDAP360_WMAC0_MAC_OFFSET, 1);
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = WNDAP360_LAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndap360_leds_gpio),
+					wndap360_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNDAP360_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wndap360_gpio_keys),
+					 wndap360_gpio_keys);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(art + WNDAP360_CALDATA0_OFFSET,
+		      art + WNDAP360_WMAC0_MAC_OFFSET,
+		      art + WNDAP360_CALDATA1_OFFSET,
+		      art + WNDAP360_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDAP360, "WNDAP360", "NETGEAR WNDAP360", wndap360_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr3700.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr3700.c
new file mode 100644
index 0000000000..b9132fc363
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr3700.c
@@ -0,0 +1,172 @@
+/*
+ *  Netgear WNDR3700 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WNDR3700_GPIO_LED_WPS_ORANGE	0
+#define WNDR3700_GPIO_LED_POWER_ORANGE	1
+#define WNDR3700_GPIO_LED_POWER_GREEN	2
+#define WNDR3700_GPIO_LED_WPS_GREEN	4
+#define WNDR3700_GPIO_LED_WAN_GREEN	6
+
+#define WNDR3700_GPIO_BTN_WPS		3
+#define WNDR3700_GPIO_BTN_RESET		8
+#define WNDR3700_GPIO_BTN_RFKILL	11
+
+#define WNDR3700_GPIO_RTL8366_SDA	5
+#define WNDR3700_GPIO_RTL8366_SCK	7
+
+#define WNDR3700_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR3700_KEYS_DEBOUNCE_INTERVAL (3 * WNDR3700_KEYS_POLL_INTERVAL)
+
+#define WNDR3700_ETH0_MAC_OFFSET	0
+#define WNDR3700_ETH1_MAC_OFFSET	0x6
+
+#define WNDR3700_WMAC0_MAC_OFFSET	0
+#define WNDR3700_WMAC1_MAC_OFFSET	0xc
+#define WNDR3700_CALDATA0_OFFSET	0x1000
+#define WNDR3700_CALDATA1_OFFSET	0x5000
+
+static struct gpio_led wndr3700_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNDR3700_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wndr3700_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "rfkill",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda	= WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck	= WNDR3700_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wndr3700_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wndr3700_rtl8366s_data,
+	}
+};
+
+static void __init wndr3700_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/*
+	 * The eth0 and wmac0 interfaces share the same MAC address which
+	 * can lead to problems if operated unbridged. Set the locally
+	 * administered bit on the eth0 MAC to make it unique.
+	 */
+	ath79_init_local_mac(ath79_eth0_data.mac_addr,
+			     art + WNDR3700_ETH0_MAC_OFFSET);
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+	ath79_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + WNDR3700_ETH1_MAC_OFFSET, 0);
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+	ath79_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+				 wndr3700_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNDR3700_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wndr3700_gpio_keys),
+					wndr3700_gpio_keys);
+
+	platform_device_register(&wndr3700_rtl8366s_device);
+	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	/* 2.4 GHz uses the first fixed antenna group (1, 0, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(0, (0xf << 6), (0xa << 6));
+
+	/* 5 GHz uses the second fixed antenna group (0, 1, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(1, (0xf << 6), (0x6 << 6));
+
+	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
+		      art + WNDR3700_WMAC0_MAC_OFFSET,
+		      art + WNDR3700_CALDATA1_OFFSET,
+		      art + WNDR3700_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDR3700, "WNDR3700",
+	     "NETGEAR WNDR3700/WNDR3800/WNDRMAC",
+	     wndr3700_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wndr4300.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr4300.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wndr4300.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wndr4300.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v3.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v3.c
new file mode 100644
index 0000000000..6c18dc6d90
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v3.c
@@ -0,0 +1,637 @@
+/*
+ *  NETGEAR WNR2000v3/WNR612v2/WNR1000v2/WPN824N board support
+ *
+ *  Copyright (C) 2015 Hartmut Knaack <knaack.h@gmx.de>
+ *  Copyright (C) 2013 Mathieu Olivari <mathieu.olivari@gmail.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/kernel.h> /* for max() macro */
+#include <linux/platform_device.h> /* PLATFORM_DEVID_AUTO is defined here */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h> /* needed to disable switch LEDs */
+#include "common.h" /* needed to disable switch LEDs */
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+/* WNR2000v3 - connected through AR7241 */
+#define WNR2000V3_GPIO_LED_WAN_GREEN	0
+#define WNR2000V3_GPIO_LED_LAN1_AMBER	1
+#define WNR2000V3_GPIO_LED_LAN2_AMBER	6
+#define WNR2000V3_GPIO_LED_WPS_GREEN	7
+#define WNR2000V3_GPIO_LED_LAN3_AMBER	8
+#define WNR2000V3_GPIO_BTN_WPS		11
+#define WNR2000V3_GPIO_LED_LAN4_AMBER	12
+#define WNR2000V3_GPIO_LED_LAN1_GREEN	13
+#define WNR2000V3_GPIO_LED_LAN2_GREEN	14
+#define WNR2000V3_GPIO_LED_LAN3_GREEN	15
+#define WNR2000V3_GPIO_LED_LAN4_GREEN	16
+#define WNR2000V3_GPIO_LED_WAN_AMBER	17
+
+/* WNR2000v3 - connected through AR9287 */
+#define WNR2000V3_GPIO_WMAC_LED_WLAN_BLUE	1
+#define WNR2000V3_GPIO_WMAC_LED_TEST_AMBER	2
+#define WNR2000V3_GPIO_WMAC_LED_POWER_GREEN	3
+#define WNR2000V3_GPIO_WMAC_BTN_RESET		8
+#define WNR2000V3_GPIO_WMAC_BTN_RFKILL		9
+
+/* WNR612v2 - connected through AR7241 */
+#define WNR612V2_GPIO_LED_POWER_GREEN	11
+#define WNR612V2_GPIO_LED_LAN1_GREEN	13
+#define WNR612V2_GPIO_LED_LAN2_GREEN	14
+#define WNR612V2_GPIO_LED_WAN_GREEN	17
+
+/* WNR612v2 - connected through AR9285 */
+#define WNR612V2_GPIO_WMAC_LED_WLAN_GREEN	1
+#define WNR612V2_GPIO_WMAC_BTN_RESET		7
+
+/* WNR1000v2 - connected through AR7240 */
+#define WNR1000V2_GPIO_LED_WAN_AMBER	0
+#define WNR1000V2_GPIO_LED_TEST_AMBER	1
+#define WNR1000V2_GPIO_LED_LAN1_AMBER	6 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR1000V2_GPIO_LED_LAN2_AMBER	7 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR1000V2_GPIO_LED_LAN3_AMBER	8 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR1000V2_GPIO_LED_POWER_GREEN	11
+#define WNR1000V2_GPIO_LED_LAN4_AMBER	12
+#define WNR1000V2_GPIO_LED_LAN1_GREEN	13 /* AR724X_..._ETH_SWITCH_LED0 */
+#define WNR1000V2_GPIO_LED_LAN2_GREEN	14 /* AR724X_..._ETH_SWITCH_LED1 */
+#define WNR1000V2_GPIO_LED_LAN3_GREEN	15 /* AR724X_..._ETH_SWITCH_LED2 */
+#define WNR1000V2_GPIO_LED_LAN4_GREEN	16 /* AR724X_..._ETH_SWITCH_LED3 */
+#define WNR1000V2_GPIO_LED_WAN_GREEN	17 /* AR724X_..._ETH_SWITCH_LED4 */
+
+/* WNR1000v2 - connected through AR9285 */
+#define WNR1000V2_GPIO_WMAC_LED_WLAN_BLUE	1
+#define WNR1000V2_GPIO_WMAC_LED_WPS_GREEN	5
+#define WNR1000V2_GPIO_WMAC_BTN_WPS		6
+#define WNR1000V2_GPIO_WMAC_BTN_RESET		7
+#define WNR1000V2_GPIO_WMAC_BTN_RFKILL		8
+
+/* WPN824N - connected through AR7240 */
+#define WPN824N_GPIO_LED_WAN_AMBER	0
+#define WPN824N_GPIO_LED_STATUS_AMBER	1
+#define WPN824N_GPIO_LED_LAN1_AMBER	6 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WPN824N_GPIO_LED_LAN2_AMBER	7 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WPN824N_GPIO_LED_LAN3_AMBER	8 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WPN824N_GPIO_LED_LAN4_AMBER	12
+#define WPN824N_GPIO_LED_LAN1_GREEN	13
+#define WPN824N_GPIO_LED_LAN2_GREEN	14
+#define WPN824N_GPIO_LED_LAN3_GREEN	15 /* AR724X_GPIO_FUNC_CLK_OBS3_EN */
+#define WPN824N_GPIO_LED_LAN4_GREEN	16
+#define WPN824N_GPIO_LED_WAN_GREEN	17
+
+/* WPN824N - connected through AR9285 */
+#define WPN824N_WGPIO_LED_PWR_GREEN	0
+#define WPN824N_WGPIO_LED_WLAN_BLUE	1
+#define WPN824N_WGPIO_LED_WPS1_BLUE	5
+#define WPN824N_WGPIO_LED_WPS2_BLUE	9
+#define WPN824N_WGPIO_LED_TEST_AMBER	10
+#define WPN824N_WGPIO_BTN_WPS		6
+#define WPN824N_WGPIO_BTN_RESET		7
+#define WPN824N_WGPIO_BTN_WLAN		8
+
+#define WNR2000V3_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000V3_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000V3_KEYS_POLL_INTERVAL)
+
+/* ART offsets for: WNR2000v3, WNR612v2, WNR1000v2 */
+#define WNR2000V3_MAC0_OFFSET		0
+#define WNR2000V3_MAC1_OFFSET		6
+#define WNR2000V3_PCIE_CALDATA_OFFSET	0x1000
+#define WNR2000V3_WMAC_OFFSET		0x108c	/* wireless MAC is inside ART */
+
+static struct gpio_led wnr2000v3_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= WNR2000V3_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan1",
+		.gpio		= WNR2000V3_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR2000V3_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR2000V3_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR2000V3_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2000V3_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR2000V3_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR2000V3_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR2000V3_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR2000V3_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR2000V3_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr2000v3_wmac_leds_gpio[] = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR2000V3_GPIO_WMAC_LED_POWER_GREEN,
+		.active_low	= 1,
+		.default_state	= LEDS_GPIO_DEFSTATE_ON,
+	}, {
+		.name		= "netgear:amber:test",
+		.gpio		= WNR2000V3_GPIO_WMAC_LED_TEST_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2000V3_GPIO_WMAC_LED_WLAN_BLUE,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr612v2_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR612V2_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR612V2_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR612V2_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNR612V2_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr612v2_wmac_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:wlan",
+		.gpio		= WNR612V2_GPIO_WMAC_LED_WLAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr1000v2_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:amber:lan1",
+		.gpio		= WNR1000V2_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR1000V2_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR1000V2_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR1000V2_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:test",
+		.gpio		= WNR1000V2_GPIO_LED_TEST_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR1000V2_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR1000V2_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR1000V2_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR1000V2_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR1000V2_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:power",
+		.gpio		= WNR1000V2_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNR1000V2_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr1000v2_wmac_leds_gpio[] = {
+	{
+		.name		= "netgear:green:wps",
+		.gpio		= WNR1000V2_GPIO_WMAC_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR1000V2_GPIO_WMAC_LED_WLAN_BLUE,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wpn824n_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= WPN824N_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:status",
+		.gpio		= WPN824N_GPIO_LED_STATUS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan1",
+		.gpio		= WPN824N_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan2",
+		.gpio		= WPN824N_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan3",
+		.gpio		= WPN824N_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan4",
+		.gpio		= WPN824N_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WPN824N_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WPN824N_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan3",
+		.gpio		= WPN824N_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan4",
+		.gpio		= WPN824N_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WPN824N_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wpn824n_wmac_leds_gpio[] = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WPN824N_WGPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wps1",
+		.gpio		= WPN824N_WGPIO_LED_WPS1_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wps2",
+		.gpio		= WPN824N_WGPIO_LED_WPS2_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:test",
+		.gpio		= WPN824N_WGPIO_LED_TEST_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WPN824N_WGPIO_LED_WLAN_BLUE,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000v3_keys_gpio[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V3_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000v3_wmac_keys_gpio[] = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V3_GPIO_WMAC_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "rfkill",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V3_GPIO_WMAC_BTN_RFKILL,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr612v2_wmac_keys_gpio[] = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR612V2_GPIO_WMAC_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr1000v2_wmac_keys_gpio[] = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR1000V2_GPIO_WMAC_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "rfkill",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR1000V2_GPIO_WMAC_BTN_RFKILL,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR1000V2_GPIO_WMAC_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpn824n_wmac_keys_gpio[] = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WPN824N_WGPIO_BTN_RESET,
+		.active_low		= 1,
+	}, {
+		.desc			= "rfkill",
+		.type			= EV_KEY,
+		.code			= KEY_RFKILL,
+		.debounce_interval	= WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WPN824N_WGPIO_BTN_WLAN,
+		.active_low		= 1,
+	}, {
+		.desc			= "wps",
+		.type			= EV_KEY,
+		.code			= KEY_WPS_BUTTON,
+		.debounce_interval	= WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= WPN824N_WGPIO_BTN_WPS,
+		.active_low		= 1,
+	}
+};
+
+/*
+ * For WNR2000v3 ART flash area used for WLAN MAC is usually empty (0xff)
+ * so ath9k driver uses random MAC instead each time module is loaded.
+ * To fix that, assign permanent WLAN MAC equal to ethN's MAC plus 1,
+ * so network interfaces get sequential addresses.
+ * If ART wireless MAC address field has been filled by user, use it.
+ */
+static void __init wnr_get_wmac(u8 *wmac_gen_addr, int mac0_art_offset,
+				int mac1_art_offset, int wmac_art_offset)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *eth0_mac_addr = (u8 *) (art + mac0_art_offset);
+	u8 *eth1_mac_addr = (u8 *) (art + mac1_art_offset);
+	u8 *wlan_mac_addr = (u8 *) (art + wmac_art_offset);
+
+	/* only 0xff if all bits are set - address is invalid, empty area */
+	if ((wlan_mac_addr[0] & wlan_mac_addr[1] & wlan_mac_addr[2] &
+	     wlan_mac_addr[3] & wlan_mac_addr[4] & wlan_mac_addr[5]) == 0xff) {
+		memcpy(wmac_gen_addr, eth0_mac_addr, 5);
+		wmac_gen_addr[5] = max(eth0_mac_addr[5], eth1_mac_addr[5]) + 1;
+
+		/* Avoid potential conflict in case max(0xff,0x00)+1==0x00 */
+		if (!wmac_gen_addr[5])
+			wmac_gen_addr[5] = 1;
+	} else
+		memcpy(wmac_gen_addr, wlan_mac_addr, 6);
+}
+
+static void __init wnr_common_setup(u8 *wmac_addr)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+WNR2000V3_MAC0_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+WNR2000V3_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+	ap91_pci_init(art + WNR2000V3_PCIE_CALDATA_OFFSET, wmac_addr);
+}
+
+static void __init wnr2000v3_setup(void)
+{
+	u8 wlan_mac_addr[6];
+
+	/*
+	 * Disable JTAG to use all AR724X GPIO LEDs.
+	 * Also disable CLKs and bit 20 as u-boot does.
+	 * Finally, allow OS to control all link LEDs.
+	 */
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE |
+				  AR724X_GPIO_FUNC_UART_EN,
+				  AR724X_GPIO_FUNC_CLK_OBS1_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS2_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS3_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS4_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS5_EN |
+				  AR724X_GPIO_FUNC_GE0_MII_CLK_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN |
+				  BIT(20));
+
+	wnr_get_wmac(wlan_mac_addr, WNR2000V3_MAC0_OFFSET,
+		     WNR2000V3_MAC1_OFFSET, WNR2000V3_WMAC_OFFSET);
+
+	wnr_common_setup(wlan_mac_addr);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000v3_leds_gpio),
+				 wnr2000v3_leds_gpio);
+
+	/* Do not use id=-1, we can have more GPIO key-polled devices */
+	ath79_register_gpio_keys_polled(PLATFORM_DEVID_AUTO,
+					WNR2000V3_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000v3_keys_gpio),
+					wnr2000v3_keys_gpio);
+
+	ap9x_pci_setup_wmac_leds(0, wnr2000v3_wmac_leds_gpio,
+				 ARRAY_SIZE(wnr2000v3_wmac_leds_gpio));
+
+	ap9x_pci_setup_wmac_btns(0, wnr2000v3_wmac_keys_gpio,
+				 ARRAY_SIZE(wnr2000v3_wmac_keys_gpio),
+				 WNR2000V3_KEYS_POLL_INTERVAL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000_V3, "WNR2000V3", "NETGEAR WNR2000 V3", wnr2000v3_setup);
+
+static void __init wnr612v2_setup(void)
+{
+	u8 wlan_mac_addr[6];
+
+	/*
+	 * Disable JTAG and CLKs. Allow OS to control all link LEDs.
+	 * Note: U-Boot for WNR612v2 sets undocumented bit 15 but
+	 * we leave it for now.
+	 */
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE |
+				  AR724X_GPIO_FUNC_UART_EN,
+				  AR724X_GPIO_FUNC_CLK_OBS1_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS2_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS3_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS4_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS5_EN |
+				  AR724X_GPIO_FUNC_GE0_MII_CLK_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	wnr_get_wmac(wlan_mac_addr, WNR2000V3_MAC0_OFFSET,
+		     WNR2000V3_MAC1_OFFSET, WNR2000V3_WMAC_OFFSET);
+
+	wnr_common_setup(wlan_mac_addr);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr612v2_leds_gpio),
+				 wnr612v2_leds_gpio);
+
+	ap9x_pci_setup_wmac_leds(0, wnr612v2_wmac_leds_gpio,
+				 ARRAY_SIZE(wnr612v2_leds_gpio));
+
+	ap9x_pci_setup_wmac_btns(0, wnr612v2_wmac_keys_gpio,
+				 ARRAY_SIZE(wnr612v2_wmac_keys_gpio),
+				 WNR2000V3_KEYS_POLL_INTERVAL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR612_V2, "WNR612V2", "NETGEAR WNR612 V2", wnr612v2_setup);
+
+static void __init wnr1000v2_setup(void)
+{
+	u8 wlan_mac_addr[6];
+
+	/*
+	 * Disable JTAG and CLKs. Allow OS to control all link LEDs.
+	 * Note: U-Boot for WNR1000v2 sets undocumented bit 15 but
+	 * we leave it for now.
+	 */
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE |
+				  AR724X_GPIO_FUNC_UART_EN,
+				  AR724X_GPIO_FUNC_CLK_OBS1_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS2_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS3_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS4_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS5_EN |
+				  AR724X_GPIO_FUNC_GE0_MII_CLK_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	wnr_get_wmac(wlan_mac_addr, WNR2000V3_MAC0_OFFSET,
+		     WNR2000V3_MAC1_OFFSET, WNR2000V3_WMAC_OFFSET);
+
+	wnr_common_setup(wlan_mac_addr);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr1000v2_leds_gpio),
+				 wnr1000v2_leds_gpio);
+
+	ap9x_pci_setup_wmac_leds(0, wnr1000v2_wmac_leds_gpio,
+				 ARRAY_SIZE(wnr1000v2_wmac_leds_gpio));
+
+	/* All 3 buttons are connected to wireless chip */
+	ap9x_pci_setup_wmac_btns(0, wnr1000v2_wmac_keys_gpio,
+				 ARRAY_SIZE(wnr1000v2_wmac_keys_gpio),
+				 WNR2000V3_KEYS_POLL_INTERVAL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR1000_V2, "WNR1000V2", "NETGEAR WNR1000 V2", wnr1000v2_setup);
+
+static void __init wpn824n_setup(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS3_EN);
+
+	wnr_common_setup(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpn824n_leds_gpio),
+				 wpn824n_leds_gpio);
+
+	ap9x_pci_setup_wmac_leds(0, wpn824n_wmac_leds_gpio,
+				 ARRAY_SIZE(wpn824n_wmac_leds_gpio));
+	ap9x_pci_setup_wmac_btns(0, wpn824n_wmac_keys_gpio,
+				 ARRAY_SIZE(wpn824n_wmac_keys_gpio),
+				 WNR2000V3_KEYS_POLL_INTERVAL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPN824N, "WPN824N", "NETGEAR WPN824N", wpn824n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v4.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v4.c
new file mode 100644
index 0000000000..c5159a30ca
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000-v4.c
@@ -0,0 +1,214 @@
+/*
+ *  NETGEAR WNR2000v4 board support
+ *
+ *  Copyright (C) 2015 Michael Bazzinotti <mbazzinotti@gmail.com>
+ *  Copyright (C) 2014 Michal Burtin <mburtin@gmail.com>
+ *  Copyright (C) 2013 Mathieu Olivari <mathieu.olivari@gmail.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* AR9341 GPIOs */
+#define WNR2000V4_GPIO_LED_PWR_GREEN      0
+#define WNR2000V4_GPIO_LED_PWR_AMBER      1
+#define WNR2000V4_GPIO_LED_WPS            2
+#define WNR2000V4_GPIO_LED_WLAN           12
+#define WNR2000V4_GPIO_LED_LAN1_GREEN     13
+#define WNR2000V4_GPIO_LED_LAN2_GREEN     14
+#define WNR2000V4_GPIO_LED_LAN3_GREEN     15
+#define WNR2000V4_GPIO_LED_LAN4_GREEN     16
+#define WNR2000V4_GPIO_LED_LAN1_AMBER     18
+#define WNR2000V4_GPIO_LED_LAN2_AMBER     19
+#define WNR2000V4_GPIO_LED_LAN3_AMBER     20
+#define WNR2000V4_GPIO_LED_LAN4_AMBER     21
+#define WNR2000V4_GPIO_LED_WAN_GREEN      17
+#define WNR2000V4_GPIO_LED_WAN_AMBER      22
+/* Buttons */
+#define WNR2000V4_GPIO_BTN_WPS            3
+#define WNR2000V4_GPIO_BTN_RESET          4
+#define WNR2000V4_GPIO_BTN_WLAN           11
+#define WNR2000V4_KEYS_POLL_INTERVAL      20      /* msecs */
+#define WNR2000V4_KEYS_DEBOUNCE_INTERVAL  (3 * WNR2000V4_KEYS_POLL_INTERVAL)
+
+
+/* ART offsets */
+#define WNR2000V4_MAC0_OFFSET             0       /* WAN/WLAN0 MAC   */
+#define WNR2000V4_MAC1_OFFSET             6       /* Eth-switch0 MAC */
+
+static struct gpio_led wnr2000v4_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR2000V4_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	},
+	{
+		.name		= "netgear:amber:status",
+		.gpio		= WNR2000V4_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= WNR2000V4_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR2000V4_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2000V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	/* LAN LEDS */
+	{
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR2000V4_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR2000V4_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR2000V4_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR2000V4_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan1",
+		.gpio		= WNR2000V4_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR2000V4_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR2000V4_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR2000V4_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2000V4_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wnr2000v4_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init wnr_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+WNR2000V4_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+WNR2000V4_MAC1_OFFSET, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch, GE0 */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch, GE1 */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, art);
+}
+
+static void __init wnr2000v4_setup(void)
+{
+	int i;
+
+	wnr_common_setup();
+
+	/* Ensure no LED has an internal MUX signal, otherwise
+	control of LED could be lost... This is especially important
+	for most green LEDS (Eth,WAN).. who arrive in this function with
+	MUX signals set. */
+	for (i = 0; i < ARRAY_SIZE(wnr2000v4_leds_gpio); i++)
+		ath79_gpio_output_select(wnr2000v4_leds_gpio[i].gpio,
+					AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000v4_leds_gpio),
+				 wnr2000v4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000V4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000v4_gpio_keys),
+					wnr2000v4_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000_V4, "WNR2000V4", "NETGEAR WNR2000 V4", wnr2000v4_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000.c
new file mode 100644
index 0000000000..6e3becab3a
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2000.c
@@ -0,0 +1,102 @@
+/*
+ *  NETGEAR WNR2000 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WNR2000_GPIO_LED_PWR_GREEN	14
+#define WNR2000_GPIO_LED_PWR_AMBER	7
+#define WNR2000_GPIO_LED_WPS		4
+#define WNR2000_GPIO_LED_WLAN		6
+#define WNR2000_GPIO_BTN_RESET		21
+#define WNR2000_GPIO_BTN_WPS		8
+
+#define WNR2000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wnr2000_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2000_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2000_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr2000_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
+				 wnr2000_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000_gpio_keys),
+					wnr2000_gpio_keys);
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2200.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2200.c
new file mode 100644
index 0000000000..54217220f7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wnr2200.c
@@ -0,0 +1,245 @@
+/*
+ *  NETGEAR WNR2200 board support
+ *
+ *  Copyright (C) 2013 Aidan Kissane <aidankissane at googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/kernel.h> /* for max() macro */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h> /* needed to disable switch LEDs */
+#include "common.h" /* needed to disable switch LEDs */
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+/* WNR2200 - connected through AR7241 */
+#define WNR2200_GPIO_LED_LAN2_AMBER	0
+#define WNR2200_GPIO_LED_LAN4_AMBER	1
+#define WNR2200_GPIO_LED_LAN1_AMBER	6 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR2200_GPIO_LED_WPS_GREEN	7 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR2200_GPIO_LED_USB_GREEN	8 /* AR724X_GPIO_FUNC_JTAG_DISABLE */
+#define WNR2200_GPIO_LED_LAN3_AMBER	11
+#define WNR2200_GPIO_LED_WAN_AMBER	12
+#define WNR2200_GPIO_LED_LAN1_GREEN	13 /* AR724X_..._ETH_SWITCH_LED0 */
+#define WNR2200_GPIO_LED_LAN2_GREEN	14 /* AR724X_..._ETH_SWITCH_LED1 */
+#define WNR2200_GPIO_LED_LAN3_GREEN	15 /* AR724X_..._ETH_SWITCH_LED2 */
+#define WNR2200_GPIO_LED_LAN4_GREEN	16 /* AR724X_..._ETH_SWITCH_LED3 */
+#define WNR2200_GPIO_LED_WAN_GREEN	17 /* AR724X_..._ETH_SWITCH_LED4 */
+
+/* WNR2200 - connected through AR9287 */
+#define WNR2200_GPIO_WMAC_LED_WLAN_BLUE		0
+#define WNR2200_GPIO_WMAC_LED_TEST_AMBER	1
+#define WNR2200_GPIO_WMAC_LED_POWER_GREEN	2
+#define WNR2200_GPIO_WMAC_BTN_RFKILL		3
+#define WNR2200_GPIO_WMAC_USB_5V		4
+#define WNR2200_GPIO_WMAC_BTN_WPS		5
+#define WNR2200_GPIO_WMAC_BTN_RESET		6
+
+#define WNR2200_KEYS_POLL_INTERVAL	20 /* msecs */
+#define WNR2200_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2200_KEYS_POLL_INTERVAL)
+
+#define WNR2200_MAC0_OFFSET		0
+#define WNR2200_MAC1_OFFSET		6
+#define WNR2200_PCIE_CALDATA_OFFSET	0x1000
+#define WNR2200_WMAC_OFFSET		0x108c	/* wireless MAC is inside ART */
+
+static struct gpio_led wnr2200_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:amber:lan1",
+		.gpio		= WNR2200_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR2200_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR2200_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR2200_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR2200_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR2200_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR2200_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR2200_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR2200_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:usb",
+		.gpio		= WNR2200_GPIO_LED_USB_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNR2200_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2200_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr2200_wmac_leds_gpio[] = {
+	{
+		.name		= "netgear:amber:test",
+		.gpio		= WNR2200_GPIO_WMAC_LED_TEST_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:power",
+		.gpio		= WNR2200_GPIO_WMAC_LED_POWER_GREEN,
+		.active_low	= 1,
+		.default_state	= LEDS_GPIO_DEFSTATE_ON,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2200_GPIO_WMAC_LED_WLAN_BLUE,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2200_wmac_keys_gpio[] = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2200_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2200_GPIO_WMAC_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "rfkill",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNR2200_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2200_GPIO_WMAC_BTN_RFKILL,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2200_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2200_GPIO_WMAC_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+/*
+ * For WNR2200 ART flash area used for WLAN MAC is usually empty (0xff)
+ * so ath9k driver uses random MAC instead each time module is loaded.
+ * OpenWrt's original fix was to copy eth1 address to WLAN interface.
+ * New solution does not duplicate hardware addresses and is taken from
+ * WNR2000v3 code. It assigns permanent WLAN MAC equal to ethN's MAC
+ * plus 1, so network interfaces get sequential addresses.
+ * If ART wireless MAC address field has been filled by user, use it.
+ */
+static void __init wnr2200_get_wmac(u8 *wmac_gen_addr, int mac0_art_offset,
+				    int mac1_art_offset, int wmac_art_offset)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *eth0_mac_addr = (u8 *) (art + mac0_art_offset);
+	u8 *eth1_mac_addr = (u8 *) (art + mac1_art_offset);
+	u8 *wlan_mac_addr = (u8 *) (art + wmac_art_offset);
+
+	/* only 0xff if all bits are set - address is invalid, empty area */
+	if ((wlan_mac_addr[0] & wlan_mac_addr[1] & wlan_mac_addr[2] &
+	     wlan_mac_addr[3] & wlan_mac_addr[4] & wlan_mac_addr[5]) == 0xff) {
+		memcpy(wmac_gen_addr, eth0_mac_addr, 5);
+		wmac_gen_addr[5] = max(eth0_mac_addr[5], eth1_mac_addr[5]) + 1;
+
+		/* Avoid potential conflict in case max(0xff,0x00)+1==0x00 */
+		if (!wmac_gen_addr[5])
+			wmac_gen_addr[5] = 1;
+	} else
+		memcpy(wmac_gen_addr, wlan_mac_addr, 6);
+}
+
+static void __init wnr2200_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 wlan_mac_addr[6];
+
+	/*
+	 * Disable JTAG to use all AR724X GPIO LEDs. Disable CLKs.
+	 * Allow OS to control all link LEDs.
+	 */
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE |
+				  AR724X_GPIO_FUNC_UART_EN,
+				  AR724X_GPIO_FUNC_CLK_OBS1_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS2_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS3_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS4_EN |
+				  AR724X_GPIO_FUNC_CLK_OBS5_EN |
+				  AR724X_GPIO_FUNC_GE0_MII_CLK_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WNR2200_MAC0_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + WNR2200_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	wnr2200_get_wmac(wlan_mac_addr, WNR2200_MAC0_OFFSET,
+			 WNR2200_MAC1_OFFSET, WNR2200_WMAC_OFFSET);
+	ap91_pci_init(art + WNR2200_PCIE_CALDATA_OFFSET, wlan_mac_addr);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2200_leds_gpio),
+				 wnr2200_leds_gpio);
+
+	ap9x_pci_setup_wmac_leds(0, wnr2200_wmac_leds_gpio,
+				 ARRAY_SIZE(wnr2200_wmac_leds_gpio));
+
+	/* All 3 buttons are connected to wireless chip */
+	ap9x_pci_setup_wmac_btns(0, wnr2200_wmac_keys_gpio,
+				 ARRAY_SIZE(wnr2200_wmac_keys_gpio),
+				 WNR2200_KEYS_POLL_INTERVAL);
+
+	/* enable power for the USB port */
+	ap9x_pci_setup_wmac_gpio(0, BIT(WNR2200_GPIO_WMAC_USB_5V),
+				 BIT(WNR2200_GPIO_WMAC_USB_5V));
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2200, "WNR2200", "NETGEAR WNR2200", wnr2200_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wp543.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wp543.c
new file mode 100644
index 0000000000..dc4aee0c1b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wp543.c
@@ -0,0 +1,109 @@
+/*
+ *  Compex WP543/WPJ543 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WP543_GPIO_SW6		2
+#define WP543_GPIO_LED_1	3
+#define WP543_GPIO_LED_2	4
+#define WP543_GPIO_LED_WLAN	5
+#define WP543_GPIO_LED_CONN	6
+#define WP543_GPIO_LED_DIAG	7
+#define WP543_GPIO_SW4		8
+
+#define WP543_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WP543_KEYS_DEBOUNCE_INTERVAL	(3 * WP543_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wp543_leds_gpio[] __initdata = {
+	{
+		.name		= "wp543:green:led1",
+		.gpio		= WP543_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:led2",
+		.gpio		= WP543_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:wlan",
+		.gpio		= WP543_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:conn",
+		.gpio		= WP543_GPIO_LED_CONN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:diag",
+		.gpio		= WP543_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wp543_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw6",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW6,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static const char *wp543_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wp543_flash_data = {
+	.part_probes	= wp543_part_probes,
+};
+
+static void __init wp543_setup(void)
+{
+	ath79_register_m25p80(&wp543_flash_data);
+
+	ath79_register_mdio(0, 0xfffffff0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x0f;
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
+					wp543_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WP543_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wp543_gpio_keys),
+					 wp543_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpe72.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpe72.c
new file mode 100644
index 0000000000..9452484279
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpe72.c
@@ -0,0 +1,97 @@
+/*
+ *  Compex WPE72 board support
+ *
+ *  Copyright (C) 2012 Johnathan Boyce<jon.boyce@globalreach.eu.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WPE72_GPIO_RESET	12
+#define WPE72_GPIO_LED_DIAG	13
+#define WPE72_GPIO_LED_1	14
+#define WPE72_GPIO_LED_2	15
+#define WPE72_GPIO_LED_3	16
+#define WPE72_GPIO_LED_4	17
+
+#define WPE72_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPE72_KEYS_DEBOUNCE_INTERVAL	(3 * WPE72_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wpe72_leds_gpio[] __initdata = {
+	{
+		.name		= "wpe72:green:led1",
+		.gpio		= WPE72_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led2",
+		.gpio		= WPE72_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led3",
+		.gpio		= WPE72_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led4",
+		.gpio		= WPE72_GPIO_LED_4,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:diag",
+		.gpio		= WPE72_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpe72_gpio_keys[] __initdata = {
+	{
+		.desc           = "reset",
+		.type           = EV_KEY,
+		.code           = KEY_RESTART,
+		.debounce_interval = WPE72_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = WPE72_GPIO_RESET,
+		.active_low	= 1,
+	}
+};
+
+static const char *wpe72_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wpe72_flash_data = {
+	.part_probes	= wpe72_part_probes,
+};
+
+static void __init wpe72_setup(void)
+{
+	ath79_register_m25p80(&wpe72_flash_data);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpe72_leds_gpio),
+				 wpe72_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WPE72_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpe72_gpio_keys),
+					wpe72_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPE72, "WPE72", "Compex WPE72", wpe72_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpj342.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj342.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpj342.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj342.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpj344.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj344.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpj344.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj344.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj531.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj531.c
new file mode 100644
index 0000000000..df817dac91
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj531.c
@@ -0,0 +1,143 @@
+/*
+ * Compex WPJ531 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "pci.h"
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ531_GPIO_LED_SIG1    13
+#define WPJ531_GPIO_LED_SIG2    14
+#define WPJ531_GPIO_LED_SIG3    15
+#define WPJ531_GPIO_LED_SIG4    16
+#define WPJ531_GPIO_BUZZER      4
+
+#define WPJ531_GPIO_BTN_RESET   17
+
+#define WPJ531_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ531_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ531_KEYS_POLL_INTERVAL)
+
+#define WPJ531_MAC0_OFFSET		0x10
+#define WPJ531_MAC1_OFFSET		0x18
+#define WPJ531_WMAC_CALDATA_OFFSET	0x1000
+#define WPJ531_PCIE_CALDATA_OFFSET	0x5000
+
+#define WPJ531_ART_SIZE		0x8000
+
+static struct gpio_led wpj531_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj531:red:sig1",
+		.gpio		= WPJ531_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:yellow:sig2",
+		.gpio		= WPJ531_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:green:sig3",
+		.gpio		= WPJ531_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:green:sig4",
+		.gpio		= WPJ531_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:buzzer",
+		.gpio		= WPJ531_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button wpj531_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ531_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ531_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ531_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + WPJ531_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + WPJ531_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+	ath79_register_usb();
+}
+
+static void __init wpj531_setup(void)
+{
+	common_setup();
+
+	ath79_register_leds_gpio(-1,
+				ARRAY_SIZE(wpj531_leds_gpio),
+				wpj531_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1,
+					WPJ531_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj531_gpio_keys),
+					wpj531_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ531, "WPJ531", "Compex WPJ531", wpj531_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpj558.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj558.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpj558.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj558.c
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wpj563.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj563.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wpj563.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wpj563.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt160nl.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt160nl.c
new file mode 100644
index 0000000000..ede3c214c2
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt160nl.c
@@ -0,0 +1,126 @@
+/*
+ *  Linksys WRT160NL board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "nvram.h"
+#include "machtypes.h"
+
+#define WRT160NL_GPIO_LED_POWER		14
+#define WRT160NL_GPIO_LED_WPS_AMBER	9
+#define WRT160NL_GPIO_LED_WPS_BLUE	8
+#define WRT160NL_GPIO_LED_WLAN		6
+
+#define WRT160NL_GPIO_BTN_WPS		7
+#define WRT160NL_GPIO_BTN_RESET		21
+
+#define WRT160NL_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT160NL_KEYS_DEBOUNCE_INTERVAL	(3 * WRT160NL_KEYS_POLL_INTERVAL)
+
+#define WRT160NL_NVRAM_ADDR	0x1f7e0000
+#define WRT160NL_NVRAM_SIZE	0x10000
+
+static const char *wrt160nl_part_probes[] = {
+	"cybertan",
+	NULL,
+};
+
+static struct flash_platform_data wrt160nl_flash_data = {
+	.part_probes	= wrt160nl_part_probes,
+};
+
+static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt160nl:blue:power",
+		.gpio		= WRT160NL_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "wrt160nl:amber:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wlan",
+		.gpio		= WRT160NL_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrt160nl_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt160nl_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(WRT160NL_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "lan_hwaddr=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = 0x01;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt160nl_flash_data);
+
+	ath79_register_usb();
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "wl0_hwaddr=", mac) == 0)
+		ath79_register_wmac(eeprom, mac);
+	else
+		ath79_register_wmac(eeprom, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
+				 wrt160nl_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT160NL_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt160nl_gpio_keys),
+					wrt160nl_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT160NL, "WRT160NL", "Linksys WRT160NL",
+	     wrt160nl_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt400n.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt400n.c
new file mode 100644
index 0000000000..6c4c1cb0d6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrt400n.c
@@ -0,0 +1,161 @@
+/*
+ *  Linksys WRT400N board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WRT400N_GPIO_LED_POWER		1
+#define WRT400N_GPIO_LED_WPS_BLUE	4
+#define WRT400N_GPIO_LED_WPS_AMBER	5
+#define WRT400N_GPIO_LED_WLAN		6
+
+#define WRT400N_GPIO_BTN_RESET		8
+#define WRT400N_GPIO_BTN_WLSEC		3
+
+#define WRT400N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT400N_KEYS_DEBOUNE_INTERVAL	(3 * WRT400N_KEYS_POLL_INTERVAL)
+
+#define WRT400N_MAC_ADDR_OFFSET		0x120c
+#define WRT400N_CALDATA0_OFFSET		0x1000
+#define WRT400N_CALDATA1_OFFSET		0x5000
+
+static struct mtd_partition wrt400n_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "linux",
+		.offset		= 0x040000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x180000,
+		.size		= 0x630000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "factory",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x770000,
+	}
+};
+
+static struct flash_platform_data wrt400n_flash_data = {
+	.parts		= wrt400n_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt400n_partitions),
+};
+
+static struct gpio_led wrt400n_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt400n:blue:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:amber:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:wlan",
+		.gpio		= WRT400N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:power",
+		.gpio		= WRT400N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}
+};
+
+static struct gpio_keys_button wrt400n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wlsec",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_WLSEC,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt400n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = art + WRT400N_MAC_ADDR_OFFSET;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt400n_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
+				 wrt400n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT400N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt400n_gpio_keys),
+					wrt400n_gpio_keys);
+
+	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
+		      art + WRT400N_CALDATA1_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT400N, "WRT400N", "Linksys WRT400N", wrt400n_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrtnode2q.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrtnode2q.c
new file mode 100644
index 0000000000..150a28b0d7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wrtnode2q.c
@@ -0,0 +1,126 @@
+/*
+ * WRTnode2Q board support
+ *
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2015 Kelei <xzmu@wrtnode.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WRTNODE2Q_GPIO_LED_WLAN		12
+#define WRTNODE2Q_GPIO_LED_WPS		13
+#define WRTNODE2Q_GPIO_LED_STATUS		13
+
+#define WRTNODE2Q_GPIO_LED_WAN		4
+#define WRTNODE2Q_GPIO_LED_LAN1		16
+#define WRTNODE2Q_GPIO_LED_LAN2		15
+#define WRTNODE2Q_GPIO_LED_LAN3		14
+#define WRTNODE2Q_GPIO_LED_LAN4		11
+
+#define WRTNODE2Q_GPIO_BTN_WPS		17
+
+#define WRTNODE2Q_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRTNODE2Q_KEYS_DEBOUNCE_INTERVAL	(3 * WRTNODE2Q_KEYS_POLL_INTERVAL)
+
+#define WRTNODE2Q_MAC0_OFFSET		0
+#define WRTNODE2Q_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led wrtnode2q_leds_gpio[] __initdata = {
+	{
+		.name		= "wrtnode2q:green:status",
+		.gpio		= WRTNODE2Q_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wrtnode2q:green:wlan",
+		.gpio		= WRTNODE2Q_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrtnode2q_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRTNODE2Q_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRTNODE2Q_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void __init wrtnode2q_gpio_led_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrtnode2q_leds_gpio),
+			wrtnode2q_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WRTNODE2Q_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(wrtnode2q_gpio_keys),
+			wrtnode2q_gpio_keys);
+}
+
+static void __init wrtnode2q_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f040000);
+
+	ath79_register_m25p80(NULL);
+
+	wrtnode2q_gpio_led_setup();
+
+	ath79_register_pci();
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WRTNODE2Q_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WRTNODE2Q_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + WRTNODE2Q_MAC0_OFFSET, 1);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRTNODE2Q, "WRTNODE2Q", "WRTnode2Q board",
+	     wrtnode2q_setup);
\ No newline at end of file
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-450hp2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-450hp2.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-wzr-450hp2.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-450hp2.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-ag300h.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-ag300h.c
new file mode 100644
index 0000000000..a9ed3fdd46
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-ag300h.c
@@ -0,0 +1,202 @@
+/*
+ *  Buffalo WZR-HP-AG300H board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@nbd.name>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPAG300H_MAC_OFFSET		0x20c
+#define WZRHPAG300H_KEYS_POLL_INTERVAL	20      /* msecs */
+#define WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPAG300H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpag300h_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wzrhpag300h_flash_data = {
+	.parts      = wzrhpag300h_flash_partitions,
+	.nr_parts   = ARRAY_SIZE(wzrhpag300h_flash_partitions),
+};
+
+static struct gpio_led wzrhpag300h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wzrhpag300h_wmac0_leds_gpio[] = {
+        {
+                .name           = "buffalo:amber:band2g",
+                .gpio           = 1,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:usb",
+                .gpio           = 3,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:band2g",
+                .gpio           = 5,
+                .active_low     = 1,
+	},
+};
+
+static struct gpio_led wzrhpag300h_wmac1_leds_gpio[] = {
+        {
+                .name           = "buffalo:green:band5g",
+                .gpio           = 1,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:router",
+                .gpio           = 3,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:blue:movie_engine",
+                .gpio           = 4,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:amber:band5g",
+                .gpio           = 5,
+                .active_low     = 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpag300h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 5,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_SW,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_SW,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.desc		= "movie_engine",
+		.type		= EV_SW,
+		.code		= BTN_7,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 1,
+	}
+};
+
+static void __init wzrhpag300h_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *eeprom2 = (u8 *) KSEG1ADDR(0x1f055000);
+	u8 *mac1 = eeprom1 + WZRHPAG300H_MAC_OFFSET;
+	u8 *mac2 = eeprom2 + WZRHPAG300H_MAC_OFFSET;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 1);
+
+	ath79_register_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	gpio_request_one(2, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpag300h_leds_gpio),
+					wzrhpag300h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPAG300H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpag300h_gpio_keys),
+					 wzrhpag300h_gpio_keys);
+
+	ath79_register_m25p80_multi(&wzrhpag300h_flash_data);
+
+	ap94_pci_init(eeprom1, mac1, eeprom2, mac2);
+
+	ap9x_pci_setup_wmac_leds(0, wzrhpag300h_wmac0_leds_gpio,
+				ARRAY_SIZE(wzrhpag300h_wmac0_leds_gpio));
+	ap9x_pci_setup_wmac_leds(1, wzrhpag300h_wmac1_leds_gpio,
+				ARRAY_SIZE(wzrhpag300h_wmac1_leds_gpio));
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_AG300H, "WZR-HP-AG300H",
+	     "Buffalo WZR-HP-AG300H/WZR-600DHP", wzrhpag300h_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh.c
new file mode 100644
index 0000000000..0a3eba9f77
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh.c
@@ -0,0 +1,279 @@
+/*
+ *  Buffalo WZR-HP-G300NH board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/nxp_74hc153.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH_GPIO_LED_USB	0
+#define WZRHPG300NH_GPIO_LED_DIAG	1
+#define WZRHPG300NH_GPIO_LED_WIRELESS	6
+#define WZRHPG300NH_GPIO_LED_SECURITY	17
+#define WZRHPG300NH_GPIO_LED_ROUTER	18
+
+#define WZRHPG300NH_GPIO_RTL8366_SDA	19
+#define WZRHPG300NH_GPIO_RTL8366_SCK	20
+
+#define WZRHPG300NH_GPIO_74HC153_S0	9
+#define WZRHPG300NH_GPIO_74HC153_S1	11
+#define WZRHPG300NH_GPIO_74HC153_1Y	12
+#define WZRHPG300NH_GPIO_74HC153_2Y	14
+
+#define WZRHPG300NH_GPIO_EXP_BASE	32
+#define WZRHPG300NH_GPIO_BTN_AOSS	(WZRHPG300NH_GPIO_EXP_BASE + 0)
+#define WZRHPG300NH_GPIO_BTN_RESET	(WZRHPG300NH_GPIO_EXP_BASE + 1)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_ON	(WZRHPG300NH_GPIO_EXP_BASE + 2)
+#define WZRHPG300NH_GPIO_BTN_QOS_ON	(WZRHPG300NH_GPIO_EXP_BASE + 3)
+#define WZRHPG300NH_GPIO_BTN_USB	(WZRHPG300NH_GPIO_EXP_BASE + 5)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
+#define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
+
+#define WZRHPG300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH_KEYS_POLL_INTERVAL)
+
+#define WZRHPG300NH_MAC_OFFSET		0x20c
+
+static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f60000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fc0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct physmap_flash_data wzrhpg300nh_flash_data = {
+	.width		= 2,
+	.parts		= wzrhpg300nh_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+};
+
+#define WZRHPG300NH_FLASH_BASE	0x1e000000
+#define WZRHPG300NH_FLASH_SIZE	(32 * 1024 * 1024)
+
+static struct resource wzrhpg300nh_flash_resources[] = {
+	[0] = {
+		.start	= WZRHPG300NH_FLASH_BASE,
+		.end	= WZRHPG300NH_FLASH_BASE + WZRHPG300NH_FLASH_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device wzrhpg300nh_flash_device = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.resource	= wzrhpg300nh_flash_resources,
+	.num_resources	= ARRAY_SIZE(wzrhpg300nh_flash_resources),
+	.dev		= {
+		.platform_data = &wzrhpg300nh_flash_data,
+	}
+};
+
+static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wireless",
+		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:blue:usb",
+		.gpio		= WZRHPG300NH_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wzrhpg300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos_on",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "qos_off",
+		.type		= EV_KEY,
+		.code		= BTN_4,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
+		.active_low	= 0,
+	}
+};
+
+static struct nxp_74hc153_platform_data wzrhpg300nh_74hc153_data = {
+	.gpio_base	= WZRHPG300NH_GPIO_EXP_BASE,
+	.gpio_pin_s0	= WZRHPG300NH_GPIO_74HC153_S0,
+	.gpio_pin_s1	= WZRHPG300NH_GPIO_74HC153_S1,
+	.gpio_pin_1y	= WZRHPG300NH_GPIO_74HC153_1Y,
+	.gpio_pin_2y	= WZRHPG300NH_GPIO_74HC153_2Y,
+};
+
+static struct platform_device wzrhpg300nh_74hc153_device = {
+	.name		= NXP_74HC153_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_74hc153_data,
+	}
+};
+
+static struct rtl8366_platform_data wzrhpg300nh_rtl8366_data = {
+	.gpio_sda	= WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck	= WZRHPG300NH_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wzrhpg300nh_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static struct platform_device wzrhpg300nh_rtl8366rb_device = {
+	.name           = RTL8366RB_DRIVER_NAME,
+	.id             = -1,
+	.dev = {
+		.platform_data  = &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static void __init wzrhpg300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = eeprom + WZRHPG300NH_MAC_OFFSET;
+	bool hasrtl8366rb = false;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	if (rtl8366_smi_detect(&wzrhpg300nh_rtl8366_data) == RTL8366_TYPE_RB)
+		hasrtl8366rb = true;
+
+	if (hasrtl8366rb) {
+		ath79_eth0_pll_data.pll_1000 = 0x1f000000;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+	} else {
+		ath79_eth0_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	}
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_wmac(eeprom, NULL);
+
+	platform_device_register(&wzrhpg300nh_74hc153_device);
+	platform_device_register(&wzrhpg300nh_flash_device);
+
+	if (hasrtl8366rb)
+		platform_device_register(&wzrhpg300nh_rtl8366rb_device);
+	else
+		platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
+					wzrhpg300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpg300nh_gpio_keys),
+					 wzrhpg300nh_gpio_keys);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH, "WZR-HP-G300NH",
+	     "Buffalo WZR-HP-G300NH", wzrhpg300nh_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh2.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh2.c
new file mode 100644
index 0000000000..c44a9cf770
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g300nh2.c
@@ -0,0 +1,174 @@
+/*
+ *  Buffalo WZR-HP-G300NH2 board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@nbd.name>
+ *  Copyright (C) 2011 Mark Deneen <mdeneen@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH2_MAC_OFFSET		0x20c
+#define WZRHPG300NH2_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH2_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg300nh2_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wzrhpg300nh2_flash_data = {
+	.parts          = wzrhpg300nh2_flash_partitions,
+	.nr_parts       = ARRAY_SIZE(wzrhpg300nh2_flash_partitions),
+};
+
+static struct gpio_led wzrhpg300nh2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 16,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wzrhpg300nh2_wmac_leds_gpio[] = {
+	{
+		.name           = "buffalo:blue:usb",
+		.gpio           = 4,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:green:wireless",
+		.gpio           = 5,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:orange:security",
+		.gpio           = 6,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:green:router",
+		.gpio           = 7,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_on",
+		.gpio           = 8,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_off",
+		.gpio           = 9,
+		.active_low     = 1,
+	},
+};
+
+/* The AOSS button is wmac gpio 12 */
+static struct gpio_keys_button wzrhpg300nh2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 0,
+	},
+};
+
+static void __init wzrhpg300nh2_setup(void)
+{
+
+	u8 *eeprom = (u8 *)   KSEG1ADDR(0x1f051000);
+	u8 *mac0   = eeprom + WZRHPG300NH2_MAC_OFFSET;
+	/* There is an eth1 but it is not connected to the switch */
+
+	ath79_register_m25p80_multi(&wzrhpg300nh2_flash_data);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_register_mdio(0, ~(BIT(0)));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	/* gpio13 is usb power.  Turn it on. */
+	gpio_request_one(13, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh2_leds_gpio),
+				 wzrhpg300nh2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg300nh2_gpio_keys),
+					wzrhpg300nh2_gpio_keys);
+	ap9x_pci_setup_wmac_leds(0, wzrhpg300nh2_wmac_leds_gpio,
+				ARRAY_SIZE(wzrhpg300nh2_wmac_leds_gpio));
+
+	ap91_pci_init(eeprom, mac0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH2, "WZR-HP-G300NH2",
+	     "Buffalo WZR-HP-G300NH2", wzrhpg300nh2_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g450h.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g450h.c
new file mode 100644
index 0000000000..5d235c49f4
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-wzr-hp-g450h.c
@@ -0,0 +1,169 @@
+/*
+ *  Buffalo WZR-HP-G450G board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@nbd.name>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG450H_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG450H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG450H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg450h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f80000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+	}
+};
+
+static struct flash_platform_data wzrhpg450h_flash_data = {
+	.parts		= wzrhpg450h_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg450h_partitions),
+};
+
+static struct gpio_led wzrhpg450h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_led wzrhpg450h_wmac_leds_gpio[] = {
+	{
+		.name		= "buffalo:blue:movie_engine",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:router",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:wireless",
+		.gpio		= 15,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpg450h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 1,
+	}, {
+		.desc		= "movie_engine",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 0,
+	}
+};
+
+
+static void __init wzrhpg450h_init(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *mac = (u8 *) ee + 2;
+
+	ath79_register_m25p80_multi(&wzrhpg450h_flash_data);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg450h_leds_gpio),
+				 wzrhpg450h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG450H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg450h_gpio_keys),
+					wzrhpg450h_gpio_keys);
+
+	ath79_register_eth(0);
+
+	gpio_request_one(16, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ap91_pci_init(ee, NULL);
+	ap9x_pci_get_wmac_data(0)->tx_gain_buffalo = true;
+	ap9x_pci_get_wmac_data(1)->tx_gain_buffalo = true;
+	ap9x_pci_setup_wmac_leds(0, wzrhpg450h_wmac_leds_gpio,
+				 ARRAY_SIZE(wzrhpg450h_wmac_leds_gpio));
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G450H, "WZR-HP-G450H", "Buffalo WZR-HP-G450H",
+	     wzrhpg450h_init);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-z1.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-z1.c
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/mach-z1.c
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-z1.c
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zbt-we1526.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zbt-we1526.c
new file mode 100644
index 0000000000..42bad11905
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zbt-we1526.c
@@ -0,0 +1,153 @@
+/*
+ * Zbtlink ZBT-WE1526 board support
+ *
+ * Copyright (C) 2016 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * Based on mach-dr531.c and mach-tl-wr841n-v9.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define ZBT_WE1526_GPIO_LED_STATUS	13
+#define ZBT_WE1526_GPIO_LED_LAN1	16
+#define ZBT_WE1526_GPIO_LED_LAN2	15
+#define ZBT_WE1526_GPIO_LED_LAN3	14
+#define ZBT_WE1526_GPIO_LED_LAN4	11
+#define ZBT_WE1526_GPIO_LED_WAN		4
+#define ZBT_WE1526_GPIO_LED_WLAN	12
+
+#define ZBT_WE1526_GPIO_BTN_RESET	17
+
+#define ZBT_WE1526_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZBT_WE1526_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * ZBT_WE1526_KEYS_POLL_INTERVAL)
+
+#define ZBT_WE1526_MAC0_OFFSET		0x0
+#define ZBT_WE1526_MAC1_OFFSET		0x6
+#define ZBT_WE1526_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led zbt_we1526_leds_gpio[] __initdata = {
+	{
+		.name		= "zbt-we1526:green:status",
+		.gpio		= ZBT_WE1526_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:lan1",
+		.gpio		= ZBT_WE1526_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:lan2",
+		.gpio		= ZBT_WE1526_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:lan3",
+		.gpio		= ZBT_WE1526_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:lan4",
+		.gpio		= ZBT_WE1526_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:wan",
+		.gpio		= ZBT_WE1526_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "zbt-we1526:green:wlan",
+		.gpio		= ZBT_WE1526_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button zbt_we1526_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZBT_WE1526_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZBT_WE1526_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init zbt_we1526_gpio_setup(void)
+{
+	/* For LED on GPIO4 */
+	ath79_gpio_function_disable(AR934X_GPIO_FUNC_CLK_OBS4_EN);
+	ath79_gpio_output_select(ZBT_WE1526_GPIO_LED_WAN, 0);
+
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_STATUS, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_LAN1, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_LAN2, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_LAN3, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_LAN4, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(ZBT_WE1526_GPIO_LED_WLAN, true);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(zbt_we1526_leds_gpio),
+				 zbt_we1526_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ZBT_WE1526_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(zbt_we1526_gpio_keys),
+					zbt_we1526_gpio_keys);
+}
+
+static void __init zbt_we1526_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	zbt_we1526_gpio_setup();
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + ZBT_WE1526_MAC0_OFFSET, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + ZBT_WE1526_MAC1_OFFSET, 0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + ZBT_WE1526_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_ZBT_WE1526, "ZBT-WE1526", "Zbtlink ZBT-WE1526",
+	     zbt_we1526_setup);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zcn-1523h.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zcn-1523h.c
new file mode 100644
index 0000000000..bc79ab9953
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/mach-zcn-1523h.c
@@ -0,0 +1,154 @@
+/*
+ *  Zcomax ZCN-1523H-2-8/5-16 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+
+#define ZCN_1523H_GPIO_BTN_RESET	0
+#define ZCN_1523H_GPIO_LED_INIT		11
+#define ZCN_1523H_GPIO_LED_LAN1		17
+
+#define ZCN_1523H_2_GPIO_LED_WEAK	13
+#define ZCN_1523H_2_GPIO_LED_MEDIUM	14
+#define ZCN_1523H_2_GPIO_LED_STRONG	15
+
+#define ZCN_1523H_5_GPIO_LAN2_POWER	1
+#define ZCN_1523H_5_GPIO_LED_LAN2	13
+#define ZCN_1523H_5_GPIO_LED_WEAK	14
+#define ZCN_1523H_5_GPIO_LED_MEDIUM	15
+#define ZCN_1523H_5_GPIO_LED_STRONG	16
+
+#define ZCN_1523H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZCN_1523H_KEYS_DEBOUNCE_INTERVAL (3 * ZCN_1523H_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button zcn_1523h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZCN_1523H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZCN_1523H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:amber:init",
+		.gpio		= ZCN_1523H_GPIO_LED_INIT,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan1",
+		.gpio		= ZCN_1523H_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_2_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_2_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_2_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_2_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_5_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_5_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_5_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_5_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan2",
+		.gpio		= ZCN_1523H_5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}
+};
+
+static void __init zcn_1523h_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0004);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(zcn_1523h_leds_gpio),
+					zcn_1523h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ZCN_1523H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(zcn_1523h_gpio_keys),
+					zcn_1523h_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN1 port */
+	ath79_register_eth(0);
+}
+
+static void __init zcn_1523h_2_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(9), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_2_leds_gpio),
+				 zcn_1523h_2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_2, "ZCN-1523H-2", "Zcomax ZCN-1523H-2",
+	     zcn_1523h_2_setup);
+
+static void __init zcn_1523h_5_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(8), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_5_leds_gpio),
+				 zcn_1523h_5_leds_gpio);
+
+	/* LAN2 port */
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_5, "ZCN-1523H-5", "Zcomax ZCN-1523H-5",
+	     zcn_1523h_5_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/machtypes.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/machtypes.h
similarity index 100%
rename from target/linux/ar71xx/files/arch/mips/ath79/machtypes.h
rename to target/linux/ar71xx/files-4.9/arch/mips/ath79/machtypes.h
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.c
new file mode 100644
index 0000000000..a1de55fb19
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.c
@@ -0,0 +1,85 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/etherdevice.h>
+
+#include "nvram.h"
+
+char *ath79_nvram_find_var(const char *name, const char *buf, unsigned buf_len)
+{
+	unsigned len = strlen(name);
+	char *cur, *last;
+
+	if (buf_len == 0 || len == 0)
+		return NULL;
+
+	if (buf_len < len)
+		return NULL;
+
+	if (len == 1)
+		return memchr(buf, (int) *name, buf_len);
+
+	last = (char *) buf + buf_len - len;
+	for (cur = (char *) buf; cur <= last; cur++)
+		if (cur[0] == name[0] && memcmp(cur, name, len) == 0)
+			return cur + len;
+
+	return NULL;
+}
+
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac)
+{
+	char *buf;
+	char *mac_str;
+	int ret;
+	int t;
+
+	buf = vmalloc(nvram_len);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, nvram, nvram_len);
+	buf[nvram_len - 1] = '\0';
+
+	mac_str = ath79_nvram_find_var(name, buf, nvram_len);
+	if (!mac_str) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	if (strlen(mac_str) == 19 && mac_str[0] == '"' && mac_str[18] == '"') {
+		mac_str[18] = 0;
+		mac_str++;
+	}
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx-%02hhx-%02hhx-%02hhx-%02hhx-%02hhx",
+			&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	ret = 0;
+
+free:
+	vfree(buf);
+	return ret;
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.h
new file mode 100644
index 0000000000..75151d4a3c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/nvram.h
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_NVRAM_H
+#define _ATH79_NVRAM_H
+
+char *ath79_nvram_find_var(const char *name, const char *buf,
+			   unsigned buf_len);
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac);
+
+#endif /* _ATH79_NVRAM_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.c
new file mode 100644
index 0000000000..2202351806
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.c
@@ -0,0 +1,126 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case ATH79_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+	case ATH79_SOC_AR9344:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.h
new file mode 100644
index 0000000000..5794941f08
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/pci-ath9k-fixup.h
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.c b/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.c
new file mode 100644
index 0000000000..76776e1d84
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.c
@@ -0,0 +1,358 @@
+/*
+ *  RouterBoot helper routines
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb: " fmt
+
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/routerboot.h>
+#include <linux/rle.h>
+#include <linux/lzo.h>
+
+#include "routerboot.h"
+
+#define RB_BLOCK_SIZE		0x1000
+#define RB_ART_SIZE		0x10000
+#define RB_MAGIC_ERD		0x00455244	/* extended radio data */
+
+static struct rb_info rb_info;
+
+static u32 get_u32(void *buf)
+{
+	u8 *p = buf;
+
+	return ((u32) p[3] + ((u32) p[2] << 8) + ((u32) p[1] << 16) +
+	       ((u32) p[0] << 24));
+}
+
+static u16 get_u16(void *buf)
+{
+	u8 *p = buf;
+
+	return (u16) p[1] + ((u16) p[0] << 8);
+}
+
+__init int
+routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard)
+{
+	u32 magic_ref = hard ? RB_MAGIC_HARD : RB_MAGIC_SOFT;
+	u32 magic;
+	u32 cur = *offset;
+
+	while (cur < buflen) {
+		magic = get_u32(buf + cur);
+		if (magic == magic_ref) {
+			*offset = cur;
+			return 0;
+		}
+
+		cur += 0x1000;
+	}
+
+	return -ENOENT;
+}
+
+__init int
+routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+		    u8 **tag_data, u16 *tag_len)
+{
+	uint32_t magic;
+	bool align = false;
+	int ret;
+
+	if (buflen < 4)
+		return -EINVAL;
+
+	magic = get_u32(buf);
+	switch (magic) {
+	case RB_MAGIC_ERD:
+		align = true;
+		/* fall trough */
+	case RB_MAGIC_HARD:
+		/* skip magic value */
+		buf += 4;
+		buflen -= 4;
+		break;
+
+	case RB_MAGIC_SOFT:
+		if (buflen < 8)
+			return -EINVAL;
+
+		/* skip magic and CRC value */
+		buf += 8;
+		buflen -= 8;
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	ret = -ENOENT;
+	while (buflen > 2) {
+		u16 id;
+		u16 len;
+
+		len = get_u16(buf);
+		buf += 2;
+		buflen -= 2;
+
+		if (buflen < 2)
+			break;
+
+		id = get_u16(buf);
+		buf += 2;
+		buflen -= 2;
+
+		if (id == RB_ID_TERMINATOR)
+			break;
+
+		if (buflen < len)
+			break;
+
+		if (id == tag_id) {
+			if (tag_len)
+				*tag_len = len;
+			if (tag_data)
+				*tag_data = buf;
+			ret = 0;
+			break;
+		}
+
+		if (align)
+			len = (len + 3) / 4;
+
+		buf += len;
+		buflen -= len;
+	}
+
+	return ret;
+}
+
+static inline int
+rb_find_hard_cfg_tag(u16 tag_id, u8 **tag_data, u16 *tag_len)
+{
+	if (!rb_info.hard_cfg_data ||
+	    !rb_info.hard_cfg_size)
+		return -ENOENT;
+
+	return routerboot_find_tag(rb_info.hard_cfg_data,
+				   rb_info.hard_cfg_size,
+				   tag_id, tag_data, tag_len);
+}
+
+__init const char *
+rb_get_board_name(void)
+{
+	u16 tag_len;
+	u8 *tag;
+	int err;
+
+	err = rb_find_hard_cfg_tag(RB_ID_BOARD_NAME, &tag, &tag_len);
+	if (err)
+		return NULL;
+
+	return tag;
+}
+
+__init u32
+rb_get_hw_options(void)
+{
+	u16 tag_len;
+	u8 *tag;
+	int err;
+
+	err = rb_find_hard_cfg_tag(RB_ID_HW_OPTIONS, &tag, &tag_len);
+	if (err)
+		return 0;
+
+	return get_u32(tag);
+}
+
+static void * __init
+__rb_get_wlan_data(u16 id)
+{
+	u16 tag_len;
+	u8 *tag;
+	void *buf;
+	int err;
+	u32 magic;
+	size_t src_done;
+	size_t dst_done;
+
+	err = rb_find_hard_cfg_tag(RB_ID_WLAN_DATA, &tag, &tag_len);
+	if (err) {
+		pr_err("no calibration data found\n");
+		goto err;
+	}
+
+	buf = kmalloc(RB_ART_SIZE, GFP_KERNEL);
+	if (buf == NULL) {
+		pr_err("no memory for calibration data\n");
+		goto err;
+	}
+
+	magic = get_u32(tag);
+	if (magic == RB_MAGIC_ERD) {
+		u8 *erd_data;
+		u16 erd_len;
+
+		if (id == 0)
+			goto err_free;
+
+		err = routerboot_find_tag(tag, tag_len, id,
+					  &erd_data, &erd_len);
+		if (err) {
+			pr_err("no ERD data found for id %u\n", id);
+			goto err_free;
+		}
+
+		dst_done = RB_ART_SIZE;
+		err = lzo1x_decompress_safe(erd_data, erd_len, buf, &dst_done);
+		if (err) {
+			pr_err("unable to decompress calibration data %d\n",
+			       err);
+			goto err_free;
+		}
+	} else {
+		if (id != 0)
+			goto err_free;
+
+		err = rle_decode((char *) tag, tag_len, buf, RB_ART_SIZE,
+				 &src_done, &dst_done);
+		if (err) {
+			pr_err("unable to decode calibration data\n");
+			goto err_free;
+		}
+	}
+
+	return buf;
+
+err_free:
+	kfree(buf);
+err:
+	return NULL;
+}
+
+__init void *
+rb_get_wlan_data(void)
+{
+	return __rb_get_wlan_data(0);
+}
+
+__init void *
+rb_get_ext_wlan_data(u16 id)
+{
+	return __rb_get_wlan_data(id);
+}
+
+__init const struct rb_info *
+rb_init_info(void *data, unsigned int size)
+{
+	unsigned int offset;
+
+	if (size == 0 || (size % RB_BLOCK_SIZE) != 0)
+		return NULL;
+
+	for (offset = 0; offset < size; offset += RB_BLOCK_SIZE) {
+		u32 magic;
+
+		magic = get_u32(data + offset);
+		switch (magic) {
+		case RB_MAGIC_HARD:
+			rb_info.hard_cfg_offs = offset;
+			break;
+
+		case RB_MAGIC_SOFT:
+			rb_info.soft_cfg_offs = offset;
+			break;
+		}
+	}
+
+	if (!rb_info.hard_cfg_offs) {
+		pr_err("could not find a valid RouterBOOT hard config\n");
+		return NULL;
+	}
+
+	if (!rb_info.soft_cfg_offs) {
+		pr_err("could not find a valid RouterBOOT soft config\n");
+		return NULL;
+	}
+
+	rb_info.hard_cfg_size = RB_BLOCK_SIZE;
+	rb_info.hard_cfg_data = kmemdup(data + rb_info.hard_cfg_offs,
+					RB_BLOCK_SIZE, GFP_KERNEL);
+	if (!rb_info.hard_cfg_data)
+		return NULL;
+
+	rb_info.board_name = rb_get_board_name();
+	rb_info.hw_options = rb_get_hw_options();
+
+	return &rb_info;
+}
+
+static char *rb_ext_wlan_data;
+
+static ssize_t
+rb_ext_wlan_data_read(struct file *filp, struct kobject *kobj,
+		      struct bin_attribute *attr, char *buf,
+		      loff_t off, size_t count)
+{
+         if (off + count > attr->size)
+                 return -EFBIG;
+
+         memcpy(buf, &rb_ext_wlan_data[off], count);
+
+         return count;
+}
+
+static const struct bin_attribute rb_ext_wlan_data_attr = {
+	.attr = {
+		.name = "ext_wlan_data",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.read = rb_ext_wlan_data_read,
+	.size = RB_ART_SIZE,
+};
+
+static int __init rb_sysfs_init(void)
+{
+	struct kobject *rb_kobj;
+	int ret;
+
+	rb_ext_wlan_data = rb_get_ext_wlan_data(1);
+	if (rb_ext_wlan_data == NULL)
+		return -ENOENT;
+
+	rb_kobj = kobject_create_and_add("routerboot", firmware_kobj);
+	if (rb_kobj == NULL) {
+		ret = -ENOMEM;
+		pr_err("unable to create sysfs entry\n");
+		goto err_free_wlan_data;
+	}
+
+	ret = sysfs_create_bin_file(rb_kobj, &rb_ext_wlan_data_attr);
+	if (ret) {
+		pr_err("unable to create sysfs file, %d\n", ret);
+		goto err_put_kobj;
+	}
+
+	return 0;
+
+err_put_kobj:
+	kobject_put(rb_kobj);
+err_free_wlan_data:
+	kfree(rb_ext_wlan_data);
+	return ret;
+}
+
+late_initcall(rb_sysfs_init);
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.h b/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.h
new file mode 100644
index 0000000000..cf189362d6
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/ath79/routerboot.h
@@ -0,0 +1,89 @@
+/*
+ *  RouterBoot definitions
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_ROUTERBOOT_H_
+#define _ATH79_ROUTERBOOT_H_
+
+struct rb_info {
+	unsigned int hard_cfg_offs;
+	unsigned int hard_cfg_size;
+	void *hard_cfg_data;
+	unsigned int soft_cfg_offs;
+
+	const char *board_name;
+	u32 hw_options;
+};
+
+/* Bit definitions for hardware options */
+#define RB_HW_OPT_UART_ABSENT		BIT(0)
+#define RB_HW_OPT_HAS_VOLTAGE		BIT(1)
+#define RB_HW_OPT_HAS_USB		BIT(2)
+#define RB_HW_OPT_HAS_ATTINY		BIT(3)
+#define RB_HW_OPT_NO_NAND		BIT(14)
+#define RB_HW_OPT_HAS_LCD		BIT(15)
+#define RB_HW_OPT_HAS_POE_OUT		BIT(16)
+#define RB_HW_OPT_HAS_uSD		BIT(17)
+#define RB_HW_OPT_HAS_SFP		BIT(20)
+#define RB_HW_OPT_HAS_WIFI		BIT(21)
+#define RB_HW_OPT_HAS_TS_FOR_ADC	BIT(22)
+#define RB_HW_OPT_HAS_PLC		BIT(29)
+
+static inline bool
+rb_hw_option_match(const struct rb_info *info, u32 mask, u32 val)
+{
+	return (info->hw_options & (val | mask)) == val;
+}
+
+static inline bool
+rb_has_hw_option(const struct rb_info *info, u32 mask)
+{
+	return rb_hw_option_match(info, mask, mask);
+}
+
+#ifdef CONFIG_ATH79_ROUTERBOOT
+const struct rb_info *rb_init_info(void *data, unsigned int size);
+void *rb_get_wlan_data(void);
+void *rb_get_ext_wlan_data(u16 id);
+
+int routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+			u8 **tag_data, u16 *tag_len);
+int routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard);
+#else
+static inline const struct rb_info *
+rb_init_info(void *data, unsigned int size)
+{
+	return NULL;
+}
+
+static inline void *rb_get_wlan_data(void)
+{
+	return NULL;
+}
+
+static inline void *rb_get_wlan_data(u16 id)
+{
+	return NULL;
+}
+
+static inline int
+routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+		    u8 **tag_data, u16 *tag_len)
+{
+	return -ENOENT;
+}
+
+static inline int
+routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard)
+{
+	return -ENOENT;
+}
+#endif
+
+#endif /* _ATH79_ROUTERBOOT_H_ */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/include/asm/fw/myloader/myloader.h b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/fw/myloader/myloader.h
new file mode 100644
index 0000000000..8a99d566d7
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/fw/myloader/myloader.h
@@ -0,0 +1,34 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_MIPS_FW_MYLOADER_H
+#define _ASM_MIPS_FW_MYLOADER_H
+
+#include <linux/myloader.h>
+
+struct myloader_info {
+	uint32_t	vid;
+	uint32_t	did;
+	uint32_t	svid;
+	uint32_t	sdid;
+	uint8_t		macs[MYLO_ETHADDR_COUNT][6];
+};
+
+#ifdef CONFIG_MYLOADER
+extern struct myloader_info *myloader_get_info(void) __init;
+#else
+static inline struct myloader_info *myloader_get_info(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_MYLOADER */
+
+#endif /* _ASM_MIPS_FW_MYLOADER_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/ag71xx_platform.h b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
new file mode 100644
index 0000000000..c4c3a6d44c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
@@ -0,0 +1,64 @@
+/*
+ *  Atheros AR71xx SoC specific platform data definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_ATH79_PLATFORM_H
+#define __ASM_MACH_ATH79_PLATFORM_H
+
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+
+struct ag71xx_switch_platform_data {
+	u8		phy4_mii_en:1;
+	u8		phy_poll_mask;
+};
+
+struct ag71xx_platform_data {
+	phy_interface_t	phy_if_mode;
+	u32		phy_mask;
+	int		speed;
+	int		duplex;
+	u32		reset_bit;
+	u8		mac_addr[ETH_ALEN];
+	struct device	*mii_bus_dev;
+
+	u8		has_gbit:1;
+	u8		is_ar91xx:1;
+	u8		is_ar7240:1;
+	u8		is_ar724x:1;
+	u8		has_ar8216:1;
+	u8		use_flow_control:1;
+	u8		disable_inline_checksum_engine:1;
+
+	struct ag71xx_switch_platform_data *switch_data;
+
+	void		(*ddr_flush)(void);
+	void		(*set_speed)(int speed);
+	void		(*update_pll)(u32 pll_10, u32 pll_100, u32 pll_1000);
+
+	unsigned int	max_frame_len;
+	unsigned int	desc_pktlen_mask;
+};
+
+struct ag71xx_mdio_platform_data {
+	u32		phy_mask;
+	u8		builtin_switch:1;
+	u8		is_ar7240:1;
+	u8		is_ar9330:1;
+	u8		is_ar934x:1;
+	unsigned long	mdio_clock;
+	unsigned long	ref_clock;
+
+	void		(*reset)(struct mii_bus *bus);
+};
+
+#endif /* __ASM_MACH_ATH79_PLATFORM_H */
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/mach-rb750.h b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/mach-rb750.h
new file mode 100644
index 0000000000..50d5a20974
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/mach-rb750.h
@@ -0,0 +1,84 @@
+/*
+ *  MikroTik RouterBOARD 750 definitions
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#ifndef _MACH_RB750_H
+#define _MACH_RB750_H
+
+#include <linux/bitops.h>
+
+#define RB750_GPIO_LVC573_LE	0	/* Latch enable on LVC573 */
+#define RB750_GPIO_NAND_IO0	1	/* NAND I/O 0 */
+#define RB750_GPIO_NAND_IO1	2	/* NAND I/O 1 */
+#define RB750_GPIO_NAND_IO2	3	/* NAND I/O 2 */
+#define RB750_GPIO_NAND_IO3	4	/* NAND I/O 3 */
+#define RB750_GPIO_NAND_IO4	5	/* NAND I/O 4 */
+#define RB750_GPIO_NAND_IO5	6	/* NAND I/O 5 */
+#define RB750_GPIO_NAND_IO6	7	/* NAND I/O 6 */
+#define RB750_GPIO_NAND_IO7	8	/* NAND I/O 7 */
+#define RB750_GPIO_NAND_NCE	11	/* NAND Chip Enable (active low) */
+#define RB750_GPIO_NAND_RDY	12	/* NAND Ready */
+#define RB750_GPIO_NAND_CLE	14	/* NAND Command Latch Enable */
+#define RB750_GPIO_NAND_ALE	15	/* NAND Address Latch Enable */
+#define RB750_GPIO_NAND_NRE	16	/* NAND Read Enable (active low) */
+#define RB750_GPIO_NAND_NWE	17	/* NAND Write Enable (active low) */
+
+#define RB750_GPIO_BTN_RESET	1
+#define RB750_GPIO_SPI_CS0	2
+#define RB750_GPIO_LED_ACT	12
+#define RB750_GPIO_LED_PORT1	13
+#define RB750_GPIO_LED_PORT2	14
+#define RB750_GPIO_LED_PORT3	15
+#define RB750_GPIO_LED_PORT4	16
+#define RB750_GPIO_LED_PORT5	17
+
+#define RB750_LED_ACT		BIT(RB750_GPIO_LED_ACT)
+#define RB750_LED_PORT1		BIT(RB750_GPIO_LED_PORT1)
+#define RB750_LED_PORT2		BIT(RB750_GPIO_LED_PORT2)
+#define RB750_LED_PORT3		BIT(RB750_GPIO_LED_PORT3)
+#define RB750_LED_PORT4		BIT(RB750_GPIO_LED_PORT4)
+#define RB750_LED_PORT5		BIT(RB750_GPIO_LED_PORT5)
+#define RB750_NAND_NCE		BIT(RB750_GPIO_NAND_NCE)
+
+#define RB750_LVC573_LE		BIT(RB750_GPIO_LVC573_LE)
+
+#define RB750_LED_BITS	(RB750_LED_PORT1 | RB750_LED_PORT2 | RB750_LED_PORT3 | \
+			 RB750_LED_PORT4 | RB750_LED_PORT5 | RB750_LED_ACT)
+
+#define RB7XX_GPIO_NAND_NCE	0
+#define RB7XX_GPIO_MON		9
+#define RB7XX_GPIO_LED_ACT	11
+#define RB7XX_GPIO_USB_POWERON	13
+
+#define RB7XX_NAND_NCE		BIT(RB7XX_GPIO_NAND_NCE)
+#define RB7XX_LED_ACT		BIT(RB7XX_GPIO_LED_ACT)
+#define RB7XX_MONITOR		BIT(RB7XX_GPIO_MON)
+#define RB7XX_USB_POWERON	BIT(RB7XX_GPIO_USB_POWERON)
+
+struct rb750_led_data {
+	char	*name;
+	char	*default_trigger;
+	u32	mask;
+	int	active_low;
+};
+
+struct rb750_led_platform_data {
+	int			num_leds;
+	struct rb750_led_data	*leds;
+	void			(*latch_change)(u32 clear, u32 set);
+};
+
+struct rb7xx_nand_platform_data {
+	u32 nce_line;
+
+	void (*enable_pins)(void);
+	void (*disable_pins)(void);
+	void (*latch_change)(u32, u32);
+};
+
+#endif /* _MACH_RB750_H */
\ No newline at end of file
diff --git a/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
new file mode 100644
index 0000000000..37512ba1a1
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
@@ -0,0 +1,43 @@
+/*
+ * SPI driver definitions for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define CPLD_GPIO_nLED1		0
+#define CPLD_GPIO_nLED2		1
+#define CPLD_GPIO_nLED3		2
+#define CPLD_GPIO_nLED4		3
+#define CPLD_GPIO_FAN		4
+#define CPLD_GPIO_ALE		5
+#define CPLD_GPIO_CLE		6
+#define CPLD_GPIO_nCE		7
+#define CPLD_GPIO_nLED5		8
+
+#define CPLD_NUM_GPIOS		9
+
+#define CPLD_CFG_nLED1		BIT(CPLD_GPIO_nLED1)
+#define CPLD_CFG_nLED2		BIT(CPLD_GPIO_nLED2)
+#define CPLD_CFG_nLED3		BIT(CPLD_GPIO_nLED3)
+#define CPLD_CFG_nLED4		BIT(CPLD_GPIO_nLED4)
+#define CPLD_CFG_FAN		BIT(CPLD_GPIO_FAN)
+#define CPLD_CFG_ALE		BIT(CPLD_GPIO_ALE)
+#define CPLD_CFG_CLE		BIT(CPLD_GPIO_CLE)
+#define CPLD_CFG_nCE		BIT(CPLD_GPIO_nCE)
+#define CPLD_CFG_nLED5		BIT(CPLD_GPIO_nLED5)
+
+struct rb4xx_cpld_platform_data {
+	unsigned	gpio_base;
+};
+
+extern int rb4xx_cpld_change_cfg(unsigned mask, unsigned value);
+extern int rb4xx_cpld_read(unsigned char *rx_buf,
+			   unsigned cnt);
+extern int rb4xx_cpld_write(const unsigned char *buf, unsigned count);
diff --git a/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-latch.c b/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-latch.c
new file mode 100644
index 0000000000..d911f6a2cb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-latch.c
@@ -0,0 +1,220 @@
+/*
+ *  GPIO latch driver
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include <linux/platform_data/gpio-latch.h>
+
+struct gpio_latch_chip {
+	struct gpio_chip gc;
+
+	struct mutex mutex;
+	struct mutex latch_mutex;
+	bool latch_enabled;
+	int le_gpio;
+	bool le_active_low;
+	int *gpios;
+};
+
+static inline struct gpio_latch_chip *to_gpio_latch_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct gpio_latch_chip, gc);
+}
+
+static void gpio_latch_lock(struct gpio_latch_chip *glc, bool enable)
+{
+	mutex_lock(&glc->mutex);
+
+	if (enable)
+		glc->latch_enabled = true;
+
+	if (glc->latch_enabled)
+		mutex_lock(&glc->latch_mutex);
+}
+
+static void gpio_latch_unlock(struct gpio_latch_chip *glc, bool disable)
+{
+	if (glc->latch_enabled)
+		mutex_unlock(&glc->latch_mutex);
+
+	if (disable)
+		glc->latch_enabled = true;
+
+	mutex_unlock(&glc->mutex);
+}
+
+static int
+gpio_latch_get(struct gpio_chip *gc, unsigned offset)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	int ret;
+
+	gpio_latch_lock(glc, false);
+	ret = gpio_get_value(glc->gpios[offset]);
+	gpio_latch_unlock(glc, false);
+
+	return ret;
+}
+
+static void
+gpio_latch_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	bool enable_latch = false;
+	bool disable_latch = false;
+	int gpio;
+
+	gpio = glc->gpios[offset];
+
+	if (gpio == glc->le_gpio) {
+		enable_latch = value ^ glc->le_active_low;
+		disable_latch = !enable_latch;
+	}
+
+	gpio_latch_lock(glc, enable_latch);
+	gpio_set_value(gpio, value);
+	gpio_latch_unlock(glc, disable_latch);
+}
+
+static int
+gpio_latch_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	int ret;
+
+	gpio_latch_lock(glc, false);
+	ret = gpio_direction_input(glc->gpios[offset]);
+	gpio_latch_unlock(glc, false);
+
+	return ret;
+}
+
+static int
+gpio_latch_direction_output(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	bool enable_latch = false;
+	bool disable_latch = false;
+	int gpio;
+	int ret;
+
+	gpio = glc->gpios[offset];
+
+	if (gpio == glc->le_gpio) {
+		enable_latch = value ^ glc->le_active_low;
+		disable_latch = !enable_latch;
+	}
+
+	gpio_latch_lock(glc, enable_latch);
+	ret = gpio_direction_output(gpio, value);
+	gpio_latch_unlock(glc, disable_latch);
+
+	return ret;
+}
+
+static int gpio_latch_probe(struct platform_device *pdev)
+{
+	struct gpio_latch_chip *glc;
+	struct gpio_latch_platform_data *pdata;
+	struct gpio_chip *gc;
+	int size;
+	int ret;
+	int i;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata)
+		return -EINVAL;
+
+	if (pdata->le_gpio_index >= pdata->num_gpios ||
+	    !pdata->num_gpios ||
+	    !pdata->gpios)
+		return -EINVAL;
+
+	for (i = 0; i < pdata->num_gpios; i++) {
+		int gpio = pdata->gpios[i];
+
+		ret = devm_gpio_request(&pdev->dev, gpio,
+					GPIO_LATCH_DRIVER_NAME);
+		if (ret)
+			return ret;
+	}
+
+	glc = devm_kzalloc(&pdev->dev, sizeof(*glc), GFP_KERNEL);
+	if (!glc)
+		return -ENOMEM;
+
+	mutex_init(&glc->mutex);
+	mutex_init(&glc->latch_mutex);
+
+	size = pdata->num_gpios * sizeof(glc->gpios[0]);
+	glc->gpios = devm_kzalloc(&pdev->dev, size , GFP_KERNEL);
+	if (!glc->gpios)
+		return -ENOMEM;
+
+	memcpy(glc->gpios, pdata->gpios, size);
+
+	glc->le_gpio = glc->gpios[pdata->le_gpio_index];
+	glc->le_active_low = pdata->le_active_low;
+
+	gc = &glc->gc;
+
+	gc->label = GPIO_LATCH_DRIVER_NAME;
+	gc->base = pdata->base;
+	gc->can_sleep = true;
+	gc->ngpio = pdata->num_gpios;
+	gc->get = gpio_latch_get;
+	gc->set = gpio_latch_set;
+	gc->direction_input = gpio_latch_direction_input,
+	gc->direction_output = gpio_latch_direction_output;
+
+	platform_set_drvdata(pdev, glc);
+
+	ret = gpiochip_add(&glc->gc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int gpio_latch_remove(struct platform_device *pdev)
+{
+	struct gpio_latch_chip *glc = platform_get_drvdata(pdev);
+
+	gpiochip_remove(&glc->gc);
+	return 0;
+}
+
+
+static struct platform_driver gpio_latch_driver = {
+	.probe = gpio_latch_probe,
+	.remove = gpio_latch_remove,
+	.driver = {
+		.name = GPIO_LATCH_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init gpio_latch_init(void)
+{
+	return platform_driver_register(&gpio_latch_driver);
+}
+
+postcore_initcall(gpio_latch_init);
+
+MODULE_DESCRIPTION("GPIO latch driver");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" GPIO_LATCH_DRIVER_NAME);
diff --git a/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-nxp-74hc153.c b/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-nxp-74hc153.c
new file mode 100644
index 0000000000..82e6e943ff
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/gpio/gpio-nxp-74hc153.c
@@ -0,0 +1,243 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer GPIO driver
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/nxp_74hc153.h>
+
+#define NXP_74HC153_NUM_GPIOS	8
+#define NXP_74HC153_S0_MASK	0x1
+#define NXP_74HC153_S1_MASK	0x2
+#define NXP_74HC153_BANK_MASK	0x4
+
+struct nxp_74hc153_chip {
+	struct device		*parent;
+	struct gpio_chip	gpio_chip;
+	struct mutex		lock;
+};
+
+static struct nxp_74hc153_chip *gpio_to_nxp(struct gpio_chip *gc)
+{
+	return container_of(gc, struct nxp_74hc153_chip, gpio_chip);
+}
+
+static int nxp_74hc153_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	return 0;
+}
+
+static int nxp_74hc153_direction_output(struct gpio_chip *gc,
+					unsigned offset, int val)
+{
+	return -EINVAL;
+}
+
+static int nxp_74hc153_get_value(struct gpio_chip *gc, unsigned offset)
+{
+	struct nxp_74hc153_chip *nxp;
+	struct nxp_74hc153_platform_data *pdata;
+	unsigned s0;
+	unsigned s1;
+	unsigned pin;
+	int ret;
+
+	nxp = gpio_to_nxp(gc);
+	pdata = nxp->parent->platform_data;
+
+	s0 = !!(offset & NXP_74HC153_S0_MASK);
+	s1 = !!(offset & NXP_74HC153_S1_MASK);
+	pin = (offset & NXP_74HC153_BANK_MASK) ? pdata->gpio_pin_2y
+					       : pdata->gpio_pin_1y;
+
+	mutex_lock(&nxp->lock);
+	gpio_set_value(pdata->gpio_pin_s0, s0);
+	gpio_set_value(pdata->gpio_pin_s1, s1);
+	ret = gpio_get_value(pin);
+	mutex_unlock(&nxp->lock);
+
+	return ret;
+}
+
+static void nxp_74hc153_set_value(struct gpio_chip *gc,
+				  unsigned offset, int val)
+{
+	/* not supported */
+}
+
+static int nxp_74hc153_probe(struct platform_device *pdev)
+{
+	struct nxp_74hc153_platform_data *pdata;
+	struct nxp_74hc153_chip *nxp;
+	struct gpio_chip *gc;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_dbg(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	nxp = kzalloc(sizeof(struct nxp_74hc153_chip), GFP_KERNEL);
+	if (nxp == NULL) {
+		dev_err(&pdev->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s0, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_nxp;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s1, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_s0;
+	}
+
+	err = gpio_request(pdata->gpio_pin_1y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_s1;
+	}
+
+	err = gpio_request(pdata->gpio_pin_2y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_1y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s0, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s1, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_1y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_2y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_2y;
+	}
+
+	nxp->parent = &pdev->dev;
+	mutex_init(&nxp->lock);
+
+	gc = &nxp->gpio_chip;
+
+	gc->direction_input  = nxp_74hc153_direction_input;
+	gc->direction_output = nxp_74hc153_direction_output;
+	gc->get = nxp_74hc153_get_value;
+	gc->set = nxp_74hc153_set_value;
+	gc->can_sleep = 1;
+
+	gc->base = pdata->gpio_base;
+	gc->ngpio = NXP_74HC153_NUM_GPIOS;
+	gc->label = dev_name(nxp->parent);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	gc->dev = nxp->parent;
+#else
+	gc->parent = nxp->parent;
+#endif
+	gc->owner = THIS_MODULE;
+
+	err = gpiochip_add(&nxp->gpio_chip);
+	if (err) {
+		dev_err(&pdev->dev, "unable to add gpio chip, err=%d\n", err);
+		goto err_free_2y;
+	}
+
+	platform_set_drvdata(pdev, nxp);
+	return 0;
+
+err_free_2y:
+	gpio_free(pdata->gpio_pin_2y);
+err_free_1y:
+	gpio_free(pdata->gpio_pin_1y);
+err_free_s1:
+	gpio_free(pdata->gpio_pin_s1);
+err_free_s0:
+	gpio_free(pdata->gpio_pin_s0);
+err_free_nxp:
+	kfree(nxp);
+	return err;
+}
+
+static int nxp_74hc153_remove(struct platform_device *pdev)
+{
+	struct nxp_74hc153_chip *nxp = platform_get_drvdata(pdev);
+	struct nxp_74hc153_platform_data *pdata = pdev->dev.platform_data;
+
+	if (nxp) {
+		gpiochip_remove(&nxp->gpio_chip);
+		gpio_free(pdata->gpio_pin_2y);
+		gpio_free(pdata->gpio_pin_1y);
+		gpio_free(pdata->gpio_pin_s1);
+		gpio_free(pdata->gpio_pin_s0);
+
+		kfree(nxp);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver nxp_74hc153_driver = {
+	.probe		= nxp_74hc153_probe,
+	.remove		= nxp_74hc153_remove,
+	.driver = {
+		.name	= NXP_74HC153_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nxp_74hc153_init(void)
+{
+	return platform_driver_register(&nxp_74hc153_driver);
+}
+subsys_initcall(nxp_74hc153_init);
+
+static void __exit nxp_74hc153_exit(void)
+{
+	platform_driver_unregister(&nxp_74hc153_driver);
+}
+module_exit(nxp_74hc153_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("GPIO expander driver for NXP 74HC153");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" NXP_74HC153_DRIVER_NAME);
diff --git a/target/linux/ar71xx/files-4.9/drivers/leds/leds-nu801.c b/target/linux/ar71xx/files-4.9/drivers/leds/leds-nu801.c
new file mode 100644
index 0000000000..11e8927785
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/leds/leds-nu801.c
@@ -0,0 +1,396 @@
+/*
+ * LED driver for NU801
+ *
+ * Kevin Paul Herbert
+ * Copyright (c) 2012, Meraki, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/leds-nu801.h>
+
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+#define MAX_NAME_LENGTH 24
+#define NUM_COLORS 3
+
+static const char * const led_nu801_colors[] = { "blue", "green", "red" };
+
+struct led_nu801_led_data {
+	struct led_classdev cdev;
+	struct led_nu801_data *controller;
+	enum led_brightness level;
+	char name[MAX_NAME_LENGTH];
+};
+
+struct led_nu801_data {
+	unsigned cki;
+	unsigned sdi;
+	int lei;
+	struct delayed_work work;
+	struct led_nu801_led_data *led_chain;
+	int num_leds;
+	const char *device_name;
+	const char *name;
+	u32 ndelay;
+	atomic_t pending;
+};
+
+static void led_nu801_work(struct work_struct *work)
+{
+	struct led_nu801_data	*controller =
+		container_of(work, struct led_nu801_data, work.work);
+	struct led_nu801_led_data *led;
+	u16 bit;
+	u16 brightness;
+	int index;
+
+	for (index = 0; index < controller->num_leds; index++) {
+		led = &controller->led_chain[index];
+		brightness = led->level << 8; /* To do: gamma correction */
+		for (bit = 0x8000; bit; bit = bit >> 1) {
+			gpio_set_value(controller->sdi,
+				       (brightness & bit) != 0);
+			gpio_set_value(controller->cki, 1);
+			if (unlikely(((index == (controller->num_leds - 1)) &&
+				      (bit == 1) &&
+				      (controller->lei < 0)))) {
+				udelay(600);
+			} else {
+				ndelay(controller->ndelay);
+			}
+			gpio_set_value(controller->cki, 0);
+			ndelay(controller->ndelay);
+		}
+	}
+	if (controller->lei >= 0) {
+		gpio_set_value(controller->lei, 1);
+		ndelay(controller->ndelay);
+		gpio_set_value(controller->lei, 0);
+	}
+	atomic_set(&controller->pending, 1);
+}
+
+static void led_nu801_set(struct led_classdev *led_cdev,
+			  enum led_brightness value)
+{
+	struct led_nu801_led_data *led_dat =
+		container_of(led_cdev, struct led_nu801_led_data, cdev);
+	struct led_nu801_data *controller = led_dat->controller;
+
+	if (led_dat->level != value) {
+		led_dat->level = value;
+		if (atomic_dec_and_test(&controller->pending))
+			schedule_delayed_work(&led_dat->controller->work,
+					      (HZ/1000) + 1);
+	}
+}
+
+static int led_nu801_create(struct led_nu801_data *controller,
+				    struct device *parent,
+				    int index,
+				    enum led_brightness brightness,
+#ifdef CONFIG_LEDS_TRIGGERS
+				    const char *default_trigger,
+#endif
+				    const char *color)
+{
+	struct led_nu801_led_data *led = &controller->led_chain[index];
+	int ret;
+
+	scnprintf(led->name, sizeof(led->name), "%s:%s:%s%d",
+		  controller->device_name, color, controller->name,
+		  (controller->num_leds - (index + 1)) / NUM_COLORS);
+	led->cdev.name = led->name;
+	led->cdev.brightness_set = led_nu801_set;
+#ifdef CONFIG_LEDS_TRIGGERS
+	led->cdev.default_trigger = default_trigger;
+#endif
+	led->level = brightness;
+	led->controller = controller;
+	ret = led_classdev_register(parent, &led->cdev);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(led);
+	return ret;
+}
+
+static int
+led_nu801_create_chain(const struct led_nu801_template *template,
+			struct led_nu801_data *controller,
+			struct device *parent)
+{
+	int ret;
+	int index;
+
+	controller->cki = template->cki;
+	controller->sdi = template->sdi;
+	controller->lei = template->lei;
+	controller->num_leds = template->num_leds * 3;
+	controller->device_name = template->device_name;
+	controller->name = template->name;
+	controller->ndelay = template->ndelay;
+	atomic_set(&controller->pending, 1);
+
+	controller->led_chain = kzalloc(sizeof(struct led_nu801_led_data) *
+					controller->num_leds, GFP_KERNEL);
+
+	if (!controller->led_chain)
+		return -ENOMEM;
+
+	ret = gpio_request(controller->cki, template->name);
+	if (ret < 0)
+		goto err_free_chain;
+
+	ret = gpio_request(controller->sdi, template->name);
+	if (ret < 0)
+		goto err_ret_cki;
+
+	if (controller->lei >= 0) {
+		ret = gpio_request(controller->lei, template->name);
+		if (ret < 0)
+			goto err_ret_sdi;
+		ret = gpio_direction_output(controller->lei, 0);
+		if (ret < 0)
+			goto err_ret_lei;
+	}
+
+	ret = gpio_direction_output(controller->cki, 0);
+	if (ret < 0)
+		goto err_ret_lei;
+
+	ret = gpio_direction_output(controller->sdi, 0);
+	if (ret < 0)
+		goto err_ret_lei;
+
+	for (index = 0; index < controller->num_leds; index++) {
+		ret = led_nu801_create(controller, parent, index,
+			template->init_brightness
+			[index % NUM_COLORS],
+#ifdef CONFIG_LEDS_TRIGGERS
+			template->default_trigger,
+#endif
+			template->led_colors[index % NUM_COLORS] ?
+			template->led_colors[index % NUM_COLORS] :
+			led_nu801_colors[index % NUM_COLORS]);
+		if (ret < 0)
+			goto err_ret_sdi;
+	}
+
+	INIT_DELAYED_WORK(&controller->work, led_nu801_work);
+	schedule_delayed_work(&controller->work, 0);
+
+	return 0;
+
+err_ret_lei:
+	if (controller->lei >= 0)
+		gpio_free(controller->lei);
+err_ret_sdi:
+	gpio_free(controller->sdi);
+err_ret_cki:
+	gpio_free(controller->cki);
+err_free_chain:
+	kfree(controller->led_chain);
+
+	return ret;
+}
+
+static void led_nu801_delete_chain(struct led_nu801_data *controller)
+{
+	struct led_nu801_led_data *led_chain;
+	struct led_nu801_led_data *led;
+	int index;
+	int num_leds;
+
+	led_chain = controller->led_chain;
+	controller->led_chain = 0;
+	num_leds = controller->num_leds;
+	controller->num_leds = 0;
+	cancel_delayed_work_sync(&controller->work);
+
+	for (index = 0; index < num_leds; index++) {
+		led = &led_chain[index];
+		led_classdev_unregister(&led->cdev);
+	}
+
+	gpio_free(controller->cki);
+	gpio_free(controller->sdi);
+	if (controller->lei >= 0)
+		gpio_free(controller->lei);
+
+	kfree(led_chain);
+}
+
+static struct led_nu801_data *
+leds_nu801_create_of(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node, *child;
+	struct led_nu801_data *controllers;
+	int count = 0, ret;
+	int i = 0;
+
+	for_each_child_of_node(np, child)
+		count++;
+	if (!count)
+		return NULL;
+
+	controllers = kzalloc(sizeof(struct led_nu801_data) * count,
+			      GFP_KERNEL);
+	if (!controllers)
+		return NULL;
+
+	for_each_child_of_node(np, child) {
+		const char *state;
+		struct led_nu801_template template = {};
+		struct device_node *colors;
+		int jj;
+
+		template.cki = of_get_named_gpio_flags(child, "cki", 0, NULL);
+		template.sdi = of_get_named_gpio_flags(child, "sdi", 0, NULL);
+		if (of_find_property(child, "lei", NULL)) {
+			template.lei = of_get_named_gpio_flags(child, "lei",
+							       0, NULL);
+		} else {
+			template.lei = -1;
+		}
+		of_property_read_u32(child, "ndelay", &template.ndelay);
+		of_property_read_u32(child, "num_leds", &template.num_leds);
+		template.name = of_get_property(child, "label", NULL) ? :
+			child->name;
+		template.default_trigger = of_get_property(child,
+			"default-trigger", NULL);
+
+		jj = 0;
+		for_each_child_of_node(child, colors) {
+			template.led_colors[jj] = of_get_property(colors,
+				 "label", NULL);
+			state = of_get_property(colors, "state", NULL);
+			if (!strncmp(state, "off", 3))
+				template.init_brightness[jj] = LED_OFF;
+			else if (!strncmp(state, "half", 4))
+				template.init_brightness[jj] = LED_HALF;
+			else if (!strncmp(state, "full", 4))
+				template.init_brightness[jj] = LED_FULL;
+			jj++;
+		}
+
+		ret = led_nu801_create_chain(&template,
+					     &controllers[i],
+					     &pdev->dev);
+		if (ret < 0)
+			goto err;
+		i++;
+	}
+
+	return controllers;
+
+err:
+	for (i = i - 1; i >= 0; i--)
+		led_nu801_delete_chain(&controllers[i]);
+	kfree(controllers);
+	return NULL;
+}
+
+static int led_nu801_probe(struct platform_device *pdev)
+{
+	struct led_nu801_platform_data *pdata = pdev->dev.platform_data;
+	struct led_nu801_data *controllers;
+	int i, ret = 0;
+
+	if (!(pdata && pdata->num_controllers)) {
+		controllers = leds_nu801_create_of(pdev);
+		if (!controllers)
+			return -ENODEV;
+	}
+
+	controllers = kzalloc(sizeof(struct led_nu801_data) *
+			      pdata->num_controllers, GFP_KERNEL);
+	if (!controllers)
+		return -ENOMEM;
+
+	for (i = 0; i < pdata->num_controllers; i++) {
+		ret = led_nu801_create_chain(&pdata->template[i],
+					      &controllers[i],
+					      &pdev->dev);
+		if (ret < 0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, controllers);
+
+	return 0;
+
+err:
+	for (i = i - 1; i >= 0; i--)
+		led_nu801_delete_chain(&controllers[i]);
+
+	kfree(controllers);
+
+	return ret;
+}
+
+static int led_nu801_remove(struct platform_device *pdev)
+{
+	int i;
+	struct led_nu801_platform_data *pdata = pdev->dev.platform_data;
+	struct led_nu801_data *controllers;
+
+	controllers = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pdata->num_controllers; i++)
+		led_nu801_delete_chain(&controllers[i]);
+
+	kfree(controllers);
+
+	return 0;
+}
+
+static const struct of_device_id of_numen_leds_match[] = {
+	{ .compatible = "numen,leds-nu801", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_pwm_leds_match);
+
+static struct platform_driver led_nu801_driver = {
+	.probe		= led_nu801_probe,
+	.remove		= led_nu801_remove,
+	.driver		= {
+		.name	= "leds-nu801",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_numen_leds_match,
+	},
+};
+
+static int __init led_nu801_init(void)
+{
+	return platform_driver_register(&led_nu801_driver);
+}
+
+static void __exit led_nu801_exit(void)
+{
+	platform_driver_unregister(&led_nu801_driver);
+}
+
+module_init(led_nu801_init);
+module_exit(led_nu801_exit);
+
+MODULE_AUTHOR("Kevin Paul Herbert <kph@meraki.net>");
+MODULE_DESCRIPTION("NU801 LED driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:leds-nu801");
diff --git a/target/linux/ar71xx/files-4.9/drivers/leds/leds-rb750.c b/target/linux/ar71xx/files-4.9/drivers/leds/leds-rb750.c
new file mode 100644
index 0000000000..79e98b4882
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/leds/leds-rb750.c
@@ -0,0 +1,144 @@
+/*
+ * LED driver for the RouterBOARD 750
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ath79/mach-rb750.h>
+
+#define DRV_NAME	"leds-rb750"
+
+struct rb750_led_dev {
+	struct led_classdev	cdev;
+	u32			mask;
+	int			active_low;
+	void			(*latch_change)(u32 clear, u32 set);
+};
+
+struct rb750_led_drvdata {
+	struct rb750_led_dev	*led_devs;
+	int			num_leds;
+};
+
+static inline struct rb750_led_dev *to_rbled(struct led_classdev *led_cdev)
+{
+	return (struct rb750_led_dev *)container_of(led_cdev,
+		struct rb750_led_dev, cdev);
+}
+
+static void rb750_led_brightness_set(struct led_classdev *led_cdev,
+				     enum led_brightness value)
+{
+	struct rb750_led_dev *rbled = to_rbled(led_cdev);
+	int level;
+
+	level = (value == LED_OFF) ? 0 : 1;
+	level ^= rbled->active_low;
+
+	if (level)
+		rbled->latch_change(0, rbled->mask);
+	else
+		rbled->latch_change(rbled->mask, 0);
+}
+
+static int rb750_led_probe(struct platform_device *pdev)
+{
+	struct rb750_led_platform_data *pdata;
+	struct rb750_led_drvdata *drvdata;
+	int ret = 0;
+	int i;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	drvdata = kzalloc(sizeof(struct rb750_led_drvdata) +
+			  sizeof(struct rb750_led_dev) * pdata->num_leds,
+			  GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->num_leds = pdata->num_leds;
+	drvdata->led_devs = (struct rb750_led_dev *) &drvdata[1];
+
+	for (i = 0; i < drvdata->num_leds; i++) {
+		struct rb750_led_dev *rbled = &drvdata->led_devs[i];
+		struct rb750_led_data *led_data = &pdata->leds[i];
+
+		rbled->cdev.name = led_data->name;
+		rbled->cdev.default_trigger = led_data->default_trigger;
+		rbled->cdev.brightness_set = rb750_led_brightness_set;
+		rbled->cdev.brightness = LED_OFF;
+
+		rbled->mask = led_data->mask;
+		rbled->active_low = !!led_data->active_low;
+		rbled->latch_change = pdata->latch_change;
+
+		ret = led_classdev_register(&pdev->dev, &rbled->cdev);
+		if (ret)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+	return 0;
+
+err:
+	for (i = i - 1; i >= 0; i--)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return ret;
+}
+
+static int rb750_led_remove(struct platform_device *pdev)
+{
+	struct rb750_led_drvdata *drvdata;
+	int i;
+
+	drvdata = platform_get_drvdata(pdev);
+	for (i = 0; i < drvdata->num_leds; i++)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return 0;
+}
+
+static struct platform_driver rb750_led_driver = {
+	.probe		= rb750_led_probe,
+	.remove		= rb750_led_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:leds-rb750");
+
+static int __init rb750_led_init(void)
+{
+	return platform_driver_register(&rb750_led_driver);
+}
+
+static void __exit rb750_led_exit(void)
+{
+	platform_driver_unregister(&rb750_led_driver);
+}
+
+module_init(rb750_led_init);
+module_exit(rb750_led_exit);
+
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_DESCRIPTION("LED driver for the RouterBOARD 750");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/leds/leds-wndr3700-usb.c b/target/linux/ar71xx/files-4.9/drivers/leds/leds-wndr3700-usb.c
new file mode 100644
index 0000000000..6425b055da
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/leds/leds-wndr3700-usb.c
@@ -0,0 +1,76 @@
+/*
+ *  USB LED driver for the NETGEAR WNDR3700
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRIVER_NAME	"wndr3700-led-usb"
+
+static void wndr3700_usb_led_set(struct led_classdev *cdev,
+				 enum led_brightness brightness)
+{
+	if (brightness)
+		ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
+	else
+		ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
+}
+
+static enum led_brightness wndr3700_usb_led_get(struct led_classdev *cdev)
+{
+	return ath79_device_reset_get(AR71XX_RESET_GE1_PHY) ? LED_OFF : LED_FULL;
+}
+
+static struct led_classdev wndr3700_usb_led = {
+	.name = "netgear:green:usb",
+	.brightness_set = wndr3700_usb_led_set,
+	.brightness_get = wndr3700_usb_led_get,
+};
+
+static int wndr3700_usb_led_probe(struct platform_device *pdev)
+{
+	return led_classdev_register(&pdev->dev, &wndr3700_usb_led);
+}
+
+static int wndr3700_usb_led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&wndr3700_usb_led);
+	return 0;
+}
+
+static struct platform_driver wndr3700_usb_led_driver = {
+	.probe = wndr3700_usb_led_probe,
+	.remove = wndr3700_usb_led_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init wndr3700_usb_led_init(void)
+{
+	return platform_driver_register(&wndr3700_usb_led_driver);
+}
+
+static void __exit wndr3700_usb_led_exit(void)
+{
+	platform_driver_unregister(&wndr3700_usb_led_driver);
+}
+
+module_init(wndr3700_usb_led_init);
+module_exit(wndr3700_usb_led_exit);
+
+MODULE_DESCRIPTION("USB LED driver for the NETGEAR WNDR3700");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/cybertan_part.c b/target/linux/ar71xx/files-4.9/drivers/mtd/cybertan_part.c
new file mode 100644
index 0000000000..4d33c19b7e
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/cybertan_part.c
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2009 Christian Daniel <cd@maintech.de>
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * TRX flash partition table.
+ * Based on ar7 map by Felix Fietkau <nbd@nbd.name>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+
+struct cybertan_header {
+	char	magic[4];
+	u8	res1[4];
+	char	fw_date[3];
+	char	fw_ver[3];
+	char	id[4];
+	char	hw_ver;
+	char	unused;
+	u8	flags[2];
+	u8	res2[10];
+};
+
+#define TRX_PARTS	6
+#define TRX_MAGIC	0x30524448
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	uint32_t magic;           /* "HDR0" */
+	uint32_t len;             /* Length of file including header */
+	uint32_t crc32;           /* 32-bit CRC from flag_version to end of file */
+	uint32_t flag_version;    /* 0:15 flags, 16:31 version */
+	uint32_t offsets[TRX_MAX_OFFSET]; /* Offsets of partitions from start of header */
+};
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number */
+#define IH_NMLEN	32		/* Image Name Length */
+
+struct uimage_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number */
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum */
+	uint32_t	ih_time;	/* Image Creation Timestamp */
+	uint32_t	ih_size;	/* Image Data Size */
+	uint32_t	ih_load;	/* Data Load  Address */
+	uint32_t	ih_ep;		/* Entry Point Address */
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum */
+	uint8_t		ih_os;		/* Operating System */
+	uint8_t		ih_arch;	/* CPU architecture */
+	uint8_t		ih_type;	/* Image Type */
+	uint8_t		ih_comp;	/* Compression Type */
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name */
+};
+
+struct firmware_header {
+	struct cybertan_header	cybertan;
+	struct trx_header	trx;
+	struct uimage_header	uimage;
+} __packed;
+
+#define UBOOT_LEN	0x40000
+#define ART_LEN		0x10000
+#define NVRAM_LEN	0x10000
+
+static int cybertan_parse_partitions(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				     struct mtd_partition **pparts,
+#else
+				     const struct mtd_partition **pparts,
+#endif
+				     struct mtd_part_parser_data *data)
+{
+	struct firmware_header *header;
+	struct trx_header *theader;
+	struct uimage_header *uheader;
+	struct mtd_partition *trx_parts;
+	size_t retlen;
+	unsigned int kernel_len;
+	unsigned int uboot_len;
+	unsigned int nvram_len;
+	unsigned int art_len;
+	int ret;
+
+	uboot_len = max_t(unsigned int, master->erasesize, UBOOT_LEN);
+	nvram_len = max_t(unsigned int, master->erasesize, NVRAM_LEN);
+	art_len = max_t(unsigned int, master->erasesize, ART_LEN);
+
+	trx_parts = kzalloc(TRX_PARTS * sizeof(struct mtd_partition),
+			    GFP_KERNEL);
+	if (!trx_parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	header = vmalloc(sizeof(*header));
+	if (!header) {
+		return -ENOMEM;
+		goto free_parts;
+	}
+
+	ret = mtd_read(master, uboot_len, sizeof(*header),
+		       &retlen, (void *) header);
+	if (ret)
+		goto free_hdr;
+
+	if (retlen != sizeof(*header)) {
+		ret = -EIO;
+		goto free_hdr;
+	}
+
+	theader = &header->trx;
+	if (le32_to_cpu(theader->magic) != TRX_MAGIC) {
+		printk(KERN_NOTICE "%s: no TRX header found\n", master->name);
+		goto free_hdr;
+	}
+
+	uheader = &header->uimage;
+	if (uheader->ih_magic != IH_MAGIC) {
+		printk(KERN_NOTICE "%s: no uImage found\n", master->name);
+		goto free_hdr;
+	}
+
+	kernel_len = le32_to_cpu(theader->offsets[1]) +
+		sizeof(struct cybertan_header);
+
+	trx_parts[0].name = "u-boot";
+	trx_parts[0].offset = 0;
+	trx_parts[0].size = uboot_len;
+	trx_parts[0].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[1].name = "kernel";
+	trx_parts[1].offset = trx_parts[0].offset + trx_parts[0].size;
+	trx_parts[1].size = kernel_len;
+	trx_parts[1].mask_flags = 0;
+
+	trx_parts[2].name = "rootfs";
+	trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
+	trx_parts[2].size = master->size - uboot_len - nvram_len - art_len -
+		trx_parts[1].size;
+	trx_parts[2].mask_flags = 0;
+
+	trx_parts[3].name = "nvram";
+	trx_parts[3].offset = master->size - nvram_len - art_len;
+	trx_parts[3].size = nvram_len;
+	trx_parts[3].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[4].name = "art";
+	trx_parts[4].offset = master->size - art_len;
+	trx_parts[4].size = art_len;
+	trx_parts[4].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[5].name = "firmware";
+	trx_parts[5].offset = uboot_len;
+	trx_parts[5].size = master->size - uboot_len - nvram_len - art_len;
+	trx_parts[5].mask_flags = 0;
+
+	vfree(header);
+
+	*pparts = trx_parts;
+	return TRX_PARTS;
+
+free_hdr:
+	vfree(header);
+free_parts:
+	kfree(trx_parts);
+out:
+	return ret;
+}
+
+static struct mtd_part_parser cybertan_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= cybertan_parse_partitions,
+	.name		= "cybertan",
+};
+
+static int __init cybertan_parser_init(void)
+{
+	register_mtd_parser(&cybertan_parser);
+
+	return 0;
+}
+
+module_init(cybertan_parser_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Daniel <cd@maintech.de>");
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/nand/ar934x_nfc.c b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/ar934x_nfc.c
new file mode 100644
index 0000000000..a135e0f52f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/ar934x_nfc.c
@@ -0,0 +1,1587 @@
+/*
+ * Driver for the built-in NAND controller of the Atheros AR934x SoCs
+ *
+ * Copyright (C) 2011-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include <linux/platform/ar934x_nfc.h>
+
+#define AR934X_NFC_REG_CMD		0x00
+#define AR934X_NFC_REG_CTRL		0x04
+#define AR934X_NFC_REG_STATUS		0x08
+#define AR934X_NFC_REG_INT_MASK		0x0c
+#define AR934X_NFC_REG_INT_STATUS	0x10
+#define AR934X_NFC_REG_ECC_CTRL		0x14
+#define AR934X_NFC_REG_ECC_OFFSET	0x18
+#define AR934X_NFC_REG_ADDR0_0		0x1c
+#define AR934X_NFC_REG_ADDR0_1		0x24
+#define AR934X_NFC_REG_ADDR1_0		0x20
+#define AR934X_NFC_REG_ADDR1_1		0x28
+#define AR934X_NFC_REG_SPARE_SIZE	0x30
+#define AR934X_NFC_REG_PROTECT		0x38
+#define AR934X_NFC_REG_LOOKUP_EN	0x40
+#define AR934X_NFC_REG_LOOKUP(_x)	(0x44 + (_i) * 4)
+#define AR934X_NFC_REG_DMA_ADDR		0x64
+#define AR934X_NFC_REG_DMA_COUNT	0x68
+#define AR934X_NFC_REG_DMA_CTRL		0x6c
+#define AR934X_NFC_REG_MEM_CTRL		0x80
+#define AR934X_NFC_REG_DATA_SIZE	0x84
+#define AR934X_NFC_REG_READ_STATUS	0x88
+#define AR934X_NFC_REG_TIME_SEQ		0x8c
+#define AR934X_NFC_REG_TIMINGS_ASYN	0x90
+#define AR934X_NFC_REG_TIMINGS_SYN	0x94
+#define AR934X_NFC_REG_FIFO_DATA	0x98
+#define AR934X_NFC_REG_TIME_MODE	0x9c
+#define AR934X_NFC_REG_DMA_ADDR_OFFS	0xa0
+#define AR934X_NFC_REG_FIFO_INIT	0xb0
+#define AR934X_NFC_REG_GEN_SEQ_CTRL	0xb4
+
+#define AR934X_NFC_CMD_CMD_SEQ_S		0
+#define AR934X_NFC_CMD_CMD_SEQ_M		0x3f
+#define   AR934X_NFC_CMD_SEQ_1C			0x00
+#define   AR934X_NFC_CMD_SEQ_ERASE		0x0e
+#define   AR934X_NFC_CMD_SEQ_12			0x0c
+#define   AR934X_NFC_CMD_SEQ_1C1AXR		0x21
+#define   AR934X_NFC_CMD_SEQ_S			0x24
+#define   AR934X_NFC_CMD_SEQ_1C3AXR		0x27
+#define   AR934X_NFC_CMD_SEQ_1C5A1CXR		0x2a
+#define   AR934X_NFC_CMD_SEQ_18			0x32
+#define AR934X_NFC_CMD_INPUT_SEL_SIU		0
+#define AR934X_NFC_CMD_INPUT_SEL_DMA		BIT(6)
+#define AR934X_NFC_CMD_ADDR_SEL_0		0
+#define AR934X_NFC_CMD_ADDR_SEL_1		BIT(7)
+#define AR934X_NFC_CMD_CMD0_S			8
+#define AR934X_NFC_CMD_CMD0_M			0xff
+#define AR934X_NFC_CMD_CMD1_S			16
+#define AR934X_NFC_CMD_CMD1_M			0xff
+#define AR934X_NFC_CMD_CMD2_S			24
+#define AR934X_NFC_CMD_CMD2_M			0xff
+
+#define AR934X_NFC_CTRL_ADDR_CYCLE0_M		0x7
+#define AR934X_NFC_CTRL_ADDR_CYCLE0_S		0
+#define AR934X_NFC_CTRL_SPARE_EN		BIT(3)
+#define AR934X_NFC_CTRL_INT_EN			BIT(4)
+#define AR934X_NFC_CTRL_ECC_EN			BIT(5)
+#define AR934X_NFC_CTRL_BLOCK_SIZE_S		6
+#define AR934X_NFC_CTRL_BLOCK_SIZE_M		0x3
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_32		0
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_64		1
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_128	2
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_256	3
+#define AR934X_NFC_CTRL_PAGE_SIZE_S		8
+#define AR934X_NFC_CTRL_PAGE_SIZE_M		0x7
+#define   AR934X_NFC_CTRL_PAGE_SIZE_256		0
+#define   AR934X_NFC_CTRL_PAGE_SIZE_512		1
+#define   AR934X_NFC_CTRL_PAGE_SIZE_1024	2
+#define   AR934X_NFC_CTRL_PAGE_SIZE_2048	3
+#define   AR934X_NFC_CTRL_PAGE_SIZE_4096	4
+#define   AR934X_NFC_CTRL_PAGE_SIZE_8192	5
+#define   AR934X_NFC_CTRL_PAGE_SIZE_16384	6
+#define AR934X_NFC_CTRL_CUSTOM_SIZE_EN		BIT(11)
+#define AR934X_NFC_CTRL_IO_WIDTH_8BITS		0
+#define AR934X_NFC_CTRL_IO_WIDTH_16BITS		BIT(12)
+#define AR934X_NFC_CTRL_LOOKUP_EN		BIT(13)
+#define AR934X_NFC_CTRL_PROT_EN			BIT(14)
+#define AR934X_NFC_CTRL_WORK_MODE_ASYNC		0
+#define AR934X_NFC_CTRL_WORK_MODE_SYNC		BIT(15)
+#define AR934X_NFC_CTRL_ADDR0_AUTO_INC		BIT(16)
+#define AR934X_NFC_CTRL_ADDR1_AUTO_INC		BIT(17)
+#define AR934X_NFC_CTRL_ADDR_CYCLE1_M		0x7
+#define AR934X_NFC_CTRL_ADDR_CYCLE1_S		18
+#define AR934X_NFC_CTRL_SMALL_PAGE		BIT(21)
+
+#define AR934X_NFC_DMA_CTRL_DMA_START		BIT(7)
+#define AR934X_NFC_DMA_CTRL_DMA_DIR_WRITE	0
+#define AR934X_NFC_DMA_CTRL_DMA_DIR_READ	BIT(6)
+#define AR934X_NFC_DMA_CTRL_DMA_MODE_SG		BIT(5)
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_S		2
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_0		0
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_1		1
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_2		2
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_3		3
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_4		4
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_5		5
+#define AR934X_NFC_DMA_CTRL_ERR_FLAG		BIT(1)
+#define AR934X_NFC_DMA_CTRL_DMA_READY		BIT(0)
+
+#define AR934X_NFC_INT_DEV_RDY(_x)		BIT(4 + (_x))
+#define AR934X_NFC_INT_CMD_END			BIT(1)
+
+#define AR934X_NFC_ECC_CTRL_ERR_THRES_S		8
+#define AR934X_NFC_ECC_CTRL_ERR_THRES_M		0x1f
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_S		5
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_M		0x7
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_2		0
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_4		1
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_6		2
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_8		3
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_10		4
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_12		5
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_14		6
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_16		7
+#define AR934X_NFC_ECC_CTRL_ERR_OVER		BIT(2)
+#define AR934X_NFC_ECC_CTRL_ERR_UNCORRECT	BIT(1)
+#define AR934X_NFC_ECC_CTRL_ERR_CORRECT		BIT(0)
+
+#define AR934X_NFC_ECC_OFFS_OFSET_M		0xffff
+
+/* default timing values */
+#define AR934X_NFC_TIME_SEQ_DEFAULT	0x7fff
+#define AR934X_NFC_TIMINGS_ASYN_DEFAULT	0x22
+#define AR934X_NFC_TIMINGS_SYN_DEFAULT	0xf
+
+#define AR934X_NFC_ID_BUF_SIZE		8
+#define AR934X_NFC_DEV_READY_TIMEOUT	25 /* msecs */
+#define AR934X_NFC_DMA_READY_TIMEOUT	25 /* msecs */
+#define AR934X_NFC_DONE_TIMEOUT		1000
+#define AR934X_NFC_DMA_RETRIES		20
+
+#define AR934X_NFC_USE_IRQ		true
+#define AR934X_NFC_IRQ_MASK		AR934X_NFC_INT_DEV_RDY(0)
+
+#define  AR934X_NFC_GENSEQ_SMALL_PAGE_READ	0x30043
+
+#undef AR934X_NFC_DEBUG_DATA
+#undef AR934X_NFC_DEBUG
+
+struct ar934x_nfc;
+
+static inline  __attribute__ ((format (printf, 2, 3)))
+void _nfc_dbg(struct ar934x_nfc *nfc, const char *fmt, ...)
+{
+}
+
+#ifdef AR934X_NFC_DEBUG
+#define nfc_dbg(_nfc, fmt, ...) \
+	dev_info((_nfc)->parent, fmt, ##__VA_ARGS__)
+#else
+#define nfc_dbg(_nfc, fmt, ...) \
+	_nfc_dbg((_nfc), fmt, ##__VA_ARGS__)
+#endif /* AR934X_NFC_DEBUG */
+
+#ifdef AR934X_NFC_DEBUG_DATA
+static void
+nfc_debug_data(const char *label, void *data, int len)
+{
+	print_hex_dump(KERN_WARNING, label, DUMP_PREFIX_OFFSET, 16, 1,
+		       data, len, 0);
+}
+#else
+static inline void
+nfc_debug_data(const char *label, void *data, int len) {}
+#endif /* AR934X_NFC_DEBUG_DATA */
+
+struct ar934x_nfc {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct mtd_info mtd;
+#endif
+	struct nand_chip nand_chip;
+	struct device *parent;
+	void __iomem *base;
+	void (*select_chip)(int chip_no);
+	bool swap_dma;
+	int irq;
+	wait_queue_head_t irq_waitq;
+
+	bool spurious_irq_expected;
+	u32 irq_status;
+
+	u32 ctrl_reg;
+	u32 ecc_ctrl_reg;
+	u32 ecc_offset_reg;
+	u32 ecc_thres;
+	u32 ecc_oob_pos;
+
+	bool small_page;
+	unsigned int addr_count0;
+	unsigned int addr_count1;
+
+	u8 *buf;
+	dma_addr_t buf_dma;
+	unsigned int buf_size;
+	int buf_index;
+
+	bool read_id;
+
+	int erase1_page_addr;
+
+	int rndout_page_addr;
+	int rndout_read_cmd;
+
+	int seqin_page_addr;
+	int seqin_column;
+	int seqin_read_cmd;
+};
+
+static void ar934x_nfc_restart(struct ar934x_nfc *nfc);
+
+static inline bool
+is_all_ff(u8 *buf, int len)
+{
+	while (len--)
+		if (buf[len] != 0xff)
+			return false;
+
+	return true;
+}
+
+static inline void
+ar934x_nfc_wr(struct ar934x_nfc *nfc, unsigned reg, u32 val)
+{
+	__raw_writel(val, nfc->base + reg);
+}
+
+static inline u32
+ar934x_nfc_rr(struct ar934x_nfc *nfc, unsigned reg)
+{
+	return __raw_readl(nfc->base + reg);
+}
+
+static inline struct ar934x_nfc_platform_data *
+ar934x_nfc_get_platform_data(struct ar934x_nfc *nfc)
+{
+	return nfc->parent->platform_data;
+}
+
+static inline struct
+ar934x_nfc *mtd_to_ar934x_nfc(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return container_of(mtd, struct ar934x_nfc, mtd);
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	return container_of(chip, struct ar934x_nfc, nand_chip);
+#endif
+}
+
+static struct mtd_info *ar934x_nfc_to_mtd(struct ar934x_nfc *nfc)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return &nfc->mtd;
+#else
+	return nand_to_mtd(&nfc->nand_chip);
+#endif
+}
+
+static inline bool ar934x_nfc_use_irq(struct ar934x_nfc *nfc)
+{
+	return AR934X_NFC_USE_IRQ;
+}
+
+static inline void ar934x_nfc_write_cmd_reg(struct ar934x_nfc *nfc, u32 cmd_reg)
+{
+	wmb();
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CMD, cmd_reg);
+	/* flush write */
+	ar934x_nfc_rr(nfc, AR934X_NFC_REG_CMD);
+}
+
+static bool
+__ar934x_nfc_dev_ready(struct ar934x_nfc *nfc)
+{
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS);
+	return (status & 0xff) == 0xff;
+}
+
+static inline bool
+__ar934x_nfc_is_dma_ready(struct ar934x_nfc *nfc)
+{
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL);
+	return (status & AR934X_NFC_DMA_CTRL_DMA_READY) != 0;
+}
+
+static int
+ar934x_nfc_wait_dev_ready(struct ar934x_nfc *nfc)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT);
+	do {
+		if (__ar934x_nfc_dev_ready(nfc))
+			return 0;
+	} while time_before(jiffies, timeout);
+
+	nfc_dbg(nfc, "timeout waiting for device ready, status:%08x int:%08x\n",
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS),
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS));
+	return -ETIMEDOUT;
+}
+
+static int
+ar934x_nfc_wait_dma_ready(struct ar934x_nfc *nfc)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DMA_READY_TIMEOUT);
+	do {
+		if (__ar934x_nfc_is_dma_ready(nfc))
+			return 0;
+	} while time_before(jiffies, timeout);
+
+	nfc_dbg(nfc, "timeout waiting for DMA ready, dma_ctrl:%08x\n",
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL));
+	return -ETIMEDOUT;
+}
+
+static int
+ar934x_nfc_wait_irq(struct ar934x_nfc *nfc)
+{
+	long timeout;
+	int ret;
+
+	timeout = wait_event_timeout(nfc->irq_waitq,
+				(nfc->irq_status & AR934X_NFC_IRQ_MASK) != 0,
+				msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT));
+
+	ret = 0;
+	if (!timeout) {
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_MASK, 0);
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+		/* flush write */
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+		nfc_dbg(nfc,
+			"timeout waiting for interrupt, status:%08x\n",
+			nfc->irq_status);
+		ret = -ETIMEDOUT;
+	}
+
+	nfc->irq_status = 0;
+	return ret;
+}
+
+static int
+ar934x_nfc_wait_done(struct ar934x_nfc *nfc)
+{
+	int ret;
+
+	if (ar934x_nfc_use_irq(nfc))
+		ret = ar934x_nfc_wait_irq(nfc);
+	else
+		ret = ar934x_nfc_wait_dev_ready(nfc);
+
+	if (ret)
+		return ret;
+
+	return ar934x_nfc_wait_dma_ready(nfc);
+}
+
+static int
+ar934x_nfc_alloc_buf(struct ar934x_nfc *nfc, unsigned size)
+{
+	nfc->buf = dma_alloc_coherent(nfc->parent, size,
+				      &nfc->buf_dma, GFP_KERNEL);
+	if (nfc->buf == NULL) {
+		dev_err(nfc->parent, "no memory for DMA buffer\n");
+		return -ENOMEM;
+	}
+
+	nfc->buf_size = size;
+	nfc_dbg(nfc, "buf:%p size:%u\n", nfc->buf, nfc->buf_size);
+
+	return 0;
+}
+
+static void
+ar934x_nfc_free_buf(struct ar934x_nfc *nfc)
+{
+	dma_free_coherent(nfc->parent, nfc->buf_size, nfc->buf, nfc->buf_dma);
+}
+
+static void
+ar934x_nfc_get_addr(struct ar934x_nfc *nfc, int column, int page_addr,
+		    u32 *addr0, u32 *addr1)
+{
+	u32 a0, a1;
+
+	a0 = 0;
+	a1 = 0;
+
+	if (column == -1) {
+		/* ERASE1 */
+		a0 = (page_addr & 0xffff) << 16;
+		a1 = (page_addr >> 16) & 0xf;
+	} else if (page_addr != -1) {
+		/* SEQIN, READ0, etc.. */
+
+		/* TODO: handle 16bit bus width */
+		if (nfc->small_page) {
+			a0 = column & 0xff;
+			a0 |= (page_addr & 0xff) << 8;
+			a0 |= ((page_addr >> 8) & 0xff) << 16;
+			a0 |= ((page_addr >> 16) & 0xff) << 24;
+		} else {
+			a0 = column & 0x0FFF;
+			a0 |= (page_addr & 0xffff) << 16;
+
+			if (nfc->addr_count0 > 4)
+				a1 = (page_addr >> 16) & 0xf;
+		}
+	}
+
+	*addr0 = a0;
+	*addr1 = a1;
+}
+
+static void
+ar934x_nfc_send_cmd(struct ar934x_nfc *nfc, unsigned command)
+{
+	u32 cmd_reg;
+
+	cmd_reg = AR934X_NFC_CMD_INPUT_SEL_SIU | AR934X_NFC_CMD_ADDR_SEL_0 |
+		  AR934X_NFC_CMD_SEQ_1C;
+	cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+}
+
+static int
+ar934x_nfc_do_rw_command(struct ar934x_nfc *nfc, int column, int page_addr,
+			 int len, u32 cmd_reg, u32 ctrl_reg, bool write)
+{
+	u32 addr0, addr1;
+	u32 dma_ctrl;
+	int dir;
+	int err;
+	int retries = 0;
+
+	WARN_ON(len & 3);
+
+	if (WARN_ON(len > nfc->buf_size))
+		dev_err(nfc->parent, "len=%d > buf_size=%d", len, nfc->buf_size);
+
+	if (write) {
+		dma_ctrl = AR934X_NFC_DMA_CTRL_DMA_DIR_WRITE;
+		dir = DMA_TO_DEVICE;
+	} else {
+		dma_ctrl = AR934X_NFC_DMA_CTRL_DMA_DIR_READ;
+		dir = DMA_FROM_DEVICE;
+	}
+
+	ar934x_nfc_get_addr(nfc, column, page_addr, &addr0, &addr1);
+
+	dma_ctrl |= AR934X_NFC_DMA_CTRL_DMA_START |
+		    (AR934X_NFC_DMA_CTRL_DMA_BURST_3 <<
+		     AR934X_NFC_DMA_CTRL_DMA_BURST_S);
+
+	cmd_reg |= AR934X_NFC_CMD_INPUT_SEL_DMA | AR934X_NFC_CMD_ADDR_SEL_0;
+	ctrl_reg |= AR934X_NFC_CTRL_INT_EN;
+
+	nfc_dbg(nfc, "%s a0:%08x a1:%08x len:%x cmd:%08x dma:%08x ctrl:%08x\n",
+		(write) ? "write" : "read",
+		addr0, addr1, len, cmd_reg, dma_ctrl, ctrl_reg);
+
+retry:
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_0, addr0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_1, addr1);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_ADDR, nfc->buf_dma);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_COUNT, len);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DATA_SIZE, len);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_CTRL, dma_ctrl);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ECC_CTRL, nfc->ecc_ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ECC_OFFSET, nfc->ecc_offset_reg);
+
+	if (ar934x_nfc_use_irq(nfc)) {
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_MASK, AR934X_NFC_IRQ_MASK);
+		/* flush write */
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_MASK);
+	}
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	err = ar934x_nfc_wait_done(nfc);
+	if (err) {
+		dev_dbg(nfc->parent, "%s operation stuck at page %d\n",
+			(write) ? "write" : "read", page_addr);
+
+		ar934x_nfc_restart(nfc);
+		if (retries++ < AR934X_NFC_DMA_RETRIES)
+			goto retry;
+
+		dev_err(nfc->parent, "%s operation failed on page %d\n",
+			(write) ? "write" : "read", page_addr);
+	}
+
+	return err;
+}
+
+static int
+ar934x_nfc_send_readid(struct ar934x_nfc *nfc, unsigned command)
+{
+	u32 cmd_reg;
+	int err;
+
+	nfc_dbg(nfc, "readid, cmd:%02x\n", command);
+
+	cmd_reg = AR934X_NFC_CMD_SEQ_1C1AXR;
+	cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	err = ar934x_nfc_do_rw_command(nfc, -1, -1, AR934X_NFC_ID_BUF_SIZE,
+				       cmd_reg, nfc->ctrl_reg, false);
+
+	nfc_debug_data("[id] ", nfc->buf, AR934X_NFC_ID_BUF_SIZE);
+
+	return err;
+}
+
+static int
+ar934x_nfc_send_read(struct ar934x_nfc *nfc, unsigned command, int column,
+		     int page_addr, int len)
+{
+	u32 cmd_reg;
+	int err;
+
+	nfc_dbg(nfc, "read, column=%d page=%d len=%d\n",
+		column, page_addr, len);
+
+	cmd_reg = (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	if (nfc->small_page) {
+		cmd_reg |= AR934X_NFC_CMD_SEQ_18;
+	} else {
+		cmd_reg |= NAND_CMD_READSTART << AR934X_NFC_CMD_CMD1_S;
+		cmd_reg |= AR934X_NFC_CMD_SEQ_1C5A1CXR;
+	}
+
+	err = ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
+				       cmd_reg, nfc->ctrl_reg, false);
+
+	nfc_debug_data("[data] ", nfc->buf, len);
+
+	return err;
+}
+
+static void
+ar934x_nfc_send_erase(struct ar934x_nfc *nfc, unsigned command, int column,
+		      int page_addr)
+{
+	u32 addr0, addr1;
+	u32 ctrl_reg;
+	u32 cmd_reg;
+
+	ar934x_nfc_get_addr(nfc, column, page_addr, &addr0, &addr1);
+
+	ctrl_reg = nfc->ctrl_reg;
+	if (nfc->small_page) {
+		/* override number of address cycles for the erase command */
+		ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE0_M <<
+			      AR934X_NFC_CTRL_ADDR_CYCLE0_S);
+		ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE1_M <<
+			      AR934X_NFC_CTRL_ADDR_CYCLE1_S);
+		ctrl_reg &= ~(AR934X_NFC_CTRL_SMALL_PAGE);
+		ctrl_reg |= (nfc->addr_count0 + 1) <<
+			    AR934X_NFC_CTRL_ADDR_CYCLE0_S;
+	}
+
+	cmd_reg = NAND_CMD_ERASE1 << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_ERASE;
+
+	nfc_dbg(nfc, "erase page %d, a0:%08x a1:%08x cmd:%08x ctrl:%08x\n",
+		page_addr, addr0, addr1, cmd_reg, ctrl_reg);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_0, addr0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_1, addr1);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+}
+
+static int
+ar934x_nfc_send_write(struct ar934x_nfc *nfc, unsigned command, int column,
+		     int page_addr, int len)
+{
+	u32 cmd_reg;
+
+	nfc_dbg(nfc, "write, column=%d page=%d len=%d\n",
+		column, page_addr, len);
+
+	nfc_debug_data("[data] ", nfc->buf, len);
+
+	cmd_reg = NAND_CMD_SEQIN << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_12;
+
+	return ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
+					cmd_reg, nfc->ctrl_reg, true);
+}
+
+static void
+ar934x_nfc_read_status(struct ar934x_nfc *nfc)
+{
+	u32 cmd_reg;
+	u32 status;
+
+	cmd_reg = NAND_CMD_STATUS << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_S;
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_READ_STATUS);
+
+	nfc_dbg(nfc, "read status, cmd:%08x status:%02x\n",
+		cmd_reg, (status & 0xff));
+
+	if (nfc->swap_dma)
+		nfc->buf[0 ^ 3] = status;
+	else
+		nfc->buf[0] = status;
+}
+
+static void
+ar934x_nfc_cmdfunc(struct mtd_info *mtd, unsigned int command, int column,
+		   int page_addr)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	struct nand_chip *nand = &nfc->nand_chip;
+
+	nfc->read_id = false;
+	if (command != NAND_CMD_PAGEPROG)
+		nfc->buf_index = 0;
+
+	switch (command) {
+	case NAND_CMD_RESET:
+		ar934x_nfc_send_cmd(nfc, command);
+		break;
+
+	case NAND_CMD_READID:
+		nfc->read_id = true;
+		ar934x_nfc_send_readid(nfc, command);
+		break;
+
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+		if (nfc->small_page) {
+			ar934x_nfc_send_read(nfc, command, column, page_addr,
+					     mtd->writesize + mtd->oobsize);
+		} else {
+			ar934x_nfc_send_read(nfc, command, 0, page_addr,
+					     mtd->writesize + mtd->oobsize);
+			nfc->buf_index = column;
+			nfc->rndout_page_addr = page_addr;
+			nfc->rndout_read_cmd = command;
+		}
+		break;
+
+	case NAND_CMD_READOOB:
+		if (nfc->small_page)
+			ar934x_nfc_send_read(nfc, NAND_CMD_READOOB,
+					     column, page_addr,
+					     mtd->oobsize);
+		else
+			ar934x_nfc_send_read(nfc, NAND_CMD_READ0,
+					     mtd->writesize, page_addr,
+					     mtd->oobsize);
+		break;
+
+	case NAND_CMD_RNDOUT:
+		if (WARN_ON(nfc->small_page))
+			break;
+
+		/* emulate subpage read */
+		ar934x_nfc_send_read(nfc, nfc->rndout_read_cmd, 0,
+				     nfc->rndout_page_addr,
+				     mtd->writesize + mtd->oobsize);
+		nfc->buf_index = column;
+		break;
+
+	case NAND_CMD_ERASE1:
+		nfc->erase1_page_addr = page_addr;
+		break;
+
+	case NAND_CMD_ERASE2:
+		ar934x_nfc_send_erase(nfc, command, -1, nfc->erase1_page_addr);
+		break;
+
+	case NAND_CMD_STATUS:
+		ar934x_nfc_read_status(nfc);
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (nfc->small_page) {
+			/* output read command */
+			if (column >= mtd->writesize) {
+				column -= mtd->writesize;
+				nfc->seqin_read_cmd = NAND_CMD_READOOB;
+			} else if (column < 256) {
+				nfc->seqin_read_cmd = NAND_CMD_READ0;
+			} else {
+				column -= 256;
+				nfc->seqin_read_cmd = NAND_CMD_READ1;
+			}
+		} else {
+			nfc->seqin_read_cmd = NAND_CMD_READ0;
+		}
+		nfc->seqin_column = column;
+		nfc->seqin_page_addr = page_addr;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		if (nand->ecc.mode == NAND_ECC_HW) {
+			/* the data is already written */
+			break;
+		}
+
+		if (nfc->small_page)
+			ar934x_nfc_send_cmd(nfc, nfc->seqin_read_cmd);
+
+		ar934x_nfc_send_write(nfc, command, nfc->seqin_column,
+				      nfc->seqin_page_addr,
+				      nfc->buf_index);
+		break;
+
+	default:
+		dev_err(nfc->parent,
+			"unsupported command: %x, column:%d page_addr=%d\n",
+			command, column, page_addr);
+		break;
+	}
+}
+
+static int
+ar934x_nfc_dev_ready(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	return __ar934x_nfc_dev_ready(nfc);
+}
+
+static void
+ar934x_nfc_select_chip(struct mtd_info *mtd, int chip_no)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	if (nfc->select_chip)
+		nfc->select_chip(chip_no);
+}
+
+static u8
+ar934x_nfc_read_byte(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	u8 data;
+
+	WARN_ON(nfc->buf_index >= nfc->buf_size);
+
+	if (nfc->swap_dma || nfc->read_id)
+		data = nfc->buf[nfc->buf_index ^ 3];
+	else
+		data = nfc->buf[nfc->buf_index];
+
+	nfc->buf_index++;
+
+	return data;
+}
+
+static void
+ar934x_nfc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int i;
+
+	WARN_ON(nfc->buf_index + len > nfc->buf_size);
+
+	if (nfc->swap_dma) {
+		for (i = 0; i < len; i++) {
+			nfc->buf[nfc->buf_index ^ 3] = buf[i];
+			nfc->buf_index++;
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			nfc->buf[nfc->buf_index] = buf[i];
+			nfc->buf_index++;
+		}
+	}
+}
+
+static void
+ar934x_nfc_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int buf_index;
+	int i;
+
+	WARN_ON(nfc->buf_index + len > nfc->buf_size);
+
+	buf_index = nfc->buf_index;
+
+	if (nfc->swap_dma || nfc->read_id) {
+		for (i = 0; i < len; i++) {
+			buf[i] = nfc->buf[buf_index ^ 3];
+			buf_index++;
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			buf[i] = nfc->buf[buf_index];
+			buf_index++;
+		}
+	}
+
+	nfc->buf_index = buf_index;
+}
+
+static inline void
+ar934x_nfc_enable_hwecc(struct ar934x_nfc *nfc)
+{
+	nfc->ctrl_reg |= AR934X_NFC_CTRL_ECC_EN;
+	nfc->ctrl_reg &= ~AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+}
+
+static inline void
+ar934x_nfc_disable_hwecc(struct ar934x_nfc *nfc)
+{
+	nfc->ctrl_reg &= ~AR934X_NFC_CTRL_ECC_EN;
+	nfc->ctrl_reg |= AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+}
+
+static int
+ar934x_nfc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		    int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int err;
+
+	nfc_dbg(nfc, "read_oob: page:%d\n", page);
+
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize, page,
+				   mtd->oobsize);
+	if (err)
+		return err;
+
+	memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);
+
+	return 0;
+}
+
+static int
+ar934x_nfc_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		     int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	nfc_dbg(nfc, "write_oob: page:%d\n", page);
+
+	memcpy(nfc->buf, chip->oob_poi, mtd->oobsize);
+
+	return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, mtd->writesize,
+				     page, mtd->oobsize);
+}
+
+static int
+ar934x_nfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			 u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int len;
+	int err;
+
+	nfc_dbg(nfc, "read_page_raw: page:%d oob:%d\n", page, oob_required);
+
+	len = mtd->writesize;
+	if (oob_required)
+		len += mtd->oobsize;
+
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page, len);
+	if (err)
+		return err;
+
+	memcpy(buf, nfc->buf, mtd->writesize);
+
+	if (oob_required)
+		memcpy(chip->oob_poi, &nfc->buf[mtd->writesize], mtd->oobsize);
+
+	return 0;
+}
+
+static int
+ar934x_nfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+		     u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	u32 ecc_ctrl;
+	int max_bitflips = 0;
+	bool ecc_failed;
+	bool ecc_corrected;
+	int err;
+
+	nfc_dbg(nfc, "read_page: page:%d oob:%d\n", page, oob_required);
+
+	ar934x_nfc_enable_hwecc(nfc);
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page,
+				   mtd->writesize);
+	ar934x_nfc_disable_hwecc(nfc);
+
+	if (err)
+		return err;
+
+	/* TODO: optimize to avoid memcpy */
+	memcpy(buf, nfc->buf, mtd->writesize);
+
+	/* read the ECC status */
+	ecc_ctrl = ar934x_nfc_rr(nfc, AR934X_NFC_REG_ECC_CTRL);
+	ecc_failed = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_UNCORRECT;
+	ecc_corrected = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_CORRECT;
+
+	if (oob_required || ecc_failed) {
+		err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize,
+					   page, mtd->oobsize);
+		if (err)
+			return err;
+
+		if (oob_required)
+			memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);
+	}
+
+	if (ecc_failed) {
+		/*
+		 * The hardware ECC engine reports uncorrectable errors
+		 * on empty pages. Check the ECC bytes and the data. If
+		 * both contains 0xff bytes only, dont report a failure.
+		 *
+		 * TODO: prebuild a buffer with 0xff bytes and use memcmp
+		 * for better performance?
+		 */
+		if (!is_all_ff(&nfc->buf[nfc->ecc_oob_pos], chip->ecc.total) ||
+		    !is_all_ff(buf, mtd->writesize))
+				mtd->ecc_stats.failed++;
+	} else if (ecc_corrected) {
+		/*
+		 * The hardware does not report the exact count of the
+		 * corrected bitflips, use assumptions based on the
+		 * threshold.
+		 */
+		if (ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_OVER) {
+			/*
+			 * The number of corrected bitflips exceeds the
+			 * threshold. Assume the maximum.
+			 */
+			max_bitflips = chip->ecc.strength * chip->ecc.steps;
+		} else {
+			max_bitflips = nfc->ecc_thres * chip->ecc.steps;
+		}
+
+		mtd->ecc_stats.corrected += max_bitflips;
+	}
+
+	return max_bitflips;
+}
+
+static int
+ar934x_nfc_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			  const u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int len;
+
+	nfc_dbg(nfc, "write_page_raw: page:%d oob:%d\n", page, oob_required);
+
+	memcpy(nfc->buf, buf, mtd->writesize);
+	len = mtd->writesize;
+
+	if (oob_required) {
+		memcpy(&nfc->buf[mtd->writesize], chip->oob_poi, mtd->oobsize);
+		len += mtd->oobsize;
+	}
+
+	return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page, len);
+}
+
+static int
+ar934x_nfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		      const u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int err;
+
+	nfc_dbg(nfc, "write_page: page:%d oob:%d\n", page, oob_required);
+
+	/* write OOB first */
+	if (oob_required &&
+	    !is_all_ff(chip->oob_poi, mtd->oobsize)) {
+		err = ar934x_nfc_write_oob(mtd, chip, page);
+		if (err)
+			return err;
+	}
+
+	/* TODO: optimize to avoid memcopy */
+	memcpy(nfc->buf, buf, mtd->writesize);
+
+	ar934x_nfc_enable_hwecc(nfc);
+	err = ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page,
+				    mtd->writesize);
+	ar934x_nfc_disable_hwecc(nfc);
+
+	return err;
+}
+
+static void
+ar934x_nfc_hw_init(struct ar934x_nfc *nfc)
+{
+	struct ar934x_nfc_platform_data *pdata;
+
+	pdata = ar934x_nfc_get_platform_data(nfc);
+	if (pdata->hw_reset) {
+		pdata->hw_reset(true);
+		pdata->hw_reset(false);
+	}
+
+	/*
+	 * setup timings
+	 * TODO: make it configurable via platform data
+	 */
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIME_SEQ,
+		      AR934X_NFC_TIME_SEQ_DEFAULT);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_ASYN,
+		      AR934X_NFC_TIMINGS_ASYN_DEFAULT);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_SYN,
+		      AR934X_NFC_TIMINGS_SYN_DEFAULT);
+
+	/* disable WP on all chips, and select chip 0 */
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_MEM_CTRL, 0xff00);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_ADDR_OFFS, 0);
+
+	/* initialize Control register */
+	nfc->ctrl_reg = AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	if (nfc->small_page) {
+		/*  Setup generic sequence register for small page reads. */
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_GEN_SEQ_CTRL,
+			      AR934X_NFC_GENSEQ_SMALL_PAGE_READ);
+	}
+}
+
+static void
+ar934x_nfc_restart(struct ar934x_nfc *nfc)
+{
+	u32 ctrl_reg;
+
+	if (nfc->select_chip)
+		nfc->select_chip(-1);
+
+	ctrl_reg = nfc->ctrl_reg;
+	ar934x_nfc_hw_init(nfc);
+	nfc->ctrl_reg = ctrl_reg;
+
+	if (nfc->select_chip)
+		nfc->select_chip(0);
+
+	ar934x_nfc_send_cmd(nfc, NAND_CMD_RESET);
+}
+
+static irqreturn_t
+ar934x_nfc_irq_handler(int irq, void *data)
+{
+	struct ar934x_nfc *nfc = data;
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	/* flush write */
+	ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+	status &= ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_MASK);
+	if (status) {
+		nfc_dbg(nfc, "got IRQ, status:%08x\n", status);
+
+		nfc->irq_status = status;
+		nfc->spurious_irq_expected = true;
+		wake_up(&nfc->irq_waitq);
+	} else {
+		if (nfc->spurious_irq_expected) {
+			nfc->spurious_irq_expected = false;
+		} else {
+			dev_warn(nfc->parent, "spurious interrupt\n");
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int
+ar934x_nfc_init_tail(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	struct nand_chip *chip = &nfc->nand_chip;
+	u32 ctrl;
+	u32 t;
+	int err;
+
+	switch (mtd->oobsize) {
+	case 16:
+	case 64:
+	case 128:
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_SPARE_SIZE, mtd->oobsize);
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported OOB size: %d bytes\n",
+			mtd->oobsize);
+		return -ENXIO;
+	}
+
+	ctrl = AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+
+	switch (mtd->erasesize / mtd->writesize) {
+	case 32:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_32;
+		break;
+
+	case 64:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_64;
+		break;
+
+	case 128:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_128;
+		break;
+
+	case 256:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_256;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported block size: %u\n",
+			mtd->erasesize / mtd->writesize);
+		return -ENXIO;
+	}
+
+	ctrl |= t << AR934X_NFC_CTRL_BLOCK_SIZE_S;
+
+	switch (mtd->writesize) {
+	case 256:
+		nfc->small_page = 1;
+		t = AR934X_NFC_CTRL_PAGE_SIZE_256;
+		break;
+
+	case 512:
+		nfc->small_page = 1;
+		t = AR934X_NFC_CTRL_PAGE_SIZE_512;
+		break;
+
+	case 1024:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_1024;
+		break;
+
+	case 2048:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_2048;
+		break;
+
+	case 4096:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_4096;
+		break;
+
+	case 8192:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_8192;
+		break;
+
+	case 16384:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_16384;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported write size: %d bytes\n",
+			mtd->writesize);
+		return -ENXIO;
+	}
+
+	ctrl |= t << AR934X_NFC_CTRL_PAGE_SIZE_S;
+
+	if (nfc->small_page) {
+		ctrl |= AR934X_NFC_CTRL_SMALL_PAGE;
+
+		if (chip->chipsize > (32 << 20)) {
+			nfc->addr_count0 = 4;
+			nfc->addr_count1 = 3;
+		} else if (chip->chipsize > (2 << 16)) {
+			nfc->addr_count0 = 3;
+			nfc->addr_count1 = 2;
+		} else {
+			nfc->addr_count0 = 2;
+			nfc->addr_count1 = 1;
+		}
+	} else {
+		if (chip->chipsize > (128 << 20)) {
+			nfc->addr_count0 = 5;
+			nfc->addr_count1 = 3;
+		} else if (chip->chipsize > (8 << 16)) {
+			nfc->addr_count0 = 4;
+			nfc->addr_count1 = 2;
+		} else {
+			nfc->addr_count0 = 3;
+			nfc->addr_count1 = 1;
+		}
+	}
+
+	ctrl |= nfc->addr_count0 << AR934X_NFC_CTRL_ADDR_CYCLE0_S;
+	ctrl |= nfc->addr_count1 << AR934X_NFC_CTRL_ADDR_CYCLE1_S;
+
+	nfc->ctrl_reg = ctrl;
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_free_buf(nfc);
+	err = ar934x_nfc_alloc_buf(nfc, mtd->writesize + mtd->oobsize);
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static struct nand_ecclayout ar934x_nfc_oob_64_hwecc = {
+	.eccbytes = 28,
+	.eccpos = {
+		20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33,
+		34, 35, 36, 37, 38, 39, 40,
+		41, 42, 43, 44, 45, 46, 47,
+	},
+	.oobfree = {
+		{
+			.offset = 4,
+			.length = 16,
+		},
+		{
+			.offset = 48,
+			.length = 16,
+		},
+	},
+};
+
+#else
+
+static int ar934x_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,
+				    struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->offset = 20;
+	oobregion->length = 28;
+
+	return 0;
+}
+
+static int ar934x_nfc_ooblayout_free(struct mtd_info *mtd, int section,
+				     struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 4;
+		oobregion->length = 16;
+		return 0;
+	case 1:
+		oobregion->offset = 48;
+		oobregion->length = 16;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops ar934x_nfc_ecclayout_ops = {
+	.ecc = ar934x_nfc_ooblayout_ecc,
+	.free = ar934x_nfc_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static int
+ar934x_nfc_setup_hwecc(struct ar934x_nfc *nfc)
+{
+	struct nand_chip *nand = &nfc->nand_chip;
+	struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
+	u32 ecc_cap;
+	u32 ecc_thres;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	struct mtd_oob_region oobregion;
+#endif
+
+	if (!IS_ENABLED(CONFIG_MTD_NAND_AR934X_HW_ECC)) {
+		dev_err(nfc->parent, "hardware ECC support is disabled\n");
+		return -EINVAL;
+	}
+
+	switch (mtd->writesize) {
+	case 2048:
+		/*
+		 * Writing a subpage separately is not supported, because
+		 * the controller only does ECC on full-page accesses.
+		 */
+		nand->options = NAND_NO_SUBPAGE_WRITE;
+
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 7;
+		nand->ecc.strength = 4;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		nand->ecc.layout = &ar934x_nfc_oob_64_hwecc;
+#else
+		mtd_set_ooblayout(mtd, &ar934x_nfc_ecclayout_ops);
+#endif
+		break;
+
+	default:
+		dev_err(nfc->parent,
+			"hardware ECC is not available for %d byte pages\n",
+			mtd->writesize);
+		return -EINVAL;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	BUG_ON(!nand->ecc.layout);
+#else
+	BUG_ON(!mtd->ooblayout->ecc);
+#endif
+
+	switch (nand->ecc.strength) {
+	case 4:
+		ecc_cap = AR934X_NFC_ECC_CTRL_ECC_CAP_4;
+		ecc_thres = 4;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported ECC strength %u\n",
+			nand->ecc.strength);
+		return -EINVAL;
+	}
+
+	nfc->ecc_thres = ecc_thres;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	nfc->ecc_oob_pos = nand->ecc.layout->eccpos[0];
+#else
+	mtd->ooblayout->ecc(mtd, 0, &oobregion);
+	nfc->ecc_oob_pos = oobregion.offset;
+#endif
+
+	nfc->ecc_ctrl_reg = ecc_cap << AR934X_NFC_ECC_CTRL_ECC_CAP_S;
+	nfc->ecc_ctrl_reg |= ecc_thres << AR934X_NFC_ECC_CTRL_ERR_THRES_S;
+
+	nfc->ecc_offset_reg = mtd->writesize + nfc->ecc_oob_pos;
+
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.read_page = ar934x_nfc_read_page;
+	nand->ecc.read_page_raw = ar934x_nfc_read_page_raw;
+	nand->ecc.write_page = ar934x_nfc_write_page;
+	nand->ecc.write_page_raw = ar934x_nfc_write_page_raw;
+	nand->ecc.read_oob = ar934x_nfc_read_oob;
+	nand->ecc.write_oob = ar934x_nfc_write_oob;
+
+	return 0;
+}
+
+static int
+ar934x_nfc_probe(struct platform_device *pdev)
+{
+	static const char *part_probes[] = { "cmdlinepart", NULL, };
+	struct ar934x_nfc_platform_data *pdata;
+	struct ar934x_nfc *nfc;
+	struct resource *res;
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+	struct mtd_part_parser_data ppdata;
+	int ret;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_err(&pdev->dev, "no platform data defined\n");
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		return -EINVAL;
+	}
+
+	nfc = devm_kzalloc(&pdev->dev, sizeof(struct ar934x_nfc), GFP_KERNEL);
+	if (!nfc) {
+		dev_err(&pdev->dev, "failed to allocate driver data\n");
+		return -ENOMEM;
+	}
+
+	nfc->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(nfc->base)) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		return PTR_ERR(nfc->base);
+	}
+
+	nfc->irq = platform_get_irq(pdev, 0);
+	if (nfc->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource specified\n");
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&nfc->irq_waitq);
+	ret = request_irq(nfc->irq, ar934x_nfc_irq_handler, 0,
+			  dev_name(&pdev->dev), nfc);
+	if (ret) {
+		dev_err(&pdev->dev, "requast_irq failed, err:%d\n", ret);
+		return ret;
+	}
+
+	nfc->parent = &pdev->dev;
+	nfc->select_chip = pdata->select_chip;
+	nfc->swap_dma = pdata->swap_dma;
+
+	nand = &nfc->nand_chip;
+	mtd = ar934x_nfc_to_mtd(nfc);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	mtd->priv = nand;
+#endif
+	mtd->owner = THIS_MODULE;
+	if (pdata->name)
+		mtd->name = pdata->name;
+	else
+		mtd->name = dev_name(&pdev->dev);
+
+	nand->chip_delay = 25;
+
+	nand->dev_ready = ar934x_nfc_dev_ready;
+	nand->cmdfunc = ar934x_nfc_cmdfunc;
+	nand->read_byte = ar934x_nfc_read_byte;
+	nand->write_buf = ar934x_nfc_write_buf;
+	nand->read_buf = ar934x_nfc_read_buf;
+	nand->select_chip = ar934x_nfc_select_chip;
+
+	ret = ar934x_nfc_alloc_buf(nfc, AR934X_NFC_ID_BUF_SIZE);
+	if (ret)
+		goto err_free_irq;
+
+	platform_set_drvdata(pdev, nfc);
+
+	ar934x_nfc_hw_init(nfc);
+
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret) {
+		dev_err(&pdev->dev, "nand_scan_ident failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	ret = ar934x_nfc_init_tail(mtd);
+	if (ret) {
+		dev_err(&pdev->dev, "init tail failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	if (pdata->scan_fixup) {
+		ret = pdata->scan_fixup(mtd);
+		if (ret)
+			goto err_free_buf;
+	}
+
+	switch (pdata->ecc_mode) {
+	case AR934X_NFC_ECC_SOFT:
+		nand->ecc.mode = NAND_ECC_SOFT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+		nand->ecc.algo = NAND_ECC_HAMMING;
+#endif
+		break;
+
+	case AR934X_NFC_ECC_SOFT_BCH:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		nand->ecc.mode = NAND_ECC_SOFT_BCH;
+#else
+		nand->ecc.mode = NAND_ECC_SOFT;
+		nand->ecc.algo = NAND_ECC_BCH;
+#endif
+		break;
+
+	case AR934X_NFC_ECC_HW:
+		ret = ar934x_nfc_setup_hwecc(nfc);
+		if (ret)
+			goto err_free_buf;
+
+		break;
+
+	default:
+		dev_err(nfc->parent, "unknown ECC mode %d\n", pdata->ecc_mode);
+		return -EINVAL;
+	}
+
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		dev_err(&pdev->dev, "scan tail failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	memset(&ppdata, '\0', sizeof(ppdata));
+	ret = mtd_device_parse_register(mtd, part_probes, &ppdata,
+					pdata->parts, pdata->nr_parts);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register mtd, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	return 0;
+
+err_free_buf:
+	ar934x_nfc_free_buf(nfc);
+err_free_irq:
+	free_irq(nfc->irq, nfc);
+	return ret;
+}
+
+static int
+ar934x_nfc_remove(struct platform_device *pdev)
+{
+	struct ar934x_nfc *nfc;
+	struct mtd_info *mtd;
+
+	nfc = platform_get_drvdata(pdev);
+	if (nfc) {
+		mtd = ar934x_nfc_to_mtd(nfc);
+		nand_release(mtd);
+		ar934x_nfc_free_buf(nfc);
+		free_irq(nfc->irq, nfc);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ar934x_nfc_driver = {
+	.probe		= ar934x_nfc_probe,
+	.remove		= ar934x_nfc_remove,
+	.driver = {
+		.name	= AR934X_NFC_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar934x_nfc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Atheros AR934x NAND Flash Controller driver");
+MODULE_ALIAS("platform:" AR934X_NFC_DRIVER_NAME);
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb4xx_nand.c b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb4xx_nand.c
new file mode 100644
index 0000000000..5bbe9789fb
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb4xx_nand.c
@@ -0,0 +1,392 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBoard 4xx series
+ *
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was based on the driver for Linux 2.6.22 published by
+ *  MikroTik for their RouterBoard 4xx series devices.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#define DRV_NAME        "rb4xx-nand"
+#define DRV_VERSION     "0.2.0"
+#define DRV_DESC        "NAND flash driver for RouterBoard 4xx series"
+
+#define RB4XX_NAND_GPIO_READY	5
+#define RB4XX_NAND_GPIO_ALE	37
+#define RB4XX_NAND_GPIO_CLE	38
+#define RB4XX_NAND_GPIO_NCE	39
+
+struct rb4xx_nand_info {
+	struct nand_chip	chip;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct mtd_info		mtd;
+#endif
+};
+
+static inline struct rb4xx_nand_info *mtd_to_rbinfo(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return container_of(mtd, struct rb4xx_nand_info, mtd);
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	return container_of(chip, struct rb4xx_nand_info, chip);
+#endif
+}
+
+static struct mtd_info *rbinfo_to_mtd(struct rb4xx_nand_info *nfc)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return &nfc->mtd;
+#else
+	return nand_to_mtd(&nfc->chip);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb4xx_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb4xx_ooblayout_ecc(struct mtd_info *mtd, int section,
+			       struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb4xx_ooblayout_free(struct mtd_info *mtd, int section,
+				struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb4xx_nand_ecclayout_ops = {
+	.ecc = rb4xx_ooblayout_ecc,
+	.free = rb4xx_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static struct mtd_partition rb4xx_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
+{
+	return gpio_get_value_cansleep(RB4XX_NAND_GPIO_READY);
+}
+
+static void rb4xx_nand_write_cmd(unsigned char cmd)
+{
+	unsigned char data = cmd;
+	int err;
+
+	err = rb4xx_cpld_write(&data, 1);
+	if (err)
+		pr_err("rb4xx_nand: write cmd failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_CLE,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_ALE,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_NCE,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		rb4xx_nand_write_cmd(cmd);
+}
+
+static unsigned char rb4xx_nand_read_byte(struct mtd_info *mtd)
+{
+	unsigned char data = 0;
+	int err;
+
+	err = rb4xx_cpld_read(&data, 1);
+	if (err) {
+		pr_err("rb4xx_nand: read data failed, err=%d\n", err);
+		data = 0xff;
+	}
+
+	return data;
+}
+
+static void rb4xx_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf,
+				 int len)
+{
+	int err;
+
+	err = rb4xx_cpld_write(buf, len);
+	if (err)
+		pr_err("rb4xx_nand: write buf failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_read_buf(struct mtd_info *mtd, unsigned char *buf,
+				int len)
+{
+	int err;
+
+	err = rb4xx_cpld_read(buf, len);
+	if (err)
+		pr_err("rb4xx_nand: read buf failed, err=%d\n", err);
+}
+
+static int rb4xx_nand_probe(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info	*info;
+	struct mtd_info *mtd;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	ret = gpio_request(RB4XX_NAND_GPIO_READY, "NAND RDY");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err;
+	}
+
+	ret = gpio_direction_input(RB4XX_NAND_GPIO_READY);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set input mode on gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_ALE, "NAND ALE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_ALE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_CLE, "NAND CLE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_CLE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_NCE, "NAND NCE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_NCE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_NCE, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_nce;
+	}
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "rb4xx-nand: no memory for private data\n");
+		ret = -ENOMEM;
+		goto err_free_gpio_nce;
+	}
+
+	info->chip.priv	= &info;
+	mtd = rbinfo_to_mtd(info);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	mtd->priv	= &info->chip;
+#endif
+	mtd->owner	= THIS_MODULE;
+
+	info->chip.cmd_ctrl	= rb4xx_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb4xx_nand_dev_ready;
+	info->chip.read_byte	= rb4xx_nand_read_byte;
+	info->chip.write_buf	= rb4xx_nand_write_buf;
+	info->chip.read_buf	= rb4xx_nand_read_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	info->chip.ecc.algo = NAND_ECC_HAMMING;
+#endif
+	info->chip.options = NAND_NO_SUBPAGE_WRITE;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (mtd->writesize == 512)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		info->chip.ecc.layout = &rb4xx_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb4xx_nand_ecclayout_ops);
+#endif
+
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+	mtd_device_register(mtd, rb4xx_nand_partitions,
+				ARRAY_SIZE(rb4xx_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+err_free_gpio_nce:
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+err_free_gpio_cle:
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+err_free_gpio_ale:
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+err_free_gpio_ready:
+	gpio_free(RB4XX_NAND_GPIO_READY);
+err:
+	return ret;
+}
+
+static int rb4xx_nand_remove(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(rbinfo_to_mtd(info));
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+	gpio_free(RB4XX_NAND_GPIO_READY);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_nand_driver = {
+	.probe	= rb4xx_nand_probe,
+	.remove	= rb4xx_nand_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_nand_init(void)
+{
+	return platform_driver_register(&rb4xx_nand_driver);
+}
+
+static void __exit rb4xx_nand_exit(void)
+{
+	platform_driver_unregister(&rb4xx_nand_driver);
+}
+
+module_init(rb4xx_nand_init);
+module_exit(rb4xx_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb750_nand.c b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb750_nand.c
new file mode 100644
index 0000000000..dbada68dd0
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb750_nand.c
@@ -0,0 +1,436 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 750
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/mach-rb750.h>
+
+#define DRV_NAME	"rb750-nand"
+#define DRV_VERSION	"0.1.0"
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 750"
+
+#define RB750_NAND_IO0		BIT(RB750_GPIO_NAND_IO0)
+#define RB750_NAND_ALE		BIT(RB750_GPIO_NAND_ALE)
+#define RB750_NAND_CLE		BIT(RB750_GPIO_NAND_CLE)
+#define RB750_NAND_NRE		BIT(RB750_GPIO_NAND_NRE)
+#define RB750_NAND_NWE		BIT(RB750_GPIO_NAND_NWE)
+#define RB750_NAND_RDY		BIT(RB750_GPIO_NAND_RDY)
+
+#define RB750_NAND_DATA_SHIFT	1
+#define RB750_NAND_DATA_BITS	(0xff << RB750_NAND_DATA_SHIFT)
+#define RB750_NAND_INPUT_BITS	(RB750_NAND_DATA_BITS | RB750_NAND_RDY)
+#define RB750_NAND_OUTPUT_BITS	(RB750_NAND_ALE | RB750_NAND_CLE | \
+				 RB750_NAND_NRE | RB750_NAND_NWE)
+
+struct rb750_nand_info {
+	struct nand_chip	chip;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct mtd_info		mtd;
+#endif
+	struct rb7xx_nand_platform_data *pdata;
+};
+
+static inline struct rb750_nand_info *mtd_to_rbinfo(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return container_of(mtd, struct rb750_nand_info, mtd);
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	return container_of(chip, struct rb750_nand_info, chip);
+#endif
+}
+
+static struct mtd_info *rbinfo_to_mtd(struct rb750_nand_info *nfc)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return &nfc->mtd;
+#else
+	return nand_to_mtd(&nfc->chip);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb750_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb750_ooblayout_ecc(struct mtd_info *mtd, int section,
+			       struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb750_ooblayout_free(struct mtd_info *mtd, int section,
+				struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb750_nand_ecclayout_ops = {
+	.ecc = rb750_ooblayout_ecc,
+	.free = rb750_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static struct mtd_partition rb750_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb750_nand_write(const u8 *buf, unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 out;
+	u32 t;
+	unsigned i;
+
+	/* set data lines to output mode */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t | RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
+
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+	out &= ~(RB750_NAND_DATA_BITS | RB750_NAND_NWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = buf[i];
+		data <<= RB750_NAND_DATA_SHIFT;
+		data |= out;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+
+		__raw_writel(data | RB750_NAND_NWE, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	/* set data lines to input mode */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OE);
+}
+
+static void rb750_nand_read(u8 *read_buf, unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	unsigned i;
+
+	for (i = 0; i < len; i++) {
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+
+		/* read input lines */
+		data = __raw_readl(base + AR71XX_GPIO_REG_IN) >>
+		       RB750_NAND_DATA_SHIFT;
+
+		/* deactivate RE line */
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_SET);
+
+		read_buf[i] = data;
+	}
+}
+
+static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct rb750_nand_info *rbinfo = mtd_to_rbinfo(mtd);
+	void __iomem *base = ath79_gpio_base;
+	u32 t;
+
+	if (chip >= 0) {
+		rbinfo->pdata->enable_pins();
+
+		/* set input mode for data lines */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t & ~RB750_NAND_INPUT_BITS,
+			     base + AR71XX_GPIO_REG_OE);
+
+		/* deactivate RE and WE lines */
+		__raw_writel(RB750_NAND_NRE | RB750_NAND_NWE,
+			     base + AR71XX_GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
+
+		/* activate CE line */
+		__raw_writel(rbinfo->pdata->nce_line,
+			     base + AR71XX_GPIO_REG_CLEAR);
+	} else {
+		/* deactivate CE line */
+		__raw_writel(rbinfo->pdata->nce_line,
+			     base + AR71XX_GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t | RB750_NAND_IO0 | RB750_NAND_RDY,
+			     base + AR71XX_GPIO_REG_OE);
+
+		rbinfo->pdata->disable_pins();
+	}
+}
+
+static int rb750_nand_dev_ready(struct mtd_info *mtd)
+{
+	void __iomem *base = ath79_gpio_base;
+
+	return !!(__raw_readl(base + AR71XX_GPIO_REG_IN) & RB750_NAND_RDY);
+}
+
+static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		void __iomem *base = ath79_gpio_base;
+		u32 t;
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+		t &= ~(RB750_NAND_CLE | RB750_NAND_ALE);
+		t |= (ctrl & NAND_CLE) ? RB750_NAND_CLE : 0;
+		t |= (ctrl & NAND_ALE) ? RB750_NAND_ALE : 0;
+
+		__raw_writel(t, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+		rb750_nand_write(&t, 1);
+	}
+}
+
+static u8 rb750_nand_read_byte(struct mtd_info *mtd)
+{
+	u8 data = 0;
+	rb750_nand_read(&data, 1);
+	return data;
+}
+
+static void rb750_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	rb750_nand_read(buf, len);
+}
+
+static void rb750_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	rb750_nand_write(buf, len);
+}
+
+static void __init rb750_nand_gpio_init(struct rb750_nand_info *info)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 out;
+	u32 t;
+
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* setup output levels */
+	__raw_writel(RB750_NAND_NCE | RB750_NAND_NRE | RB750_NAND_NWE,
+		     base + AR71XX_GPIO_REG_SET);
+
+	__raw_writel(RB750_NAND_ALE | RB750_NAND_CLE,
+		     base + AR71XX_GPIO_REG_CLEAR);
+
+	/* setup input lines */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~(RB750_NAND_INPUT_BITS), base + AR71XX_GPIO_REG_OE);
+
+	/* setup output lines */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	t |= RB750_NAND_OUTPUT_BITS;
+	t |= info->pdata->nce_line;
+	__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+
+	info->pdata->latch_change(~out & RB750_NAND_IO0, out & RB750_NAND_IO0);
+}
+
+static int rb750_nand_probe(struct platform_device *pdev)
+{
+	struct rb750_nand_info	*info;
+	struct rb7xx_nand_platform_data *pdata;
+	struct mtd_info *mtd;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->chip.priv	= &info;
+
+	mtd = rbinfo_to_mtd(info);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	mtd->priv	= &info->chip;
+#endif
+	mtd->owner	= THIS_MODULE;
+
+	info->chip.select_chip	= rb750_nand_select_chip;
+	info->chip.cmd_ctrl	= rb750_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb750_nand_dev_ready;
+	info->chip.read_byte	= rb750_nand_read_byte;
+	info->chip.write_buf	= rb750_nand_write_buf;
+	info->chip.read_buf	= rb750_nand_read_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	info->chip.ecc.algo = NAND_ECC_HAMMING;
+#endif
+	info->chip.options = NAND_NO_SUBPAGE_WRITE;
+
+	info->pdata = pdata;
+
+	platform_set_drvdata(pdev, info);
+
+	rb750_nand_gpio_init(info);
+
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (mtd->writesize == 512)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		info->chip.ecc.layout = &rb750_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb750_nand_ecclayout_ops);
+#endif
+
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+	ret = mtd_device_register(mtd, rb750_nand_partitions,
+				 ARRAY_SIZE(rb750_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+	return ret;
+}
+
+static int rb750_nand_remove(struct platform_device *pdev)
+{
+	struct rb750_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(rbinfo_to_mtd(info));
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return 0;
+}
+
+static struct platform_driver rb750_nand_driver = {
+	.probe	= rb750_nand_probe,
+	.remove	= rb750_nand_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb750_nand_init(void)
+{
+	return platform_driver_register(&rb750_nand_driver);
+}
+
+static void __exit rb750_nand_exit(void)
+{
+	platform_driver_unregister(&rb750_nand_driver);
+}
+
+module_init(rb750_nand_init);
+module_exit(rb750_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb91x_nand.c b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb91x_nand.c
new file mode 100644
index 0000000000..c808f39989
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/nand/rb91x_nand.c
@@ -0,0 +1,460 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 91x series
+ *
+ *  Copyright (C) 2013-2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/rb91x_nand.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 91x series"
+
+#define RB91X_NAND_NRWE		BIT(12)
+
+#define RB91X_NAND_DATA_BITS	(BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) |\
+				 BIT(13) | BIT(14) | BIT(15))
+
+#define RB91X_NAND_INPUT_BITS	(RB91X_NAND_DATA_BITS | RB91X_NAND_RDY)
+#define RB91X_NAND_OUTPUT_BITS	(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE)
+
+#define RB91X_NAND_LOW_DATA_MASK	0x1f
+#define RB91X_NAND_HIGH_DATA_MASK	0xe0
+#define RB91X_NAND_HIGH_DATA_SHIFT	8
+
+struct rb91x_nand_info {
+	struct nand_chip chip;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	struct mtd_info mtd;
+#endif
+	struct device *dev;
+
+	int gpio_nce;
+	int gpio_ale;
+	int gpio_cle;
+	int gpio_rdy;
+	int gpio_read;
+	int gpio_nrw;
+	int gpio_nle;
+};
+
+static inline struct rb91x_nand_info *mtd_to_rbinfo(struct mtd_info *mtd)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return container_of(mtd, struct rb91x_nand_info, mtd);
+#else
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	return container_of(chip, struct rb91x_nand_info, chip);
+#endif
+}
+
+static struct mtd_info *rbinfo_to_mtd(struct rb91x_nand_info *nfc)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	return &nfc->mtd;
+#else
+	return nand_to_mtd(&nfc->chip);
+#endif
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb91x_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+#else
+
+static int rb91x_ooblayout_ecc(struct mtd_info *mtd, int section,
+			       struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 8;
+		oobregion->length = 3;
+		return 0;
+	case 1:
+		oobregion->offset = 13;
+		oobregion->length = 3;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static int rb91x_ooblayout_free(struct mtd_info *mtd, int section,
+				struct mtd_oob_region *oobregion)
+{
+	switch (section) {
+	case 0:
+		oobregion->offset = 0;
+		oobregion->length = 4;
+		return 0;
+	case 1:
+		oobregion->offset = 4;
+		oobregion->length = 1;
+		return 0;
+	case 2:
+		oobregion->offset = 6;
+		oobregion->length = 2;
+		return 0;
+	case 3:
+		oobregion->offset = 11;
+		oobregion->length = 2;
+		return 0;
+	default:
+		return -ERANGE;
+	}
+}
+
+static const struct mtd_ooblayout_ops rb91x_nand_ecclayout_ops = {
+	.ecc = rb91x_ooblayout_ecc,
+	.free = rb91x_ooblayout_free,
+};
+#endif /* < 4.6 */
+
+static struct mtd_partition rb91x_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "ubi",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb91x_nand_write(struct rb91x_nand_info *rbni,
+			     const u8 *buf,
+			     unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 oe_reg;
+	u32 out_reg;
+	u32 out;
+	unsigned i;
+
+	/* enable the latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 0);
+
+	oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* set data lines to output mode */
+	__raw_writel(oe_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE),
+		     base + AR71XX_GPIO_REG_OE);
+
+	out = out_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = (buf[i] & RB91X_NAND_HIGH_DATA_MASK) <<
+			RB91X_NAND_HIGH_DATA_SHIFT;
+		data |= buf[i] & RB91X_NAND_LOW_DATA_MASK;
+		data |= out;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+
+		/* deactivate WE line */
+		data |= RB91X_NAND_NRWE;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	/* restore  registers */
+	__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
+	__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* disable the latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 1);
+}
+
+static void rb91x_nand_read(struct rb91x_nand_info *rbni,
+			    u8 *read_buf,
+			    unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 oe_reg;
+	u32 out_reg;
+	unsigned i;
+
+	/* enable read mode */
+	gpio_set_value_cansleep(rbni->gpio_read, 1);
+
+	/* enable latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 0);
+
+	/* save registers */
+	oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* set data lines to input mode */
+	__raw_writel(oe_reg | RB91X_NAND_DATA_BITS,
+		     base + AR71XX_GPIO_REG_OE);
+
+	for (i = 0; i < len; i++) {
+		u32 in;
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB91X_NAND_NRWE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+
+		/* read input lines */
+		in = __raw_readl(base + AR71XX_GPIO_REG_IN);
+
+		/* deactivate RE line */
+		__raw_writel(RB91X_NAND_NRWE, base + AR71XX_GPIO_REG_SET);
+
+		data = (in & RB91X_NAND_LOW_DATA_MASK);
+		data |= (in >> RB91X_NAND_HIGH_DATA_SHIFT) &
+			RB91X_NAND_HIGH_DATA_MASK;
+
+		read_buf[i] = data;
+	}
+
+	/* restore  registers */
+	__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
+	__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* disable latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 1);
+
+	/* disable read mode */
+	gpio_set_value_cansleep(rbni->gpio_read, 0);
+}
+
+static int rb91x_nand_dev_ready(struct mtd_info *mtd)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	return gpio_get_value_cansleep(rbni->gpio_rdy);
+}
+
+static void rb91x_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(rbni->gpio_cle,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(rbni->gpio_ale,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(rbni->gpio_nce,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+
+		rb91x_nand_write(rbni, &t, 1);
+	}
+}
+
+static u8 rb91x_nand_read_byte(struct mtd_info *mtd)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+	u8 data = 0xff;
+
+	rb91x_nand_read(rbni, &data, 1);
+
+	return data;
+}
+
+static void rb91x_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	rb91x_nand_read(rbni, buf, len);
+}
+
+static void rb91x_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	rb91x_nand_write(rbni, buf, len);
+}
+
+static int rb91x_nand_gpio_init(struct rb91x_nand_info *info)
+{
+	int ret;
+
+	/*
+	 * Ensure that the LATCH is disabled before initializing
+	 * control lines.
+	 */
+	ret = devm_gpio_request_one(info->dev, info->gpio_nle,
+				    GPIOF_OUT_INIT_HIGH, "LATCH enable");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_nce,
+				    GPIOF_OUT_INIT_HIGH, "NAND nCE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_nrw,
+				    GPIOF_OUT_INIT_HIGH, "NAND nRW");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_cle,
+				    GPIOF_OUT_INIT_LOW, "NAND CLE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_ale,
+				    GPIOF_OUT_INIT_LOW, "NAND ALE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_read,
+				    GPIOF_OUT_INIT_LOW, "NAND READ");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_rdy,
+				    GPIOF_IN, "NAND RDY");
+	return ret;
+}
+
+static int rb91x_nand_probe(struct platform_device *pdev)
+{
+	struct rb91x_nand_info	*rbni;
+	struct rb91x_nand_platform_data *pdata;
+	struct mtd_info *mtd;
+	int ret;
+
+	pr_info(DRV_DESC "\n");
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata)
+		return -EINVAL;
+
+	rbni = devm_kzalloc(&pdev->dev, sizeof(*rbni), GFP_KERNEL);
+	if (!rbni)
+		return -ENOMEM;
+
+	rbni->dev = &pdev->dev;
+	rbni->gpio_nce = pdata->gpio_nce;
+	rbni->gpio_ale = pdata->gpio_ale;
+	rbni->gpio_cle = pdata->gpio_cle;
+	rbni->gpio_read = pdata->gpio_read;
+	rbni->gpio_nrw = pdata->gpio_nrw;
+	rbni->gpio_rdy = pdata->gpio_rdy;
+	rbni->gpio_nle = pdata->gpio_nle;
+
+	rbni->chip.priv	= &rbni;
+	mtd = rbinfo_to_mtd(rbni);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	mtd->priv	= &rbni->chip;
+#endif
+	mtd->owner	= THIS_MODULE;
+
+	rbni->chip.cmd_ctrl	= rb91x_nand_cmd_ctrl;
+	rbni->chip.dev_ready	= rb91x_nand_dev_ready;
+	rbni->chip.read_byte	= rb91x_nand_read_byte;
+	rbni->chip.write_buf	= rb91x_nand_write_buf;
+	rbni->chip.read_buf	= rb91x_nand_read_buf;
+
+	rbni->chip.chip_delay	= 25;
+	rbni->chip.ecc.mode	= NAND_ECC_SOFT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	rbni->chip.ecc.algo = NAND_ECC_HAMMING;
+#endif
+	rbni->chip.options = NAND_NO_SUBPAGE_WRITE;
+
+	platform_set_drvdata(pdev, rbni);
+
+	ret = rb91x_nand_gpio_init(rbni);
+	if (ret)
+		return ret;
+
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret)
+		return ret;
+
+	if (mtd->writesize == 512)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+		rbni->chip.ecc.layout = &rb91x_nand_ecclayout;
+#else
+		mtd_set_ooblayout(mtd, &rb91x_nand_ecclayout_ops);
+#endif
+
+	ret = nand_scan_tail(mtd);
+	if (ret)
+		return ret;
+
+	ret = mtd_device_register(mtd, rb91x_nand_partitions,
+				 ARRAY_SIZE(rb91x_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(mtd);
+	return ret;
+}
+
+static int rb91x_nand_remove(struct platform_device *pdev)
+{
+	struct rb91x_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(rbinfo_to_mtd(info));
+
+	return 0;
+}
+
+static struct platform_driver rb91x_nand_driver = {
+	.probe	= rb91x_nand_probe,
+	.remove	= rb91x_nand_remove,
+	.driver	= {
+		.name	= RB91X_NAND_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(rb91x_nand_driver);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/mtd/tplinkpart.c b/target/linux/ar71xx/files-4.9/drivers/mtd/tplinkpart.c
new file mode 100644
index 0000000000..1b94163b83
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/mtd/tplinkpart.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/magic.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+
+#define TPLINK_NUM_PARTS	5
+#define TPLINK_HEADER_V1	0x01000000
+#define TPLINK_HEADER_V2	0x02000000
+#define MD5SUM_LEN		16
+
+#define TPLINK_ART_LEN		0x10000
+#define TPLINK_KERNEL_OFFS	0x20000
+#define TPLINK_64K_KERNEL_OFFS	0x10000
+
+struct tplink_fw_header {
+	uint32_t	version;	/* header version */
+	char		vendor_name[24];
+	char		fw_version[36];
+	uint32_t	hw_id;		/* hardware id */
+	uint32_t	hw_rev;		/* hardware revision */
+	uint32_t	unk1;
+	uint8_t		md5sum1[MD5SUM_LEN];
+	uint32_t	unk2;
+	uint8_t		md5sum2[MD5SUM_LEN];
+	uint32_t	unk3;
+	uint32_t	kernel_la;	/* kernel load address */
+	uint32_t	kernel_ep;	/* kernel entry point */
+	uint32_t	fw_length;	/* total length of the firmware */
+	uint32_t	kernel_ofs;	/* kernel data offset */
+	uint32_t	kernel_len;	/* kernel data length */
+	uint32_t	rootfs_ofs;	/* rootfs data offset */
+	uint32_t	rootfs_len;	/* rootfs data length */
+	uint32_t	boot_ofs;	/* bootloader data offset */
+	uint32_t	boot_len;	/* bootloader data length */
+	uint8_t		pad[360];
+} __attribute__ ((packed));
+
+static struct tplink_fw_header *
+tplink_read_header(struct mtd_info *mtd, size_t offset)
+{
+	struct tplink_fw_header *header;
+	size_t header_len;
+	size_t retlen;
+	int ret;
+	u32 t;
+
+	header = vmalloc(sizeof(*header));
+	if (!header)
+		goto err;
+
+	header_len = sizeof(struct tplink_fw_header);
+	ret = mtd_read(mtd, offset, header_len, &retlen,
+		       (unsigned char *) header);
+	if (ret)
+		goto err_free_header;
+
+	if (retlen != header_len)
+		goto err_free_header;
+
+	/* sanity checks */
+	t = be32_to_cpu(header->version);
+	if ((t != TPLINK_HEADER_V1) && (t != TPLINK_HEADER_V2))
+		goto err_free_header;
+
+	t = be32_to_cpu(header->kernel_ofs);
+	if (t != header_len)
+		goto err_free_header;
+
+	return header;
+
+err_free_header:
+	vfree(header);
+err:
+	return NULL;
+}
+
+static int tplink_check_rootfs_magic(struct mtd_info *mtd, size_t offset)
+{
+	u32 magic;
+	size_t retlen;
+	int ret;
+
+	ret = mtd_read(mtd, offset, sizeof(magic), &retlen,
+		       (unsigned char *) &magic);
+	if (ret)
+		return ret;
+
+	if (retlen != sizeof(magic))
+		return -EIO;
+
+	if (le32_to_cpu(magic) != SQUASHFS_MAGIC &&
+	    magic != 0x19852003)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tplink_parse_partitions_offset(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data,
+				   size_t offset)
+{
+	struct mtd_partition *parts;
+	struct tplink_fw_header *header;
+	int nr_parts;
+	size_t art_offset;
+	size_t rootfs_offset;
+	size_t squashfs_offset;
+	int ret;
+
+	nr_parts = TPLINK_NUM_PARTS;
+	parts = kzalloc(nr_parts * sizeof(struct mtd_partition), GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	header = tplink_read_header(master, offset);
+	if (!header) {
+		pr_notice("%s: no TP-Link header found\n", master->name);
+		ret = -ENODEV;
+		goto err_free_parts;
+	}
+
+	squashfs_offset = offset + sizeof(struct tplink_fw_header) +
+			  be32_to_cpu(header->kernel_len);
+
+	ret = tplink_check_rootfs_magic(master, squashfs_offset);
+	if (ret == 0)
+		rootfs_offset = squashfs_offset;
+	else
+		rootfs_offset = offset + be32_to_cpu(header->rootfs_ofs);
+
+	art_offset = master->size - TPLINK_ART_LEN;
+
+	parts[0].name = "u-boot";
+	parts[0].offset = 0;
+	parts[0].size = offset;
+	parts[0].mask_flags = MTD_WRITEABLE;
+
+	parts[1].name = "kernel";
+	parts[1].offset = offset;
+	parts[1].size = rootfs_offset - offset;
+
+	parts[2].name = "rootfs";
+	parts[2].offset = rootfs_offset;
+	parts[2].size = art_offset - rootfs_offset;
+
+	parts[3].name = "art";
+	parts[3].offset = art_offset;
+	parts[3].size = TPLINK_ART_LEN;
+	parts[3].mask_flags = MTD_WRITEABLE;
+
+	parts[4].name = "firmware";
+	parts[4].offset = offset;
+	parts[4].size = art_offset - offset;
+
+	vfree(header);
+
+	*pparts = parts;
+	return nr_parts;
+
+err_free_parts:
+	kfree(parts);
+err:
+	*pparts = NULL;
+	return ret;
+}
+
+static int tplink_parse_partitions(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_KERNEL_OFFS);
+}
+
+static int tplink_parse_64k_partitions(struct mtd_info *master,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+				   struct mtd_partition **pparts,
+#else
+				   const struct mtd_partition **pparts,
+#endif
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_64K_KERNEL_OFFS);
+}
+
+static struct mtd_part_parser tplink_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_partitions,
+	.name		= "tp-link",
+};
+
+static struct mtd_part_parser tplink_64k_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_64k_partitions,
+	.name		= "tp-link-64k",
+};
+
+static int __init tplink_parser_init(void)
+{
+	register_mtd_parser(&tplink_parser);
+	register_mtd_parser(&tplink_64k_parser);
+
+	return 0;
+}
+
+module_init(tplink_parser_init);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
diff --git a/target/linux/ar71xx/files/drivers/net/dsa/mv88e6063.c b/target/linux/ar71xx/files-4.9/drivers/net/dsa/mv88e6063.c
similarity index 100%
rename from target/linux/ar71xx/files/drivers/net/dsa/mv88e6063.c
rename to target/linux/ar71xx/files-4.9/drivers/net/dsa/mv88e6063.c
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Kconfig b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Kconfig
new file mode 100644
index 0000000000..42d544f731
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Kconfig
@@ -0,0 +1,33 @@
+config AG71XX
+	tristate "Atheros AR7XXX/AR9XXX built-in ethernet mac support"
+	depends on ATH79
+	select PHYLIB
+	help
+	  If you wish to compile a kernel for AR7XXX/91XXX and enable
+	  ethernet support, then you should always answer Y to this.
+
+if AG71XX
+
+config AG71XX_DEBUG
+	bool "Atheros AR71xx built-in ethernet driver debugging"
+	default n
+	help
+	  Atheros AR71xx built-in ethernet driver debugging messages.
+
+config AG71XX_DEBUG_FS
+	bool "Atheros AR71xx built-in ethernet driver debugfs support"
+	depends on DEBUG_FS
+	default n
+	help
+	  Say Y, if you need access to various statistics provided by
+	  the ag71xx driver.
+
+config AG71XX_AR8216_SUPPORT
+	bool "special support for the Atheros AR8216 switch"
+	default n
+	default y if ATH79_MACH_WNR2000 || ATH79_MACH_MZK_W04NU
+	help
+	  Say 'y' here if you want to enable special support for the
+	  Atheros AR8216 switch found on some boards.
+
+endif
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Makefile b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Makefile
new file mode 100644
index 0000000000..b3ec4084c8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Atheros AR71xx built-in ethernet macs
+#
+
+ag71xx-y	+= ag71xx_main.o
+ag71xx-y	+= ag71xx_ethtool.o
+ag71xx-y	+= ag71xx_phy.o
+ag71xx-y	+= ag71xx_mdio.o
+ag71xx-y	+= ag71xx_ar7240.o
+
+ag71xx-$(CONFIG_AG71XX_DEBUG_FS)	+= ag71xx_debugfs.o
+ag71xx-$(CONFIG_AG71XX_AR8216_SUPPORT)	+= ag71xx_ar8216.o
+
+obj-$(CONFIG_AG71XX)	+= ag71xx.o
+
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx.h b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
new file mode 100644
index 0000000000..77ee5b36ec
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
@@ -0,0 +1,506 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AG71XX_H
+#define __AG71XX_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/phy.h>
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+
+#include <linux/bitops.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+#define AG71XX_DRV_NAME		"ag71xx"
+#define AG71XX_DRV_VERSION	"0.5.35"
+
+/*
+ * For our NAPI weight bigger does *NOT* mean better - it means more
+ * D-cache misses and lots more wasted cycles than we'll ever
+ * possibly gain from saving instructions.
+ */
+#define AG71XX_NAPI_WEIGHT	32
+#define AG71XX_OOM_REFILL	(1 + HZ/10)
+
+#define AG71XX_INT_ERR	(AG71XX_INT_RX_BE | AG71XX_INT_TX_BE)
+#define AG71XX_INT_TX	(AG71XX_INT_TX_PS)
+#define AG71XX_INT_RX	(AG71XX_INT_RX_PR | AG71XX_INT_RX_OF)
+
+#define AG71XX_INT_POLL	(AG71XX_INT_RX | AG71XX_INT_TX)
+#define AG71XX_INT_INIT	(AG71XX_INT_ERR | AG71XX_INT_POLL)
+
+#define AG71XX_TX_MTU_LEN	1540
+
+#define AG71XX_TX_RING_SPLIT		512
+#define AG71XX_TX_RING_DS_PER_PKT	DIV_ROUND_UP(AG71XX_TX_MTU_LEN, \
+						     AG71XX_TX_RING_SPLIT)
+#define AG71XX_TX_RING_SIZE_DEFAULT	128
+#define AG71XX_RX_RING_SIZE_DEFAULT	256
+
+#define AG71XX_TX_RING_SIZE_MAX		128
+#define AG71XX_RX_RING_SIZE_MAX		256
+
+#ifdef CONFIG_AG71XX_DEBUG
+#define DBG(fmt, args...)	pr_debug(fmt, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ag71xx_assert(_cond)						\
+do {									\
+	if (_cond)							\
+		break;							\
+	printk("%s,%d: assertion failed\n", __FILE__, __LINE__);	\
+	BUG();								\
+} while (0)
+
+struct ag71xx_desc {
+	u32	data;
+	u32	ctrl;
+#define DESC_EMPTY	BIT(31)
+#define DESC_MORE	BIT(24)
+#define DESC_PKTLEN_M	0xfff
+	u32	next;
+	u32	pad;
+} __attribute__((aligned(4)));
+
+#define AG71XX_DESC_SIZE	roundup(sizeof(struct ag71xx_desc), \
+					L1_CACHE_BYTES)
+
+struct ag71xx_buf {
+	union {
+		struct sk_buff	*skb;
+		void		*rx_buf;
+	};
+	union {
+		dma_addr_t	dma_addr;
+		unsigned int		len;
+	};
+};
+
+struct ag71xx_ring {
+	struct ag71xx_buf	*buf;
+	u8			*descs_cpu;
+	dma_addr_t		descs_dma;
+	u16			desc_split;
+	u16			order;
+	unsigned int		curr;
+	unsigned int		dirty;
+};
+
+struct ag71xx_mdio {
+	struct mii_bus		*mii_bus;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	int			mii_irq[PHY_MAX_ADDR];
+#endif
+	void __iomem		*mdio_base;
+	struct ag71xx_mdio_platform_data *pdata;
+};
+
+struct ag71xx_int_stats {
+	unsigned long		rx_pr;
+	unsigned long		rx_be;
+	unsigned long		rx_of;
+	unsigned long		tx_ps;
+	unsigned long		tx_be;
+	unsigned long		tx_ur;
+	unsigned long		total;
+};
+
+struct ag71xx_napi_stats {
+	unsigned long		napi_calls;
+	unsigned long		rx_count;
+	unsigned long		rx_packets;
+	unsigned long		rx_packets_max;
+	unsigned long		tx_count;
+	unsigned long		tx_packets;
+	unsigned long		tx_packets_max;
+
+	unsigned long		rx[AG71XX_NAPI_WEIGHT + 1];
+	unsigned long		tx[AG71XX_NAPI_WEIGHT + 1];
+};
+
+struct ag71xx_debug {
+	struct dentry		*debugfs_dir;
+
+	struct ag71xx_int_stats int_stats;
+	struct ag71xx_napi_stats napi_stats;
+};
+
+struct ag71xx {
+	/*
+	 * Critical data related to the per-packet data path are clustered
+	 * early in this structure to help improve the D-cache footprint.
+	 */
+	struct ag71xx_ring	rx_ring ____cacheline_aligned;
+	struct ag71xx_ring	tx_ring ____cacheline_aligned;
+
+	unsigned int            max_frame_len;
+	unsigned int            desc_pktlen_mask;
+	unsigned int            rx_buf_size;
+
+	struct net_device	*dev;
+	struct platform_device  *pdev;
+	spinlock_t		lock;
+	struct napi_struct	napi;
+	u32			msg_enable;
+
+	/*
+	 * From this point onwards we're not looking at per-packet fields.
+	 */
+	void __iomem		*mac_base;
+
+	struct ag71xx_desc	*stop_desc;
+	dma_addr_t		stop_desc_dma;
+
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	void			*phy_priv;
+
+	unsigned int		link;
+	unsigned int		speed;
+	int			duplex;
+
+	struct delayed_work	restart_work;
+	struct delayed_work	link_work;
+	struct timer_list	oom_timer;
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+	struct ag71xx_debug	debug;
+#endif
+};
+
+extern struct ethtool_ops ag71xx_ethtool_ops;
+void ag71xx_link_adjust(struct ag71xx *ag);
+
+int ag71xx_mdio_driver_init(void) __init;
+void ag71xx_mdio_driver_exit(void);
+
+int ag71xx_phy_connect(struct ag71xx *ag);
+void ag71xx_phy_disconnect(struct ag71xx *ag);
+void ag71xx_phy_start(struct ag71xx *ag);
+void ag71xx_phy_stop(struct ag71xx *ag);
+
+static inline struct ag71xx_platform_data *ag71xx_get_pdata(struct ag71xx *ag)
+{
+	return ag->pdev->dev.platform_data;
+}
+
+static inline int ag71xx_desc_empty(struct ag71xx_desc *desc)
+{
+	return (desc->ctrl & DESC_EMPTY) != 0;
+}
+
+static inline struct ag71xx_desc *
+ag71xx_ring_desc(struct ag71xx_ring *ring, int idx)
+{
+	return (struct ag71xx_desc *) &ring->descs_cpu[idx * AG71XX_DESC_SIZE];
+}
+
+static inline int
+ag71xx_ring_size_order(int size)
+{
+	return fls(size - 1);
+}
+
+/* Register offsets */
+#define AG71XX_REG_MAC_CFG1	0x0000
+#define AG71XX_REG_MAC_CFG2	0x0004
+#define AG71XX_REG_MAC_IPG	0x0008
+#define AG71XX_REG_MAC_HDX	0x000c
+#define AG71XX_REG_MAC_MFL	0x0010
+#define AG71XX_REG_MII_CFG	0x0020
+#define AG71XX_REG_MII_CMD	0x0024
+#define AG71XX_REG_MII_ADDR	0x0028
+#define AG71XX_REG_MII_CTRL	0x002c
+#define AG71XX_REG_MII_STATUS	0x0030
+#define AG71XX_REG_MII_IND	0x0034
+#define AG71XX_REG_MAC_IFCTL	0x0038
+#define AG71XX_REG_MAC_ADDR1	0x0040
+#define AG71XX_REG_MAC_ADDR2	0x0044
+#define AG71XX_REG_FIFO_CFG0	0x0048
+#define AG71XX_REG_FIFO_CFG1	0x004c
+#define AG71XX_REG_FIFO_CFG2	0x0050
+#define AG71XX_REG_FIFO_CFG3	0x0054
+#define AG71XX_REG_FIFO_CFG4	0x0058
+#define AG71XX_REG_FIFO_CFG5	0x005c
+#define AG71XX_REG_FIFO_RAM0	0x0060
+#define AG71XX_REG_FIFO_RAM1	0x0064
+#define AG71XX_REG_FIFO_RAM2	0x0068
+#define AG71XX_REG_FIFO_RAM3	0x006c
+#define AG71XX_REG_FIFO_RAM4	0x0070
+#define AG71XX_REG_FIFO_RAM5	0x0074
+#define AG71XX_REG_FIFO_RAM6	0x0078
+#define AG71XX_REG_FIFO_RAM7	0x007c
+
+#define AG71XX_REG_TX_CTRL	0x0180
+#define AG71XX_REG_TX_DESC	0x0184
+#define AG71XX_REG_TX_STATUS	0x0188
+#define AG71XX_REG_RX_CTRL	0x018c
+#define AG71XX_REG_RX_DESC	0x0190
+#define AG71XX_REG_RX_STATUS	0x0194
+#define AG71XX_REG_INT_ENABLE	0x0198
+#define AG71XX_REG_INT_STATUS	0x019c
+
+#define AG71XX_REG_FIFO_DEPTH	0x01a8
+#define AG71XX_REG_RX_SM	0x01b0
+#define AG71XX_REG_TX_SM	0x01b4
+
+#define MAC_CFG1_TXE		BIT(0)	/* Tx Enable */
+#define MAC_CFG1_STX		BIT(1)	/* Synchronize Tx Enable */
+#define MAC_CFG1_RXE		BIT(2)	/* Rx Enable */
+#define MAC_CFG1_SRX		BIT(3)	/* Synchronize Rx Enable */
+#define MAC_CFG1_TFC		BIT(4)	/* Tx Flow Control Enable */
+#define MAC_CFG1_RFC		BIT(5)	/* Rx Flow Control Enable */
+#define MAC_CFG1_LB		BIT(8)	/* Loopback mode */
+#define MAC_CFG1_SR		BIT(31)	/* Soft Reset */
+
+#define MAC_CFG2_FDX		BIT(0)
+#define MAC_CFG2_CRC_EN		BIT(1)
+#define MAC_CFG2_PAD_CRC_EN	BIT(2)
+#define MAC_CFG2_LEN_CHECK	BIT(4)
+#define MAC_CFG2_HUGE_FRAME_EN	BIT(5)
+#define MAC_CFG2_IF_1000	BIT(9)
+#define MAC_CFG2_IF_10_100	BIT(8)
+
+#define FIFO_CFG0_WTM		BIT(0)	/* Watermark Module */
+#define FIFO_CFG0_RXS		BIT(1)	/* Rx System Module */
+#define FIFO_CFG0_RXF		BIT(2)	/* Rx Fabric Module */
+#define FIFO_CFG0_TXS		BIT(3)	/* Tx System Module */
+#define FIFO_CFG0_TXF		BIT(4)	/* Tx Fabric Module */
+#define FIFO_CFG0_ALL	(FIFO_CFG0_WTM | FIFO_CFG0_RXS | FIFO_CFG0_RXF \
+			| FIFO_CFG0_TXS | FIFO_CFG0_TXF)
+
+#define FIFO_CFG0_ENABLE_SHIFT	8
+
+#define FIFO_CFG4_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG4_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG4_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG4_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG4_CR		BIT(4)	/* CRC error */
+#define FIFO_CFG4_LM		BIT(5)	/* Length Mismatch */
+#define FIFO_CFG4_LO		BIT(6)	/* Length out of range */
+#define FIFO_CFG4_OK		BIT(7)	/* Packet is OK */
+#define FIFO_CFG4_MC		BIT(8)	/* Multicast Packet */
+#define FIFO_CFG4_BC		BIT(9)	/* Broadcast Packet */
+#define FIFO_CFG4_DR		BIT(10)	/* Dribble */
+#define FIFO_CFG4_LE		BIT(11)	/* Long Event */
+#define FIFO_CFG4_CF		BIT(12)	/* Control Frame */
+#define FIFO_CFG4_PF		BIT(13)	/* Pause Frame */
+#define FIFO_CFG4_UO		BIT(14)	/* Unsupported Opcode */
+#define FIFO_CFG4_VT		BIT(15)	/* VLAN tag detected */
+#define FIFO_CFG4_FT		BIT(16)	/* Frame Truncated */
+#define FIFO_CFG4_UC		BIT(17)	/* Unicast Packet */
+
+#define FIFO_CFG5_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG5_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG5_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG5_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG5_LM		BIT(4)	/* Length Mismatch */
+#define FIFO_CFG5_LO		BIT(5)	/* Length Out of Range */
+#define FIFO_CFG5_OK		BIT(6)	/* Packet is OK */
+#define FIFO_CFG5_MC		BIT(7)	/* Multicast Packet */
+#define FIFO_CFG5_BC		BIT(8)	/* Broadcast Packet */
+#define FIFO_CFG5_DR		BIT(9)	/* Dribble */
+#define FIFO_CFG5_CF		BIT(10)	/* Control Frame */
+#define FIFO_CFG5_PF		BIT(11)	/* Pause Frame */
+#define FIFO_CFG5_UO		BIT(12)	/* Unsupported Opcode */
+#define FIFO_CFG5_VT		BIT(13)	/* VLAN tag detected */
+#define FIFO_CFG5_LE		BIT(14)	/* Long Event */
+#define FIFO_CFG5_FT		BIT(15)	/* Frame Truncated */
+#define FIFO_CFG5_16		BIT(16)	/* unknown */
+#define FIFO_CFG5_17		BIT(17)	/* unknown */
+#define FIFO_CFG5_SF		BIT(18)	/* Short Frame */
+#define FIFO_CFG5_BM		BIT(19)	/* Byte Mode */
+
+#define AG71XX_INT_TX_PS	BIT(0)
+#define AG71XX_INT_TX_UR	BIT(1)
+#define AG71XX_INT_TX_BE	BIT(3)
+#define AG71XX_INT_RX_PR	BIT(4)
+#define AG71XX_INT_RX_OF	BIT(6)
+#define AG71XX_INT_RX_BE	BIT(7)
+
+#define MAC_IFCTL_SPEED		BIT(16)
+
+#define MII_CFG_CLK_DIV_4	0
+#define MII_CFG_CLK_DIV_6	2
+#define MII_CFG_CLK_DIV_8	3
+#define MII_CFG_CLK_DIV_10	4
+#define MII_CFG_CLK_DIV_14	5
+#define MII_CFG_CLK_DIV_20	6
+#define MII_CFG_CLK_DIV_28	7
+#define MII_CFG_CLK_DIV_34	8
+#define MII_CFG_CLK_DIV_42	9
+#define MII_CFG_CLK_DIV_50	10
+#define MII_CFG_CLK_DIV_58	11
+#define MII_CFG_CLK_DIV_66	12
+#define MII_CFG_CLK_DIV_74	13
+#define MII_CFG_CLK_DIV_82	14
+#define MII_CFG_CLK_DIV_98	15
+#define MII_CFG_RESET		BIT(31)
+
+#define MII_CMD_WRITE		0x0
+#define MII_CMD_READ		0x1
+#define MII_ADDR_SHIFT		8
+#define MII_IND_BUSY		BIT(0)
+#define MII_IND_INVALID		BIT(2)
+
+#define TX_CTRL_TXE		BIT(0)	/* Tx Enable */
+
+#define TX_STATUS_PS		BIT(0)	/* Packet Sent */
+#define TX_STATUS_UR		BIT(1)	/* Tx Underrun */
+#define TX_STATUS_BE		BIT(3)	/* Bus Error */
+
+#define RX_CTRL_RXE		BIT(0)	/* Rx Enable */
+
+#define RX_STATUS_PR		BIT(0)	/* Packet Received */
+#define RX_STATUS_OF		BIT(2)	/* Rx Overflow */
+#define RX_STATUS_BE		BIT(3)	/* Bus Error */
+
+static inline void ag71xx_check_reg_offset(struct ag71xx *ag, unsigned reg)
+{
+	switch (reg) {
+	case AG71XX_REG_MAC_CFG1 ... AG71XX_REG_MAC_MFL:
+	case AG71XX_REG_MAC_IFCTL ... AG71XX_REG_TX_SM:
+	case AG71XX_REG_MII_CFG:
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+static inline void ag71xx_wr(struct ag71xx *ag, unsigned reg, u32 value)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	__raw_writel(value, ag->mac_base + reg);
+	/* flush write */
+	(void) __raw_readl(ag->mac_base + reg);
+}
+
+static inline u32 ag71xx_rr(struct ag71xx *ag, unsigned reg)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	return __raw_readl(ag->mac_base + reg);
+}
+
+static inline void ag71xx_sb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) | mask, r);
+	/* flush write */
+	(void)__raw_readl(r);
+}
+
+static inline void ag71xx_cb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) & ~mask, r);
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline void ag71xx_int_enable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_sb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+static inline void ag71xx_int_disable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_cb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+#ifdef CONFIG_AG71XX_AR8216_SUPPORT
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb);
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen);
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return ag71xx_get_pdata(ag)->has_ar8216;
+}
+#else
+static inline void ag71xx_add_ar8216_header(struct ag71xx *ag,
+					   struct sk_buff *skb)
+{
+}
+
+static inline int ag71xx_remove_ar8216_header(struct ag71xx *ag,
+					      struct sk_buff *skb,
+					      int pktlen)
+{
+	return 0;
+}
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+int ag71xx_debugfs_root_init(void);
+void ag71xx_debugfs_root_exit(void);
+int ag71xx_debugfs_init(struct ag71xx *ag);
+void ag71xx_debugfs_exit(struct ag71xx *ag);
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status);
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx);
+#else
+static inline int ag71xx_debugfs_root_init(void) { return 0; }
+static inline void ag71xx_debugfs_root_exit(void) {}
+static inline int ag71xx_debugfs_init(struct ag71xx *ag) { return 0; }
+static inline void ag71xx_debugfs_exit(struct ag71xx *ag) {}
+static inline void ag71xx_debugfs_update_int_stats(struct ag71xx *ag,
+						   u32 status) {}
+static inline void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag,
+						    int rx, int tx) {}
+#endif /* CONFIG_AG71XX_DEBUG_FS */
+
+void ag71xx_ar7240_start(struct ag71xx *ag);
+void ag71xx_ar7240_stop(struct ag71xx *ag);
+int ag71xx_ar7240_init(struct ag71xx *ag);
+void ag71xx_ar7240_cleanup(struct ag71xx *ag);
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg);
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val);
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr);
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val);
+
+#endif /* _AG71XX_H */
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
new file mode 100644
index 0000000000..3f2f64e2ae
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
@@ -0,0 +1,1382 @@
+/*
+ *  Driver for the built-in ethernet switch of the Atheros AR7240 SoC
+ *  Copyright (c) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (c) 2010 Felix Fietkau <nbd@nbd.name>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/mii.h>
+#include <linux/bitops.h>
+#include <linux/switch.h>
+#include "ag71xx.h"
+
+#define BITM(_count)	(BIT(_count) - 1)
+#define BITS(_shift, _count)	(BITM(_count) << _shift)
+
+#define AR7240_REG_MASK_CTRL		0x00
+#define AR7240_MASK_CTRL_REVISION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_S	8
+#define   AR7240_MASK_CTRL_VERSION_AR7240 0x01
+#define   AR7240_MASK_CTRL_VERSION_AR934X 0x02
+#define AR7240_MASK_CTRL_SOFT_RESET	BIT(31)
+
+#define AR7240_REG_MAC_ADDR0		0x20
+#define AR7240_REG_MAC_ADDR1		0x24
+
+#define AR7240_REG_FLOOD_MASK		0x2c
+#define AR7240_FLOOD_MASK_BROAD_TO_CPU	BIT(26)
+
+#define AR7240_REG_GLOBAL_CTRL		0x30
+#define AR7240_GLOBAL_CTRL_MTU_M	BITM(11)
+#define AR9340_GLOBAL_CTRL_MTU_M	BITM(14)
+
+#define AR7240_REG_VTU			0x0040
+#define   AR7240_VTU_OP			BITM(3)
+#define   AR7240_VTU_OP_NOOP		0x0
+#define   AR7240_VTU_OP_FLUSH		0x1
+#define   AR7240_VTU_OP_LOAD		0x2
+#define   AR7240_VTU_OP_PURGE		0x3
+#define   AR7240_VTU_OP_REMOVE_PORT	0x4
+#define   AR7240_VTU_ACTIVE		BIT(3)
+#define   AR7240_VTU_FULL		BIT(4)
+#define   AR7240_VTU_PORT		BITS(8, 4)
+#define   AR7240_VTU_PORT_S		8
+#define   AR7240_VTU_VID		BITS(16, 12)
+#define   AR7240_VTU_VID_S		16
+#define   AR7240_VTU_PRIO		BITS(28, 3)
+#define   AR7240_VTU_PRIO_S		28
+#define   AR7240_VTU_PRIO_EN		BIT(31)
+
+#define AR7240_REG_VTU_DATA		0x0044
+#define   AR7240_VTUDATA_MEMBER		BITS(0, 10)
+#define   AR7240_VTUDATA_VALID		BIT(11)
+
+#define AR7240_REG_ATU			0x50
+#define AR7240_ATU_FLUSH_ALL		0x1
+
+#define AR7240_REG_AT_CTRL		0x5c
+#define AR7240_AT_CTRL_AGE_TIME		BITS(0, 15)
+#define AR7240_AT_CTRL_AGE_EN		BIT(17)
+#define AR7240_AT_CTRL_LEARN_CHANGE	BIT(18)
+#define AR7240_AT_CTRL_RESERVED		BIT(19)
+#define AR7240_AT_CTRL_ARP_EN		BIT(20)
+
+#define AR7240_REG_TAG_PRIORITY		0x70
+
+#define AR7240_REG_SERVICE_TAG		0x74
+#define AR7240_SERVICE_TAG_M		BITM(16)
+
+#define AR7240_REG_CPU_PORT		0x78
+#define AR7240_MIRROR_PORT_S		4
+#define AR7240_MIRROR_PORT_M		BITM(4)
+#define AR7240_CPU_PORT_EN		BIT(8)
+
+#define AR7240_REG_MIB_FUNCTION0	0x80
+#define AR7240_MIB_TIMER_M		BITM(16)
+#define AR7240_MIB_AT_HALF_EN		BIT(16)
+#define AR7240_MIB_BUSY			BIT(17)
+#define AR7240_MIB_FUNC_S		24
+#define AR7240_MIB_FUNC_M		BITM(3)
+#define AR7240_MIB_FUNC_NO_OP		0x0
+#define AR7240_MIB_FUNC_FLUSH		0x1
+#define AR7240_MIB_FUNC_CAPTURE		0x3
+
+#define AR7240_REG_MDIO_CTRL		0x98
+#define AR7240_MDIO_CTRL_DATA_M		BITM(16)
+#define AR7240_MDIO_CTRL_REG_ADDR_S	16
+#define AR7240_MDIO_CTRL_PHY_ADDR_S	21
+#define AR7240_MDIO_CTRL_CMD_WRITE	0
+#define AR7240_MDIO_CTRL_CMD_READ	BIT(27)
+#define AR7240_MDIO_CTRL_MASTER_EN	BIT(30)
+#define AR7240_MDIO_CTRL_BUSY		BIT(31)
+
+#define AR7240_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR7240_REG_PORT_STATUS(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x00)
+#define AR7240_PORT_STATUS_SPEED_S	0
+#define AR7240_PORT_STATUS_SPEED_M	BITM(2)
+#define AR7240_PORT_STATUS_SPEED_10	0
+#define AR7240_PORT_STATUS_SPEED_100	1
+#define AR7240_PORT_STATUS_SPEED_1000	2
+#define AR7240_PORT_STATUS_TXMAC	BIT(2)
+#define AR7240_PORT_STATUS_RXMAC	BIT(3)
+#define AR7240_PORT_STATUS_TXFLOW	BIT(4)
+#define AR7240_PORT_STATUS_RXFLOW	BIT(5)
+#define AR7240_PORT_STATUS_DUPLEX	BIT(6)
+#define AR7240_PORT_STATUS_LINK_UP	BIT(8)
+#define AR7240_PORT_STATUS_LINK_AUTO	BIT(9)
+#define AR7240_PORT_STATUS_LINK_PAUSE	BIT(10)
+
+#define AR7240_REG_PORT_CTRL(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x04)
+#define AR7240_PORT_CTRL_STATE_M	BITM(3)
+#define	AR7240_PORT_CTRL_STATE_DISABLED	0
+#define AR7240_PORT_CTRL_STATE_BLOCK	1
+#define AR7240_PORT_CTRL_STATE_LISTEN	2
+#define AR7240_PORT_CTRL_STATE_LEARN	3
+#define AR7240_PORT_CTRL_STATE_FORWARD	4
+#define AR7240_PORT_CTRL_LEARN_LOCK	BIT(7)
+#define AR7240_PORT_CTRL_VLAN_MODE_S	8
+#define AR7240_PORT_CTRL_VLAN_MODE_KEEP	0
+#define AR7240_PORT_CTRL_VLAN_MODE_STRIP 1
+#define AR7240_PORT_CTRL_VLAN_MODE_ADD	2
+#define AR7240_PORT_CTRL_VLAN_MODE_DOUBLE_TAG 3
+#define AR7240_PORT_CTRL_IGMP_SNOOP	BIT(10)
+#define AR7240_PORT_CTRL_HEADER		BIT(11)
+#define AR7240_PORT_CTRL_MAC_LOOP	BIT(12)
+#define AR7240_PORT_CTRL_SINGLE_VLAN	BIT(13)
+#define AR7240_PORT_CTRL_LEARN		BIT(14)
+#define AR7240_PORT_CTRL_DOUBLE_TAG	BIT(15)
+#define AR7240_PORT_CTRL_MIRROR_TX	BIT(16)
+#define AR7240_PORT_CTRL_MIRROR_RX	BIT(17)
+
+#define AR7240_REG_PORT_VLAN(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x08)
+
+#define AR7240_PORT_VLAN_DEFAULT_ID_S	0
+#define AR7240_PORT_VLAN_DEST_PORTS_S	16
+#define AR7240_PORT_VLAN_MODE_S		30
+#define AR7240_PORT_VLAN_MODE_PORT_ONLY	0
+#define AR7240_PORT_VLAN_MODE_PORT_FALLBACK	1
+#define AR7240_PORT_VLAN_MODE_VLAN_ONLY	2
+#define AR7240_PORT_VLAN_MODE_SECURE	3
+
+
+#define AR7240_REG_STATS_BASE(_port)	(0x20000 + (_port) * 0x100)
+
+#define AR7240_STATS_RXBROAD		0x00
+#define AR7240_STATS_RXPAUSE		0x04
+#define AR7240_STATS_RXMULTI		0x08
+#define AR7240_STATS_RXFCSERR		0x0c
+#define AR7240_STATS_RXALIGNERR		0x10
+#define AR7240_STATS_RXRUNT		0x14
+#define AR7240_STATS_RXFRAGMENT		0x18
+#define AR7240_STATS_RX64BYTE		0x1c
+#define AR7240_STATS_RX128BYTE		0x20
+#define AR7240_STATS_RX256BYTE		0x24
+#define AR7240_STATS_RX512BYTE		0x28
+#define AR7240_STATS_RX1024BYTE		0x2c
+#define AR7240_STATS_RX1518BYTE		0x30
+#define AR7240_STATS_RXMAXBYTE		0x34
+#define AR7240_STATS_RXTOOLONG		0x38
+#define AR7240_STATS_RXGOODBYTE		0x3c
+#define AR7240_STATS_RXBADBYTE		0x44
+#define AR7240_STATS_RXOVERFLOW		0x4c
+#define AR7240_STATS_FILTERED		0x50
+#define AR7240_STATS_TXBROAD		0x54
+#define AR7240_STATS_TXPAUSE		0x58
+#define AR7240_STATS_TXMULTI		0x5c
+#define AR7240_STATS_TXUNDERRUN		0x60
+#define AR7240_STATS_TX64BYTE		0x64
+#define AR7240_STATS_TX128BYTE		0x68
+#define AR7240_STATS_TX256BYTE		0x6c
+#define AR7240_STATS_TX512BYTE		0x70
+#define AR7240_STATS_TX1024BYTE		0x74
+#define AR7240_STATS_TX1518BYTE		0x78
+#define AR7240_STATS_TXMAXBYTE		0x7c
+#define AR7240_STATS_TXOVERSIZE		0x80
+#define AR7240_STATS_TXBYTE		0x84
+#define AR7240_STATS_TXCOLLISION	0x8c
+#define AR7240_STATS_TXABORTCOL		0x90
+#define AR7240_STATS_TXMULTICOL		0x94
+#define AR7240_STATS_TXSINGLECOL	0x98
+#define AR7240_STATS_TXEXCDEFER		0x9c
+#define AR7240_STATS_TXDEFER		0xa0
+#define AR7240_STATS_TXLATECOL		0xa4
+
+#define AR7240_PORT_CPU		0
+#define AR7240_NUM_PORTS	6
+#define AR7240_NUM_PHYS		5
+
+#define AR7240_PHY_ID1		0x004d
+#define AR7240_PHY_ID2		0xd041
+
+#define AR934X_PHY_ID1		0x004d
+#define AR934X_PHY_ID2		0xd042
+
+#define AR7240_MAX_VLANS	16
+
+#define AR934X_REG_OPER_MODE0		0x04
+#define   AR934X_OPER_MODE0_MAC_GMII_EN	BIT(6)
+#define   AR934X_OPER_MODE0_PHY_MII_EN	BIT(10)
+
+#define AR934X_REG_OPER_MODE1		0x08
+#define   AR934X_REG_OPER_MODE1_PHY4_MII_EN	BIT(28)
+
+#define AR934X_REG_FLOOD_MASK		0x2c
+#define   AR934X_FLOOD_MASK_MC_DP(_p)	BIT(16 + (_p))
+#define   AR934X_FLOOD_MASK_BC_DP(_p)	BIT(25 + (_p))
+
+#define AR934X_REG_QM_CTRL		0x3c
+#define   AR934X_QM_CTRL_ARP_EN		BIT(15)
+
+#define AR934X_REG_AT_CTRL		0x5c
+#define   AR934X_AT_CTRL_AGE_TIME	BITS(0, 15)
+#define   AR934X_AT_CTRL_AGE_EN		BIT(17)
+#define   AR934X_AT_CTRL_LEARN_CHANGE	BIT(18)
+
+#define AR934X_MIB_ENABLE		BIT(30)
+
+#define AR934X_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR934X_REG_PORT_VLAN1(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x08)
+#define   AR934X_PORT_VLAN1_DEFAULT_SVID_S		0
+#define   AR934X_PORT_VLAN1_FORCE_DEFAULT_VID_EN 	BIT(12)
+#define   AR934X_PORT_VLAN1_PORT_TLS_MODE		BIT(13)
+#define   AR934X_PORT_VLAN1_PORT_VLAN_PROP_EN		BIT(14)
+#define   AR934X_PORT_VLAN1_PORT_CLONE_EN		BIT(15)
+#define   AR934X_PORT_VLAN1_DEFAULT_CVID_S		16
+#define   AR934X_PORT_VLAN1_FORCE_PORT_VLAN_EN		BIT(28)
+#define   AR934X_PORT_VLAN1_ING_PORT_PRI_S		29
+
+#define AR934X_REG_PORT_VLAN2(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x0c)
+#define   AR934X_PORT_VLAN2_PORT_VID_MEM_S		16
+#define   AR934X_PORT_VLAN2_8021Q_MODE_S		30
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_ONLY	0
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_FALLBACK	1
+#define   AR934X_PORT_VLAN2_8021Q_MODE_VLAN_ONLY	2
+#define   AR934X_PORT_VLAN2_8021Q_MODE_SECURE		3
+
+#define sw_to_ar7240(_dev) container_of(_dev, struct ar7240sw, swdev)
+
+struct ar7240sw_port_stat {
+	unsigned long rx_broadcast;
+	unsigned long rx_pause;
+	unsigned long rx_multicast;
+	unsigned long rx_fcs_error;
+	unsigned long rx_align_error;
+	unsigned long rx_runt;
+	unsigned long rx_fragments;
+	unsigned long rx_64byte;
+	unsigned long rx_128byte;
+	unsigned long rx_256byte;
+	unsigned long rx_512byte;
+	unsigned long rx_1024byte;
+	unsigned long rx_1518byte;
+	unsigned long rx_maxbyte;
+	unsigned long rx_toolong;
+	unsigned long rx_good_byte;
+	unsigned long rx_bad_byte;
+	unsigned long rx_overflow;
+	unsigned long filtered;
+
+	unsigned long tx_broadcast;
+	unsigned long tx_pause;
+	unsigned long tx_multicast;
+	unsigned long tx_underrun;
+	unsigned long tx_64byte;
+	unsigned long tx_128byte;
+	unsigned long tx_256byte;
+	unsigned long tx_512byte;
+	unsigned long tx_1024byte;
+	unsigned long tx_1518byte;
+	unsigned long tx_maxbyte;
+	unsigned long tx_oversize;
+	unsigned long tx_byte;
+	unsigned long tx_collision;
+	unsigned long tx_abortcol;
+	unsigned long tx_multicol;
+	unsigned long tx_singlecol;
+	unsigned long tx_excdefer;
+	unsigned long tx_defer;
+	unsigned long tx_xlatecol;
+};
+
+struct ar7240sw {
+	struct mii_bus	*mii_bus;
+	struct ag71xx_switch_platform_data *swdata;
+	struct switch_dev swdev;
+	int num_ports;
+	u8 ver;
+	bool vlan;
+	u16 vlan_id[AR7240_MAX_VLANS];
+	u8 vlan_table[AR7240_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR7240_NUM_PORTS];
+	char buf[80];
+
+	rwlock_t stats_lock;
+	struct ar7240sw_port_stat port_stats[AR7240_NUM_PORTS];
+};
+
+struct ar7240sw_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+static DEFINE_MUTEX(reg_mutex);
+
+static inline int sw_is_ar7240(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR7240;
+}
+
+static inline int sw_is_ar934x(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR934X;
+}
+
+static inline u32 ar7240sw_port_mask(struct ar7240sw *as, int port)
+{
+	return BIT(port);
+}
+
+static inline u32 ar7240sw_port_mask_all(struct ar7240sw *as)
+{
+	return BIT(as->swdev.ports) - 1;
+}
+
+static inline u32 ar7240sw_port_mask_but(struct ar7240sw *as, int port)
+{
+	return ar7240sw_port_mask_all(as) & ~BIT(port);
+}
+
+static inline u16 mk_phy_addr(u32 reg)
+{
+	return 0x17 & ((reg >> 4) | 0x10);
+}
+
+static inline u16 mk_phy_reg(u32 reg)
+{
+	return (reg << 1) & 0x1e;
+}
+
+static inline u16 mk_high_addr(u32 reg)
+{
+	return (reg >> 7) & 0x1ff;
+}
+
+static u32 __ar7240sw_reg_read(struct mii_bus *mii, u32 reg)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+	u32 hi, lo;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	lo = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg);
+	hi = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg + 1);
+	local_irq_restore(flags);
+
+	return (hi << 16) | lo;
+}
+
+static void __ar7240sw_reg_write(struct mii_bus *mii, u32 reg, u32 val)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg + 1, (val >> 16));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg, (val & 0xffff));
+	local_irq_restore(flags);
+}
+
+static u32 ar7240sw_reg_read(struct mii_bus *mii, u32 reg_addr)
+{
+	u32 ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_read(mii, reg_addr);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static void ar7240sw_reg_write(struct mii_bus *mii, u32 reg_addr, u32 reg_val)
+{
+	mutex_lock(&reg_mutex);
+	__ar7240sw_reg_write(mii, reg_addr, reg_val);
+	mutex_unlock(&reg_mutex);
+}
+
+static u32 ar7240sw_reg_rmw(struct mii_bus *mii, u32 reg, u32 mask, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t &= ~mask;
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+
+	return t;
+}
+
+static void ar7240sw_reg_set(struct mii_bus *mii, u32 reg, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+}
+
+static int __ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			       unsigned timeout)
+{
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		u32 t;
+
+		t = __ar7240sw_reg_read(mii, reg);
+		if ((t & mask) == val)
+			return 0;
+
+		usleep_range(1000, 2000);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			     unsigned timeout)
+{
+	int ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_wait(mii, reg, mask, val, timeout);
+	mutex_unlock(&reg_mutex);
+	return ret;
+}
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr)
+{
+	u32 t, val = 0xffff;
+	int err;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return 0xffff;
+
+	mutex_lock(&reg_mutex);
+	t = (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_READ;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	err = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	if (!err)
+		val = __ar7240sw_reg_read(mii, AR7240_REG_MDIO_CTRL);
+	mutex_unlock(&reg_mutex);
+
+	return val & AR7240_MDIO_CTRL_DATA_M;
+}
+
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val)
+{
+	u32 t;
+	int ret;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return -EINVAL;
+
+	mutex_lock(&reg_mutex);
+	t = (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_WRITE |
+	    reg_val;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	ret = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static int ar7240sw_capture_stats(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int port;
+	int ret;
+
+	write_lock(&as->stats_lock);
+
+	/* Capture the hardware statistics for all ports */
+	ar7240sw_reg_rmw(mii, AR7240_REG_MIB_FUNCTION0,
+			 (AR7240_MIB_FUNC_M << AR7240_MIB_FUNC_S),
+			 (AR7240_MIB_FUNC_CAPTURE << AR7240_MIB_FUNC_S));
+
+	/* Wait for the capturing to complete. */
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MIB_FUNCTION0,
+				AR7240_MIB_BUSY, 0, 10);
+
+	if (ret)
+		goto unlock;
+
+	for (port = 0; port < AR7240_NUM_PORTS; port++) {
+		unsigned int base;
+		struct ar7240sw_port_stat *stats;
+
+		base = AR7240_REG_STATS_BASE(port);
+		stats = &as->port_stats[port];
+
+#define READ_STAT(_r) ar7240sw_reg_read(mii, base + AR7240_STATS_ ## _r)
+
+		stats->rx_good_byte += READ_STAT(RXGOODBYTE);
+		stats->tx_byte += READ_STAT(TXBYTE);
+
+#undef READ_STAT
+	}
+
+	ret = 0;
+
+unlock:
+	write_unlock(&as->stats_lock);
+	return ret;
+}
+
+static void ar7240sw_disable_port(struct ar7240sw *as, unsigned port)
+{
+	ar7240sw_reg_write(as->mii_bus, AR7240_REG_PORT_CTRL(port),
+			   AR7240_PORT_CTRL_STATE_DISABLED);
+}
+
+static void ar7240sw_setup(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	/* Enable CPU port, and disable mirror port */
+	ar7240sw_reg_write(mii, AR7240_REG_CPU_PORT,
+			   AR7240_CPU_PORT_EN |
+			   (15 << AR7240_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar7240sw_reg_write(mii, AR7240_REG_TAG_PRIORITY, 0xfa50);
+
+	if (sw_is_ar934x(as)) {
+		/* Enable aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR934X_REG_AT_CTRL,
+			0x2b /* 5 min age time */ |
+			AR934X_AT_CTRL_AGE_EN |
+			AR934X_AT_CTRL_LEARN_CHANGE);
+		/* Enable ARP frame acknowledge */
+		ar7240sw_reg_set(mii, AR934X_REG_QM_CTRL,
+				 AR934X_QM_CTRL_ARP_EN);
+		/* Enable Broadcast/Multicast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR934X_REG_FLOOD_MASK,
+				 AR934X_FLOOD_MASK_BC_DP(0) |
+				 AR934X_FLOOD_MASK_MC_DP(0));
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR9340_GLOBAL_CTRL_MTU_M,
+				 AR9340_GLOBAL_CTRL_MTU_M);
+
+		/* Enable MIB counters */
+		ar7240sw_reg_set(mii, AR7240_REG_MIB_FUNCTION0,
+				 AR934X_MIB_ENABLE);
+
+	} else {
+		/* Enable ARP frame acknowledge, aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR7240_REG_AT_CTRL,
+			AR7240_AT_CTRL_RESERVED |
+			0x2b /* 5 min age time */ |
+			AR7240_AT_CTRL_AGE_EN |
+			AR7240_AT_CTRL_ARP_EN |
+			AR7240_AT_CTRL_LEARN_CHANGE);
+		/* Enable Broadcast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR7240_REG_FLOOD_MASK,
+				 AR7240_FLOOD_MASK_BROAD_TO_CPU);
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR7240_GLOBAL_CTRL_MTU_M,
+				 AR7240_GLOBAL_CTRL_MTU_M);
+	}
+
+	/* setup Service TAG */
+	ar7240sw_reg_rmw(mii, AR7240_REG_SERVICE_TAG, AR7240_SERVICE_TAG_M, 0);
+}
+
+/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
+static int
+ar7240sw_phy_poll_reset(struct mii_bus *bus)
+{
+	const unsigned int sleep_msecs = 20;
+	int ret, elapsed, i;
+
+	for (elapsed = sleep_msecs; elapsed <= 600;
+	     elapsed += sleep_msecs) {
+		msleep(sleep_msecs);
+		for (i = 0; i < AR7240_NUM_PHYS; i++) {
+			ret = ar7240sw_phy_read(bus, i, MII_BMCR);
+			if (ret < 0)
+				return ret;
+			if (ret & BMCR_RESET)
+				break;
+			if (i == AR7240_NUM_PHYS - 1) {
+				usleep_range(1000, 2000);
+				return 0;
+			}
+		}
+	}
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reset(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int ret;
+	int i;
+
+	/* Set all ports to disabled state. */
+	for (i = 0; i < AR7240_NUM_PORTS; i++)
+		ar7240sw_disable_port(as, i);
+
+	/* Wait for transmit queues to drain. */
+	usleep_range(2000, 3000);
+
+	/* Reset the switch. */
+	ar7240sw_reg_write(mii, AR7240_REG_MASK_CTRL,
+			   AR7240_MASK_CTRL_SOFT_RESET);
+
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MASK_CTRL,
+				AR7240_MASK_CTRL_SOFT_RESET, 0, 1000);
+
+	/* setup PHYs */
+	for (i = 0; i < AR7240_NUM_PHYS; i++) {
+		ar7240sw_phy_write(mii, i, MII_ADVERTISE,
+				   ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
+				   ADVERTISE_PAUSE_ASYM);
+		ar7240sw_phy_write(mii, i, MII_BMCR,
+				   BMCR_RESET | BMCR_ANENABLE);
+	}
+	ret = ar7240sw_phy_poll_reset(mii);
+	if (ret)
+		return ret;
+
+	ar7240sw_setup(as);
+	return ret;
+}
+
+static void ar7240sw_setup_port(struct ar7240sw *as, unsigned port, u8 portmask)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 ctrl;
+	u32 vid, mode;
+
+	ctrl = AR7240_PORT_CTRL_STATE_FORWARD | AR7240_PORT_CTRL_LEARN |
+		AR7240_PORT_CTRL_SINGLE_VLAN;
+
+	if (port == AR7240_PORT_CPU) {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_SPEED_1000 |
+				   AR7240_PORT_STATUS_TXFLOW |
+				   AR7240_PORT_STATUS_RXFLOW |
+				   AR7240_PORT_STATUS_TXMAC |
+				   AR7240_PORT_STATUS_RXMAC |
+				   AR7240_PORT_STATUS_DUPLEX);
+	} else {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_LINK_AUTO);
+	}
+
+	/* Set the default VID for this port */
+	if (as->vlan) {
+		vid = as->vlan_id[as->pvid[port]];
+		mode = AR7240_PORT_VLAN_MODE_SECURE;
+	} else {
+		vid = port;
+		mode = AR7240_PORT_VLAN_MODE_PORT_ONLY;
+	}
+
+	if (as->vlan) {
+		if (as->vlan_tagged & BIT(port))
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_ADD <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+		else
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_STRIP <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+	} else {
+		ctrl |= AR7240_PORT_CTRL_VLAN_MODE_KEEP <<
+			AR7240_PORT_CTRL_VLAN_MODE_S;
+	}
+
+	if (!portmask) {
+		if (port == AR7240_PORT_CPU)
+			portmask = ar7240sw_port_mask_but(as, AR7240_PORT_CPU);
+		else
+			portmask = ar7240sw_port_mask(as, AR7240_PORT_CPU);
+	}
+
+	/* allow the port to talk to all other ports, but exclude its
+	 * own ID to prevent frames from being reflected back to the
+	 * port that they came from */
+	portmask &= ar7240sw_port_mask_but(as, port);
+
+	ar7240sw_reg_write(mii, AR7240_REG_PORT_CTRL(port), ctrl);
+	if (sw_is_ar934x(as)) {
+		u32 vlan1, vlan2;
+
+		vlan1 = (vid << AR934X_PORT_VLAN1_DEFAULT_CVID_S);
+		vlan2 = (portmask << AR934X_PORT_VLAN2_PORT_VID_MEM_S) |
+			(mode << AR934X_PORT_VLAN2_8021Q_MODE_S);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN1(port), vlan1);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN2(port), vlan2);
+	} else {
+		u32 vlan;
+
+		vlan = vid | (mode << AR7240_PORT_VLAN_MODE_S) |
+		       (portmask << AR7240_PORT_VLAN_DEST_PORTS_S);
+
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_VLAN(port), vlan);
+	}
+}
+
+static int ar7240_set_addr(struct ar7240sw *as, u8 *addr)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 t;
+
+	t = (addr[4] << 8) | addr[5];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR0, t);
+
+	t = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR1, t);
+
+	return 0;
+}
+
+static int
+ar7240_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan_id[val->port_vlan];
+	return 0;
+}
+
+static int
+ar7240_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	/* make sure no invalid PVIDs get set */
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	as->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar7240_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	*vlan = as->pvid[port];
+	return 0;
+}
+
+static int
+ar7240_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 ports = as->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < as->swdev.ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (as->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 *vt = &as->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+			as->vlan_tagged |= (1 << p->id);
+		else {
+			as->vlan_tagged &= ~(1 << p->id);
+			as->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR7240_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				as->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
+
+		*vt |= 1 << p->id;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan;
+	return 0;
+}
+
+static void
+ar7240_vtu_op(struct ar7240sw *as, u32 op, u32 val)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	if (ar7240sw_reg_wait(mii, AR7240_REG_VTU, AR7240_VTU_ACTIVE, 0, 5))
+		return;
+
+	if ((op & AR7240_VTU_OP) == AR7240_VTU_OP_LOAD) {
+		val &= AR7240_VTUDATA_MEMBER;
+		val |= AR7240_VTUDATA_VALID;
+		ar7240sw_reg_write(mii, AR7240_REG_VTU_DATA, val);
+	}
+	op |= AR7240_VTU_ACTIVE;
+	ar7240sw_reg_write(mii, AR7240_REG_VTU, op);
+}
+
+static int
+ar7240_hw_apply(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 portmask[AR7240_NUM_PORTS];
+	int i, j;
+
+	/* flush all vlan translation unit entries */
+	ar7240_vtu_op(as, AR7240_VTU_OP_FLUSH, 0);
+
+	memset(portmask, 0, sizeof(portmask));
+	if (as->vlan) {
+		/* calculate the port destination masks and load vlans
+		 * into the vlan translation unit */
+		for (j = 0; j < AR7240_MAX_VLANS; j++) {
+			u8 vp = as->vlan_table[j];
+
+			if (!vp)
+				continue;
+
+			for (i = 0; i < as->swdev.ports; i++) {
+				u8 mask = (1 << i);
+				if (vp & mask)
+					portmask[i] |= vp & ~mask;
+			}
+
+			ar7240_vtu_op(as,
+				AR7240_VTU_OP_LOAD |
+				(as->vlan_id[j] << AR7240_VTU_VID_S),
+				as->vlan_table[j]);
+		}
+	} else {
+		/* vlan disabled:
+		 * isolate all ports, but connect them to the cpu port */
+		for (i = 0; i < as->swdev.ports; i++) {
+			if (i == AR7240_PORT_CPU)
+				continue;
+
+			portmask[i] = 1 << AR7240_PORT_CPU;
+			portmask[AR7240_PORT_CPU] |= (1 << i);
+		}
+	}
+
+	/* update the port destination mask registers and tag settings */
+	for (i = 0; i < as->swdev.ports; i++)
+		ar7240sw_setup_port(as, i, portmask[i]);
+
+	return 0;
+}
+
+static int
+ar7240_reset_switch(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	ar7240sw_reset(as);
+	return 0;
+}
+
+static int
+ar7240_get_port_link(struct switch_dev *dev, int port,
+		     struct switch_port_link *link)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+	u32 status;
+
+	if (port >= AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	status = ar7240sw_reg_read(mii, AR7240_REG_PORT_STATUS(port));
+	link->aneg = !!(status & AR7240_PORT_STATUS_LINK_AUTO);
+	if (link->aneg) {
+		link->link = !!(status & AR7240_PORT_STATUS_LINK_UP);
+		if (!link->link)
+			return 0;
+	} else {
+		link->link = true;
+	}
+
+	link->duplex = !!(status & AR7240_PORT_STATUS_DUPLEX);
+	link->tx_flow = !!(status & AR7240_PORT_STATUS_TXFLOW);
+	link->rx_flow = !!(status & AR7240_PORT_STATUS_RXFLOW);
+	switch (status & AR7240_PORT_STATUS_SPEED_M) {
+	case AR7240_PORT_STATUS_SPEED_10:
+		link->speed = SWITCH_PORT_SPEED_10;
+		break;
+	case AR7240_PORT_STATUS_SPEED_100:
+		link->speed = SWITCH_PORT_SPEED_100;
+		break;
+	case AR7240_PORT_STATUS_SPEED_1000:
+		link->speed = SWITCH_PORT_SPEED_1000;
+		break;
+	}
+
+	return 0;
+}
+
+static int
+ar7240_get_port_stats(struct switch_dev *dev, int port,
+		      struct switch_port_stats *stats)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	if (port >= AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	ar7240sw_capture_stats(as);
+
+	read_lock(&as->stats_lock);
+	stats->rx_bytes = as->port_stats[port].rx_good_byte;
+	stats->tx_bytes = as->port_stats[port].tx_byte;
+	read_unlock(&as->stats_lock);
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_monitor_port(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->value.i;
+
+	if (port > 15)
+		return -EINVAL;
+
+	ar7240sw_reg_rmw(mii, AR7240_REG_CPU_PORT,
+		AR7240_MIRROR_PORT_M << AR7240_MIRROR_PORT_S,
+		port << AR7240_MIRROR_PORT_S);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_monitor_port(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ret;
+
+	ret = ar7240sw_reg_read(mii, AR7240_REG_CPU_PORT);
+	val->value.i = (ret >> AR7240_MIRROR_PORT_S) & AR7240_MIRROR_PORT_M;
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	if (val && val->value.i == 1)
+		ar7240sw_reg_set(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_RX);
+	else
+		ar7240sw_reg_rmw(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_RX, 0);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ctrl;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_PORT_CTRL(port));
+
+	if ((ctrl & AR7240_PORT_CTRL_MIRROR_RX) == AR7240_PORT_CTRL_MIRROR_RX)
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	return 0;
+}
+
+static int
+ar7240_set_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	if (val && val->value.i == 1)
+		ar7240sw_reg_set(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_TX);
+	else
+		ar7240sw_reg_rmw(mii, AR7240_REG_PORT_CTRL(port),
+			AR7240_PORT_CTRL_MIRROR_TX, 0);
+
+	return 0;
+}
+
+static int
+ar7240_get_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
+		      struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+
+	u32 ctrl;
+
+	int port = val->port_vlan;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_PORT_CTRL(port));
+
+	if ((ctrl & AR7240_PORT_CTRL_MIRROR_TX) == AR7240_PORT_CTRL_MIRROR_TX)
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	return 0;
+}
+
+static struct switch_attr ar7240_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar7240_set_vlan,
+		.get = ar7240_get_vlan,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar7240_set_mirror_monitor_port,
+		.get = ar7240_get_mirror_monitor_port,
+		.max = 15
+	},
+};
+
+static struct switch_attr ar7240_port[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar7240_set_mirror_rx,
+		.get = ar7240_get_mirror_rx,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar7240_set_mirror_tx,
+		.get = ar7240_get_mirror_tx,
+		.max = 1
+	},
+};
+
+static struct switch_attr ar7240_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID",
+		.set = ar7240_set_vid,
+		.get = ar7240_get_vid,
+		.max = 4094,
+	},
+};
+
+static const struct switch_dev_ops ar7240_ops = {
+	.attr_global = {
+		.attr = ar7240_globals,
+		.n_attr = ARRAY_SIZE(ar7240_globals),
+	},
+	.attr_port = {
+		.attr = ar7240_port,
+		.n_attr = ARRAY_SIZE(ar7240_port),
+	},
+	.attr_vlan = {
+		.attr = ar7240_vlan,
+		.n_attr = ARRAY_SIZE(ar7240_vlan),
+	},
+	.get_port_pvid = ar7240_get_pvid,
+	.set_port_pvid = ar7240_set_pvid,
+	.get_vlan_ports = ar7240_get_ports,
+	.set_vlan_ports = ar7240_set_ports,
+	.apply_config = ar7240_hw_apply,
+	.reset_switch = ar7240_reset_switch,
+	.get_port_link = ar7240_get_port_link,
+	.get_port_stats = ar7240_get_port_stats,
+};
+
+static struct ar7240sw *ar7240_probe(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct mii_bus *mii = ag->mii_bus;
+	struct ar7240sw *as;
+	struct switch_dev *swdev;
+	u32 ctrl;
+	u16 phy_id1;
+	u16 phy_id2;
+	int i;
+
+	phy_id1 = ar7240sw_phy_read(mii, 0, MII_PHYSID1);
+	phy_id2 = ar7240sw_phy_read(mii, 0, MII_PHYSID2);
+	if ((phy_id1 != AR7240_PHY_ID1 || phy_id2 != AR7240_PHY_ID2) &&
+	    (phy_id1 != AR934X_PHY_ID1 || phy_id2 != AR934X_PHY_ID2)) {
+		pr_err("%s: unknown phy id '%04x:%04x'\n",
+		       dev_name(&mii->dev), phy_id1, phy_id2);
+		return NULL;
+	}
+
+	as = kzalloc(sizeof(*as), GFP_KERNEL);
+	if (!as)
+		return NULL;
+
+	as->mii_bus = mii;
+	as->swdata = pdata->switch_data;
+
+	swdev = &as->swdev;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_MASK_CTRL);
+	as->ver = (ctrl >> AR7240_MASK_CTRL_VERSION_S) &
+		  AR7240_MASK_CTRL_VERSION_M;
+
+	if (sw_is_ar7240(as)) {
+		swdev->name = "AR7240/AR9330 built-in switch";
+		swdev->ports = AR7240_NUM_PORTS - 1;
+	} else if (sw_is_ar934x(as)) {
+		swdev->name = "AR934X built-in switch";
+
+		if (pdata->phy_if_mode == PHY_INTERFACE_MODE_GMII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_MAC_GMII_EN);
+		} else if (pdata->phy_if_mode == PHY_INTERFACE_MODE_MII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_PHY_MII_EN);
+		} else {
+			pr_err("%s: invalid PHY interface mode\n",
+			       dev_name(&mii->dev));
+			goto err_free;
+		}
+
+		if (as->swdata->phy4_mii_en) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE1,
+					 AR934X_REG_OPER_MODE1_PHY4_MII_EN);
+			swdev->ports = AR7240_NUM_PORTS - 1;
+		} else {
+			swdev->ports = AR7240_NUM_PORTS;
+		}
+	} else {
+		pr_err("%s: unsupported chip, ctrl=%08x\n",
+			dev_name(&mii->dev), ctrl);
+		goto err_free;
+	}
+
+	swdev->cpu_port = AR7240_PORT_CPU;
+	swdev->vlans = AR7240_MAX_VLANS;
+	swdev->ops = &ar7240_ops;
+
+	if (register_switch(&as->swdev, ag->dev) < 0)
+		goto err_free;
+
+	pr_info("%s: Found an %s\n", dev_name(&mii->dev), swdev->name);
+
+	/* initialize defaults */
+	for (i = 0; i < AR7240_MAX_VLANS; i++)
+		as->vlan_id[i] = i;
+
+	as->vlan_table[0] = ar7240sw_port_mask_all(as);
+
+	return as;
+
+err_free:
+	kfree(as);
+	return NULL;
+}
+
+static void link_function(struct work_struct *work) {
+	struct ag71xx *ag = container_of(work, struct ag71xx, link_work.work);
+	struct ar7240sw *as = ag->phy_priv;
+	unsigned long flags;
+	u8 mask;
+	int i;
+	int status = 0;
+
+	mask = ~as->swdata->phy_poll_mask;
+	for (i = 0; i < AR7240_NUM_PHYS; i++) {
+		int link;
+
+		if (!(mask & BIT(i)))
+			continue;
+
+		link = ar7240sw_phy_read(ag->mii_bus, i, MII_BMSR);
+		if (link & BMSR_LSTATUS) {
+			status = 1;
+			break;
+		}
+	}
+
+	spin_lock_irqsave(&ag->lock, flags);
+	if (status != ag->link) {
+		ag->link = status;
+		ag71xx_link_adjust(ag);
+	}
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	schedule_delayed_work(&ag->link_work, HZ / 2);
+}
+
+void ag71xx_ar7240_start(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	ar7240sw_reset(as);
+
+	ag->speed = SPEED_1000;
+	ag->duplex = 1;
+
+	ar7240_set_addr(as, ag->dev->dev_addr);
+	ar7240_hw_apply(&as->swdev);
+
+	schedule_delayed_work(&ag->link_work, HZ / 10);
+}
+
+void ag71xx_ar7240_stop(struct ag71xx *ag)
+{
+	cancel_delayed_work_sync(&ag->link_work);
+}
+
+int ag71xx_ar7240_init(struct ag71xx *ag)
+{
+	struct ar7240sw *as;
+
+	as = ar7240_probe(ag);
+	if (!as)
+		return -ENODEV;
+
+	ag->phy_priv = as;
+	ar7240sw_reset(as);
+
+	rwlock_init(&as->stats_lock);
+	INIT_DELAYED_WORK(&ag->link_work, link_function);
+
+	return 0;
+}
+
+void ag71xx_ar7240_cleanup(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	if (!as)
+		return;
+
+	unregister_switch(&as->swdev);
+	kfree(as);
+	ag->phy_priv = NULL;
+}
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
new file mode 100644
index 0000000000..7ec43b7221
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
@@ -0,0 +1,44 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *  Special support for the Atheros ar8216 switch chip
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AR8216_PACKET_TYPE_MASK		0xf
+#define AR8216_PACKET_TYPE_NORMAL	0
+
+#define AR8216_HEADER_LEN	2
+
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb)
+{
+	skb_push(skb, AR8216_HEADER_LEN);
+	skb->data[0] = 0x10;
+	skb->data[1] = 0x80;
+}
+
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen)
+{
+	u8 type;
+
+	type = skb->data[1] & AR8216_PACKET_TYPE_MASK;
+	switch (type) {
+	case AR8216_PACKET_TYPE_NORMAL:
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	skb_pull(skb, AR8216_HEADER_LEN);
+	return 0;
+}
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
new file mode 100644
index 0000000000..20cf1c15c8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
@@ -0,0 +1,285 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/debugfs.h>
+
+#include "ag71xx.h"
+
+static struct dentry *ag71xx_debugfs_root;
+
+static int ag71xx_debugfs_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status)
+{
+	if (status)
+		ag->debug.int_stats.total++;
+	if (status & AG71XX_INT_TX_PS)
+		ag->debug.int_stats.tx_ps++;
+	if (status & AG71XX_INT_TX_UR)
+		ag->debug.int_stats.tx_ur++;
+	if (status & AG71XX_INT_TX_BE)
+		ag->debug.int_stats.tx_be++;
+	if (status & AG71XX_INT_RX_PR)
+		ag->debug.int_stats.rx_pr++;
+	if (status & AG71XX_INT_RX_OF)
+		ag->debug.int_stats.rx_of++;
+	if (status & AG71XX_INT_RX_BE)
+		ag->debug.int_stats.rx_be++;
+}
+
+static ssize_t read_file_int_stats(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+#define PR_INT_STAT(_label, _field)					\
+	len += snprintf(buf + len, sizeof(buf) - len,			\
+		"%20s: %10lu\n", _label, ag->debug.int_stats._field);
+
+	struct ag71xx *ag = file->private_data;
+	char buf[256];
+	unsigned int len = 0;
+
+	PR_INT_STAT("TX Packet Sent", tx_ps);
+	PR_INT_STAT("TX Underrun", tx_ur);
+	PR_INT_STAT("TX Bus Error", tx_be);
+	PR_INT_STAT("RX Packet Received", rx_pr);
+	PR_INT_STAT("RX Overflow", rx_of);
+	PR_INT_STAT("RX Bus Error", rx_be);
+	len += snprintf(buf + len, sizeof(buf) - len, "\n");
+	PR_INT_STAT("Total", total);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+#undef PR_INT_STAT
+}
+
+static const struct file_operations ag71xx_fops_int_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_int_stats,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx)
+{
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+
+	if (rx) {
+		stats->rx_count++;
+		stats->rx_packets += rx;
+		if (rx <= AG71XX_NAPI_WEIGHT)
+			stats->rx[rx]++;
+		if (rx > stats->rx_packets_max)
+			stats->rx_packets_max = rx;
+	}
+
+	if (tx) {
+		stats->tx_count++;
+		stats->tx_packets += tx;
+		if (tx <= AG71XX_NAPI_WEIGHT)
+			stats->tx[tx]++;
+		if (tx > stats->tx_packets_max)
+			stats->tx_packets_max = tx;
+	}
+}
+
+static ssize_t read_file_napi_stats(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long rx_avg = 0;
+	unsigned long tx_avg = 0;
+	int ret;
+	int i;
+
+	buflen = 2048;
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (stats->rx_count)
+		rx_avg = stats->rx_packets / stats->rx_count;
+
+	if (stats->tx_count)
+		tx_avg = stats->tx_packets / stats->tx_count;
+
+	len += snprintf(buf + len, buflen - len, "%3s  %10s %10s\n",
+			"len", "rx", "tx");
+
+	for (i = 1; i <= AG71XX_NAPI_WEIGHT; i++)
+		len += snprintf(buf + len, buflen - len,
+				"%3d: %10lu %10lu\n",
+				i, stats->rx[i], stats->tx[i]);
+
+	len += snprintf(buf + len, buflen - len, "\n");
+
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"sum", stats->rx_count, stats->tx_count);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"avg", rx_avg, tx_avg);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"max", stats->rx_packets_max, stats->tx_packets_max);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"pkt", stats->rx_packets, stats->tx_packets);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations ag71xx_fops_napi_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_napi_stats,
+	.owner	= THIS_MODULE
+};
+
+#define DESC_PRINT_LEN	64
+
+static ssize_t read_file_ring(struct file *file, char __user *user_buf,
+			      size_t count, loff_t *ppos,
+			      struct ag71xx *ag,
+			      struct ag71xx_ring *ring,
+			      unsigned desc_reg)
+{
+	int ring_size = BIT(ring->order);
+	int ring_mask = ring_size - 1;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long flags;
+	ssize_t ret;
+	int curr;
+	int dirty;
+	u32 desc_hw;
+	int i;
+
+	buflen = (ring_size * DESC_PRINT_LEN);
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += snprintf(buf + len, buflen - len,
+			"Idx ... %-8s %-8s %-8s %-8s .\n",
+			"desc", "next", "data", "ctrl");
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	curr = (ring->curr & ring_mask);
+	dirty = (ring->dirty & ring_mask);
+	desc_hw = ag71xx_rr(ag, desc_reg);
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		u32 desc_dma = ((u32) ring->descs_dma) + i * AG71XX_DESC_SIZE;
+
+		len += snprintf(buf + len, buflen - len,
+			"%3d %c%c%c %08x %08x %08x %08x %c\n",
+			i,
+			(i == curr) ? 'C' : ' ',
+			(i == dirty) ? 'D' : ' ',
+			(desc_hw == desc_dma) ? 'H' : ' ',
+			desc_dma,
+			desc->next,
+			desc->data,
+			desc->ctrl,
+			(desc->ctrl & DESC_EMPTY) ? 'E' : '*');
+	}
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t read_file_tx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->tx_ring,
+			      AG71XX_REG_TX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_tx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_tx_ring,
+	.owner	= THIS_MODULE
+};
+
+static ssize_t read_file_rx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->rx_ring,
+			      AG71XX_REG_RX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_rx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_rx_ring,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_exit(struct ag71xx *ag)
+{
+	debugfs_remove_recursive(ag->debug.debugfs_dir);
+}
+
+int ag71xx_debugfs_init(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+
+	ag->debug.debugfs_dir = debugfs_create_dir(dev_name(dev),
+						   ag71xx_debugfs_root);
+	if (!ag->debug.debugfs_dir) {
+		dev_err(dev, "unable to create debugfs directory\n");
+		return -ENOENT;
+	}
+
+	debugfs_create_file("int_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_int_stats);
+	debugfs_create_file("napi_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_napi_stats);
+	debugfs_create_file("tx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_tx_ring);
+	debugfs_create_file("rx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_rx_ring);
+
+	return 0;
+}
+
+int ag71xx_debugfs_root_init(void)
+{
+	if (ag71xx_debugfs_root)
+		return -EBUSY;
+
+	ag71xx_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!ag71xx_debugfs_root)
+		return -ENOENT;
+
+	return 0;
+}
+
+void ag71xx_debugfs_root_exit(void)
+{
+	debugfs_remove(ag71xx_debugfs_root);
+	ag71xx_debugfs_root = NULL;
+}
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
new file mode 100644
index 0000000000..f0e102152f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
@@ -0,0 +1,131 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static int ag71xx_ethtool_get_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int ag71xx_ethtool_set_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static void ag71xx_ethtool_get_drvinfo(struct net_device *dev,
+				       struct ethtool_drvinfo *info)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	strcpy(info->driver, ag->pdev->dev.driver->name);
+	strcpy(info->version, AG71XX_DRV_VERSION);
+	strcpy(info->bus_info, dev_name(&ag->pdev->dev));
+}
+
+static u32 ag71xx_ethtool_get_msglevel(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	return ag->msg_enable;
+}
+
+static void ag71xx_ethtool_set_msglevel(struct net_device *dev, u32 msg_level)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	ag->msg_enable = msg_level;
+}
+
+static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	er->tx_max_pending = AG71XX_TX_RING_SIZE_MAX;
+	er->rx_max_pending = AG71XX_RX_RING_SIZE_MAX;
+	er->rx_mini_max_pending = 0;
+	er->rx_jumbo_max_pending = 0;
+
+	er->tx_pending = BIT(ag->tx_ring.order);
+	er->rx_pending = BIT(ag->rx_ring.order);
+	er->rx_mini_pending = 0;
+	er->rx_jumbo_pending = 0;
+
+	if (ag->tx_ring.desc_split)
+		er->tx_pending /= AG71XX_TX_RING_DS_PER_PKT;
+}
+
+static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
+					struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned tx_size;
+	unsigned rx_size;
+	int err = 0;
+
+	if (er->rx_mini_pending != 0||
+	    er->rx_jumbo_pending != 0 ||
+	    er->rx_pending == 0 ||
+	    er->tx_pending == 0)
+		return -EINVAL;
+
+	tx_size = er->tx_pending < AG71XX_TX_RING_SIZE_MAX ?
+		  er->tx_pending : AG71XX_TX_RING_SIZE_MAX;
+
+	rx_size = er->rx_pending < AG71XX_RX_RING_SIZE_MAX ?
+		  er->rx_pending : AG71XX_RX_RING_SIZE_MAX;
+
+	if (netif_running(dev)) {
+		err = dev->netdev_ops->ndo_stop(dev);
+		if (err)
+			return err;
+	}
+
+	if (ag->tx_ring.desc_split)
+		tx_size *= AG71XX_TX_RING_DS_PER_PKT;
+
+	ag->tx_ring.order = ag71xx_ring_size_order(tx_size);
+	ag->rx_ring.order = ag71xx_ring_size_order(rx_size);
+
+	if (netif_running(dev))
+		err = dev->netdev_ops->ndo_open(dev);
+
+	return err;
+}
+
+struct ethtool_ops ag71xx_ethtool_ops = {
+	.set_settings	= ag71xx_ethtool_set_settings,
+	.get_settings	= ag71xx_ethtool_get_settings,
+	.get_drvinfo	= ag71xx_ethtool_get_drvinfo,
+	.get_msglevel	= ag71xx_ethtool_get_msglevel,
+	.set_msglevel	= ag71xx_ethtool_set_msglevel,
+	.get_ringparam	= ag71xx_ethtool_get_ringparam,
+	.set_ringparam	= ag71xx_ethtool_set_ringparam,
+	.get_link	= ethtool_op_get_link,
+	.get_ts_info	= ethtool_op_get_ts_info,
+};
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
new file mode 100644
index 0000000000..54ec8e67b3
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
@@ -0,0 +1,1479 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_DEFAULT_MSG_ENABLE	\
+	(NETIF_MSG_DRV			\
+	| NETIF_MSG_PROBE		\
+	| NETIF_MSG_LINK		\
+	| NETIF_MSG_TIMER		\
+	| NETIF_MSG_IFDOWN		\
+	| NETIF_MSG_IFUP		\
+	| NETIF_MSG_RX_ERR		\
+	| NETIF_MSG_TX_ERR)
+
+static int ag71xx_msg_level = -1;
+
+module_param_named(msg_level, ag71xx_msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
+
+#define ETH_SWITCH_HEADER_LEN	2
+
+static int ag71xx_tx_packets(struct ag71xx *ag, bool flush);
+
+static inline unsigned int ag71xx_max_frame_len(unsigned int mtu)
+{
+	return ETH_SWITCH_HEADER_LEN + ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;
+}
+
+static void ag71xx_dump_dma_regs(struct ag71xx *ag)
+{
+	DBG("%s: dma_tx_ctrl=%08x, dma_tx_desc=%08x, dma_tx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_TX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_TX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_TX_STATUS));
+
+	DBG("%s: dma_rx_ctrl=%08x, dma_rx_desc=%08x, dma_rx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_RX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_RX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_RX_STATUS));
+}
+
+static void ag71xx_dump_regs(struct ag71xx *ag)
+{
+	DBG("%s: mac_cfg1=%08x, mac_cfg2=%08x, ipg=%08x, hdx=%08x, mfl=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IPG),
+		ag71xx_rr(ag, AG71XX_REG_MAC_HDX),
+		ag71xx_rr(ag, AG71XX_REG_MAC_MFL));
+	DBG("%s: mac_ifctl=%08x, mac_addr1=%08x, mac_addr2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR2));
+	DBG("%s: fifo_cfg0=%08x, fifo_cfg1=%08x, fifo_cfg2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+	DBG("%s: fifo_cfg3=%08x, fifo_cfg4=%08x, fifo_cfg5=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+}
+
+static inline void ag71xx_dump_intr(struct ag71xx *ag, char *label, u32 intr)
+{
+	DBG("%s: %s intr=%08x %s%s%s%s%s%s\n",
+		ag->dev->name, label, intr,
+		(intr & AG71XX_INT_TX_PS) ? "TXPS " : "",
+		(intr & AG71XX_INT_TX_UR) ? "TXUR " : "",
+		(intr & AG71XX_INT_TX_BE) ? "TXBE " : "",
+		(intr & AG71XX_INT_RX_PR) ? "RXPR " : "",
+		(intr & AG71XX_INT_RX_OF) ? "RXOF " : "",
+		(intr & AG71XX_INT_RX_BE) ? "RXBE " : "");
+}
+
+static void ag71xx_ring_tx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct net_device *dev = ag->dev;
+	int ring_mask = BIT(ring->order) - 1;
+	u32 bytes_compl = 0, pkts_compl = 0;
+
+	while (ring->curr != ring->dirty) {
+		struct ag71xx_desc *desc;
+		u32 i = ring->dirty & ring_mask;
+
+		desc = ag71xx_ring_desc(ring, i);
+		if (!ag71xx_desc_empty(desc)) {
+			desc->ctrl = 0;
+			dev->stats.tx_errors++;
+		}
+
+		if (ring->buf[i].skb) {
+			bytes_compl += ring->buf[i].len;
+			pkts_compl++;
+			dev_kfree_skb_any(ring->buf[i].skb);
+		}
+		ring->buf[i].skb = NULL;
+		ring->dirty++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	netdev_completed_queue(dev, pkts_compl, bytes_compl);
+}
+
+static void ag71xx_ring_tx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int ring_size = BIT(ring->order);
+	int ring_mask = ring_size - 1;
+	int i;
+
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			AG71XX_DESC_SIZE * ((i + 1) & ring_mask));
+
+		desc->ctrl = DESC_EMPTY;
+		ring->buf[i].skb = NULL;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+	netdev_reset_queue(ag->dev);
+}
+
+static void ag71xx_ring_rx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_size = BIT(ring->order);
+	int i;
+
+	if (!ring->buf)
+		return;
+
+	for (i = 0; i < ring_size; i++)
+		if (ring->buf[i].rx_buf) {
+			dma_unmap_single(&ag->dev->dev, ring->buf[i].dma_addr,
+					 ag->rx_buf_size, DMA_FROM_DEVICE);
+			skb_free_frag(ring->buf[i].rx_buf);
+		}
+}
+
+static int ag71xx_buffer_offset(struct ag71xx *ag)
+{
+	int offset = NET_SKB_PAD;
+
+	/*
+	 * On AR71xx/AR91xx packets must be 4-byte aligned.
+	 *
+	 * When using builtin AR8216 support, hardware adds a 2-byte header,
+	 * so we don't need any extra alignment in that case.
+	 */
+	if (!ag71xx_get_pdata(ag)->is_ar724x || ag71xx_has_ar8216(ag))
+		return offset;
+
+	return offset + NET_IP_ALIGN;
+}
+
+static int ag71xx_buffer_size(struct ag71xx *ag)
+{
+	return ag->rx_buf_size +
+	       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+}
+
+static bool ag71xx_fill_rx_buf(struct ag71xx *ag, struct ag71xx_buf *buf,
+			       int offset,
+			       void *(*alloc)(unsigned int size))
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	struct ag71xx_desc *desc = ag71xx_ring_desc(ring, buf - &ring->buf[0]);
+	void *data;
+
+	data = alloc(ag71xx_buffer_size(ag));
+	if (!data)
+		return false;
+
+	buf->rx_buf = data;
+	buf->dma_addr = dma_map_single(&ag->dev->dev, data, ag->rx_buf_size,
+				       DMA_FROM_DEVICE);
+	desc->data = (u32) buf->dma_addr + offset;
+	return true;
+}
+
+static int ag71xx_ring_rx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_size = BIT(ring->order);
+	int ring_mask = BIT(ring->order) - 1;
+	unsigned int i;
+	int ret;
+	int offset = ag71xx_buffer_offset(ag);
+
+	ret = 0;
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			AG71XX_DESC_SIZE * ((i + 1) & ring_mask));
+
+		DBG("ag71xx: RX desc at %p, next is %08x\n",
+			desc, desc->next);
+	}
+
+	for (i = 0; i < ring_size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_fill_rx_buf(ag, &ring->buf[i], offset,
+					netdev_alloc_frag)) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		desc->ctrl = DESC_EMPTY;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+
+	return ret;
+}
+
+static int ag71xx_ring_rx_refill(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int ring_mask = BIT(ring->order) - 1;
+	unsigned int count;
+	int offset = ag71xx_buffer_offset(ag);
+
+	count = 0;
+	for (; ring->curr - ring->dirty > 0; ring->dirty++) {
+		struct ag71xx_desc *desc;
+		unsigned int i;
+
+		i = ring->dirty & ring_mask;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ring->buf[i].rx_buf &&
+		    !ag71xx_fill_rx_buf(ag, &ring->buf[i], offset,
+					napi_alloc_frag))
+			break;
+
+		desc->ctrl = DESC_EMPTY;
+		count++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	DBG("%s: %u rx descriptors refilled\n", ag->dev->name, count);
+
+	return count;
+}
+
+static int ag71xx_rings_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *tx = &ag->tx_ring;
+	struct ag71xx_ring *rx = &ag->rx_ring;
+	int ring_size = BIT(tx->order) + BIT(rx->order);
+	int tx_size = BIT(tx->order);
+
+	tx->buf = kzalloc(ring_size * sizeof(*tx->buf), GFP_KERNEL);
+	if (!tx->buf)
+		return -ENOMEM;
+
+	tx->descs_cpu = dma_alloc_coherent(NULL, ring_size * AG71XX_DESC_SIZE,
+					   &tx->descs_dma, GFP_ATOMIC);
+	if (!tx->descs_cpu) {
+		kfree(tx->buf);
+		tx->buf = NULL;
+		return -ENOMEM;
+	}
+
+	rx->buf = &tx->buf[BIT(tx->order)];
+	rx->descs_cpu = ((void *)tx->descs_cpu) + tx_size * AG71XX_DESC_SIZE;
+	rx->descs_dma = tx->descs_dma + tx_size * AG71XX_DESC_SIZE;
+
+	ag71xx_ring_tx_init(ag);
+	return ag71xx_ring_rx_init(ag);
+}
+
+static void ag71xx_rings_free(struct ag71xx *ag)
+{
+	struct ag71xx_ring *tx = &ag->tx_ring;
+	struct ag71xx_ring *rx = &ag->rx_ring;
+	int ring_size = BIT(tx->order) + BIT(rx->order);
+
+	if (tx->descs_cpu)
+		dma_free_coherent(NULL, ring_size * AG71XX_DESC_SIZE,
+				  tx->descs_cpu, tx->descs_dma);
+
+	kfree(tx->buf);
+
+	tx->descs_cpu = NULL;
+	rx->descs_cpu = NULL;
+	tx->buf = NULL;
+	rx->buf = NULL;
+}
+
+static void ag71xx_rings_cleanup(struct ag71xx *ag)
+{
+	ag71xx_ring_rx_clean(ag);
+	ag71xx_ring_tx_clean(ag);
+	ag71xx_rings_free(ag);
+
+	netdev_reset_queue(ag->dev);
+}
+
+static unsigned char *ag71xx_speed_str(struct ag71xx *ag)
+{
+	switch (ag->speed) {
+	case SPEED_1000:
+		return "1000";
+	case SPEED_100:
+		return "100";
+	case SPEED_10:
+		return "10";
+	}
+
+	return "?";
+}
+
+static void ag71xx_hw_set_macaddr(struct ag71xx *ag, unsigned char *mac)
+{
+	u32 t;
+
+	t = (((u32) mac[5]) << 24) | (((u32) mac[4]) << 16)
+	  | (((u32) mac[3]) << 8) | ((u32) mac[2]);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);
+
+	t = (((u32) mac[1]) << 24) | (((u32) mac[0]) << 16);
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);
+}
+
+static void ag71xx_dma_reset(struct ag71xx *ag)
+{
+	u32 val;
+	int i;
+
+	ag71xx_dump_dma_regs(ag);
+
+	/* stop RX and TX */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+
+	/*
+	 * give the hardware some time to really stop all rx/tx activity
+	 * clearing the descriptors too early causes random memory corruption
+	 */
+	mdelay(1);
+
+	/* clear descriptor addresses */
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);
+
+	/* clear pending RX/TX interrupts */
+	for (i = 0; i < 256; i++) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+		ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+	}
+
+	/* clear pending errors */
+	ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);
+	ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);
+
+	val = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (val)
+		pr_alert("%s: unable to clear DMA Rx status: %08x\n",
+			 ag->dev->name, val);
+
+	val = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+
+	/* mask out reserved bits */
+	val &= ~0xff000000;
+
+	if (val)
+		pr_alert("%s: unable to clear DMA Tx status: %08x\n",
+			 ag->dev->name, val);
+
+	ag71xx_dump_dma_regs(ag);
+}
+
+#define MAC_CFG1_INIT	(MAC_CFG1_RXE | MAC_CFG1_TXE | \
+			 MAC_CFG1_SRX | MAC_CFG1_STX)
+
+#define FIFO_CFG0_INIT	(FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT)
+
+#define FIFO_CFG4_INIT	(FIFO_CFG4_DE | FIFO_CFG4_DV | FIFO_CFG4_FC | \
+			 FIFO_CFG4_CE | FIFO_CFG4_CR | FIFO_CFG4_LM | \
+			 FIFO_CFG4_LO | FIFO_CFG4_OK | FIFO_CFG4_MC | \
+			 FIFO_CFG4_BC | FIFO_CFG4_DR | FIFO_CFG4_LE | \
+			 FIFO_CFG4_CF | FIFO_CFG4_PF | FIFO_CFG4_UO | \
+			 FIFO_CFG4_VT)
+
+#define FIFO_CFG5_INIT	(FIFO_CFG5_DE | FIFO_CFG5_DV | FIFO_CFG5_FC | \
+			 FIFO_CFG5_CE | FIFO_CFG5_LO | FIFO_CFG5_OK | \
+			 FIFO_CFG5_MC | FIFO_CFG5_BC | FIFO_CFG5_DR | \
+			 FIFO_CFG5_CF | FIFO_CFG5_PF | FIFO_CFG5_VT | \
+			 FIFO_CFG5_LE | FIFO_CFG5_FT | FIFO_CFG5_16 | \
+			 FIFO_CFG5_17 | FIFO_CFG5_SF)
+
+static void ag71xx_hw_stop(struct ag71xx *ag)
+{
+	/* disable all interrupts and stop the rx/tx engine */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+}
+
+static void ag71xx_hw_setup(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 init = MAC_CFG1_INIT;
+
+	/* setup MAC configuration registers */
+	if (pdata->use_flow_control)
+		init |= MAC_CFG1_TFC | MAC_CFG1_RFC;
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, init);
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG2,
+		  MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);
+
+	/* setup max frame length to zero */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, 0);
+
+	/* setup FIFO configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);
+	if (pdata->is_ar724x) {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, 0x0010ffff);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, 0x015500aa);
+	} else {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, 0x0fff0000);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, 0x00001fff);
+	}
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);
+}
+
+static void ag71xx_hw_init(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 reset_mask = pdata->reset_bit;
+
+	ag71xx_hw_stop(ag);
+
+	if (pdata->is_ar724x) {
+		u32 reset_phy = reset_mask;
+
+		reset_phy &= AR71XX_RESET_GE0_PHY | AR71XX_RESET_GE1_PHY;
+		reset_mask &= ~(AR71XX_RESET_GE0_PHY | AR71XX_RESET_GE1_PHY);
+
+		ath79_device_reset_set(reset_phy);
+		msleep(50);
+		ath79_device_reset_clear(reset_phy);
+		msleep(200);
+	}
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);
+	udelay(20);
+
+	ath79_device_reset_set(reset_mask);
+	msleep(100);
+	ath79_device_reset_clear(reset_mask);
+	msleep(200);
+
+	ag71xx_hw_setup(ag);
+
+	ag71xx_dma_reset(ag);
+}
+
+static void ag71xx_fast_reset(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	u32 reset_mask = pdata->reset_bit;
+	u32 rx_ds;
+	u32 mii_reg;
+
+	reset_mask &= AR71XX_RESET_GE0_MAC | AR71XX_RESET_GE1_MAC;
+
+	ag71xx_hw_stop(ag);
+	wmb();
+
+	mii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);
+	rx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);
+
+	ag71xx_tx_packets(ag, true);
+
+	ath79_device_reset_set(reset_mask);
+	udelay(10);
+	ath79_device_reset_clear(reset_mask);
+	udelay(10);
+
+	ag71xx_dma_reset(ag);
+	ag71xx_hw_setup(ag);
+	ag->tx_ring.curr = 0;
+	ag->tx_ring.dirty = 0;
+	netdev_reset_queue(ag->dev);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
+		  ag71xx_max_frame_len(ag->dev->mtu));
+
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+}
+
+static void ag71xx_hw_start(struct ag71xx *ag)
+{
+	/* start RX engine */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+
+	/* enable interrupts */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);
+
+	netif_wake_queue(ag->dev);
+}
+
+static void
+__ag71xx_link_adjust(struct ag71xx *ag, bool update)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 cfg2;
+	u32 ifctl;
+	u32 fifo5;
+	u32 fifo3;
+
+	if (!ag->link && update) {
+		ag71xx_hw_stop(ag);
+		netif_carrier_off(ag->dev);
+		if (netif_msg_link(ag))
+			pr_info("%s: link down\n", ag->dev->name);
+		return;
+	}
+
+	if (pdata->is_ar724x)
+		ag71xx_fast_reset(ag);
+
+	cfg2 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG2);
+	cfg2 &= ~(MAC_CFG2_IF_1000 | MAC_CFG2_IF_10_100 | MAC_CFG2_FDX);
+	cfg2 |= (ag->duplex) ? MAC_CFG2_FDX : 0;
+
+	ifctl = ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL);
+	ifctl &= ~(MAC_IFCTL_SPEED);
+
+	fifo5 = ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5);
+	fifo5 &= ~FIFO_CFG5_BM;
+
+	switch (ag->speed) {
+	case SPEED_1000:
+		cfg2 |= MAC_CFG2_IF_1000;
+		fifo5 |= FIFO_CFG5_BM;
+		break;
+	case SPEED_100:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		ifctl |= MAC_IFCTL_SPEED;
+		break;
+	case SPEED_10:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (pdata->is_ar91xx)
+		fifo3 = 0x00780fff;
+	else if (pdata->is_ar724x)
+		fifo3 = 0x01f00140;
+	else
+		fifo3 = 0x008001ff;
+
+	if (ag->tx_ring.desc_split) {
+		fifo3 &= 0xffff;
+		fifo3 |= ((2048 - ag->tx_ring.desc_split) / 4) << 16;
+	}
+
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, fifo3);
+
+	if (update && pdata->set_speed)
+		pdata->set_speed(ag->speed);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG2, cfg2);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, fifo5);
+	ag71xx_wr(ag, AG71XX_REG_MAC_IFCTL, ifctl);
+
+	if (pdata->disable_inline_checksum_engine) {
+		/*
+		 * The rx ring buffer can stall on small packets on QCA953x and
+		 * QCA956x. Disabling the inline checksum engine fixes the stall.
+		 * The wr, rr functions cannot be used since this hidden register
+		 * is outside of the normal ag71xx register block.
+		 */
+		void __iomem *dam = ioremap_nocache(0xb90001bc, 0x4);
+		if (dam) {
+			__raw_writel(__raw_readl(dam) & ~BIT(27), dam);
+			(void)__raw_readl(dam);
+			iounmap(dam);
+		}
+	}
+
+	ag71xx_hw_start(ag);
+
+	netif_carrier_on(ag->dev);
+	if (update && netif_msg_link(ag))
+		pr_info("%s: link up (%sMbps/%s duplex)\n",
+			ag->dev->name,
+			ag71xx_speed_str(ag),
+			(DUPLEX_FULL == ag->duplex) ? "Full" : "Half");
+
+	DBG("%s: fifo_cfg0=%#x, fifo_cfg1=%#x, fifo_cfg2=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+
+	DBG("%s: fifo_cfg3=%#x, fifo_cfg4=%#x, fifo_cfg5=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+
+	DBG("%s: mac_cfg2=%#x, mac_ifctl=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL));
+}
+
+void ag71xx_link_adjust(struct ag71xx *ag)
+{
+	__ag71xx_link_adjust(ag, true);
+}
+
+static int ag71xx_hw_enable(struct ag71xx *ag)
+{
+	int ret;
+
+	ret = ag71xx_rings_init(ag);
+	if (ret)
+		return ret;
+
+	napi_enable(&ag->napi);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);
+	netif_start_queue(ag->dev);
+
+	return 0;
+}
+
+static void ag71xx_hw_disable(struct ag71xx *ag)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	netif_stop_queue(ag->dev);
+
+	ag71xx_hw_stop(ag);
+	ag71xx_dma_reset(ag);
+
+	napi_disable(&ag->napi);
+	del_timer_sync(&ag->oom_timer);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ag71xx_rings_cleanup(ag);
+}
+
+static int ag71xx_open(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned int max_frame_len;
+	int ret;
+
+	netif_carrier_off(dev);
+	max_frame_len = ag71xx_max_frame_len(dev->mtu);
+	ag->rx_buf_size = SKB_DATA_ALIGN(max_frame_len + NET_SKB_PAD + NET_IP_ALIGN);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, max_frame_len);
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+
+	ret = ag71xx_hw_enable(ag);
+	if (ret)
+		goto err;
+
+	ag71xx_phy_start(ag);
+
+	return 0;
+
+err:
+	ag71xx_rings_cleanup(ag);
+	return ret;
+}
+
+static int ag71xx_stop(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	netif_carrier_off(dev);
+	ag71xx_phy_stop(ag);
+	ag71xx_hw_disable(ag);
+
+	return 0;
+}
+
+static int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)
+{
+	int i;
+	struct ag71xx_desc *desc;
+	int ring_mask = BIT(ring->order) - 1;
+	int ndesc = 0;
+	int split = ring->desc_split;
+
+	if (!split)
+		split = len;
+
+	while (len > 0) {
+		unsigned int cur_len = len;
+
+		i = (ring->curr + ndesc) & ring_mask;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_desc_empty(desc))
+			return -1;
+
+		if (cur_len > split) {
+			cur_len = split;
+
+			/*
+			 * TX will hang if DMA transfers <= 4 bytes,
+			 * make sure next segment is more than 4 bytes long.
+			 */
+			if (len <= split + 4)
+				cur_len -= 4;
+		}
+
+		desc->data = addr;
+		addr += cur_len;
+		len -= cur_len;
+
+		if (len > 0)
+			cur_len |= DESC_MORE;
+
+		/* prevent early tx attempt of this descriptor */
+		if (!ndesc)
+			cur_len |= DESC_EMPTY;
+
+		desc->ctrl = cur_len;
+		ndesc++;
+	}
+
+	return ndesc;
+}
+
+static netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,
+					  struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	struct ag71xx_desc *desc;
+	dma_addr_t dma_addr;
+	int i, n, ring_min;
+
+	if (ag71xx_has_ar8216(ag))
+		ag71xx_add_ar8216_header(ag, skb);
+
+	if (skb->len <= 4) {
+		DBG("%s: packet len is too small\n", ag->dev->name);
+		goto err_drop;
+	}
+
+	dma_addr = dma_map_single(&dev->dev, skb->data, skb->len,
+				  DMA_TO_DEVICE);
+
+	i = ring->curr & ring_mask;
+	desc = ag71xx_ring_desc(ring, i);
+
+	/* setup descriptor fields */
+	n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
+	if (n < 0)
+		goto err_drop_unmap;
+
+	i = (ring->curr + n - 1) & ring_mask;
+	ring->buf[i].len = skb->len;
+	ring->buf[i].skb = skb;
+
+	netdev_sent_queue(dev, skb->len);
+
+	skb_tx_timestamp(skb);
+
+	desc->ctrl &= ~DESC_EMPTY;
+	ring->curr += n;
+
+	/* flush descriptor */
+	wmb();
+
+	ring_min = 2;
+	if (ring->desc_split)
+	    ring_min *= AG71XX_TX_RING_DS_PER_PKT;
+
+	if (ring->curr - ring->dirty >= ring_size - ring_min) {
+		DBG("%s: tx queue full\n", dev->name);
+		netif_stop_queue(dev);
+	}
+
+	DBG("%s: packet injected into TX queue\n", ag->dev->name);
+
+	/* enable TX engine */
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);
+
+	return NETDEV_TX_OK;
+
+err_drop_unmap:
+	dma_unmap_single(&dev->dev, dma_addr, skb->len, DMA_TO_DEVICE);
+
+err_drop:
+	dev->stats.tx_dropped++;
+
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	int ret;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		if (ag->phy_dev == NULL)
+			break;
+
+		spin_lock_irq(&ag->lock);
+		ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
+		spin_unlock_irq(&ag->lock);
+		return ret;
+
+	case SIOCSIFHWADDR:
+		if (copy_from_user
+			(dev->dev_addr, ifr->ifr_data, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGIFHWADDR:
+		if (copy_to_user
+			(ifr->ifr_data, dev->dev_addr, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (ag->phy_dev == NULL)
+			break;
+
+		return phy_mii_ioctl(ag->phy_dev, ifr, cmd);
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static void ag71xx_oom_timer_handler(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ag71xx *ag = netdev_priv(dev);
+
+	napi_schedule(&ag->napi);
+}
+
+static void ag71xx_tx_timeout(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	if (netif_msg_tx_err(ag))
+		pr_info("%s: tx timeout\n", ag->dev->name);
+
+	schedule_delayed_work(&ag->restart_work, 1);
+}
+
+static void ag71xx_restart_work_func(struct work_struct *work)
+{
+	struct ag71xx *ag = container_of(work, struct ag71xx, restart_work.work);
+
+	rtnl_lock();
+	ag71xx_hw_disable(ag);
+	ag71xx_hw_enable(ag);
+	if (ag->link)
+		__ag71xx_link_adjust(ag, false);
+	rtnl_unlock();
+}
+
+static bool ag71xx_check_dma_stuck(struct ag71xx *ag)
+{
+	unsigned long timestamp;
+	u32 rx_sm, tx_sm, rx_fd;
+
+	timestamp = netdev_get_tx_queue(ag->dev, 0)->trans_start;
+	if (likely(time_before(jiffies, timestamp + HZ/10)))
+		return false;
+
+	if (!netif_carrier_ok(ag->dev))
+		return false;
+
+	rx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);
+	if ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)
+		return true;
+
+	tx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);
+	rx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);
+	if (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&
+	    ((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)
+		return true;
+
+	return false;
+}
+
+static int ag71xx_tx_packets(struct ag71xx *ag, bool flush)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	bool dma_stuck = false;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	int sent = 0;
+	int bytes_compl = 0;
+	int n = 0;
+
+	DBG("%s: processing TX ring\n", ag->dev->name);
+
+	while (ring->dirty + n != ring->curr) {
+		unsigned int i = (ring->dirty + n) & ring_mask;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		struct sk_buff *skb = ring->buf[i].skb;
+
+		if (!flush && !ag71xx_desc_empty(desc)) {
+			if (pdata->is_ar724x &&
+			    ag71xx_check_dma_stuck(ag)) {
+				schedule_delayed_work(&ag->restart_work, HZ / 2);
+				dma_stuck = true;
+			}
+			break;
+		}
+
+		if (flush)
+			desc->ctrl |= DESC_EMPTY;
+
+		n++;
+		if (!skb)
+			continue;
+
+		dev_kfree_skb_any(skb);
+		ring->buf[i].skb = NULL;
+
+		bytes_compl += ring->buf[i].len;
+
+		sent++;
+		ring->dirty += n;
+
+		while (n > 0) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+			n--;
+		}
+	}
+
+	DBG("%s: %d packets sent out\n", ag->dev->name, sent);
+
+	if (!sent)
+		return 0;
+
+	ag->dev->stats.tx_bytes += bytes_compl;
+	ag->dev->stats.tx_packets += sent;
+
+	netdev_completed_queue(ag->dev, sent, bytes_compl);
+	if ((ring->curr - ring->dirty) < (ring_size * 3) / 4)
+		netif_wake_queue(ag->dev);
+
+	if (!dma_stuck)
+		cancel_delayed_work(&ag->restart_work);
+
+	return sent;
+}
+
+static int ag71xx_rx_packets(struct ag71xx *ag, int limit)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int offset = ag71xx_buffer_offset(ag);
+	unsigned int pktlen_mask = ag->desc_pktlen_mask;
+	int ring_mask = BIT(ring->order) - 1;
+	int ring_size = BIT(ring->order);
+	struct sk_buff_head queue;
+	struct sk_buff *skb;
+	int done = 0;
+
+	DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
+			dev->name, limit, ring->curr, ring->dirty);
+
+	skb_queue_head_init(&queue);
+
+	while (done < limit) {
+		unsigned int i = ring->curr & ring_mask;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		int pktlen;
+		int err = 0;
+
+		if (ag71xx_desc_empty(desc))
+			break;
+
+		if ((ring->dirty + ring_size) == ring->curr) {
+			ag71xx_assert(0);
+			break;
+		}
+
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+
+		pktlen = desc->ctrl & pktlen_mask;
+		pktlen -= ETH_FCS_LEN;
+
+		dma_unmap_single(&dev->dev, ring->buf[i].dma_addr,
+				 ag->rx_buf_size, DMA_FROM_DEVICE);
+
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += pktlen;
+
+		skb = build_skb(ring->buf[i].rx_buf, ag71xx_buffer_size(ag));
+		if (!skb) {
+			skb_free_frag(ring->buf[i].rx_buf);
+			goto next;
+		}
+
+		skb_reserve(skb, offset);
+		skb_put(skb, pktlen);
+
+		if (ag71xx_has_ar8216(ag))
+			err = ag71xx_remove_ar8216_header(ag, skb, pktlen);
+
+		if (err) {
+			dev->stats.rx_dropped++;
+			kfree_skb(skb);
+		} else {
+			skb->dev = dev;
+			skb->ip_summed = CHECKSUM_NONE;
+			__skb_queue_tail(&queue, skb);
+		}
+
+next:
+		ring->buf[i].rx_buf = NULL;
+		done++;
+
+		ring->curr++;
+	}
+
+	ag71xx_ring_rx_refill(ag);
+
+	while ((skb = __skb_dequeue(&queue)) != NULL) {
+		skb->protocol = eth_type_trans(skb, dev);
+		netif_receive_skb(skb);
+	}
+
+	DBG("%s: rx finish, curr=%u, dirty=%u, done=%d\n",
+		dev->name, ring->curr, ring->dirty, done);
+
+	return done;
+}
+
+static int ag71xx_poll(struct napi_struct *napi, int limit)
+{
+	struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *rx_ring = &ag->rx_ring;
+	int rx_ring_size = BIT(rx_ring->order);
+	unsigned long flags;
+	u32 status;
+	int tx_done;
+	int rx_done;
+
+	pdata->ddr_flush();
+	tx_done = ag71xx_tx_packets(ag, false);
+
+	DBG("%s: processing RX ring\n", dev->name);
+	rx_done = ag71xx_rx_packets(ag, limit);
+
+	ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);
+
+	if (rx_ring->buf[rx_ring->dirty % rx_ring_size].rx_buf == NULL)
+		goto oom;
+
+	status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (unlikely(status & RX_STATUS_OF)) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
+		dev->stats.rx_fifo_errors++;
+
+		/* restart RX */
+		ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+	}
+
+	if (rx_done < limit) {
+		if (status & RX_STATUS_PR)
+			goto more;
+
+		status = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+		if (status & TX_STATUS_PS)
+			goto more;
+
+		DBG("%s: disable polling mode, rx=%d, tx=%d,limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+
+		napi_complete(napi);
+
+		/* enable interrupts */
+		spin_lock_irqsave(&ag->lock, flags);
+		ag71xx_int_enable(ag, AG71XX_INT_POLL);
+		spin_unlock_irqrestore(&ag->lock, flags);
+		return rx_done;
+	}
+
+more:
+	DBG("%s: stay in polling mode, rx=%d, tx=%d, limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+	return limit;
+
+oom:
+	if (netif_msg_rx_err(ag))
+		pr_info("%s: out of memory\n", dev->name);
+
+	mod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);
+	napi_complete(napi);
+	return 0;
+}
+
+static irqreturn_t ag71xx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct ag71xx *ag = netdev_priv(dev);
+	u32 status;
+
+	status = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);
+	ag71xx_dump_intr(ag, "raw", status);
+
+	if (unlikely(!status))
+		return IRQ_NONE;
+
+	if (unlikely(status & AG71XX_INT_ERR)) {
+		if (status & AG71XX_INT_TX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);
+			dev_err(&dev->dev, "TX BUS error\n");
+		}
+		if (status & AG71XX_INT_RX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);
+			dev_err(&dev->dev, "RX BUS error\n");
+		}
+	}
+
+	if (likely(status & AG71XX_INT_POLL)) {
+		ag71xx_int_disable(ag, AG71XX_INT_POLL);
+		DBG("%s: enable polling mode\n", dev->name);
+		napi_schedule(&ag->napi);
+	}
+
+	ag71xx_debugfs_update_int_stats(ag, status);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void ag71xx_netpoll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	ag71xx_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+static int ag71xx_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned int max_frame_len;
+
+	max_frame_len = ag71xx_max_frame_len(new_mtu);
+	if (new_mtu < 68 || max_frame_len > ag->max_frame_len)
+		return -EINVAL;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static const struct net_device_ops ag71xx_netdev_ops = {
+	.ndo_open		= ag71xx_open,
+	.ndo_stop		= ag71xx_stop,
+	.ndo_start_xmit		= ag71xx_hard_start_xmit,
+	.ndo_do_ioctl		= ag71xx_do_ioctl,
+	.ndo_tx_timeout		= ag71xx_tx_timeout,
+	.ndo_change_mtu		= ag71xx_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ag71xx_netpoll,
+#endif
+};
+
+static const char *ag71xx_get_phy_if_mode_name(phy_interface_t mode)
+{
+	switch (mode) {
+	case PHY_INTERFACE_MODE_MII:
+		return "MII";
+	case PHY_INTERFACE_MODE_GMII:
+		return "GMII";
+	case PHY_INTERFACE_MODE_RMII:
+		return "RMII";
+	case PHY_INTERFACE_MODE_RGMII:
+		return "RGMII";
+	case PHY_INTERFACE_MODE_SGMII:
+		return "SGMII";
+	default:
+		break;
+	}
+
+	return "unknown";
+}
+
+
+static int ag71xx_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct resource *res;
+	struct ag71xx *ag;
+	struct ag71xx_platform_data *pdata;
+	int tx_size, err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	if (pdata->mii_bus_dev == NULL && pdata->phy_mask) {
+		dev_err(&pdev->dev, "no MII bus device specified\n");
+		err = -EINVAL;
+		goto err_out;
+	}
+
+	dev = alloc_etherdev(sizeof(*ag));
+	if (!dev) {
+		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	if (!pdata->max_frame_len || !pdata->desc_pktlen_mask)
+		return -EINVAL;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	ag = netdev_priv(dev);
+	ag->pdev = pdev;
+	ag->dev = dev;
+	ag->msg_enable = netif_msg_init(ag71xx_msg_level,
+					AG71XX_DEFAULT_MSG_ENABLE);
+	spin_lock_init(&ag->lock);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac_base");
+	if (!res) {
+		dev_err(&pdev->dev, "no mac_base resource found\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	ag->mac_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!ag->mac_base) {
+		dev_err(&pdev->dev, "unable to ioremap mac_base\n");
+		err = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	err = request_irq(dev->irq, ag71xx_interrupt,
+			  0x0,
+			  dev->name, dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", dev->irq);
+		goto err_unmap_base;
+	}
+
+	dev->base_addr = (unsigned long)ag->mac_base;
+	dev->netdev_ops = &ag71xx_netdev_ops;
+	dev->ethtool_ops = &ag71xx_ethtool_ops;
+
+	INIT_DELAYED_WORK(&ag->restart_work, ag71xx_restart_work_func);
+
+	init_timer(&ag->oom_timer);
+	ag->oom_timer.data = (unsigned long) dev;
+	ag->oom_timer.function = ag71xx_oom_timer_handler;
+
+	tx_size = AG71XX_TX_RING_SIZE_DEFAULT;
+	ag->rx_ring.order = ag71xx_ring_size_order(AG71XX_RX_RING_SIZE_DEFAULT);
+
+	ag->max_frame_len = pdata->max_frame_len;
+	ag->desc_pktlen_mask = pdata->desc_pktlen_mask;
+
+	if (!pdata->is_ar724x && !pdata->is_ar91xx) {
+		ag->tx_ring.desc_split = AG71XX_TX_RING_SPLIT;
+		tx_size *= AG71XX_TX_RING_DS_PER_PKT;
+	}
+	ag->tx_ring.order = ag71xx_ring_size_order(tx_size);
+
+	ag->stop_desc = dma_alloc_coherent(NULL,
+		sizeof(struct ag71xx_desc), &ag->stop_desc_dma, GFP_KERNEL);
+
+	if (!ag->stop_desc)
+		goto err_free_irq;
+
+	ag->stop_desc->data = 0;
+	ag->stop_desc->ctrl = 0;
+	ag->stop_desc->next = (u32) ag->stop_desc_dma;
+
+	memcpy(dev->dev_addr, pdata->mac_addr, ETH_ALEN);
+
+	netif_napi_add(dev, &ag->napi, ag71xx_poll, AG71XX_NAPI_WEIGHT);
+
+	ag71xx_dump_regs(ag);
+
+	ag71xx_hw_init(ag);
+
+	ag71xx_dump_regs(ag);
+
+	err = ag71xx_phy_connect(ag);
+	if (err)
+		goto err_free_desc;
+
+	err = ag71xx_debugfs_init(ag);
+	if (err)
+		goto err_phy_disconnect;
+
+	platform_set_drvdata(pdev, dev);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to register net device\n");
+		goto err_debugfs_exit;
+	}
+
+	pr_info("%s: Atheros AG71xx at 0x%08lx, irq %d, mode:%s\n",
+		dev->name, dev->base_addr, dev->irq,
+		ag71xx_get_phy_if_mode_name(pdata->phy_if_mode));
+
+	return 0;
+
+err_debugfs_exit:
+	ag71xx_debugfs_exit(ag);
+err_phy_disconnect:
+	ag71xx_phy_disconnect(ag);
+err_free_desc:
+	dma_free_coherent(NULL, sizeof(struct ag71xx_desc), ag->stop_desc,
+			  ag->stop_desc_dma);
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_unmap_base:
+	iounmap(ag->mac_base);
+err_free_dev:
+	kfree(dev);
+err_out:
+	platform_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static int ag71xx_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		struct ag71xx *ag = netdev_priv(dev);
+
+		ag71xx_debugfs_exit(ag);
+		ag71xx_phy_disconnect(ag);
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		iounmap(ag->mac_base);
+		kfree(dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_driver = {
+	.probe		= ag71xx_probe,
+	.remove		= ag71xx_remove,
+	.driver = {
+		.name	= AG71XX_DRV_NAME,
+	}
+};
+
+static int __init ag71xx_module_init(void)
+{
+	int ret;
+
+	ret = ag71xx_debugfs_root_init();
+	if (ret)
+		goto err_out;
+
+	ret = ag71xx_mdio_driver_init();
+	if (ret)
+		goto err_debugfs_exit;
+
+	ret = platform_driver_register(&ag71xx_driver);
+	if (ret)
+		goto err_mdio_exit;
+
+	return 0;
+
+err_mdio_exit:
+	ag71xx_mdio_driver_exit();
+err_debugfs_exit:
+	ag71xx_debugfs_root_exit();
+err_out:
+	return ret;
+}
+
+static void __exit ag71xx_module_exit(void)
+{
+	platform_driver_unregister(&ag71xx_driver);
+	ag71xx_mdio_driver_exit();
+	ag71xx_debugfs_root_exit();
+}
+
+module_init(ag71xx_module_init);
+module_exit(ag71xx_module_exit);
+
+MODULE_VERSION(AG71XX_DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" AG71XX_DRV_NAME);
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
new file mode 100644
index 0000000000..cf41aa8a3f
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
@@ -0,0 +1,320 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_MDIO_RETRY	1000
+#define AG71XX_MDIO_DELAY	5
+
+static inline void ag71xx_mdio_wr(struct ag71xx_mdio *am, unsigned reg,
+				  u32 value)
+{
+	void __iomem *r;
+
+	r = am->mdio_base + reg;
+	__raw_writel(value, r);
+
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline u32 ag71xx_mdio_rr(struct ag71xx_mdio *am, unsigned reg)
+{
+	return __raw_readl(am->mdio_base + reg);
+}
+
+static void ag71xx_mdio_dump_regs(struct ag71xx_mdio *am)
+{
+	DBG("%s: mii_cfg=%08x, mii_cmd=%08x, mii_addr=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CFG),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CMD),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_ADDR));
+	DBG("%s: mii_ctrl=%08x, mii_status=%08x, mii_ind=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CTRL),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_IND));
+}
+
+static int ag71xx_mdio_wait_busy(struct ag71xx_mdio *am)
+{
+	int i;
+
+	for (i = 0; i < AG71XX_MDIO_RETRY; i++) {
+		u32 busy;
+
+		udelay(AG71XX_MDIO_DELAY);
+
+		busy = ag71xx_mdio_rr(am, AG71XX_REG_MII_IND);
+		if (!busy)
+			return 0;
+
+		udelay(AG71XX_MDIO_DELAY);
+	}
+
+	pr_err("%s: MDIO operation timed out\n", am->mii_bus->name);
+
+	return -ETIMEDOUT;
+}
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg)
+{
+	int err;
+	int ret;
+
+	err = ag71xx_mdio_wait_busy(am);
+	if (err)
+		return 0xffff;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_READ);
+
+	err = ag71xx_mdio_wait_busy(am);
+	if (err)
+		return 0xffff;
+
+	ret = ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS) & 0xffff;
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+
+	DBG("mii_read: addr=%04x, reg=%04x, value=%04x\n", addr, reg, ret);
+
+	return ret;
+}
+
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val)
+{
+	DBG("mii_write: addr=%04x, reg=%04x, value=%04x\n", addr, reg, val);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CTRL, val);
+
+	ag71xx_mdio_wait_busy(am);
+}
+
+static const u32 ar71xx_mdio_div_table[] = {
+	4, 4, 6, 8, 10, 14, 20, 28,
+};
+
+static const u32 ar7240_mdio_div_table[] = {
+	2, 2, 4, 6, 8, 12, 18, 26, 32, 40, 48, 56, 62, 70, 78, 96,
+};
+
+static const u32 ar933x_mdio_div_table[] = {
+	4, 4, 6, 8, 10, 14, 20, 28, 34, 42, 50, 58, 66, 74, 82, 98,
+};
+
+static int ag71xx_mdio_get_divider(struct ag71xx_mdio *am, u32 *div)
+{
+	unsigned long ref_clock, mdio_clock;
+	const u32 *table;
+	int ndivs;
+	int i;
+
+	ref_clock = am->pdata->ref_clock;
+	mdio_clock = am->pdata->mdio_clock;
+
+	if (!ref_clock || !mdio_clock)
+		return -EINVAL;
+
+	if (am->pdata->is_ar9330 || am->pdata->is_ar934x) {
+		table = ar933x_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar933x_mdio_div_table);
+	} else if (am->pdata->is_ar7240) {
+		table = ar7240_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar7240_mdio_div_table);
+	} else {
+		table = ar71xx_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar71xx_mdio_div_table);
+	}
+
+	for (i = 0; i < ndivs; i++) {
+		unsigned long t;
+
+		t = ref_clock / table[i];
+		if (t <= mdio_clock) {
+			*div = i;
+			return 0;
+		}
+	}
+
+	dev_err(&am->mii_bus->dev, "no divider found for %lu/%lu\n",
+		ref_clock, mdio_clock);
+	return -ENOENT;
+}
+
+static int ag71xx_mdio_reset(struct mii_bus *bus)
+{
+	struct ag71xx_mdio *am = bus->priv;
+	u32 t;
+	int err;
+
+	err = ag71xx_mdio_get_divider(am, &t);
+	if (err) {
+		/* fallback */
+		if (am->pdata->is_ar7240)
+			t = MII_CFG_CLK_DIV_6;
+		else if (am->pdata->builtin_switch && !am->pdata->is_ar934x)
+			t = MII_CFG_CLK_DIV_10;
+		else if (!am->pdata->builtin_switch && am->pdata->is_ar934x)
+			t = MII_CFG_CLK_DIV_58;
+		else
+			t = MII_CFG_CLK_DIV_28;
+	}
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);
+	udelay(100);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t);
+	udelay(100);
+
+	if (am->pdata->reset)
+		am->pdata->reset(bus);
+
+	return 0;
+}
+
+static int ag71xx_mdio_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->builtin_switch)
+		return ar7240sw_phy_read(bus, addr, reg);
+	else
+		return ag71xx_mdio_mii_read(am, addr, reg);
+}
+
+static int ag71xx_mdio_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->builtin_switch)
+		ar7240sw_phy_write(bus, addr, reg, val);
+	else
+		ag71xx_mdio_mii_write(am, addr, reg, val);
+	return 0;
+}
+
+static int ag71xx_mdio_probe(struct platform_device *pdev)
+{
+	struct ag71xx_mdio_platform_data *pdata;
+	struct ag71xx_mdio *am;
+	struct resource *res;
+	int i;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	am = kzalloc(sizeof(*am), GFP_KERNEL);
+	if (!am) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	am->pdata = pdata;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no iomem resource found\n");
+		err = -ENXIO;
+		goto err_free_mdio;
+	}
+
+	am->mdio_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!am->mdio_base) {
+		dev_err(&pdev->dev, "unable to ioremap registers\n");
+		err = -ENOMEM;
+		goto err_free_mdio;
+	}
+
+	am->mii_bus = mdiobus_alloc();
+	if (am->mii_bus == NULL) {
+		err = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	am->mii_bus->name = "ag71xx_mdio";
+	am->mii_bus->read = ag71xx_mdio_read;
+	am->mii_bus->write = ag71xx_mdio_write;
+	am->mii_bus->reset = ag71xx_mdio_reset;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	am->mii_bus->irq = am->mii_irq;
+#endif
+	am->mii_bus->priv = am;
+	am->mii_bus->parent = &pdev->dev;
+	snprintf(am->mii_bus->id, MII_BUS_ID_SIZE, "%s", dev_name(&pdev->dev));
+	am->mii_bus->phy_mask = pdata->phy_mask;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		am->mii_bus->irq[i] = PHY_POLL;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MAC_CFG1, 0);
+
+	err = mdiobus_register(am->mii_bus);
+	if (err)
+		goto err_free_bus;
+
+	ag71xx_mdio_dump_regs(am);
+
+	platform_set_drvdata(pdev, am);
+	return 0;
+
+err_free_bus:
+	mdiobus_free(am->mii_bus);
+err_iounmap:
+	iounmap(am->mdio_base);
+err_free_mdio:
+	kfree(am);
+err_out:
+	return err;
+}
+
+static int ag71xx_mdio_remove(struct platform_device *pdev)
+{
+	struct ag71xx_mdio *am = platform_get_drvdata(pdev);
+
+	if (am) {
+		mdiobus_unregister(am->mii_bus);
+		mdiobus_free(am->mii_bus);
+		iounmap(am->mdio_base);
+		kfree(am);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_mdio_driver = {
+	.probe		= ag71xx_mdio_probe,
+	.remove		= ag71xx_mdio_remove,
+	.driver = {
+		.name	= "ag71xx-mdio",
+	}
+};
+
+int __init ag71xx_mdio_driver_init(void)
+{
+	return platform_driver_register(&ag71xx_mdio_driver);
+}
+
+void ag71xx_mdio_driver_exit(void)
+{
+	platform_driver_unregister(&ag71xx_mdio_driver);
+}
diff --git a/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
new file mode 100644
index 0000000000..12fa2e301b
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
@@ -0,0 +1,261 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static void ag71xx_phy_link_adjust(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+	unsigned long flags;
+	int status_change = 0;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	if (phydev->link) {
+		if (ag->duplex != phydev->duplex
+		    || ag->speed != phydev->speed) {
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != ag->link)
+		status_change = 1;
+
+	ag->link = phydev->link;
+	ag->duplex = phydev->duplex;
+	ag->speed = phydev->speed;
+
+	if (status_change)
+		ag71xx_link_adjust(ag);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+void ag71xx_phy_start(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (ag->phy_dev) {
+		phy_start(ag->phy_dev);
+	} else if (pdata->mii_bus_dev && pdata->switch_data) {
+		ag71xx_ar7240_start(ag);
+	} else {
+		ag->link = 1;
+		ag71xx_link_adjust(ag);
+	}
+}
+
+void ag71xx_phy_stop(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	unsigned long flags;
+
+	if (ag->phy_dev)
+		phy_stop(ag->phy_dev);
+	else if (pdata->mii_bus_dev && pdata->switch_data)
+		ag71xx_ar7240_stop(ag);
+
+	spin_lock_irqsave(&ag->lock, flags);
+	if (ag->link) {
+		ag->link = 0;
+		ag71xx_link_adjust(ag);
+	}
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+static int ag71xx_phy_connect_fixed(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	int ret = 0;
+
+	/* use fixed settings */
+	switch (pdata->speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		break;
+	default:
+		dev_err(dev, "invalid speed specified\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	dev_dbg(dev, "using fixed link parameters\n");
+
+	ag->duplex = pdata->duplex;
+	ag->speed = pdata->speed;
+
+	return ret;
+}
+
+static int ag71xx_phy_connect_multi(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+	int ret = 0;
+
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (!(pdata->phy_mask & (1 << phy_addr)))
+			continue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+		if (ag->mii_bus->phy_map[phy_addr] == NULL)
+			continue;
+
+		DBG("%s: PHY found at %s, uid=%08x\n",
+			dev_name(dev),
+			dev_name(&ag->mii_bus->phy_map[phy_addr]->dev),
+			ag->mii_bus->phy_map[phy_addr]->phy_id);
+
+		if (phydev == NULL)
+			phydev = ag->mii_bus->phy_map[phy_addr];
+#else
+		if (ag->mii_bus->mdio_map[phy_addr] == NULL)
+			continue;
+
+		DBG("%s: PHY found at %s, uid=%08x\n",
+			dev_name(dev),
+			dev_name(&ag->mii_bus->mdio_map[phy_addr]->dev),
+			ag->mii_bus->mdio_map[phy_addr]->phy_id);
+
+		if (phydev == NULL)
+			phydev = mdiobus_get_phy(ag->mii_bus, phy_addr);
+#endif
+	}
+
+	if (!phydev) {
+		dev_err(dev, "no PHY found with phy_mask=%08x\n",
+			   pdata->phy_mask);
+		return -ENODEV;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	ag->phy_dev = phy_connect(ag->dev, dev_name(&phydev->dev),
+#else
+	ag->phy_dev = phy_connect(ag->dev, phydev_name(phydev),
+#endif
+				  &ag71xx_phy_link_adjust,
+				  pdata->phy_if_mode);
+
+	if (IS_ERR(ag->phy_dev)) {
+		dev_err(dev, "could not connect to PHY at %s\n",
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+			   dev_name(&phydev->dev));
+#else
+			   phydev_name(phydev));
+#endif
+		return PTR_ERR(ag->phy_dev);
+	}
+
+	/* mask with MAC supported features */
+	if (pdata->has_gbit)
+		phydev->supported &= PHY_GBIT_FEATURES;
+	else
+		phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->advertising = phydev->supported;
+
+	dev_info(dev, "connected to PHY at %s [uid=%08x, driver=%s]\n",
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+		    dev_name(&phydev->dev),
+#else
+		    phydev_name(phydev),
+#endif
+		    phydev->phy_id, phydev->drv->name);
+
+	ag->link = 0;
+	ag->speed = 0;
+	ag->duplex = -1;
+
+	return ret;
+}
+
+static int dev_is_class(struct device *dev, void *class)
+{
+	if (dev->class != NULL && !strcmp(dev->class->name, class))
+		return 1;
+
+	return 0;
+}
+
+static struct device *dev_find_class(struct device *parent, char *class)
+{
+	if (dev_is_class(parent, class)) {
+		get_device(parent);
+		return parent;
+	}
+
+	return device_find_child(parent, class, dev_is_class);
+}
+
+static struct mii_bus *dev_to_mii_bus(struct device *dev)
+{
+	struct device *d;
+
+	d = dev_find_class(dev, "mdio_bus");
+	if (d != NULL) {
+		struct mii_bus *bus;
+
+		bus = to_mii_bus(d);
+		put_device(d);
+
+		return bus;
+	}
+
+	return NULL;
+}
+
+int ag71xx_phy_connect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->mii_bus_dev == NULL ||
+	    pdata->mii_bus_dev->bus == NULL )
+		return ag71xx_phy_connect_fixed(ag);
+
+	ag->mii_bus = dev_to_mii_bus(pdata->mii_bus_dev);
+	if (ag->mii_bus == NULL) {
+		dev_err(&ag->pdev->dev, "unable to find MII bus on device '%s'\n",
+			   dev_name(pdata->mii_bus_dev));
+		return -ENODEV;
+	}
+
+	/* Reset the mdio bus explicitly */
+	if (ag->mii_bus->reset) {
+		mutex_lock(&ag->mii_bus->mdio_lock);
+		ag->mii_bus->reset(ag->mii_bus);
+		mutex_unlock(&ag->mii_bus->mdio_lock);
+	}
+
+	if (pdata->switch_data)
+		return ag71xx_ar7240_init(ag);
+
+	if (pdata->phy_mask)
+		return ag71xx_phy_connect_multi(ag);
+
+	return ag71xx_phy_connect_fixed(ag);
+}
+
+void ag71xx_phy_disconnect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->switch_data)
+		ag71xx_ar7240_cleanup(ag);
+	else if (ag->phy_dev)
+		phy_disconnect(ag->phy_dev);
+}
diff --git a/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx-cpld.c b/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx-cpld.c
new file mode 100644
index 0000000000..18af83b67c
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx-cpld.c
@@ -0,0 +1,347 @@
+/*
+ * SPI driver for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#define DRV_NAME	"spi-rb4xx-cpld"
+#define DRV_DESC	"RB4xx CPLD driver"
+#define DRV_VERSION	"0.1.0"
+
+#define CPLD_CMD_WRITE_NAND	0x08 /* send cmd, n x send data, send indle */
+#define CPLD_CMD_WRITE_CFG	0x09 /* send cmd, n x send cfg */
+#define CPLD_CMD_READ_NAND	0x0a /* send cmd, send idle, n x read data */
+#define CPLD_CMD_READ_FAST	0x0b /* send cmd, 4 x idle, n x read data */
+#define CPLD_CMD_LED5_ON	0x0c /* send cmd */
+#define CPLD_CMD_LED5_OFF	0x0d /* send cmd */
+
+struct rb4xx_cpld {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct gpio_chip	chip;
+	unsigned int		config;
+};
+
+static struct rb4xx_cpld *rb4xx_cpld;
+
+static inline struct rb4xx_cpld *gpio_to_cpld(struct gpio_chip *chip)
+{
+	return container_of(chip, struct rb4xx_cpld, chip);
+}
+
+static int rb4xx_cpld_write_cmd(struct rb4xx_cpld *cpld, unsigned char cmd)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char tx_buf[1];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = tx_buf;
+	t[0].len = sizeof(tx_buf);
+	spi_message_add_tail(&t[0], &m);
+
+	tx_buf[0] = cmd;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int rb4xx_cpld_write_cfg(struct rb4xx_cpld *cpld, unsigned char config)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char cmd[2];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_CFG;
+	cmd[1] = config;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int __rb4xx_cpld_change_cfg(struct rb4xx_cpld *cpld, unsigned mask,
+				   unsigned value)
+{
+	unsigned int config;
+	int err;
+
+	config = cpld->config & ~mask;
+	config |= value;
+
+	if ((cpld->config ^ config) & 0xff) {
+		err = rb4xx_cpld_write_cfg(cpld, config);
+		if (err)
+			return err;
+	}
+
+	if ((cpld->config ^ config) & CPLD_CFG_nLED5) {
+		err = rb4xx_cpld_write_cmd(cpld, (value) ? CPLD_CMD_LED5_ON :
+							   CPLD_CMD_LED5_OFF);
+		if (err)
+			return err;
+	}
+
+	cpld->config = config;
+	return 0;
+}
+
+int rb4xx_cpld_change_cfg(unsigned mask, unsigned value)
+{
+	int ret;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	mutex_lock(&rb4xx_cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(rb4xx_cpld, mask, value);
+	mutex_unlock(&rb4xx_cpld->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_change_cfg);
+
+int rb4xx_cpld_read(unsigned char *rx_buf, unsigned count)
+{
+	static const unsigned char cmd[2] = { CPLD_CMD_READ_NAND, 0 };
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 2,
+		}, {
+			.rx_buf = rx_buf,
+			.len = count,
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read);
+
+int rb4xx_cpld_write(const unsigned char *buf, unsigned count)
+{
+	static const unsigned char cmd = CPLD_CMD_WRITE_NAND;
+	struct spi_transfer t[3] = {
+		{
+			.tx_buf = &cmd,
+			.len = 1,
+		}, {
+			.tx_buf = buf,
+			.len = count,
+			.tx_nbits = SPI_NBITS_DUAL,
+		}, {
+			.len = 1,
+			.tx_nbits = SPI_NBITS_DUAL,
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	spi_message_add_tail(&t[2], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_write);
+
+static int rb4xx_cpld_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = (cpld->config >> offset) & 1;
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static void rb4xx_cpld_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+
+	mutex_lock(&cpld->lock);
+	__rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+}
+
+static int rb4xx_cpld_gpio_direction_input(struct gpio_chip *chip,
+					   unsigned offset)
+{
+	return -EOPNOTSUPP;
+}
+
+static int rb4xx_cpld_gpio_direction_output(struct gpio_chip *chip,
+					    unsigned offset,
+					    int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static int rb4xx_cpld_gpio_init(struct rb4xx_cpld *cpld, unsigned int base)
+{
+	int err;
+
+	/* init config */
+	cpld->config = CPLD_CFG_nLED1 | CPLD_CFG_nLED2 | CPLD_CFG_nLED3 |
+		       CPLD_CFG_nLED4 | CPLD_CFG_nCE;
+	rb4xx_cpld_write_cfg(cpld, cpld->config);
+
+	/* setup GPIO chip */
+	cpld->chip.label = DRV_NAME;
+
+	cpld->chip.get = rb4xx_cpld_gpio_get;
+	cpld->chip.set = rb4xx_cpld_gpio_set;
+	cpld->chip.direction_input = rb4xx_cpld_gpio_direction_input;
+	cpld->chip.direction_output = rb4xx_cpld_gpio_direction_output;
+
+	cpld->chip.base = base;
+	cpld->chip.ngpio = CPLD_NUM_GPIOS;
+	cpld->chip.can_sleep = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	cpld->chip.dev = &cpld->spi->dev;
+#else
+	cpld->chip.parent = &cpld->spi->dev;
+#endif
+	cpld->chip.owner = THIS_MODULE;
+
+	err = gpiochip_add(&cpld->chip);
+	if (err)
+		dev_err(&cpld->spi->dev, "adding GPIO chip failed, err=%d\n",
+			err);
+
+	return err;
+}
+
+static int rb4xx_cpld_probe(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+	struct rb4xx_cpld_platform_data *pdata;
+	int err;
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	cpld = kzalloc(sizeof(*cpld), GFP_KERNEL);
+	if (!cpld) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&cpld->lock);
+	cpld->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, cpld);
+
+	spi->mode = SPI_MODE_0 | SPI_TX_DUAL;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = rb4xx_cpld_gpio_init(cpld, pdata->gpio_base);
+	if (err)
+		goto err_drvdata;
+
+	rb4xx_cpld = cpld;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return err;
+}
+
+static int rb4xx_cpld_remove(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+
+	rb4xx_cpld = NULL;
+	cpld = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return 0;
+}
+
+static struct spi_driver rb4xx_cpld_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= rb4xx_cpld_probe,
+	.remove		= rb4xx_cpld_remove,
+};
+
+static int __init rb4xx_cpld_init(void)
+{
+	return spi_register_driver(&rb4xx_cpld_driver);
+}
+module_init(rb4xx_cpld_init);
+
+static void __exit rb4xx_cpld_exit(void)
+{
+	spi_unregister_driver(&rb4xx_cpld_driver);
+}
+module_exit(rb4xx_cpld_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx.c b/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx.c
new file mode 100644
index 0000000000..2d95e80495
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/spi/spi-rb4xx.c
@@ -0,0 +1,430 @@
+/*
+ * SPI controller driver for the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRV_NAME	"rb4xx-spi"
+#define DRV_DESC	"Mikrotik RB4xx SPI controller driver"
+#define DRV_VERSION	"0.1.0"
+
+#define SPI_CTRL_FASTEST	0x40
+#define SPI_FLASH_HZ		33333334
+#define SPI_CPLD_HZ		33333334
+
+#define CPLD_CMD_READ_FAST	0x0b
+
+#undef RB4XX_SPI_DEBUG
+
+struct rb4xx_spi {
+	void __iomem		*base;
+	struct spi_master	*master;
+
+	unsigned		spi_ctrl_flash;
+	unsigned		spi_ctrl_fread;
+
+	struct clk		*ahb_clk;
+	unsigned long		ahb_freq;
+
+	spinlock_t		lock;
+	struct list_head	queue;
+	int			busy:1;
+	int			cs_wait;
+};
+
+static unsigned spi_clk_low = AR71XX_SPI_IOC_CS1;
+
+#ifdef RB4XX_SPI_DEBUG
+static inline void do_spi_delay(void)
+{
+	ndelay(20000);
+}
+#else
+static inline void do_spi_delay(void) { }
+#endif
+
+static inline void do_spi_init(struct spi_device *spi)
+{
+	unsigned cs = AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1;
+
+	if (!(spi->mode & SPI_CS_HIGH))
+		cs ^= (spi->chip_select == 2) ? AR71XX_SPI_IOC_CS1 :
+						AR71XX_SPI_IOC_CS0;
+
+	spi_clk_low = cs;
+}
+
+static inline void do_spi_finish(void __iomem *base)
+{
+	do_spi_delay();
+	__raw_writel(AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1,
+		     base + AR71XX_SPI_REG_IOC);
+}
+
+static inline void do_spi_clk(void __iomem *base, int bit)
+{
+	unsigned bval = spi_clk_low | ((bit & 1) ? AR71XX_SPI_IOC_DO : 0);
+
+	do_spi_delay();
+	__raw_writel(bval, base + AR71XX_SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | AR71XX_SPI_IOC_CLK, base + AR71XX_SPI_REG_IOC);
+}
+
+static void do_spi_byte(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk(base, byte >> 7);
+	do_spi_clk(base, byte >> 6);
+	do_spi_clk(base, byte >> 5);
+	do_spi_clk(base, byte >> 4);
+	do_spi_clk(base, byte >> 3);
+	do_spi_clk(base, byte >> 2);
+	do_spi_clk(base, byte >> 1);
+	do_spi_clk(base, byte);
+
+	pr_debug("spi_byte sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char)__raw_readl(base + AR71XX_SPI_REG_RDS));
+}
+
+static inline void do_spi_clk_fast(void __iomem *base, unsigned bit1,
+				   unsigned bit2)
+{
+	unsigned bval = (spi_clk_low |
+			 ((bit1 & 1) ? AR71XX_SPI_IOC_DO : 0) |
+			 ((bit2 & 1) ? AR71XX_SPI_IOC_CS2 : 0));
+	do_spi_delay();
+	__raw_writel(bval, base + AR71XX_SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | AR71XX_SPI_IOC_CLK, base + AR71XX_SPI_REG_IOC);
+}
+
+static void do_spi_byte_fast(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk_fast(base, byte >> 7, byte >> 6);
+	do_spi_clk_fast(base, byte >> 5, byte >> 4);
+	do_spi_clk_fast(base, byte >> 3, byte >> 2);
+	do_spi_clk_fast(base, byte >> 1, byte >> 0);
+
+	pr_debug("spi_byte_fast sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char) __raw_readl(base + AR71XX_SPI_REG_RDS));
+}
+
+static int rb4xx_spi_txrx(void __iomem *base, struct spi_transfer *t)
+{
+	const unsigned char *tx_ptr = t->tx_buf;
+	unsigned char *rx_ptr = t->rx_buf;
+	unsigned i;
+
+	pr_debug("spi_txrx len %u tx %u rx %u\n",
+	       t->len,
+	       (t->tx_buf ? 1 : 0),
+	       (t->rx_buf ? 1 : 0));
+
+	for (i = 0; i < t->len; ++i) {
+		unsigned char sdata = tx_ptr ? tx_ptr[i] : 0;
+
+		if (t->tx_nbits == SPI_NBITS_DUAL)
+			do_spi_byte_fast(base, sdata);
+		else
+			do_spi_byte(base, sdata);
+
+		if (rx_ptr)
+			rx_ptr[i] = __raw_readl(base + AR71XX_SPI_REG_RDS) & 0xff;
+	}
+
+	return i;
+}
+
+static int rb4xx_spi_msg(struct rb4xx_spi *rbspi, struct spi_message *m)
+{
+	struct spi_transfer *t = NULL;
+	void __iomem *base = rbspi->base;
+
+	m->status = 0;
+	if (list_empty(&m->transfers))
+		return -1;
+
+	__raw_writel(AR71XX_SPI_FS_GPIO, base + AR71XX_SPI_REG_FS);
+	__raw_writel(SPI_CTRL_FASTEST, base + AR71XX_SPI_REG_CTRL);
+	do_spi_init(m->spi);
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		int len;
+
+		len = rb4xx_spi_txrx(base, t);
+		if (len != t->len) {
+			m->status = -EMSGSIZE;
+			break;
+		}
+		m->actual_length += len;
+
+		if (t->cs_change) {
+			if (list_is_last(&t->transfer_list, &m->transfers)) {
+				/* wait for continuation */
+				return m->spi->chip_select;
+			}
+			do_spi_finish(base);
+			ndelay(100);
+		}
+	}
+
+	do_spi_finish(base);
+	__raw_writel(rbspi->spi_ctrl_flash, base + AR71XX_SPI_REG_CTRL);
+	__raw_writel(0, base + AR71XX_SPI_REG_FS);
+	return -1;
+}
+
+static void rb4xx_spi_process_queue_locked(struct rb4xx_spi *rbspi,
+					   unsigned long *flags)
+{
+	int cs = rbspi->cs_wait;
+
+	rbspi->busy = 1;
+	while (!list_empty(&rbspi->queue)) {
+		struct spi_message *m;
+
+		list_for_each_entry(m, &rbspi->queue, queue)
+			if (cs < 0 || cs == m->spi->chip_select)
+				break;
+
+		if (&m->queue == &rbspi->queue)
+			break;
+
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&rbspi->lock, *flags);
+
+		cs = rb4xx_spi_msg(rbspi, m);
+		m->complete(m->context);
+
+		spin_lock_irqsave(&rbspi->lock, *flags);
+	}
+
+	rbspi->cs_wait = cs;
+	rbspi->busy = 0;
+
+	if (cs >= 0) {
+		/* TODO: add timer to unlock cs after 1s inactivity */
+	}
+}
+
+static int rb4xx_spi_transfer(struct spi_device *spi,
+			      struct spi_message *m)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	list_add_tail(&m->queue, &rbspi->queue);
+	if (rbspi->busy ||
+	    (rbspi->cs_wait >= 0 && rbspi->cs_wait != m->spi->chip_select)) {
+		/* job will be done later */
+		spin_unlock_irqrestore(&rbspi->lock, flags);
+		return 0;
+	}
+
+	/* process job in current context */
+	rb4xx_spi_process_queue_locked(rbspi, &flags);
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static int rb4xx_spi_setup(struct spi_device *spi)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	if (spi->mode & ~(SPI_CS_HIGH | SPI_TX_DUAL)) {
+		dev_err(&spi->dev, "mode %x not supported\n",
+			(unsigned) spi->mode);
+		return -EINVAL;
+	}
+
+	if (spi->bits_per_word != 8 && spi->bits_per_word != 0) {
+		dev_err(&spi->dev, "bits_per_word %u not supported\n",
+			(unsigned) spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	if (rbspi->cs_wait == spi->chip_select && !rbspi->busy) {
+		rbspi->cs_wait = -1;
+		rb4xx_spi_process_queue_locked(rbspi, &flags);
+	}
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static unsigned get_spi_ctrl(struct rb4xx_spi *rbspi, unsigned hz_max,
+			     const char *name)
+{
+	unsigned div;
+
+	div = (rbspi->ahb_freq - 1) / (2 * hz_max);
+
+	/*
+	 * CPU has a bug at (div == 0) - first bit read is random
+	 */
+	if (div == 0)
+		++div;
+
+	if (name) {
+		unsigned ahb_khz = (rbspi->ahb_freq + 500) / 1000;
+		unsigned div_real = 2 * (div + 1);
+		pr_debug("rb4xx: %s SPI clock %u kHz (AHB %u kHz / %u)\n",
+		       name,
+		       ahb_khz / div_real,
+		       ahb_khz, div_real);
+	}
+
+	return SPI_CTRL_FASTEST + div;
+}
+
+static int rb4xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct rb4xx_spi *rbspi;
+	struct resource *r;
+	int err = 0;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*rbspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "no memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = 3;
+	master->mode_bits = SPI_TX_DUAL;
+	master->setup = rb4xx_spi_setup;
+	master->transfer = rb4xx_spi_transfer;
+
+	rbspi = spi_master_get_devdata(master);
+
+	rbspi->ahb_clk = clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(rbspi->ahb_clk)) {
+		err = PTR_ERR(rbspi->ahb_clk);
+		goto err_put_master;
+	}
+
+	err = clk_prepare_enable(rbspi->ahb_clk);
+	if (err)
+		goto err_clk_put;
+
+	rbspi->ahb_freq = clk_get_rate(rbspi->ahb_clk);
+	if (!rbspi->ahb_freq) {
+		err = -EINVAL;
+		goto err_clk_disable;
+	}
+
+	platform_set_drvdata(pdev, rbspi);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		err = -ENOENT;
+		goto err_clk_disable;
+	}
+
+	rbspi->base = ioremap(r->start, r->end - r->start + 1);
+	if (!rbspi->base) {
+		err = -ENXIO;
+		goto err_clk_disable;
+	}
+
+	rbspi->master = master;
+	rbspi->spi_ctrl_flash = get_spi_ctrl(rbspi, SPI_FLASH_HZ, "FLASH");
+	rbspi->spi_ctrl_fread = get_spi_ctrl(rbspi, SPI_CPLD_HZ, "CPLD");
+	rbspi->cs_wait = -1;
+
+	spin_lock_init(&rbspi->lock);
+	INIT_LIST_HEAD(&rbspi->queue);
+
+	err = spi_register_master(master);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto err_iounmap;
+	}
+
+	return 0;
+
+err_iounmap:
+	iounmap(rbspi->base);
+err_clk_disable:
+	clk_disable_unprepare(rbspi->ahb_clk);
+err_clk_put:
+	clk_put(rbspi->ahb_clk);
+err_put_master:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(master);
+err_out:
+	return err;
+}
+
+static int rb4xx_spi_remove(struct platform_device *pdev)
+{
+	struct rb4xx_spi *rbspi = platform_get_drvdata(pdev);
+
+	iounmap(rbspi->base);
+	clk_disable_unprepare(rbspi->ahb_clk);
+	clk_put(rbspi->ahb_clk);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(rbspi->master);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_spi_drv = {
+	.probe		= rb4xx_spi_probe,
+	.remove		= rb4xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_spi_init(void)
+{
+	return platform_driver_register(&rb4xx_spi_drv);
+}
+subsys_initcall(rb4xx_spi_init);
+
+static void __exit rb4xx_spi_exit(void)
+{
+	platform_driver_unregister(&rb4xx_spi_drv);
+}
+
+module_exit(rb4xx_spi_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/files-4.9/drivers/spi/spi-vsc7385.c b/target/linux/ar71xx/files-4.9/drivers/spi/spi-vsc7385.c
new file mode 100644
index 0000000000..b712e71875
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/drivers/spi/spi-vsc7385.c
@@ -0,0 +1,621 @@
+/*
+ * SPI driver for the Vitesse VSC7385 ethernet switch
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/firmware.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/vsc7385.h>
+
+#define DRV_NAME	"spi-vsc7385"
+#define DRV_DESC	"Vitesse VSC7385 Gbit ethernet switch driver"
+#define DRV_VERSION	"0.1.0"
+
+#define VSC73XX_BLOCK_MAC	0x1
+#define VSC73XX_BLOCK_2		0x2
+#define VSC73XX_BLOCK_MII	0x3
+#define VSC73XX_BLOCK_4		0x4
+#define VSC73XX_BLOCK_5		0x5
+#define VSC73XX_BLOCK_SYSTEM	0x7
+
+#define VSC73XX_SUBBLOCK_PORT_0		0
+#define VSC73XX_SUBBLOCK_PORT_1		1
+#define VSC73XX_SUBBLOCK_PORT_2		2
+#define VSC73XX_SUBBLOCK_PORT_3		3
+#define VSC73XX_SUBBLOCK_PORT_4		4
+#define VSC73XX_SUBBLOCK_PORT_MAC	6
+
+/* MAC Block registers */
+#define VSC73XX_MAC_CFG		0x0
+#define VSC73XX_ADVPORTM	0x19
+#define VSC73XX_RXOCT		0x50
+#define VSC73XX_TXOCT		0x51
+#define VSC73XX_C_RX0		0x52
+#define VSC73XX_C_RX1		0x53
+#define VSC73XX_C_RX2		0x54
+#define VSC73XX_C_TX0		0x55
+#define VSC73XX_C_TX1		0x56
+#define VSC73XX_C_TX2		0x57
+#define VSC73XX_C_CFG		0x58
+
+/* MAC_CFG register bits */
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1 << 31)
+#define VSC73XX_MAC_CFG_PORT_RST	(1 << 29)
+#define VSC73XX_MAC_CFG_TX_EN		(1 << 28)
+#define VSC73XX_MAC_CFG_SEED_LOAD	(1 << 27)
+#define VSC73XX_MAC_CFG_FDX		(1 << 18)
+#define VSC73XX_MAC_CFG_GIGE		(1 << 17)
+#define VSC73XX_MAC_CFG_RX_EN		(1 << 16)
+#define VSC73XX_MAC_CFG_VLAN_DBLAWR	(1 << 15)
+#define VSC73XX_MAC_CFG_VLAN_AWR	(1 << 14)
+#define VSC73XX_MAC_CFG_100_BASE_T	(1 << 13)
+#define VSC73XX_MAC_CFG_TX_IPG(x)	(((x) & 0x1f) << 6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST	(1 << 5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST	(1 << 4)
+#define VSC73XX_MAC_CFG_BIT2		(1 << 2)
+#define VSC73XX_MAC_CFG_CLK_SEL(x)	((x) & 0x3)
+
+/* ADVPORTM register bits */
+#define VSC73XX_ADVPORTM_IFG_PPM	(1 << 7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT	(1 << 6)
+#define VSC73XX_ADVPORTM_EXT_PORT	(1 << 5)
+#define VSC73XX_ADVPORTM_INV_GTX	(1 << 4)
+#define VSC73XX_ADVPORTM_ENA_GTX	(1 << 3)
+#define VSC73XX_ADVPORTM_DDR_MODE	(1 << 2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK	(1 << 1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK	(1 << 0)
+
+/* MII Block registers */
+#define VSC73XX_MII_STAT	0x0
+#define VSC73XX_MII_CMD		0x1
+#define VSC73XX_MII_DATA	0x2
+
+/* System Block registers */
+#define VSC73XX_ICPU_SIPAD		0x01
+#define VSC73XX_ICPU_CLOCK_DELAY	0x05
+#define VSC73XX_ICPU_CTRL		0x10
+#define VSC73XX_ICPU_ADDR		0x11
+#define VSC73XX_ICPU_SRAM		0x12
+#define VSC73XX_ICPU_MBOX_VAL		0x15
+#define VSC73XX_ICPU_MBOX_SET		0x16
+#define VSC73XX_ICPU_MBOX_CLR		0x17
+#define VSC73XX_ICPU_CHIPID		0x18
+#define VSC73XX_ICPU_GPIO		0x34
+
+#define VSC73XX_ICPU_CTRL_CLK_DIV	(1 << 8)
+#define VSC73XX_ICPU_CTRL_SRST_HOLD	(1 << 7)
+#define VSC73XX_ICPU_CTRL_BOOT_EN	(1 << 3)
+#define VSC73XX_ICPU_CTRL_EXT_ACC_EN	(1 << 2)
+#define VSC73XX_ICPU_CTRL_CLK_EN	(1 << 1)
+#define VSC73XX_ICPU_CTRL_SRST		(1 << 0)
+
+#define VSC73XX_ICPU_CHIPID_ID_SHIFT	12
+#define VSC73XX_ICPU_CHIPID_ID_MASK	0xffff
+#define VSC73XX_ICPU_CHIPID_REV_SHIFT	28
+#define VSC73XX_ICPU_CHIPID_REV_MASK	0xf
+#define VSC73XX_ICPU_CHIPID_ID_7385	0x7385
+#define VSC73XX_ICPU_CHIPID_ID_7395	0x7395
+
+#define VSC73XX_CMD_MODE_READ		0
+#define VSC73XX_CMD_MODE_WRITE		1
+#define VSC73XX_CMD_MODE_SHIFT		4
+#define VSC73XX_CMD_BLOCK_SHIFT		5
+#define VSC73XX_CMD_BLOCK_MASK		0x7
+#define VSC73XX_CMD_SUBBLOCK_MASK	0xf
+
+#define VSC7385_CLOCK_DELAY		((3 << 4) | 3)
+#define VSC7385_CLOCK_DELAY_MASK	((3 << 4) | 3)
+
+#define VSC73XX_ICPU_CTRL_STOP	(VSC73XX_ICPU_CTRL_SRST_HOLD | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_EXT_ACC_EN)
+
+#define VSC73XX_ICPU_CTRL_START	(VSC73XX_ICPU_CTRL_CLK_DIV | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_CLK_EN | \
+				 VSC73XX_ICPU_CTRL_SRST)
+
+#define VSC7385_ADVPORTM_MASK	(VSC73XX_ADVPORTM_IFG_PPM | \
+				 VSC73XX_ADVPORTM_EXC_COL_CONT | \
+				 VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_INV_GTX | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE | \
+				 VSC73XX_ADVPORTM_IO_LOOPBACK | \
+				 VSC73XX_ADVPORTM_HOST_LOOPBACK)
+
+#define VSC7385_ADVPORTM_INIT	(VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE)
+
+#define VSC7385_MAC_CFG_RESET	(VSC73XX_MAC_CFG_PORT_RST | \
+				 VSC73XX_MAC_CFG_MAC_RX_RST | \
+				 VSC73XX_MAC_CFG_MAC_TX_RST)
+
+#define VSC73XX_MAC_CFG_INIT	(VSC73XX_MAC_CFG_TX_EN | \
+				 VSC73XX_MAC_CFG_FDX | \
+				 VSC73XX_MAC_CFG_GIGE | \
+				 VSC73XX_MAC_CFG_RX_EN)
+
+#define VSC73XX_RESET_DELAY	100
+
+struct vsc7385 {
+	struct spi_device		*spi;
+	struct mutex			lock;
+	struct vsc7385_platform_data	*pdata;
+};
+
+static int vsc7385_is_addr_valid(u8 block, u8 subblock)
+{
+	switch (block) {
+	case VSC73XX_BLOCK_MAC:
+		switch (subblock) {
+		case 0 ... 4:
+		case 6:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_2:
+	case VSC73XX_BLOCK_SYSTEM:
+		switch (subblock) {
+		case 0:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_MII:
+	case VSC73XX_BLOCK_4:
+	case VSC73XX_BLOCK_5:
+		switch (subblock) {
+		case 0 ... 1:
+			return 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static inline u8 vsc7385_make_addr(u8 mode, u8 block, u8 subblock)
+{
+	u8 ret;
+
+	ret = (block & VSC73XX_CMD_BLOCK_MASK) << VSC73XX_CMD_BLOCK_SHIFT;
+	ret |= (mode & 1) << VSC73XX_CMD_MODE_SHIFT;
+	ret |= subblock & VSC73XX_CMD_SUBBLOCK_MASK;
+
+	return ret;
+}
+
+static int vsc7385_read(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			u32 *value)
+{
+	u8 cmd[4];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_READ, block, subblock);
+	cmd[1] = reg;
+	cmd[2] = 0;
+	cmd[3] = 0;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	if (err)
+		return err;
+
+	*value = (((u32) buf[0]) << 24) | (((u32) buf[1]) << 16) |
+		 (((u32) buf[2]) << 8) | ((u32) buf[3]);
+
+	return 0;
+}
+
+
+static int vsc7385_write(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			 u32 value)
+{
+	u8 cmd[2];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_WRITE, block, subblock);
+	cmd[1] = reg;
+
+	buf[0] = (value >> 24) & 0xff;
+	buf[1] = (value >> 16) & 0xff;
+	buf[2] = (value >> 8) & 0xff;
+	buf[3] = value & 0xff;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	return err;
+}
+
+static inline int vsc7385_write_verify(struct vsc7385 *vsc, u8 block,
+				       u8 subblock, u8 reg, u32 value,
+				       u32 read_mask, u32 read_val)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	int err;
+
+	err = vsc7385_write(vsc, block, subblock, reg, value);
+	if (err)
+		return err;
+
+	err = vsc7385_read(vsc, block, subblock, reg, &t);
+	if (err)
+		return err;
+
+	if ((t & read_mask) != read_val) {
+		dev_err(&spi->dev, "register write error\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int vsc7385_set_clock_delay(struct vsc7385 *vsc, u32 val)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			     VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_get_clock_delay(struct vsc7385 *vsc, u32 *val)
+{
+	return vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			    VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_icpu_stop(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_STOP);
+}
+
+static inline int vsc7385_icpu_start(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_START);
+}
+
+static inline int vsc7385_icpu_reset(struct vsc7385 *vsc)
+{
+	int rc;
+
+	rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+			   0x0000);
+	if (rc)
+		dev_err(&vsc->spi->dev,
+			"could not reset microcode, err=%d\n", rc);
+
+	return rc;
+}
+
+static int vsc7385_upload_ucode(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	const struct firmware *firmware;
+	char *ucode_name;
+	unsigned char *dp;
+	unsigned int curVal;
+	int i;
+	int diffs;
+	int rc;
+
+	ucode_name = (vsc->pdata->ucode_name) ? vsc->pdata->ucode_name
+					      : "vsc7385_ucode.bin";
+	rc = request_firmware(&firmware, ucode_name, &spi->dev);
+	if (rc) {
+		dev_err(&spi->dev, "request_firmware failed, err=%d\n",
+			rc);
+		return rc;
+	}
+
+	rc = vsc7385_icpu_stop(vsc);
+	if (rc)
+		goto out;
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "uploading microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_SRAM, *dp++);
+		if (rc) {
+			dev_err(&spi->dev, "could not load microcode, err=%d\n",
+				rc);
+			goto out;
+		}
+	}
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "verifying microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	diffs = 0;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				  VSC73XX_ICPU_SRAM, &curVal);
+		if (rc) {
+			dev_err(&spi->dev, "could not read microcode %d\n",
+				rc);
+			goto out;
+		}
+
+		if (curVal > 0xff) {
+			dev_err(&spi->dev, "bad val read: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+			rc = -EIO;
+			goto out;
+		}
+
+		if ((curVal & 0xff) != *dp) {
+			diffs++;
+			dev_err(&spi->dev, "verify error: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+
+			if (diffs > 4)
+				break;
+			}
+		dp++;
+	}
+
+	if (diffs) {
+		dev_err(&spi->dev, "microcode verification failed\n");
+		rc = -EIO;
+		goto out;
+	}
+
+	dev_info(&spi->dev, "microcode uploaded\n");
+
+	rc = vsc7385_icpu_start(vsc);
+
+out:
+	release_firmware(firmware);
+	return rc;
+}
+
+static int vsc7385_setup(struct vsc7385 *vsc)
+{
+	struct vsc7385_platform_data *pdata = vsc->pdata;
+	u32 t;
+	int err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY_MASK,
+				   VSC7385_CLOCK_DELAY);
+	if (err)
+		goto err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_MAC,
+				   VSC73XX_SUBBLOCK_PORT_MAC, VSC73XX_ADVPORTM,
+				   VSC7385_ADVPORTM_INIT,
+				   VSC7385_ADVPORTM_MASK,
+				   VSC7385_ADVPORTM_INIT);
+	if (err)
+		goto err;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, VSC7385_MAC_CFG_RESET);
+	if (err)
+		goto err;
+
+	t = VSC73XX_MAC_CFG_INIT;
+	t |= VSC73XX_MAC_CFG_TX_IPG(pdata->mac_cfg.tx_ipg);
+	t |= VSC73XX_MAC_CFG_CLK_SEL(pdata->mac_cfg.clk_sel);
+	if (pdata->mac_cfg.bit2)
+		t |= VSC73XX_MAC_CFG_BIT2;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, t);
+	if (err)
+		goto err;
+
+	return 0;
+
+err:
+	return err;
+}
+
+static int vsc7385_detect(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	u32 id;
+	u32 rev;
+	int err;
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_MBOX_VAL, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read mailbox, err=%d\n", err);
+		return err;
+	}
+
+	if (t == 0xffffffff) {
+		dev_dbg(&spi->dev, "assert chip reset\n");
+		if (vsc->pdata->reset)
+			vsc->pdata->reset();
+
+	}
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_CHIPID, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read chip id, err=%d\n", err);
+		return err;
+	}
+
+	id = (t >> VSC73XX_ICPU_CHIPID_ID_SHIFT) & VSC73XX_ICPU_CHIPID_ID_MASK;
+	switch (id) {
+	case VSC73XX_ICPU_CHIPID_ID_7385:
+	case VSC73XX_ICPU_CHIPID_ID_7395:
+		break;
+	default:
+		dev_err(&spi->dev, "unsupported chip, id=%04x\n", id);
+		return -ENODEV;
+	}
+
+	rev = (t >> VSC73XX_ICPU_CHIPID_REV_SHIFT) &
+	      VSC73XX_ICPU_CHIPID_REV_MASK;
+	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found\n", id, rev);
+
+	return 0;
+}
+
+static int vsc7385_probe(struct spi_device *spi)
+{
+	struct vsc7385 *vsc;
+	struct vsc7385_platform_data *pdata;
+	int	err;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION"\n");
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_err(&spi->dev, "no platform data specified\n");
+		return -ENODEV;
+	}
+
+	vsc = kzalloc(sizeof(*vsc), GFP_KERNEL);
+	if (!vsc) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&vsc->lock);
+	vsc->pdata = pdata;
+	vsc->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, vsc);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_detect(vsc);
+	if (err) {
+		dev_err(&spi->dev, "no chip found, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_upload_ucode(vsc);
+	if (err)
+		goto err_drvdata;
+
+	err = vsc7385_setup(vsc);
+	if (err)
+		goto err_drvdata;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+	return err;
+}
+
+static int vsc7385_remove(struct spi_device *spi)
+{
+	struct vsc7385_data	*vsc;
+
+	vsc = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+
+	return 0;
+}
+
+static struct spi_driver vsc7385_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= vsc7385_probe,
+	.remove		= vsc7385_remove,
+};
+
+static int __init vsc7385_init(void)
+{
+	return spi_register_driver(&vsc7385_driver);
+}
+module_init(vsc7385_init);
+
+static void __exit vsc7385_exit(void)
+{
+	spi_unregister_driver(&vsc7385_driver);
+}
+module_exit(vsc7385_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/target/linux/ar71xx/files-4.9/include/linux/leds-nu801.h b/target/linux/ar71xx/files-4.9/include/linux/leds-nu801.h
new file mode 100644
index 0000000000..0fc310d277
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/leds-nu801.h
@@ -0,0 +1,38 @@
+#ifndef __LEDS_NU801_H__
+#define __LEDS_NU801_H__
+
+/*
+ * Definitions for LED driver for NU801
+ *
+ * Kevin Paul Herbert
+ * Copyright (c) 2012, Meraki, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/leds.h>
+
+struct led_nu801_template {
+	const char *device_name;	/* Name of the platform device */
+	const char *name;	/* Name of this LED chain */
+	int num_leds;		/* Number of LEDs in the chain */
+	unsigned cki;		/* GPIO pin for CKI */
+	unsigned sdi;		/* GPIO pin for SDI */
+	int lei;		/* GPIO pin for LEI; < 0 if none */
+	u32 ndelay;		/* Delay in nanoseconds */
+	enum led_brightness init_brightness[3]; /* Default rgb state */
+#ifdef CONFIG_LEDS_TRIGGERS
+	const char *default_trigger; /* default trigger */
+#endif
+	const char *led_colors[3];  /* rgb color order */
+};
+
+struct led_nu801_platform_data {
+	int num_controllers;	/* Numnber of controllers */
+	struct led_nu801_template *template; /* Template per controller */
+};
+
+#endif /* __LEDS_NU801_H__ */
diff --git a/target/linux/ar71xx/files-4.9/include/linux/nxp_74hc153.h b/target/linux/ar71xx/files-4.9/include/linux/nxp_74hc153.h
new file mode 100644
index 0000000000..20b8845e53
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/nxp_74hc153.h
@@ -0,0 +1,24 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer defines
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _NXP_74HC153_H
+#define _NXP_74HC153_H
+
+#define NXP_74HC153_DRIVER_NAME "nxp-74hc153"
+
+struct nxp_74hc153_platform_data {
+	unsigned	gpio_base;
+	unsigned	gpio_pin_s0;
+	unsigned	gpio_pin_s1;
+	unsigned	gpio_pin_1y;
+	unsigned	gpio_pin_2y;
+};
+
+#endif /* _NXP_74HC153_H */
diff --git a/target/linux/ar71xx/files-4.9/include/linux/platform/ar934x_nfc.h b/target/linux/ar71xx/files-4.9/include/linux/platform/ar934x_nfc.h
new file mode 100644
index 0000000000..371aaee7f8
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/platform/ar934x_nfc.h
@@ -0,0 +1,39 @@
+/*
+ * Platform data definition for the built-in NAND controller of the
+ * Atheros AR934x SoCs
+ *
+ * Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#ifndef _AR934X_NFC_PLATFORM_H
+#define _AR934X_NFC_PLATFORM_H
+
+#define AR934X_NFC_DRIVER_NAME		"ar934x-nfc"
+
+struct mtd_info;
+struct mtd_partition;
+
+enum ar934x_nfc_ecc_mode {
+	AR934X_NFC_ECC_SOFT = 0,
+	AR934X_NFC_ECC_HW,
+	AR934X_NFC_ECC_SOFT_BCH,
+};
+
+struct ar934x_nfc_platform_data {
+	const char *name;
+	struct mtd_partition *parts;
+	int nr_parts;
+
+	bool swap_dma;
+	enum ar934x_nfc_ecc_mode ecc_mode;
+
+	void (*hw_reset)(bool active);
+	void (*select_chip)(int chip_no);
+	int (*scan_fixup)(struct mtd_info *mtd);
+};
+
+#endif /* _AR934X_NFC_PLATFORM_H */
diff --git a/target/linux/ar71xx/files-4.9/include/linux/platform_data/gpio-latch.h b/target/linux/ar71xx/files-4.9/include/linux/platform_data/gpio-latch.h
new file mode 100644
index 0000000000..0450e679ec
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/platform_data/gpio-latch.h
@@ -0,0 +1,14 @@
+#ifndef _GPIO_LATCH_H_
+#define _GPIO_LATCH_H_
+
+#define GPIO_LATCH_DRIVER_NAME	"gpio-latch"
+
+struct gpio_latch_platform_data {
+	int base;
+	int num_gpios;
+	int *gpios;
+	int le_gpio_index;
+	bool le_active_low;
+};
+
+#endif /* _GPIO_LATCH_H_ */
diff --git a/target/linux/ar71xx/files-4.9/include/linux/platform_data/rb91x_nand.h b/target/linux/ar71xx/files-4.9/include/linux/platform_data/rb91x_nand.h
new file mode 100644
index 0000000000..5f17fb8148
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/platform_data/rb91x_nand.h
@@ -0,0 +1,16 @@
+#ifndef _RB91X_NAND_H_
+#define _RB91X_NAND_H_
+
+#define RB91X_NAND_DRIVER_NAME	"rb91x-nand"
+
+struct rb91x_nand_platform_data {
+	int gpio_nce;	/* chip enable, active low */
+	int gpio_ale;	/* address latch enable */
+	int gpio_cle;   /* command latch enable */
+	int gpio_rdy;
+	int gpio_read;
+	int gpio_nrw;	/* read/write enable, active low */
+	int gpio_nle;	/* latch enable, active low */
+};
+
+#endif /* _RB91X_NAND_H_ */
\ No newline at end of file
diff --git a/target/linux/ar71xx/files-4.9/include/linux/spi/vsc7385.h b/target/linux/ar71xx/files-4.9/include/linux/spi/vsc7385.h
new file mode 100644
index 0000000000..1072ad7941
--- /dev/null
+++ b/target/linux/ar71xx/files-4.9/include/linux/spi/vsc7385.h
@@ -0,0 +1,19 @@
+/*
+ * Platform data definition for the Vitesse VSC7385 ethernet switch driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+struct vsc7385_platform_data {
+	void		(*reset)(void);
+	char		*ucode_name;
+	struct {
+		u32	tx_ipg:5;
+		u32	bit2:1;
+		u32	clk_sel:3;
+	} mac_cfg;
+};
diff --git a/target/linux/ar71xx/patches-4.14/001-spi-cs-gpio.patch b/target/linux/ar71xx/patches-4.14/001-spi-cs-gpio.patch
new file mode 100644
index 0000000000..7a0b669e43
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/001-spi-cs-gpio.patch
@@ -0,0 +1,20 @@
+--- a/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h
++++ b/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h
+@@ -14,6 +14,7 @@
+ struct ath79_spi_platform_data {
+ 	unsigned	bus_num;
+ 	unsigned	num_chipselect;
++	int *cs_gpios;
+ };
+ 
+ #endif /* _ATH79_SPI_PLATFORM_H */
+--- a/drivers/spi/spi-ath79.c
++++ b/drivers/spi/spi-ath79.c
+@@ -231,6 +231,7 @@ static int ath79_spi_probe(struct platfo
+ 	if (pdata) {
+ 		master->bus_num = pdata->bus_num;
+ 		master->num_chipselect = pdata->num_chipselect;
++		master->cs_gpios = pdata->cs_gpios;
+ 	}
+ 
+ 	sp->bitbang.master = master;
diff --git a/target/linux/ar71xx/patches-4.14/002-add_back_gpio_function_select.patch b/target/linux/ar71xx/patches-4.14/002-add_back_gpio_function_select.patch
new file mode 100644
index 0000000000..5b26a640eb
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/002-add_back_gpio_function_select.patch
@@ -0,0 +1,92 @@
+--- /dev/null
++++ b/arch/mips/ath79/gpio.c
+@@ -0,0 +1,59 @@
++/*
++ *  Atheros AR71XX/AR724X/AR913X GPIO API support
++ *
++ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
++ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
++ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
++ *
++ *  Parts of this file are based on Atheros' 2.6.15/2.6.31 BSP
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/gpio.h>
++#include <asm/mach-ath79/ar71xx_regs.h>
++#include <asm/mach-ath79/ath79.h>
++#include "common.h"
++
++void __iomem *ath79_gpio_base;
++EXPORT_SYMBOL_GPL(ath79_gpio_base);
++
++static void __iomem *ath79_gpio_get_function_reg(void)
++{
++	u32 reg = 0;
++
++	if (soc_is_ar71xx() ||
++	    soc_is_ar724x() ||
++	    soc_is_ar913x() ||
++	    soc_is_ar933x())
++		reg = AR71XX_GPIO_REG_FUNC;
++	else if (soc_is_ar934x())
++		reg = AR934X_GPIO_REG_FUNC;
++	else
++		BUG();
++
++	return ath79_gpio_base + reg;
++}
++
++void ath79_gpio_function_setup(u32 set, u32 clear)
++{
++	void __iomem *reg = ath79_gpio_get_function_reg();
++
++	__raw_writel((__raw_readl(reg) & ~clear) | set, reg);
++	/* flush write */
++	__raw_readl(reg);
++}
++
++void ath79_gpio_function_enable(u32 mask)
++{
++	ath79_gpio_function_setup(mask, 0);
++}
++
++void ath79_gpio_function_disable(u32 mask)
++{
++	ath79_gpio_function_setup(0, mask);
++}
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -118,6 +118,7 @@ static inline int soc_is_qca955x(void)
+ void ath79_ddr_wb_flush(unsigned int reg);
+ void ath79_ddr_set_pci_windows(void);
+ 
++extern void __iomem *ath79_gpio_base;
+ extern void __iomem *ath79_pll_base;
+ extern void __iomem *ath79_reset_base;
+ 
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -156,4 +156,5 @@ void __init ath79_gpio_init(void)
+ 	}
+ 
+ 	platform_device_register(&ath79_gpio_device);
++	ath79_gpio_base = ioremap(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+ }
+--- a/arch/mips/ath79/common.h
++++ b/arch/mips/ath79/common.h
+@@ -24,6 +24,9 @@ unsigned long ath79_get_sys_clk_rate(con
+ 
+ void ath79_ddr_ctrl_init(void);
+ 
++void ath79_gpio_function_enable(u32 mask);
++void ath79_gpio_function_disable(u32 mask);
++void ath79_gpio_function_setup(u32 set, u32 clear);
+ void ath79_gpio_init(void);
+ 
+ #endif /* __ATH79_COMMON_H */
diff --git a/target/linux/ar71xx/patches-4.14/004-register_gpio_driver_earlier.patch b/target/linux/ar71xx/patches-4.14/004-register_gpio_driver_earlier.patch
new file mode 100644
index 0000000000..d93498c645
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/004-register_gpio_driver_earlier.patch
@@ -0,0 +1,18 @@
+HACK: register the GPIO driver earlier to ensure that gpio_request calls
+from mach files succeed.
+
+--- a/drivers/gpio/gpio-ath79.c
++++ b/drivers/gpio/gpio-ath79.c
+@@ -322,7 +322,11 @@
+ 	.remove = ath79_gpio_remove,
+ };
+ 
+-module_platform_driver(ath79_gpio_driver);
++static int __init ath79_gpio_init(void)
++{
++	return platform_driver_register(&ath79_gpio_driver);
++}
++postcore_initcall(ath79_gpio_init);
+ 
+ MODULE_DESCRIPTION("Atheros AR71XX/AR724X/AR913X GPIO API support");
+ MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ar71xx/patches-4.14/100-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch b/target/linux/ar71xx/patches-4.14/100-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
new file mode 100644
index 0000000000..8d5b089986
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/100-MIPS-ath79-Avoid-using-unitialized-reg-variable.patch
@@ -0,0 +1,42 @@
+From 8b7a76e72fc819753878cd5684e243f33f847c79 Mon Sep 17 00:00:00 2001
+From: Markos Chandras <markos.chandras@imgtec.com>
+Date: Wed, 21 Aug 2013 11:47:22 +0100
+Subject: [PATCH] MIPS: ath79: Avoid using unitialized 'reg' variable
+
+Fixes the following build error:
+arch/mips/include/asm/mach-ath79/ath79.h:139:20: error: 'reg' may be used
+uninitialized in this function [-Werror=maybe-uninitialized]
+arch/mips/ath79/common.c:62:6: note: 'reg' was declared here
+In file included from arch/mips/ath79/common.c:20:0:
+arch/mips/ath79/common.c: In function 'ath79_device_reset_clear':
+arch/mips/include/asm/mach-ath79/ath79.h:139:20:
+error: 'reg' may be used uninitialized in this function
+[-Werror=maybe-uninitialized]
+arch/mips/ath79/common.c:90:6: note: 'reg' was declared here
+
+Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
+Acked-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ arch/mips/ath79/common.c |    4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -106,7 +106,7 @@ void ath79_device_reset_set(u32 mask)
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+-		BUG();
++		panic("Reset register not defined for this SOC");
+ 
+ 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
+ 	t = ath79_reset_rr(reg);
+@@ -134,7 +134,7 @@ void ath79_device_reset_clear(u32 mask)
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+-		BUG();
++		panic("Reset register not defined for this SOC");
+ 
+ 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
+ 	t = ath79_reset_rr(reg);
diff --git a/target/linux/ar71xx/patches-4.14/103-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch b/target/linux/ar71xx/patches-4.14/103-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
new file mode 100644
index 0000000000..64fb545b24
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/103-MIPS-ath79-fix-register-address-in-ath79_ddr_wb_flus.patch
@@ -0,0 +1,23 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 18 May 2016 18:03:31 +0200
+Subject: [PATCH] MIPS: ath79: fix register address in ath79_ddr_wb_flush()
+
+ath79_ddr_wb_flush_base has the type void __iomem *, so register offsets
+need to be a multiple of 4.
+
+Cc: Alban Bedel <albeu@free.fr>
+Fixes: 24b0e3e84fbf ("MIPS: ath79: Improve the DDR controller interface")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -58,7 +58,7 @@ EXPORT_SYMBOL_GPL(ath79_ddr_ctrl_init);
+ 
+ void ath79_ddr_wb_flush(u32 reg)
+ {
+-	void __iomem *flush_reg = ath79_ddr_wb_flush_base + reg;
++	void __iomem *flush_reg = ath79_ddr_wb_flush_base + reg * 4;
+ 
+ 	/* Flush the DDR write buffer. */
+ 	__raw_writel(0x1, flush_reg);
diff --git a/target/linux/ar71xx/patches-4.14/200-MIPS-ath79-fix-ar933x-wmac-reset.patch b/target/linux/ar71xx/patches-4.14/200-MIPS-ath79-fix-ar933x-wmac-reset.patch
new file mode 100644
index 0000000000..b7ae0ce649
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/200-MIPS-ath79-fix-ar933x-wmac-reset.patch
@@ -0,0 +1,30 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -62,10 +62,26 @@ static void __init ar913x_wmac_setup(voi
+ 
+ static int ar933x_wmac_reset(void)
+ {
++	int retries = 20;
++
+ 	ath79_device_reset_set(AR933X_RESET_WMAC);
+ 	ath79_device_reset_clear(AR933X_RESET_WMAC);
+ 
+-	return 0;
++	while (1) {
++		u32 bootstrap;
++
++		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
++		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
++			return 0;
++
++		if (retries-- == 0)
++			break;
++
++		udelay(10000);
++	}
++
++	pr_err("ar933x: WMAC reset timed out");
++	return -ETIMEDOUT;
+ }
+ 
+ static int ar933x_r1_get_wmac_revision(void)
diff --git a/target/linux/ar71xx/patches-4.14/201-ar913x_wmac_external_reset.patch b/target/linux/ar71xx/patches-4.14/201-ar913x_wmac_external_reset.patch
new file mode 100644
index 0000000000..9b704a3c47
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/201-ar913x_wmac_external_reset.patch
@@ -0,0 +1,31 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -44,7 +44,7 @@ static struct platform_device ath79_wmac
+ 	},
+ };
+ 
+-static void __init ar913x_wmac_setup(void)
++static int ar913x_wmac_reset(void)
+ {
+ 	/* reset the WMAC */
+ 	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
+@@ -53,10 +53,19 @@ static void __init ar913x_wmac_setup(voi
+ 	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
+ 	mdelay(10);
+ 
++	return 0;
++}
++
++static void __init ar913x_wmac_setup(void)
++{
++	ar913x_wmac_reset();
++
+ 	ath79_wmac_resources[0].start = AR913X_WMAC_BASE;
+ 	ath79_wmac_resources[0].end = AR913X_WMAC_BASE + AR913X_WMAC_SIZE - 1;
+ 	ath79_wmac_resources[1].start = ATH79_CPU_IRQ(2);
+ 	ath79_wmac_resources[1].end = ATH79_CPU_IRQ(2);
++
++	ath79_wmac_data.external_reset = ar913x_wmac_reset;
+ }
+ 
+ 
diff --git a/target/linux/ar71xx/patches-4.14/202-MIPS-ath79-ar934x-wmac-revision.patch b/target/linux/ar71xx/patches-4.14/202-MIPS-ath79-ar934x-wmac-revision.patch
new file mode 100644
index 0000000000..0f8016f847
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/202-MIPS-ath79-ar934x-wmac-revision.patch
@@ -0,0 +1,11 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -139,6 +139,8 @@ static void ar934x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = false;
+ 	else
+ 		ath79_wmac_data.is_clk_25mhz = true;
++
++	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
+ }
+ 
+ static void qca955x_wmac_setup(void)
diff --git a/target/linux/ar71xx/patches-4.14/203-MIPS-ath79-fix-restart.patch b/target/linux/ar71xx/patches-4.14/203-MIPS-ath79-fix-restart.patch
new file mode 100644
index 0000000000..48f4d95e74
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/203-MIPS-ath79-fix-restart.patch
@@ -0,0 +1,20 @@
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -40,6 +40,7 @@ static char ath79_sys_type[ATH79_SYS_TYP
+ 
+ static void ath79_restart(char *command)
+ {
++	local_irq_disable();
+ 	ath79_device_reset_set(AR71XX_RESET_FULL_CHIP);
+ 	for (;;)
+ 		if (cpu_wait)
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -135,6 +135,7 @@ static inline u32 ath79_pll_rr(unsigned
+ static inline void ath79_reset_wr(unsigned reg, u32 val)
+ {
+ 	__raw_writel(val, ath79_reset_base + reg);
++	(void) __raw_readl(ath79_reset_base + reg); /* flush */
+ }
+ 
+ static inline u32 ath79_reset_rr(unsigned reg)
diff --git a/target/linux/ar71xx/patches-4.14/220-add_cpu_feature_overrides.patch b/target/linux/ar71xx/patches-4.14/220-add_cpu_feature_overrides.patch
new file mode 100644
index 0000000000..d925f92624
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/220-add_cpu_feature_overrides.patch
@@ -0,0 +1,28 @@
+--- a/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h
++++ b/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h
+@@ -36,6 +36,7 @@
+ #define cpu_has_mdmx		0
+ #define cpu_has_mips3d		0
+ #define cpu_has_smartmips	0
++#define cpu_has_rixi		0
+ 
+ #define cpu_has_mips32r1	1
+ #define cpu_has_mips32r2	1
+@@ -43,6 +44,7 @@
+ #define cpu_has_mips64r2	0
+ 
+ #define cpu_has_mipsmt		0
++#define cpu_has_userlocal	0
+ 
+ #define cpu_has_64bits		0
+ #define cpu_has_64bit_zero_reg	0
+@@ -51,5 +53,9 @@
+ 
+ #define cpu_dcache_line_size()	32
+ #define cpu_icache_line_size()	32
++#define cpu_has_vtag_icache	0
++#define cpu_has_dc_aliases	1
++#define cpu_has_ic_fills_f_dc	0
++#define cpu_has_pindexed_dcache	0
+ 
+ #endif /* __ASM_MACH_ATH79_CPU_FEATURE_OVERRIDES_H */
diff --git a/target/linux/ar71xx/patches-4.14/300-MIPS-add-MIPS_MACHINE_NONAME-macro.patch b/target/linux/ar71xx/patches-4.14/300-MIPS-add-MIPS_MACHINE_NONAME-macro.patch
new file mode 100644
index 0000000000..0bc64b7a17
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/300-MIPS-add-MIPS_MACHINE_NONAME-macro.patch
@@ -0,0 +1,21 @@
+--- a/arch/mips/include/asm/mips_machine.h
++++ b/arch/mips/include/asm/mips_machine.h
+@@ -36,6 +36,18 @@ static struct mips_machine machine_##_ty
+ 	.mach_setup	= _setup,				\
+ };
+ 
++#define MIPS_MACHINE_NONAME(_type, _id, _setup)		\
++static const char machine_id_##_type[] __initconst		\
++			__aligned(1) = _id;			\
++static struct mips_machine machine_##_type			\
++		__used __section(.mips.machines.init) =		\
++{								\
++	.mach_type	= _type,				\
++	.mach_id	= machine_id_##_type,			\
++	.mach_name	= NULL,					\
++	.mach_setup	= _setup,				\
++};
++
+ extern long __mips_machines_start;
+ extern long __mips_machines_end;
+ 
diff --git a/target/linux/ar71xx/patches-4.14/310-lib-add-rle-decompression.patch b/target/linux/ar71xx/patches-4.14/310-lib-add-rle-decompression.patch
new file mode 100644
index 0000000000..766ffbeb76
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/310-lib-add-rle-decompression.patch
@@ -0,0 +1,124 @@
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -265,6 +265,9 @@ config LZMA_COMPRESS
+ config LZMA_DECOMPRESS
+     tristate
+ 
++config RLE_DECOMPRESS
++	tristate
++
+ #
+ # These all provide a common interface (hence the apparent duplication with
+ # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
+--- a/lib/Makefile
++++ b/lib/Makefile
+@@ -134,6 +134,7 @@ obj-$(CONFIG_XZ_DEC) += xz/
+ obj-$(CONFIG_RAID6_PQ) += raid6/
+ obj-$(CONFIG_LZMA_COMPRESS) += lzma/
+ obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
++obj-$(CONFIG_RLE_DECOMPRESS) += rle.o
+ 
+ lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
+ lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
+--- /dev/null
++++ b/include/linux/rle.h
+@@ -0,0 +1,18 @@
++#ifndef _RLE_H_
++#define _RLE_H_
++
++#ifdef CONFIG_RLE_DECOMPRESS
++int rle_decode(const unsigned char *src, size_t srclen,
++	       unsigned char *dst, size_t dstlen,
++	       size_t *src_done, size_t *dst_done);
++#else
++static inline int
++rle_decode(const unsigned char *src, size_t srclen,
++	   unsigned char *dst, size_t dstlen,
++	   size_t *src_done, size_t *dst_done)
++{
++	return -ENOTSUPP;
++}
++#endif /* CONFIG_RLE_DECOMPRESS */
++
++#endif /* _RLE_H_ */
+--- /dev/null
++++ b/lib/rle.c
+@@ -0,0 +1,78 @@
++/*
++ *  RLE decoding routine
++ *
++ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/rle.h>
++
++int rle_decode(const unsigned char *src, size_t srclen,
++	       unsigned char *dst, size_t dstlen,
++	       size_t *src_done, size_t *dst_done)
++{
++	size_t srcpos, dstpos;
++	int ret;
++
++	srcpos = 0;
++	dstpos = 0;
++	ret = -EINVAL;
++
++	/* sanity checks */
++	if (!src || !srclen || !dst || !dstlen)
++		goto out;
++
++	while (1) {
++		char count;
++
++		if (srcpos >= srclen)
++			break;
++
++		count = (char) src[srcpos++];
++		if (count == 0) {
++			ret = 0;
++			break;
++		}
++
++		if (count > 0) {
++			unsigned char c;
++
++			if (srcpos >= srclen)
++				break;
++
++			c = src[srcpos++];
++
++			while (count--) {
++				if (dstpos >= dstlen)
++					break;
++
++				dst[dstpos++] = c;
++			}
++		} else {
++			count *= -1;
++
++			while (count--) {
++				if (srcpos >= srclen)
++					break;
++				if (dstpos >= dstlen)
++					break;
++				dst[dstpos++] = src[srcpos++];
++			}
++		}
++	}
++
++out:
++	if (src_done)
++		*src_done = srcpos;
++	if (dst_done)
++		*dst_done = dstpos;
++
++	return ret;
++}
++
++EXPORT_SYMBOL_GPL(rle_decode);
diff --git a/target/linux/ar71xx/patches-4.14/401-mtd-physmap-add-lock-unlock.patch b/target/linux/ar71xx/patches-4.14/401-mtd-physmap-add-lock-unlock.patch
new file mode 100644
index 0000000000..db7b3ca83d
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/401-mtd-physmap-add-lock-unlock.patch
@@ -0,0 +1,94 @@
+--- a/drivers/mtd/maps/physmap.c
++++ b/drivers/mtd/maps/physmap.c
+@@ -31,6 +31,66 @@ struct physmap_flash_info {
+ 	int			vpp_refcnt;
+ };
+ 
++static struct platform_device *physmap_map2pdev(struct map_info *map)
++{
++	return (struct platform_device *) map->map_priv_1;
++}
++
++static void physmap_lock(struct map_info *map)
++{
++	struct platform_device *pdev;
++	struct physmap_flash_data *physmap_data;
++
++	pdev = physmap_map2pdev(map);
++	physmap_data = pdev->dev.platform_data;
++	physmap_data->lock(pdev);
++}
++
++static void physmap_unlock(struct map_info *map)
++{
++	struct platform_device *pdev;
++	struct physmap_flash_data *physmap_data;
++
++	pdev = physmap_map2pdev(map);
++	physmap_data = pdev->dev.platform_data;
++	physmap_data->unlock(pdev);
++}
++
++static map_word physmap_flash_read_lock(struct map_info *map, unsigned long ofs)
++{
++	map_word ret;
++
++	physmap_lock(map);
++	ret = inline_map_read(map, ofs);
++	physmap_unlock(map);
++
++	return ret;
++}
++
++static void physmap_flash_write_lock(struct map_info *map, map_word d,
++				     unsigned long ofs)
++{
++	physmap_lock(map);
++	inline_map_write(map, d, ofs);
++	physmap_unlock(map);
++}
++
++static void physmap_flash_copy_from_lock(struct map_info *map, void *to,
++					 unsigned long from, ssize_t len)
++{
++	physmap_lock(map);
++	inline_map_copy_from(map, to, from, len);
++	physmap_unlock(map);
++}
++
++static void physmap_flash_copy_to_lock(struct map_info *map, unsigned long to,
++				       const void *from, ssize_t len)
++{
++	physmap_lock(map);
++	inline_map_copy_to(map, to, from, len);
++	physmap_unlock(map);
++}
++
+ static int physmap_flash_remove(struct platform_device *dev)
+ {
+ 	struct physmap_flash_info *info;
+@@ -153,6 +213,13 @@ static int physmap_flash_probe(struct pl
+ 
+ 		simple_map_init(&info->map[i]);
+ 
++		if (physmap_data->lock && physmap_data->unlock) {
++			info->map[i].read = physmap_flash_read_lock;
++			info->map[i].write = physmap_flash_write_lock;
++			info->map[i].copy_from = physmap_flash_copy_from_lock;
++			info->map[i].copy_to = physmap_flash_copy_to_lock;
++		}
++
+ 		probe_type = rom_probe_types;
+ 		if (physmap_data->probe_type == NULL) {
+ 			for (; info->mtd[i] == NULL && *probe_type != NULL; probe_type++)
+--- a/include/linux/mtd/physmap.h
++++ b/include/linux/mtd/physmap.h
+@@ -25,6 +25,8 @@ struct physmap_flash_data {
+ 	unsigned int		width;
+ 	int			(*init)(struct platform_device *);
+ 	void			(*exit)(struct platform_device *);
++	void			(*lock)(struct platform_device *);
++	void			(*unlock)(struct platform_device *);
+ 	void			(*set_vpp)(struct platform_device *, int);
+ 	unsigned int		nr_parts;
+ 	unsigned int		pfow_base;
diff --git a/target/linux/ar71xx/patches-4.14/402-mtd-SST39VF6401B-support.patch b/target/linux/ar71xx/patches-4.14/402-mtd-SST39VF6401B-support.patch
new file mode 100644
index 0000000000..0d483ab1a4
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/402-mtd-SST39VF6401B-support.patch
@@ -0,0 +1,29 @@
+--- a/drivers/mtd/chips/jedec_probe.c
++++ b/drivers/mtd/chips/jedec_probe.c
+@@ -148,6 +148,7 @@
+ #define SST39LF160	0x2782
+ #define SST39VF1601	0x234b
+ #define SST39VF3201	0x235b
++#define SST39VF6401B	0x236d
+ #define SST39WF1601	0x274b
+ #define SST39WF1602	0x274a
+ #define SST39LF512	0x00D4
+@@ -1569,6 +1570,18 @@ static const struct amd_flash_info jedec
+ 			ERASEINFO(0x10000,64),
+ 		}
+ 	}, {
++		.mfr_id         = CFI_MFR_SST,
++		.dev_id         = SST39VF6401B,
++		.name           = "SST 39VF6401B",
++		.devtypes       = CFI_DEVICETYPE_X16,
++		.uaddr          = MTD_UADDR_0xAAAA_0x5555,
++		.dev_size       = SIZE_8MiB,
++		.cmd_set        = P_ID_AMD_STD,
++		.nr_regions     = 1,
++		.regions        = {
++			ERASEINFO(0x10000,128)
++		}
++	}, {
+ 		.mfr_id		= CFI_MFR_ST,
+ 		.dev_id		= M29F800AB,
+ 		.name		= "ST M29F800AB",
diff --git a/target/linux/ar71xx/patches-4.14/403-mtd_fix_cfi_cmdset_0002_status_check.patch b/target/linux/ar71xx/patches-4.14/403-mtd_fix_cfi_cmdset_0002_status_check.patch
new file mode 100644
index 0000000000..c5167ade20
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/403-mtd_fix_cfi_cmdset_0002_status_check.patch
@@ -0,0 +1,69 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -1635,8 +1635,8 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
+ 			break;
+ 		}
+ 
+-		if (chip_ready(map, adr))
+-			break;
++		if (chip_good(map, adr, datum))
++			goto enable_xip;
+ 
+ 		/* Latency issues. Drop the lock, wait a while and retry */
+ 		UDELAY(map, chip, adr, 1);
+@@ -1652,6 +1652,8 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
+ 
+ 		ret = -EIO;
+ 	}
++
++ enable_xip:
+ 	xip_enable(map, chip, adr);
+  op_done:
+ 	if (mode == FL_OTP_WRITE)
+@@ -2230,7 +2232,6 @@ static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+ 	return 0;
+ }
+ 
+-
+ /*
+  * Handle devices with one erase region, that only implement
+  * the chip erase command.
+@@ -2295,8 +2296,8 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
+ 			chip->erase_suspended = 0;
+ 		}
+ 
+-		if (chip_ready(map, adr))
+-			break;
++		if (chip_good(map, adr, map_word_ff(map)))
++			goto op_done;
+ 
+ 		if (time_after(jiffies, timeo)) {
+ 			printk(KERN_WARNING "MTD %s(): software timeout\n",
+@@ -2316,6 +2317,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
+ 		ret = -EIO;
+ 	}
+ 
++ op_done:
+ 	chip->state = FL_READY;
+ 	xip_enable(map, chip, adr);
+ 	DISABLE_VPP(map);
+@@ -2385,9 +2387,9 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
+ 			chip->erase_suspended = 0;
+ 		}
+ 
+-		if (chip_ready(map, adr)) {
++		if (chip_good(map, adr, map_word_ff(map))) {
+ 			xip_enable(map, chip, adr);
+-			break;
++			goto op_done;
+ 		}
+ 
+ 		if (time_after(jiffies, timeo)) {
+@@ -2409,6 +2411,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
+ 		ret = -EIO;
+ 	}
+ 
++ op_done:
+ 	chip->state = FL_READY;
+ 	DISABLE_VPP(map);
+ 	put_chip(map, chip, adr);
diff --git a/target/linux/ar71xx/patches-4.14/404-mtd-cybertan-trx-parser.patch b/target/linux/ar71xx/patches-4.14/404-mtd-cybertan-trx-parser.patch
new file mode 100644
index 0000000000..922849fcba
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/404-mtd-cybertan-trx-parser.patch
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -178,6 +178,12 @@ menu "Partition parsers"
+ source "drivers/mtd/parsers/Kconfig"
+ endmenu
+ 
++config MTD_CYBERTAN_PARTS
++	tristate "Cybertan partitioning support"
++	depends on ATH79
++	---help---
++	   Cybertan partitioning support
++
+ config MTD_MYLOADER_PARTS
+ 	tristate "MyLoader partition parsing"
+ 	depends on ADM5120 || ATH25 || ATH79
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -18,6 +18,7 @@ obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
+ obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
+ obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
+ obj-y				+= parsers/
++obj-$(CONFIG_MTD_CYBERTAN_PARTS) += cybertan_part.o
+ 
+ # 'Users' - code which presents functionality to userspace.
+ obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
diff --git a/target/linux/ar71xx/patches-4.14/405-mtd-tp-link-partition-parser.patch b/target/linux/ar71xx/patches-4.14/405-mtd-tp-link-partition-parser.patch
new file mode 100644
index 0000000000..35ae11dac1
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/405-mtd-tp-link-partition-parser.patch
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -200,6 +200,12 @@ config MTD_MYLOADER_PARTS
+ 	  You will still need the parsing functions to be called by the driver
+ 	  for your particular device. It won't happen automatically.
+ 
++config MTD_TPLINK_PARTS
++	tristate "TP-Link AR7XXX/AR9XXX partitioning support"
++	depends on ATH79
++	---help---
++	  TBD.
++
+ comment "User Modules And Translation Layers"
+ 
+ #
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -18,6 +18,7 @@ obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
+ obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
+ obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
+ obj-y				+= parsers/
++obj-$(CONFIG_MTD_TPLINK_PARTS)	+= tplinkpart.o
+ obj-$(CONFIG_MTD_CYBERTAN_PARTS) += cybertan_part.o
+ 
+ # 'Users' - code which presents functionality to userspace.
diff --git a/target/linux/ar71xx/patches-4.14/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch b/target/linux/ar71xx/patches-4.14/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
new file mode 100644
index 0000000000..f8e51d8233
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
@@ -0,0 +1,34 @@
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -235,6 +235,7 @@ static ssize_t m25p80_read(struct spi_nor *nor, loff_t from, size_t len,
+  */
+ static int m25p_probe(struct spi_device *spi)
+ {
++	struct mtd_part_parser_data	ppdata = {0,};
+ 	struct flash_platform_data	*data;
+ 	struct m25p *flash;
+ 	struct spi_nor *nor;
+@@ -300,8 +301,11 @@ static int m25p_probe(struct spi_device *spi)
+ 	if (ret)
+ 		return ret;
+ 
+-	return mtd_device_register(&nor->mtd, data ? data->parts : NULL,
+-				   data ? data->nr_parts : 0);
++	return mtd_device_parse_register(&nor->mtd,
++			data ? data->part_probes : NULL,
++			&ppdata,
++			data ? data->parts : NULL,
++ 			data ? data->nr_parts : 0);
+ }
+ 
+ 
+--- a/include/linux/spi/flash.h
++++ b/include/linux/spi/flash.h
+@@ -25,6 +25,7 @@ struct flash_platform_data {
+ 	unsigned int	nr_parts;
+ 
+ 	char		*type;
++	const char	**part_probes;
+ 
+ 	/* we'll likely add more ... use JEDEC IDs, etc */
+ };
diff --git a/target/linux/ar71xx/patches-4.14/408-mtd-redboot_partition_scan.patch b/target/linux/ar71xx/patches-4.14/408-mtd-redboot_partition_scan.patch
new file mode 100644
index 0000000000..cd41e7ceb2
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/408-mtd-redboot_partition_scan.patch
@@ -0,0 +1,44 @@
+--- a/drivers/mtd/redboot.c
++++ b/drivers/mtd/redboot.c
+@@ -76,12 +76,18 @@ static int parse_redboot_partitions(stru
+ 	static char nullstring[] = "unallocated";
+ #endif
+ 
++	buf = vmalloc(master->erasesize);
++	if (!buf)
++		return -ENOMEM;
++
++ restart:
+ 	if ( directory < 0 ) {
+ 		offset = master->size + directory * master->erasesize;
+ 		while (mtd_block_isbad(master, offset)) {
+ 			if (!offset) {
+ 			nogood:
+ 				printk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n");
++				vfree(buf);
+ 				return -EIO;
+ 			}
+ 			offset -= master->erasesize;
+@@ -94,10 +100,6 @@ static int parse_redboot_partitions(stru
+ 				goto nogood;
+ 		}
+ 	}
+-	buf = vmalloc(master->erasesize);
+-
+-	if (!buf)
+-		return -ENOMEM;
+ 
+ 	printk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",
+ 	       master->name, offset);
+@@ -170,6 +172,11 @@ static int parse_redboot_partitions(stru
+ 	}
+ 	if (i == numslots) {
+ 		/* Didn't find it */
++		if (offset + master->erasesize < master->size) {
++			/* not at the end of the flash yet, maybe next block :) */
++			directory++;
++			goto restart;
++		}
+ 		printk(KERN_NOTICE "No RedBoot partition table detected in %s\n",
+ 		       master->name);
+ 		ret = 0;
diff --git a/target/linux/ar71xx/patches-4.14/409-mtd-rb4xx_nand_driver.patch b/target/linux/ar71xx/patches-4.14/409-mtd-rb4xx_nand_driver.patch
new file mode 100644
index 0000000000..d1a307f2d1
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/409-mtd-rb4xx_nand_driver.patch
@@ -0,0 +1,21 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -563,4 +563,8 @@ config MTD_NAND_MTK
+ 	  Enables support for NAND controller on MTK SoCs.
+ 	  This controller is found on mt27xx, mt81xx, mt65xx SoCs.
+ 
++config MTD_NAND_RB4XX
++	tristate "NAND flash driver for RouterBoard 4xx series"
++	depends on MTD_NAND && ATH79_MACH_RB4XX
++
+ endif # MTD_NAND
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -34,6 +34,7 @@ obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
+ obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+ obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
+ obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
++obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
+ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
+ obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
+ obj-$(CONFIG_MTD_NAND_OXNAS)		+= oxnas_nand.o
diff --git a/target/linux/ar71xx/patches-4.14/410-mtd-rb750-nand-driver.patch b/target/linux/ar71xx/patches-4.14/410-mtd-rb750-nand-driver.patch
new file mode 100644
index 0000000000..086935be99
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/410-mtd-rb750-nand-driver.patch
@@ -0,0 +1,21 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -567,4 +567,8 @@ config MTD_NAND_RB4XX
+ 	tristate "NAND flash driver for RouterBoard 4xx series"
+ 	depends on MTD_NAND && ATH79_MACH_RB4XX
+ 
++config MTD_NAND_RB750
++	tristate "NAND flash driver for the RouterBoard 750"
++	depends on MTD_NAND && ATH79_MACH_RB750
++
+ endif # MTD_NAND
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -35,6 +35,7 @@ obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+ obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
+ obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+ obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
++obj-$(CONFIG_MTD_NAND_RB750)		+= rb750_nand.o
+ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
+ obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
+ obj-$(CONFIG_MTD_NAND_OXNAS)		+= oxnas_nand.o
diff --git a/target/linux/ar71xx/patches-4.14/411-mtd-cfi_cmdset_0002-force-word-write.patch b/target/linux/ar71xx/patches-4.14/411-mtd-cfi_cmdset_0002-force-word-write.patch
new file mode 100644
index 0000000000..8572533f23
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/411-mtd-cfi_cmdset_0002-force-word-write.patch
@@ -0,0 +1,61 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -40,7 +40,7 @@
+ #include <linux/mtd/xip.h>
+ 
+ #define AMD_BOOTLOC_BUG
+-#define FORCE_WORD_WRITE 0
++#define FORCE_WORD_WRITE 1
+ 
+ #define MAX_WORD_RETRIES 3
+ 
+@@ -51,7 +51,9 @@
+ 
+ static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+ static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
++#if !FORCE_WORD_WRITE
+ static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
++#endif
+ static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
+ static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
+ static void cfi_amdstd_sync (struct mtd_info *);
+@@ -202,6 +204,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
+ }
+ #endif
+ 
++#if !FORCE_WORD_WRITE
+ static void fixup_use_write_buffers(struct mtd_info *mtd)
+ {
+ 	struct map_info *map = mtd->priv;
+@@ -211,6 +214,7 @@ static void fixup_use_write_buffers(struct mtd_info *mtd)
+ 		mtd->_write = cfi_amdstd_write_buffers;
+ 	}
+ }
++#endif /* !FORCE_WORD_WRITE */
+ 
+ /* Atmel chips don't use the same PRI format as AMD chips */
+ static void fixup_convert_atmel_pri(struct mtd_info *mtd)
+@@ -1794,6 +1798,7 @@ static int cfi_amdstd_write_words(struct mtd_info *mtd, loff_t to, size_t len,
+ /*
+  * FIXME: interleaved mode not tested, and probably not supported!
+  */
++#if !FORCE_WORD_WRITE
+ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
+ 				    unsigned long adr, const u_char *buf,
+ 				    int len)
+@@ -1922,7 +1927,6 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
+ 	return ret;
+ }
+ 
+-
+ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
+ 				    size_t *retlen, const u_char *buf)
+ {
+@@ -1997,6 +2001,7 @@ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
+ 
+ 	return 0;
+ }
++#endif /* !FORCE_WORD_WRITE */
+ 
+ /*
+  * Wait for the flash chip to become ready to write data
diff --git a/target/linux/ar71xx/patches-4.14/413-mtd-ar934x-nand-driver.patch b/target/linux/ar71xx/patches-4.14/413-mtd-ar934x-nand-driver.patch
new file mode 100644
index 0000000000..3c7300c777
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/413-mtd-ar934x-nand-driver.patch
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -571,4 +571,12 @@ config MTD_NAND_RB750
+ 	tristate "NAND flash driver for the RouterBoard 750"
+ 	depends on MTD_NAND && ATH79_MACH_RB750
+ 
++config MTD_NAND_AR934X
++	tristate "NAND flash driver for the Qualcomm Atheros AR934x/QCA955x SoCs"
++	depends on (SOC_AR934X || SOC_QCA955X)
++
++config MTD_NAND_AR934X_HW_ECC
++	bool "Hardware ECC support for the AR934X NAND Controller (EXPERIMENTAL)"
++	depends on MTD_NAND_AR934X
++
+ endif # MTD_NAND
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -13,6 +13,7 @@ obj-$(CONFIG_MTD_NAND_AMS_DELTA)	+= ams-delta.o
+ obj-$(CONFIG_MTD_NAND_DENALI)		+= denali.o
+ obj-$(CONFIG_MTD_NAND_DENALI_PCI)	+= denali_pci.o
+ obj-$(CONFIG_MTD_NAND_DENALI_DT)	+= denali_dt.o
++obj-$(CONFIG_MTD_NAND_AR934X)		+= ar934x_nfc.o
+ obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
+ obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
+ obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
diff --git a/target/linux/ar71xx/patches-4.14/414-mtd-rb91x-nand-driver.patch b/target/linux/ar71xx/patches-4.14/414-mtd-rb91x-nand-driver.patch
new file mode 100644
index 0000000000..d01053551b
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/414-mtd-rb91x-nand-driver.patch
@@ -0,0 +1,21 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -571,4 +571,8 @@ config MTD_NAND_RB750
+ 	tristate "NAND flash driver for the RouterBoard 750"
+ 	depends on MTD_NAND && ATH79_MACH_RB750
+ 
++config MTD_NAND_RB91X
++	tristate "NAND flash driver for the RouterBOARD 91x series"
++	depends on MTD_NAND && ATH79_MACH_RB91X
++
+ endif # MTD_NAND
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -36,6 +36,7 @@ obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
+ obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+ obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
+ obj-$(CONFIG_MTD_NAND_RB750)		+= rb750_nand.o
++obj-$(CONFIG_MTD_NAND_RB91X)		+= rb91x_nand.o
+ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
+ obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
+ obj-$(CONFIG_MTD_NAND_OXNAS)		+= oxnas_nand.o
diff --git a/target/linux/ar71xx/patches-4.14/420-net-ar71xx_mac_driver.patch b/target/linux/ar71xx/patches-4.14/420-net-ar71xx_mac_driver.patch
new file mode 100644
index 0000000000..6377db0ac2
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/420-net-ar71xx_mac_driver.patch
@@ -0,0 +1,28 @@
+--- a/drivers/net/ethernet/atheros/Kconfig
++++ b/drivers/net/ethernet/atheros/Kconfig
+@@ -5,7 +5,7 @@
+ config NET_VENDOR_ATHEROS
+ 	bool "Atheros devices"
+ 	default y
+-	depends on PCI
++	depends on (PCI || ATH79)
+ 	---help---
+ 	  If you have a network (Ethernet) card belonging to this class, say Y.
+ 
+@@ -78,4 +78,6 @@ config ALX
+ 	  To compile this driver as a module, choose M here.  The module
+ 	  will be called alx.
+ 
++source drivers/net/ethernet/atheros/ag71xx/Kconfig
++
+ endif # NET_VENDOR_ATHEROS
+--- a/drivers/net/ethernet/atheros/Makefile
++++ b/drivers/net/ethernet/atheros/Makefile
+@@ -3,6 +3,7 @@
+ # Makefile for the Atheros network device drivers.
+ #
+ 
++obj-$(CONFIG_AG71XX) += ag71xx/
+ obj-$(CONFIG_ATL1) += atlx/
+ obj-$(CONFIG_ATL2) += atlx/
+ obj-$(CONFIG_ATL1E) += atl1e/
diff --git a/target/linux/ar71xx/patches-4.14/423-dsa-add-88e6063-driver.patch b/target/linux/ar71xx/patches-4.14/423-dsa-add-88e6063-driver.patch
new file mode 100644
index 0000000000..67aefe5582
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/423-dsa-add-88e6063-driver.patch
@@ -0,0 +1,27 @@
+--- a/drivers/net/dsa/Kconfig
++++ b/drivers/net/dsa/Kconfig
+@@ -39,6 +39,14 @@ config NET_DSA_MV88E6060
+ 	  This enables support for the Marvell 88E6060 ethernet switch
+ 	  chip.
+ 
++config NET_DSA_MV88E6063
++	bool "Marvell 88E6063 ethernet switch chip support"
++	depends on NET_DSA
++	select NET_DSA_TAG_TRAILER
++	---help---
++	  This enables support for the Marvell 88E6063 ethernet switch
++	  chip
++
+ source "drivers/net/dsa/microchip/Kconfig"
+ 
+ source "drivers/net/dsa/mv88e6xxx/Kconfig"
+--- a/drivers/net/dsa/Makefile
++++ b/drivers/net/dsa/Makefile
+@@ -7,6 +7,7 @@ obj-$(CONFIG_FIXED_PHY)		+= dsa_loop_bdinfo.o
+ endif
+ obj-$(CONFIG_NET_DSA_MT7530)	+= mt7530.o
+ obj-$(CONFIG_NET_DSA_MV88E6060) += mv88e6060.o
++obj-$(CONFIG_NET_DSA_MV88E6063) += mv88e6063.o
+ obj-$(CONFIG_NET_DSA_QCA8K)	+= qca8k.o
+ obj-$(CONFIG_NET_DSA_SMSC_LAN9303) += lan9303-core.o
+ obj-$(CONFIG_NET_DSA_SMSC_LAN9303_I2C) += lan9303_i2c.o
diff --git a/target/linux/ar71xx/patches-4.14/430-drivers-link-spi-before-mtd.patch b/target/linux/ar71xx/patches-4.14/430-drivers-link-spi-before-mtd.patch
new file mode 100644
index 0000000000..2f1549710b
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/430-drivers-link-spi-before-mtd.patch
@@ -0,0 +1,12 @@
+--- a/drivers/Makefile
++++ b/drivers/Makefile
+@@ -83,8 +83,8 @@ obj-$(CONFIG_SCSI)		+= scsi/
+ obj-y				+= nvme/
+ obj-$(CONFIG_ATA)		+= ata/
+ obj-$(CONFIG_TARGET_CORE)	+= target/
+-obj-$(CONFIG_MTD)		+= mtd/
+ obj-$(CONFIG_SPI)		+= spi/
++obj-$(CONFIG_MTD)		+= mtd/
+ obj-$(CONFIG_SPMI)		+= spmi/
+ obj-$(CONFIG_HSI)		+= hsi/
+ obj-y				+= net/
diff --git a/target/linux/ar71xx/patches-4.14/432-spi-rb4xx-spi-driver.patch b/target/linux/ar71xx/patches-4.14/432-spi-rb4xx-spi-driver.patch
new file mode 100644
index 0000000000..eeebc95c7f
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/432-spi-rb4xx-spi-driver.patch
@@ -0,0 +1,25 @@
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -563,6 +563,12 @@ config SPI_QUP
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called spi_qup.
+ 
++config SPI_RB4XX
++	tristate "Mikrotik RB4XX SPI master"
++	depends on SPI_MASTER && ATH79_MACH_RB4XX
++	help
++	  SPI controller driver for the Mikrotik RB4xx series boards.
++
+ config SPI_S3C24XX
+ 	tristate "Samsung S3C24XX series SPI"
+ 	depends on ARCH_S3C24XX
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -77,6 +77,7 @@ obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
+ spi-pxa2xx-platform-objs		:= spi-pxa2xx.o spi-pxa2xx-dma.o
+ obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
+ obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
++obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
+ obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
+ obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
+ obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
diff --git a/target/linux/ar71xx/patches-4.14/433-spi-rb4xx-cpld-driver.patch b/target/linux/ar71xx/patches-4.14/433-spi-rb4xx-cpld-driver.patch
new file mode 100644
index 0000000000..85201f28bf
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/433-spi-rb4xx-cpld-driver.patch
@@ -0,0 +1,26 @@
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -801,6 +801,13 @@ config SPI_TLE62X0
+ 	  sysfs interface, with each line presented as a kind of GPIO
+ 	  exposing both switch control and diagnostic feedback.
+ 
++config SPI_RB4XX_CPLD
++	tristate "MikroTik RB4XX CPLD driver"
++	depends on ATH79_MACH_RB4XX
++	help
++	  SPI driver for the Xilinx CPLD chip present on the
++	  MikroTik RB4xx boards.
++
+ #
+ # Add new SPI protocol masters in alphabetical order above this line
+ #
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -78,6 +78,7 @@ spi-pxa2xx-platform-objs		:= spi-pxa2xx.o spi-pxa2xx-dma.o
+ obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
+ obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+ obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
++obj-$(CONFIG_SPI_RB4XX_CPLD)		+= spi-rb4xx-cpld.o
+ obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
+ obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
+ obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
diff --git a/target/linux/ar71xx/patches-4.14/435-spi-vsc7385_driver.patch b/target/linux/ar71xx/patches-4.14/435-spi-vsc7385_driver.patch
new file mode 100644
index 0000000000..085dd3ebf6
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/435-spi-vsc7385_driver.patch
@@ -0,0 +1,24 @@
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -808,6 +808,11 @@ config SPI_RB4XX_CPLD
+ 	  SPI driver for the Xilinx CPLD chip present on the
+ 	  MikroTik RB4xx boards.
+ 
++config SPI_VSC7385
++	tristate "Vitesse VSC7385 ethernet switch driver"
++	help
++	  SPI driver for the Vitesse VSC7385 ethernet switch.
++
+ #
+ # Add new SPI protocol masters in alphabetical order above this line
+ #
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -105,6 +105,7 @@ spi-thunderx-objs			:= spi-cavium.o spi-cavium-thunderx.o
+ obj-$(CONFIG_SPI_THUNDERX)		+= spi-thunderx.o
+ obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
+ obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
++obj-$(CONFIG_SPI_VSC7385)		+= spi-vsc7385.o
+ obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
+ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
+ obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
diff --git a/target/linux/ar71xx/patches-4.14/440-leds-wndr3700-usb-led-driver.patch b/target/linux/ar71xx/patches-4.14/440-leds-wndr3700-usb-led-driver.patch
new file mode 100644
index 0000000000..8b6b885fcb
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/440-leds-wndr3700-usb-led-driver.patch
@@ -0,0 +1,26 @@
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -696,6 +696,13 @@ config LEDS_NIC78BX
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called leds-nic78bx.
+ 
++config LEDS_WNDR3700_USB
++	tristate "NETGEAR WNDR3700 USB LED driver"
++	depends on LEDS_CLASS && ATH79_MACH_WNDR3700
++	help
++	  This option enables support for the USB LED found on the
++	  NETGEAR WNDR3700 board.
++
+ comment "LED Triggers"
+ source "drivers/leds/trigger/Kconfig"
+ 
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -51,6 +51,7 @@ obj-$(CONFIG_LEDS_DA9052)		+= leds-da9052.o
+ obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
+ obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+ obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
++obj-${CONFIG_LEDS_WNDR3700_USB}		+= leds-wndr3700-usb.o
+ obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
+ obj-$(CONFIG_LEDS_INTEL_SS4200)		+= leds-ss4200.o
+ obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
diff --git a/target/linux/ar71xx/patches-4.14/441-leds-rb750-led-driver.patch b/target/linux/ar71xx/patches-4.14/441-leds-rb750-led-driver.patch
new file mode 100644
index 0000000000..bc844fe12c
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/441-leds-rb750-led-driver.patch
@@ -0,0 +1,23 @@
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -703,6 +703,10 @@ config LEDS_WNDR3700_USB
+ 	  This option enables support for the USB LED found on the
+ 	  NETGEAR WNDR3700 board.
+ 
++config LEDS_RB750
++	tristate "LED driver for the Mikrotik RouterBOARD 750"
++	depends on LEDS_CLASS && ATH79_MACH_RB750
++
+ comment "LED Triggers"
+ source "drivers/leds/trigger/Kconfig"
+ 
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -57,6 +57,7 @@ obj-$(CONFIG_LEDS_INTEL_SS4200)		+= leds-ss4200.o
+ obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
+ obj-$(CONFIG_LEDS_ADP5520)		+= leds-adp5520.o
+ obj-$(CONFIG_LEDS_MC13783)		+= leds-mc13783.o
++obj-$(CONFIG_LEDS_RB750)		+= leds-rb750.o
+ obj-$(CONFIG_LEDS_NS2)			+= leds-ns2.o
+ obj-$(CONFIG_LEDS_NETXBIG)		+= leds-netxbig.o
+ obj-$(CONFIG_LEDS_ASIC3)		+= leds-asic3.o
diff --git a/target/linux/ar71xx/patches-4.14/442-leds-gpio-allow-to-use-OPEN_-DRAIN-SOURCE-flags-with.patch b/target/linux/ar71xx/patches-4.14/442-leds-gpio-allow-to-use-OPEN_-DRAIN-SOURCE-flags-with.patch
new file mode 100644
index 0000000000..bc7884be0a
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/442-leds-gpio-allow-to-use-OPEN_-DRAIN-SOURCE-flags-with.patch
@@ -0,0 +1,45 @@
+From 183148e0789bee1cd5c46ba49afcb211f636f8a2 Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <juhosg@freemail.hu>
+Date: Mon, 15 Jan 2018 15:01:14 +0100
+Subject: [PATCH] leds: gpio: allow to use OPEN_{DRAIN,SOURCE} flags with
+ legacy GPIOs
+
+LEDs which are connected to open-source or open-drain type of GPIO lines
+can be used only, if those are defined via devicetree.
+Add two new fields to 'struct gpio_led' in order to make it possible to
+specify this type of GPIO lines to the leds-gpio driver via platform data.
+Also update the create_gpio_led() function to set the GPIOF_OPEN_DRAIN and
+GPIOF_OPEN_SOURCE flags for the given GPIO line.
+
+Signed-off-by: Gabor Juhos <juhosg@freemail.hu>
+---
+ drivers/leds/leds-gpio.c | 6 ++++++
+ include/linux/leds.h     | 2 ++
+ 2 files changed, 8 insertions(+)
+
+--- a/drivers/leds/leds-gpio.c
++++ b/drivers/leds/leds-gpio.c
+@@ -100,6 +100,12 @@ static int create_gpio_led(const struct gpio_led *template,
+ 		if (template->active_low)
+ 			flags |= GPIOF_ACTIVE_LOW;
+ 
++		if (template->open_drain)
++			flags |= GPIOF_OPEN_DRAIN;
++
++		if (template->open_source)
++			flags |= GPIOF_OPEN_SOURCE;
++
+ 		ret = devm_gpio_request_one(parent, template->gpio, flags,
+ 					    template->name);
+ 		if (ret < 0)
+--- a/include/linux/leds.h
++++ b/include/linux/leds.h
+@@ -395,6 +395,8 @@ struct gpio_led {
+ 	unsigned	default_state : 2;
+ 	unsigned	retain_state_shutdown : 1;
+ 	/* default_state should be one of LEDS_GPIO_DEFSTATE_(ON|OFF|KEEP) */
++	unsigned	open_drain : 1;
++	unsigned	open_source : 1;
+ 	struct gpio_desc *gpiod;
+ };
+ #define LEDS_GPIO_DEFSTATE_OFF		0
diff --git a/target/linux/ar71xx/patches-4.14/450-gpio-nxp-74hc153-gpio-chip-driver.patch b/target/linux/ar71xx/patches-4.14/450-gpio-nxp-74hc153-gpio-chip-driver.patch
new file mode 100644
index 0000000000..3ea491bc37
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/450-gpio-nxp-74hc153-gpio-chip-driver.patch
@@ -0,0 +1,25 @@
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1298,4 +1298,12 @@ config GPIO_VIPERBOARD
+ 
+ endmenu
+ 
++comment "Other GPIO expanders"
++
++config GPIO_NXP_74HC153
++	tristate "NXP 74HC153 Dual 4-input multiplexer"
++	help
++	  Platform driver for NXP 74HC153 Dual 4-input Multiplexer. This
++	  provides a GPIO interface supporting input mode only.
++
+ endif
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -89,6 +89,7 @@ obj-$(CONFIG_GPIO_MSIC)		+= gpio-msic.o
+ obj-$(CONFIG_GPIO_MVEBU)        += gpio-mvebu.o
+ obj-$(CONFIG_GPIO_MXC)		+= gpio-mxc.o
+ obj-$(CONFIG_GPIO_MXS)		+= gpio-mxs.o
++obj-$(CONFIG_GPIO_NXP_74HC153)	+= gpio-nxp-74hc153.o
+ obj-$(CONFIG_GPIO_OCTEON)	+= gpio-octeon.o
+ obj-$(CONFIG_GPIO_OMAP)		+= gpio-omap.o
+ obj-$(CONFIG_GPIO_PCA953X)	+= gpio-pca953x.o
diff --git a/target/linux/ar71xx/patches-4.14/451-gpio-74x164-improve-platform-device-support.patch b/target/linux/ar71xx/patches-4.14/451-gpio-74x164-improve-platform-device-support.patch
new file mode 100644
index 0000000000..aae5c10d3c
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/451-gpio-74x164-improve-platform-device-support.patch
@@ -0,0 +1,119 @@
+--- a/drivers/gpio/gpio-74x164.c
++++ b/drivers/gpio/gpio-74x164.c
+@@ -13,6 +13,7 @@
+ #include <linux/init.h>
+ #include <linux/mutex.h>
+ #include <linux/spi/spi.h>
++#include <linux/spi/74x164.h>
+ #include <linux/gpio.h>
+ #include <linux/of_gpio.h>
+ #include <linux/slab.h>
+@@ -105,9 +106,16 @@ static int gen_74x164_direction_output(struct gpio_chip *gc,
+ static int gen_74x164_probe(struct spi_device *spi)
+ {
+ 	struct gen_74x164_chip *chip;
++	struct gen_74x164_chip_platform_data *pdata = spi->dev.platform_data;
++	struct device_node *np = spi->dev.of_node;
+ 	u32 nregs;
+ 	int ret;
+ 
++	if (!np && !pdata) {
++		dev_err(&spi->dev, "No configuration data available.\n");
++		return -EINVAL;
++	}
++
+ 	/*
+ 	 * bits_per_word cannot be configured in platform data
+ 	 */
+@@ -117,12 +125,15 @@ static int gen_74x164_probe(struct spi_device *spi)
+ 	if (ret < 0)
+ 		return ret;
+ 
+-	if (of_property_read_u32(spi->dev.of_node, "registers-number",
+-				 &nregs)) {
+-		dev_err(&spi->dev,
+-			"Missing registers-number property in the DT.\n");
+-		return -EINVAL;
+-	}
++	if (np) {
++		if (of_property_read_u32(np, "registers-number", &nregs)) {
++			dev_err(&spi->dev,
++				"Missing registers-number property in the DT.\n");
++			return -EINVAL;
++		}
++	} else if (pdata) {
++		nregs = pdata->num_registers;
++ 	}
+ 
+ 	chip = devm_kzalloc(&spi->dev, sizeof(*chip) + nregs, GFP_KERNEL);
+ 	if (!chip)
+@@ -142,7 +153,11 @@ static int gen_74x164_probe(struct spi_device *spi)
+ 	chip->gpio_chip.get = gen_74x164_get_value;
+ 	chip->gpio_chip.set = gen_74x164_set_value;
+ 	chip->gpio_chip.set_multiple = gen_74x164_set_multiple;
+-	chip->gpio_chip.base = -1;
++	if (np)
++		chip->gpio_chip.base = -1;
++	else if (pdata)
++		chip->gpio_chip.base = pdata->base;
++
+ 
+ 	chip->registers = nregs;
+ 	chip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers;
+@@ -151,6 +166,9 @@ static int gen_74x164_probe(struct spi_device *spi)
+ 	chip->gpio_chip.parent = &spi->dev;
+ 	chip->gpio_chip.owner = THIS_MODULE;
+ 
++	if (pdata && pdata->init_data)
++		memcpy(chip->buffer, pdata->init_data, chip->registers);
++
+ 	mutex_init(&chip->lock);
+ 
+ 	ret = __gen_74x164_write_config(chip);
+@@ -180,17 +198,19 @@ static int gen_74x164_remove(struct spi_device *spi)
+ 	return 0;
+ }
+ 
++#ifdef CONFIG_OF
+ static const struct of_device_id gen_74x164_dt_ids[] = {
+ 	{ .compatible = "fairchild,74hc595" },
+ 	{ .compatible = "nxp,74lvc594" },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, gen_74x164_dt_ids);
++#endif
+ 
+ static struct spi_driver gen_74x164_driver = {
+ 	.driver = {
+ 		.name		= "74x164",
+-		.of_match_table	= gen_74x164_dt_ids,
++		.of_match_table	= of_match_ptr(gen_74x164_dt_ids),
+ 	},
+ 	.probe		= gen_74x164_probe,
+ 	.remove		= gen_74x164_remove,
+--- /dev/null
++++ b/include/linux/spi/74x164.h
+@@ -0,0 +1,13 @@
++#ifndef LINUX_SPI_74X164_H
++#define LINUX_SPI_74X164_H
++
++struct gen_74x164_chip_platform_data {
++	/* number assigned to the first GPIO */
++	unsigned        base;
++	/* number of chained registers */
++	unsigned	num_registers;
++	/* address of a buffer containing initial data */
++	u8		*init_data;
++};
++
++#endif
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1250,7 +1250,6 @@ menu "SPI GPIO expanders"
+ 
+ config GPIO_74X164
+ 	tristate "74x164 serial-in/parallel-out 8-bits shift register"
+-	depends on OF_GPIO
+ 	help
+ 	  Driver for 74x164 compatible serial-in/parallel-out 8-outputs
+ 	  shift registers. This driver can be used to provide access
diff --git a/target/linux/ar71xx/patches-4.14/452-gpio-add-gpio-latch-driver.patch b/target/linux/ar71xx/patches-4.14/452-gpio-add-gpio-latch-driver.patch
new file mode 100644
index 0000000000..0e1e327d5f
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/452-gpio-add-gpio-latch-driver.patch
@@ -0,0 +1,22 @@
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1305,4 +1305,9 @@ config GPIO_NXP_74HC153
+ 	  Platform driver for NXP 74HC153 Dual 4-input Multiplexer. This
+ 	  provides a GPIO interface supporting input mode only.
+ 
++config GPIO_LATCH
++	tristate "GPIO latch driver"
++	help
++	  Say yes here to enable a GPIO latch driver.
++
+ endif
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -63,6 +63,7 @@ obj-$(CONFIG_GPIO_JANZ_TTL)	+= gpio-janz-ttl.o
+ obj-$(CONFIG_GPIO_KEMPLD)	+= gpio-kempld.o
+ obj-$(CONFIG_ARCH_KS8695)	+= gpio-ks8695.o
+ obj-$(CONFIG_GPIO_INTEL_MID)	+= gpio-intel-mid.o
++obj-$(CONFIG_GPIO_LATCH)	+= gpio-latch.o
+ obj-$(CONFIG_GPIO_LOONGSON)	+= gpio-loongson.o
+ obj-$(CONFIG_GPIO_LP3943)	+= gpio-lp3943.o
+ obj-$(CONFIG_GPIO_LPC18XX)	+= gpio-lpc18xx.o
diff --git a/target/linux/ar71xx/patches-4.14/461-spi-ath79-add-fast-flash-read.patch b/target/linux/ar71xx/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
new file mode 100644
index 0000000000..e2771691b9
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/461-spi-ath79-add-fast-flash-read.patch
@@ -0,0 +1,60 @@
+--- a/drivers/spi/spi-ath79.c
++++ b/drivers/spi/spi-ath79.c
+@@ -102,9 +102,6 @@ static void ath79_spi_enable(struct ath79_spi *sp)
+ 	/* save CTRL register */
+ 	sp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);
+ 	sp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);
+-
+-	/* TODO: setup speed? */
+-	ath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);
+ }
+ 
+ static void ath79_spi_disable(struct ath79_spi *sp)
+@@ -204,6 +201,38 @@ static u32 ath79_spi_txrx_mode0(struct spi_device *spi, unsigned int nsecs,
+ 	return ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);
+ }
+ 
++static bool ath79_spi_flash_read_supported(struct spi_device *spi)
++{
++	if (spi->chip_select || gpio_is_valid(spi->cs_gpio))
++		return false;
++
++	return true;
++}
++
++static int ath79_spi_read_flash_data(struct spi_device *spi,
++				     struct spi_flash_read_message *msg)
++{
++	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
++
++	if (msg->addr_width > 3)
++		return -EOPNOTSUPP;
++
++	/* disable GPIO mode */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);
++
++	memcpy_fromio(msg->buf, sp->base + msg->from, msg->len);
++
++	/* enable GPIO mode */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);
++
++	/* restore IOC register */
++	ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
++
++	msg->retlen = msg->len;
++
++	return 0;
++}
++
+ static int ath79_spi_probe(struct platform_device *pdev)
+ {
+ 	struct spi_master *master;
+@@ -233,6 +262,8 @@ static int ath79_spi_probe(struct platform_device *pdev)
+ 		master->num_chipselect = pdata->num_chipselect;
+ 		master->cs_gpios = pdata->cs_gpios;
+ 	}
++	master->spi_flash_read = ath79_spi_read_flash_data;
++	master->flash_read_supported = ath79_spi_flash_read_supported;
+ 
+ 	sp->bitbang.master = master;
+ 	sp->bitbang.chipselect = ath79_spi_chipselect;
diff --git a/target/linux/ar71xx/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch b/target/linux/ar71xx/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
new file mode 100644
index 0000000000..7c39a9251d
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/470-MIPS-ath79-swizzle-pci-address-for-ar71xx.patch
@@ -0,0 +1,111 @@
+--- /dev/null
++++ b/arch/mips/include/asm/mach-ath79/mangle-port.h
+@@ -0,0 +1,37 @@
++/*
++ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
++ *
++ *  This file was derived from: inlude/asm-mips/mach-generic/mangle-port.h
++ *      Copyright (C) 2003, 2004 Ralf Baechle
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#ifndef __ASM_MACH_ATH79_MANGLE_PORT_H
++#define __ASM_MACH_ATH79_MANGLE_PORT_H
++
++#ifdef CONFIG_PCI
++extern unsigned long (ath79_pci_swizzle_b)(unsigned long port);
++extern unsigned long (ath79_pci_swizzle_w)(unsigned long port);
++#else
++#define ath79_pci_swizzle_b(port) (port)
++#define ath79_pci_swizzle_w(port) (port)
++#endif
++
++#define __swizzle_addr_b(port)	ath79_pci_swizzle_b(port)
++#define __swizzle_addr_w(port)	ath79_pci_swizzle_w(port)
++#define __swizzle_addr_l(port)	(port)
++#define __swizzle_addr_q(port)	(port)
++
++# define ioswabb(a, x)           (x)
++# define __mem_ioswabb(a, x)     (x)
++# define ioswabw(a, x)           (x)
++# define __mem_ioswabw(a, x)     cpu_to_le16(x)
++# define ioswabl(a, x)           (x)
++# define __mem_ioswabl(a, x)     cpu_to_le32(x)
++# define ioswabq(a, x)           (x)
++# define __mem_ioswabq(a, x)     cpu_to_le64(x)
++
++#endif /* __ASM_MACH_ATH79_MANGLE_PORT_H */
+--- a/arch/mips/ath79/pci.c
++++ b/arch/mips/ath79/pci.c
+@@ -13,6 +13,7 @@
+  */
+ 
+ #include <linux/init.h>
++#include <linux/export.h>
+ #include <linux/pci.h>
+ #include <linux/resource.h>
+ #include <linux/platform_device.h>
+@@ -25,6 +26,9 @@ static int (*ath79_pci_plat_dev_init)(struct pci_dev *dev);
+ static const struct ath79_pci_irq *ath79_pci_irq_map;
+ static unsigned ath79_pci_nr_irqs;
+ 
++static unsigned long (*__ath79_pci_swizzle_b)(unsigned long port);
++static unsigned long (*__ath79_pci_swizzle_w)(unsigned long port);
++
+ static const struct ath79_pci_irq ar71xx_pci_irq_map[] = {
+ 	{
+ 		.slot	= 17,
+@@ -212,12 +216,50 @@ ath79_register_pci_ar724x(int id,
+ 	return pdev;
+ }
+ 
++static inline bool ar71xx_is_pci_addr(unsigned long port)
++{
++	unsigned long phys = CPHYSADDR(port);
++
++	return (phys >= AR71XX_PCI_MEM_BASE &&
++		phys < AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE);
++}
++
++static unsigned long ar71xx_pci_swizzle_b(unsigned long port)
++{
++	return ar71xx_is_pci_addr(port) ? port ^ 3 : port;
++}
++
++static unsigned long ar71xx_pci_swizzle_w(unsigned long port)
++{
++	return ar71xx_is_pci_addr(port) ? port ^ 2 : port;
++}
++
++unsigned long ath79_pci_swizzle_b(unsigned long port)
++{
++	if (__ath79_pci_swizzle_b)
++		return __ath79_pci_swizzle_b(port);
++
++	return port;
++}
++EXPORT_SYMBOL(ath79_pci_swizzle_b);
++
++unsigned long ath79_pci_swizzle_w(unsigned long port)
++{
++	if (__ath79_pci_swizzle_w)
++		return __ath79_pci_swizzle_w(port);
++
++	return port;
++}
++EXPORT_SYMBOL(ath79_pci_swizzle_w);
++
+ int __init ath79_register_pci(void)
+ {
+ 	struct platform_device *pdev = NULL;
+ 
+ 	if (soc_is_ar71xx()) {
+ 		pdev = ath79_register_pci_ar71xx();
++		__ath79_pci_swizzle_b = ar71xx_pci_swizzle_b;
++		__ath79_pci_swizzle_w = ar71xx_pci_swizzle_w;
+ 	} else if (soc_is_ar724x()) {
+ 		pdev = ath79_register_pci_ar724x(-1,
+ 						 AR724X_PCI_CFG_BASE,
diff --git a/target/linux/ar71xx/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch b/target/linux/ar71xx/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
new file mode 100644
index 0000000000..d3c10f57ab
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/490-usb-ehci-add-quirks-for-qca-socs.patch
@@ -0,0 +1,103 @@
+--- a/drivers/usb/host/ehci-hcd.c
++++ b/drivers/usb/host/ehci-hcd.c
+@@ -252,6 +252,37 @@ int ehci_reset(struct ehci_hcd *ehci)
+ 	command |= CMD_RESET;
+ 	dbg_cmd (ehci, "reset", command);
+ 	ehci_writel(ehci, command, &ehci->regs->command);
++
++	if (ehci->qca_force_host_mode) {
++		u32 usbmode;
++
++		udelay(1000);
++
++		usbmode = ehci_readl(ehci, &ehci->regs->usbmode);
++		usbmode |= USBMODE_CM_HC | (1 << 4);
++		ehci_writel(ehci, usbmode, &ehci->regs->usbmode);
++
++		ehci_dbg(ehci, "forced host mode, usbmode: %08x\n",
++			 ehci_readl(ehci, &ehci->regs->usbmode));
++	}
++
++	if (ehci->qca_force_16bit_ptw) {
++		u32 port_status;
++
++		udelay(1000);
++
++		/* enable 16-bit UTMI interface */
++		port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
++		port_status |= BIT(28);
++		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
++
++		ehci_dbg(ehci, "16-bit UTMI interface enabled, status: %08x\n",
++			 ehci_readl(ehci, &ehci->regs->port_status[0]));
++	}
++
++	if (ehci->reset_notifier)
++		ehci->reset_notifier(ehci_to_hcd(ehci));
++
+ 	ehci->rh_state = EHCI_RH_HALTED;
+ 	ehci->next_statechange = jiffies;
+ 	retval = ehci_handshake(ehci, &ehci->regs->command,
+--- a/drivers/usb/host/ehci-platform.c
++++ b/drivers/usb/host/ehci-platform.c
+@@ -53,6 +53,14 @@ struct ehci_platform_priv {
+ 
+ static const char hcd_name[] = "ehci-platform";
+ 
++static void ehci_platform_reset_notifier(struct usb_hcd *hcd)
++{
++	struct platform_device *pdev = to_platform_device(hcd->self.controller);
++	struct usb_ehci_pdata *pdata = pdev->dev.platform_data;
++
++	pdata->reset_notifier(pdev);
++}
++
+ static int ehci_platform_reset(struct usb_hcd *hcd)
+ {
+ 	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+@@ -265,6 +273,13 @@ static int ehci_platform_probe(struct platform_device *dev)
+ 		priv->reset_on_resume = true;
+ 	if (pdata->ignore_oc)
+ 		ehci->ignore_oc = 1;
++	if (pdata->qca_force_host_mode)
++		ehci->qca_force_host_mode = 1;
++	if (pdata->qca_force_16bit_ptw)
++		ehci->qca_force_16bit_ptw = 1;
++
++	if (pdata->reset_notifier)
++		ehci->reset_notifier = ehci_platform_reset_notifier;
+ 
+ #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+ 	if (ehci->big_endian_mmio) {
+--- a/drivers/usb/host/ehci.h
++++ b/drivers/usb/host/ehci.h
+@@ -232,6 +232,10 @@ struct ehci_hcd {			/* one per controller */
+ 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
+ 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
+ 	unsigned		ignore_oc:1;
++	unsigned		qca_force_host_mode:1;
++	unsigned		qca_force_16bit_ptw:1; /* force 16 bit UTMI */
++
++	void (*reset_notifier)(struct usb_hcd *hcd);
+ 
+ 	/* required for usb32 quirk */
+ 	#define OHCI_CTRL_HCFS          (3 << 6)
+--- a/include/linux/usb/ehci_pdriver.h
++++ b/include/linux/usb/ehci_pdriver.h
+@@ -50,6 +50,8 @@ struct usb_ehci_pdata {
+ 	unsigned	reset_on_resume:1;
+ 	unsigned	dma_mask_64:1;
+ 	unsigned	ignore_oc:1;
++	unsigned	qca_force_host_mode:1;
++	unsigned	qca_force_16bit_ptw:1;
+ 
+ 	/* Turn on all power and clocks */
+ 	int (*power_on)(struct platform_device *pdev);
+@@ -59,6 +61,7 @@ struct usb_ehci_pdata {
+ 	 * turn off everything else */
+ 	void (*power_suspend)(struct platform_device *pdev);
+ 	int (*pre_setup)(struct usb_hcd *hcd);
++	void (*reset_notifier)(struct platform_device *pdev);
+ };
+ 
+ #endif /* __USB_CORE_EHCI_PDRIVER_H */
diff --git a/target/linux/ar71xx/patches-4.14/500-MIPS-fw-myloader.patch b/target/linux/ar71xx/patches-4.14/500-MIPS-fw-myloader.patch
new file mode 100644
index 0000000000..6110296783
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/500-MIPS-fw-myloader.patch
@@ -0,0 +1,22 @@
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1151,6 +1151,9 @@ config MIPS_MSC
+ config MIPS_NILE4
+ 	bool
+ 
++config MYLOADER
++	bool
++
+ config SYNC_R4K
+ 	bool
+ 
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -227,6 +227,7 @@ cflags-$(toolchain-virt)		+= -DTOOLCHAIN_SUPPORTS_VIRT
+ #
+ libs-$(CONFIG_FW_ARC)		+= arch/mips/fw/arc/
+ libs-$(CONFIG_FW_CFE)		+= arch/mips/fw/cfe/
++libs-$(CONFIG_MYLOADER)		+= arch/mips/fw/myloader/
+ libs-$(CONFIG_FW_SNIPROM)	+= arch/mips/fw/sni/
+ libs-y				+= arch/mips/fw/lib/
+ 
diff --git a/target/linux/ar71xx/patches-4.14/501-MIPS-ath79-add-mac-argument-to-ath79_register_wmac.patch b/target/linux/ar71xx/patches-4.14/501-MIPS-ath79-add-mac-argument-to-ath79_register_wmac.patch
new file mode 100644
index 0000000000..12ab3b50d6
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/501-MIPS-ath79-add-mac-argument-to-ath79_register_wmac.patch
@@ -0,0 +1,70 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -15,6 +15,7 @@
+ #include <linux/init.h>
+ #include <linux/delay.h>
+ #include <linux/irq.h>
++#include <linux/etherdevice.h>
+ #include <linux/platform_device.h>
+ #include <linux/ath9k_platform.h>
+ 
+@@ -22,6 +23,7 @@
+ #include <asm/mach-ath79/ar71xx_regs.h>
+ #include "dev-wmac.h"
+ 
++static u8 ath79_wmac_mac[ETH_ALEN];
+ static struct ath9k_platform_data ath79_wmac_data;
+ 
+ static struct resource ath79_wmac_resources[] = {
+@@ -161,7 +163,7 @@ static void qca955x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = true;
+ }
+ 
+-void __init ath79_register_wmac(u8 *cal_data)
++void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+ 		ar913x_wmac_setup();
+@@ -178,5 +180,10 @@ void __init ath79_register_wmac(u8 *cal_
+ 		memcpy(ath79_wmac_data.eeprom_data, cal_data,
+ 		       sizeof(ath79_wmac_data.eeprom_data));
+ 
++	if (mac_addr) {
++		memcpy(ath79_wmac_mac, mac_addr, sizeof(ath79_wmac_mac));
++		ath79_wmac_data.macaddr = ath79_wmac_mac;
++	}
++
+ 	platform_device_register(&ath79_wmac_device);
+ }
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -12,6 +12,6 @@
+ #ifndef _ATH79_DEV_WMAC_H
+ #define _ATH79_DEV_WMAC_H
+ 
+-void ath79_register_wmac(u8 *cal_data);
++void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
+--- a/arch/mips/ath79/mach-db120.c
++++ b/arch/mips/ath79/mach-db120.c
+@@ -128,7 +128,7 @@ static void __init db120_setup(void)
+ 	ath79_register_spi(&db120_spi_data, db120_spi_info,
+ 			   ARRAY_SIZE(db120_spi_info));
+ 	ath79_register_usb();
+-	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET);
++	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET, NULL);
+ 	db120_pci_init(art + DB120_PCIE_CALDATA_OFFSET);
+ }
+ 
+--- a/arch/mips/ath79/mach-ap121.c
++++ b/arch/mips/ath79/mach-ap121.c
+@@ -85,7 +85,7 @@ static void __init ap121_setup(void)
+ 	ath79_register_spi(&ap121_spi_data, ap121_spi_info,
+ 			   ARRAY_SIZE(ap121_spi_info));
+ 	ath79_register_usb();
+-	ath79_register_wmac(cal_data);
++	ath79_register_wmac(cal_data, NULL);
+ }
+ 
+ MIPS_MACHINE(ATH79_MACH_AP121, "AP121", "Atheros AP121 reference board",
diff --git a/target/linux/ar71xx/patches-4.14/504-MIPS-ath79-add-ath79_device_reset_get.patch b/target/linux/ar71xx/patches-4.14/504-MIPS-ath79-add-ath79_device_reset_get.patch
new file mode 100644
index 0000000000..c0e96b2729
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/504-MIPS-ath79-add-ath79_device_reset_get.patch
@@ -0,0 +1,42 @@
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -145,6 +145,7 @@ static inline u32 ath79_reset_rr(unsigne
+ 
+ void ath79_device_reset_set(u32 mask);
+ void ath79_device_reset_clear(u32 mask);
++u32 ath79_device_reset_get(u32 mask);
+ 
+ void ath79_cpu_irq_init(unsigned irq_wb_chan2, unsigned irq_wb_chan3);
+ void ath79_misc_irq_init(void __iomem *regs, int irq,
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -142,3 +142,29 @@ void ath79_device_reset_clear(u32 mask)
+ 	spin_unlock_irqrestore(&ath79_device_reset_lock, flags);
+ }
+ EXPORT_SYMBOL_GPL(ath79_device_reset_clear);
++
++u32 ath79_device_reset_get(u32 mask)
++{
++	unsigned long flags;
++	u32 reg;
++	u32 ret;
++
++	if (soc_is_ar71xx())
++		reg = AR71XX_RESET_REG_RESET_MODULE;
++	else if (soc_is_ar724x())
++		reg = AR724X_RESET_REG_RESET_MODULE;
++	else if (soc_is_ar913x())
++		reg = AR913X_RESET_REG_RESET_MODULE;
++	else if (soc_is_ar933x())
++		reg = AR933X_RESET_REG_RESET_MODULE;
++	else if (soc_is_ar934x())
++		reg = AR934X_RESET_REG_RESET_MODULE;
++	else
++		BUG();
++
++	spin_lock_irqsave(&ath79_device_reset_lock, flags);
++	ret = ath79_reset_rr(reg);
++	spin_unlock_irqrestore(&ath79_device_reset_lock, flags);
++	return ret;
++}
++EXPORT_SYMBOL_GPL(ath79_device_reset_get);
diff --git a/target/linux/ar71xx/patches-4.14/505-MIPS-ath79-add-ath79_gpio_function_select.patch b/target/linux/ar71xx/patches-4.14/505-MIPS-ath79-add-ath79_gpio_function_select.patch
new file mode 100644
index 0000000000..278e781539
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/505-MIPS-ath79-add-ath79_gpio_function_select.patch
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/common.h
++++ b/arch/mips/ath79/common.h
+@@ -27,6 +27,7 @@ void ath79_ddr_ctrl_init(void);
+ void ath79_gpio_function_enable(u32 mask);
+ void ath79_gpio_function_disable(u32 mask);
+ void ath79_gpio_function_setup(u32 set, u32 clear);
++void ath79_gpio_output_select(unsigned gpio, u8 val);
+ void ath79_gpio_init(void);
+ 
+ #endif /* __ATH79_COMMON_H */
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -57,3 +57,26 @@ void ath79_gpio_function_disable(u32 mas
+ {
+ 	ath79_gpio_function_setup(0, mask);
+ }
++
++void __init ath79_gpio_output_select(unsigned gpio, u8 val)
++{
++	void __iomem *base = ath79_gpio_base;
++	unsigned int reg;
++	u32 t, s;
++
++	BUG_ON(!soc_is_ar934x());
++
++	if (gpio >= AR934X_GPIO_COUNT)
++		return;
++
++	reg = AR934X_GPIO_REG_OUT_FUNC0 + 4 * (gpio / 4);
++	s = 8 * (gpio % 4);
++
++	t = __raw_readl(base + reg);
++	t &= ~(0xff << s);
++	t |= val << s;
++	__raw_writel(t, base + reg);
++
++	/* flush write */
++	(void) __raw_readl(base + reg);
++}
diff --git a/target/linux/ar71xx/patches-4.14/506-MIPS-ath79-prom-parse-redboot-args.patch b/target/linux/ar71xx/patches-4.14/506-MIPS-ath79-prom-parse-redboot-args.patch
new file mode 100644
index 0000000000..46beeffeea
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/506-MIPS-ath79-prom-parse-redboot-args.patch
@@ -0,0 +1,42 @@
+--- a/arch/mips/ath79/prom.c
++++ b/arch/mips/ath79/prom.c
+@@ -22,10 +22,39 @@
+ 
+ #include "common.h"
+ 
++static char ath79_cmdline_buf[COMMAND_LINE_SIZE] __initdata;
++
++static void __init ath79_prom_append_cmdline(const char *name,
++					      const char *value)
++{
++	snprintf(ath79_cmdline_buf, sizeof(ath79_cmdline_buf),
++		 " %s=%s", name, value);
++	strlcat(arcs_cmdline, ath79_cmdline_buf, sizeof(arcs_cmdline));
++}
++
+ void __init prom_init(void)
+ {
++	const char *env;
++
+ 	fw_init_cmdline();
+ 
++	env = fw_getenv("ethaddr");
++	if (env)
++		ath79_prom_append_cmdline("ethaddr", env);
++
++	env = fw_getenv("board");
++	if (env) {
++		/* Workaround for buggy bootloaders */
++		if (strcmp(env, "RouterStation") == 0 ||
++		    strcmp(env, "Ubiquiti AR71xx-based board") == 0)
++			env = "UBNT-RS";
++
++		if (strcmp(env, "RouterStation PRO") == 0)
++			env = "UBNT-RSPRO";
++
++		ath79_prom_append_cmdline("board", env);
++	}
++
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	/* Read the initrd address from the firmware environment */
+ 	initrd_start = fw_getenvl("initrd_start");
diff --git a/target/linux/ar71xx/patches-4.14/507-MIPS-ath79-prom-add-myloader-support.patch b/target/linux/ar71xx/patches-4.14/507-MIPS-ath79-prom-add-myloader-support.patch
new file mode 100644
index 0000000000..17a97335d2
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/507-MIPS-ath79-prom-add-myloader-support.patch
@@ -0,0 +1,55 @@
+--- a/arch/mips/ath79/prom.c
++++ b/arch/mips/ath79/prom.c
+@@ -19,6 +19,7 @@
+ #include <asm/bootinfo.h>
+ #include <asm/addrspace.h>
+ #include <asm/fw/fw.h>
++#include <asm/fw/myloader/myloader.h>
+ 
+ #include "common.h"
+ 
+@@ -32,10 +33,44 @@ static void __init ath79_prom_append_cmd
+ 	strlcat(arcs_cmdline, ath79_cmdline_buf, sizeof(arcs_cmdline));
+ }
+ 
++static int __init ath79_prom_init_myloader(void)
++{
++	struct myloader_info *mylo;
++	char mac_buf[32];
++	unsigned char *mac;
++
++	mylo = myloader_get_info();
++	if (!mylo)
++		return 0;
++
++	switch (mylo->did) {
++	case DEVID_COMPEX_WP543:
++		ath79_prom_append_cmdline("board", "WP543");
++		break;
++	case DEVID_COMPEX_WPE72:
++		ath79_prom_append_cmdline("board", "WPE72");
++		break;
++	default:
++		pr_warn("prom: unknown device id: %x\n", mylo->did);
++		return 0;
++	}
++
++	mac = mylo->macs[0];
++	snprintf(mac_buf, sizeof(mac_buf), "%02x:%02x:%02x:%02x:%02x:%02x",
++		 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
++
++	ath79_prom_append_cmdline("ethaddr", mac_buf);
++
++	return 1;
++}
++
+ void __init prom_init(void)
+ {
+ 	const char *env;
+ 
++	if (ath79_prom_init_myloader())
++		return;
++
+ 	fw_init_cmdline();
+ 
+ 	env = fw_getenv("ethaddr");
diff --git a/target/linux/ar71xx/patches-4.14/508-MIPS-ath79-prom-image-command-line-hack.patch b/target/linux/ar71xx/patches-4.14/508-MIPS-ath79-prom-image-command-line-hack.patch
new file mode 100644
index 0000000000..cfa5e72eec
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/508-MIPS-ath79-prom-image-command-line-hack.patch
@@ -0,0 +1,73 @@
+--- a/arch/mips/ath79/prom.c
++++ b/arch/mips/ath79/prom.c
+@@ -33,6 +33,41 @@ static void __init ath79_prom_append_cmd
+ 	strlcat(arcs_cmdline, ath79_cmdline_buf, sizeof(arcs_cmdline));
+ }
+ 
++#ifdef CONFIG_IMAGE_CMDLINE_HACK
++extern char __image_cmdline[];
++
++static int __init ath79_use_image_cmdline(void)
++{
++	char *p = __image_cmdline;
++	int replace = 0;
++
++	if (*p == '-') {
++		replace = 1;
++		p++;
++	}
++
++	if (*p == '\0')
++		return 0;
++
++	if (replace) {
++		strlcpy(arcs_cmdline, p, sizeof(arcs_cmdline));
++	} else {
++		strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
++		strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
++	}
++
++	/* Validate and setup environment pointer */
++	if (fw_arg2 < CKSEG0)
++		_fw_envp = NULL;
++	else
++		_fw_envp = (int *)fw_arg2;
++
++	return 1;
++}
++#else
++static inline int ath79_use_image_cmdline(void) { return 0; }
++#endif
++
+ static int __init ath79_prom_init_myloader(void)
+ {
+ 	struct myloader_info *mylo;
+@@ -61,6 +96,8 @@ static int __init ath79_prom_init_myload
+ 
+ 	ath79_prom_append_cmdline("ethaddr", mac_buf);
+ 
++	ath79_use_image_cmdline();
++
+ 	return 1;
+ }
+ 
+@@ -71,7 +108,8 @@ void __init prom_init(void)
+ 	if (ath79_prom_init_myloader())
+ 		return;
+ 
+-	fw_init_cmdline();
++	if (!ath79_use_image_cmdline())
++		fw_init_cmdline();
+ 
+ 	env = fw_getenv("ethaddr");
+ 	if (env)
+--- a/arch/mips/fw/lib/cmdline.c
++++ b/arch/mips/fw/lib/cmdline.c
+@@ -35,6 +35,7 @@ void __init fw_init_cmdline(void)
+ 	else
+ 		_fw_envp = (int *)fw_arg2;
+ 
++	arcs_cmdline[0] = '\0';
+ 	for (i = 1; i < fw_argc; i++) {
+ 		strlcat(arcs_cmdline, fw_argv(i), COMMAND_LINE_SIZE);
+ 		if (i < (fw_argc - 1))
diff --git a/target/linux/ar71xx/patches-4.14/509-MIPS-ath79-process-board-kernel-option.patch b/target/linux/ar71xx/patches-4.14/509-MIPS-ath79-process-board-kernel-option.patch
new file mode 100644
index 0000000000..3091ab69b6
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/509-MIPS-ath79-process-board-kernel-option.patch
@@ -0,0 +1,11 @@
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -283,6 +283,8 @@ void __init plat_time_init(void)
+ 	mips_hpt_frequency = cpu_clk_rate / 2;
+ }
+ 
++__setup("board=", mips_machtype_setup);
++
+ static int __init ath79_setup(void)
+ {
+ 	if  (mips_machtype == ATH79_MACH_GENERIC_OF)
diff --git a/target/linux/ar71xx/patches-4.14/510-MIPS-ath79-init-gpio-pin-of-wmac-device.patch b/target/linux/ar71xx/patches-4.14/510-MIPS-ath79-init-gpio-pin-of-wmac-device.patch
new file mode 100644
index 0000000000..2d2235e292
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/510-MIPS-ath79-init-gpio-pin-of-wmac-device.patch
@@ -0,0 +1,14 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -24,7 +24,10 @@
+ #include "dev-wmac.h"
+ 
+ static u8 ath79_wmac_mac[ETH_ALEN];
+-static struct ath9k_platform_data ath79_wmac_data;
++
++static struct ath9k_platform_data ath79_wmac_data = {
++	.led_pin = -1,
++};
+ 
+ static struct resource ath79_wmac_resources[] = {
+ 	{
diff --git a/target/linux/ar71xx/patches-4.14/520-MIPS-ath79-enable-UART-function.patch b/target/linux/ar71xx/patches-4.14/520-MIPS-ath79-enable-UART-function.patch
new file mode 100644
index 0000000000..c8649b7494
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/520-MIPS-ath79-enable-UART-function.patch
@@ -0,0 +1,18 @@
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -81,6 +81,15 @@ void __init ath79_register_uart(void)
+ 
+ 	uart_clk_rate = ath79_get_sys_clk_rate("uart");
+ 
++	if (soc_is_ar71xx())
++		ath79_gpio_function_enable(AR71XX_GPIO_FUNC_UART_EN);
++	else if (soc_is_ar724x())
++		ath79_gpio_function_enable(AR724X_GPIO_FUNC_UART_EN);
++	else if (soc_is_ar913x())
++		ath79_gpio_function_enable(AR913X_GPIO_FUNC_UART_EN);
++	else if (soc_is_ar933x())
++		ath79_gpio_function_enable(AR933X_GPIO_FUNC_UART_EN);
++
+ 	if (soc_is_ar71xx() ||
+ 	    soc_is_ar724x() ||
+ 	    soc_is_ar913x() ||
diff --git a/target/linux/ar71xx/patches-4.14/521-MIPS-ath79-enable-UART-for-early_serial.patch b/target/linux/ar71xx/patches-4.14/521-MIPS-ath79-enable-UART-for-early_serial.patch
new file mode 100644
index 0000000000..e546ff26fe
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/521-MIPS-ath79-enable-UART-for-early_serial.patch
@@ -0,0 +1,61 @@
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -58,6 +58,46 @@ static void prom_putchar_dummy(unsigned
+ 	/* nothing to do */
+ }
+ 
++static void prom_enable_uart(u32 id)
++{
++	void __iomem *gpio_base;
++	u32 uart_en;
++	u32 t;
++
++	switch (id) {
++	case REV_ID_MAJOR_AR71XX:
++		uart_en = AR71XX_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR7240:
++	case REV_ID_MAJOR_AR7241:
++	case REV_ID_MAJOR_AR7242:
++		uart_en = AR724X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR913X:
++		uart_en = AR913X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR9330:
++	case REV_ID_MAJOR_AR9331:
++		uart_en = AR933X_GPIO_FUNC_UART_EN;
++		break;
++
++	case REV_ID_MAJOR_AR9341:
++	case REV_ID_MAJOR_AR9342:
++	case REV_ID_MAJOR_AR9344:
++		/* TODO */
++	default:
++		return;
++	}
++
++	gpio_base = (void __iomem *)(KSEG1ADDR(AR71XX_GPIO_BASE));
++	t = __raw_readl(gpio_base + AR71XX_GPIO_REG_FUNC);
++	t |= uart_en;
++	__raw_writel(t, gpio_base + AR71XX_GPIO_REG_FUNC);
++}
++
+ static void prom_putchar_init(void)
+ {
+ 	void __iomem *base;
+@@ -88,8 +128,10 @@ static void prom_putchar_init(void)
+ 
+ 	default:
+ 		_prom_putchar = prom_putchar_dummy;
+-		break;
++		return;
+ 	}
++
++	prom_enable_uart(id);
+ }
+ 
+ void prom_putchar(unsigned char ch)
diff --git a/target/linux/ar71xx/patches-4.14/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch b/target/linux/ar71xx/patches-4.14/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch
new file mode 100644
index 0000000000..2d5559cb9d
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch
@@ -0,0 +1,21 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -190,3 +190,9 @@ void __init ath79_register_wmac(u8 *cal_
+ 
+ 	platform_device_register(&ath79_wmac_device);
+ }
++
++void __init ath79_register_wmac_simple(void)
++{
++	ath79_register_wmac(NULL, NULL);
++	ath79_wmac_data.eeprom_name = "soc_wmac.eeprom";
++}
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -13,5 +13,6 @@
+ #define _ATH79_DEV_WMAC_H
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
++void ath79_register_wmac_simple(void);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
diff --git a/target/linux/ar71xx/patches-4.14/523-MIPS-ath79-OTP-support.patch b/target/linux/ar71xx/patches-4.14/523-MIPS-ath79-OTP-support.patch
new file mode 100644
index 0000000000..d11d418f17
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/523-MIPS-ath79-OTP-support.patch
@@ -0,0 +1,192 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -166,6 +166,149 @@ static void qca955x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = true;
+ }
+ 
++#define AR93XX_WMAC_SIZE \
++	(soc_is_ar934x() ? AR934X_WMAC_SIZE : AR933X_WMAC_SIZE)
++#define AR93XX_WMAC_BASE \
++	(soc_is_ar934x() ? AR934X_WMAC_BASE : AR933X_WMAC_BASE)
++
++#define AR93XX_OTP_BASE \
++	(soc_is_ar934x() ? AR934X_OTP_BASE : AR9300_OTP_BASE)
++#define AR93XX_OTP_STATUS \
++	(soc_is_ar934x() ? AR934X_OTP_STATUS : AR9300_OTP_STATUS)
++#define AR93XX_OTP_READ_DATA \
++	(soc_is_ar934x() ? AR934X_OTP_READ_DATA : AR9300_OTP_READ_DATA)
++
++static bool __init
++ar93xx_wmac_otp_read_word(void __iomem *base, int addr, u32 *data)
++{
++	int timeout = 1000;
++	u32 val;
++
++	__raw_readl(base + AR93XX_OTP_BASE + (4 * addr));
++	while (timeout--) {
++		val = __raw_readl(base + AR93XX_OTP_STATUS);
++		if ((val & AR9300_OTP_STATUS_TYPE) == AR9300_OTP_STATUS_VALID)
++			break;
++
++		udelay(10);
++	}
++
++	if (!timeout)
++		return false;
++
++	*data = __raw_readl(base + AR93XX_OTP_READ_DATA);
++	return true;
++}
++
++static bool __init
++ar93xx_wmac_otp_read(void __iomem *base, int addr, u8 *dest, int len)
++{
++	u32 data;
++	int i;
++
++	for (i = 0; i < len; i++) {
++		int offset = 8 * ((addr - i) % 4);
++
++		if (!ar93xx_wmac_otp_read_word(base, (addr - i) / 4, &data))
++			return false;
++
++		dest[i] = (data >> offset) & 0xff;
++	}
++
++	return true;
++}
++
++static bool __init
++ar93xx_wmac_otp_uncompress(void __iomem *base, int addr, int len, u8 *dest,
++			   int dest_start, int dest_len)
++{
++	int dest_bytes = 0;
++	int offset = 0;
++	int end = addr - len;
++	u8 hdr[2];
++
++	while (addr > end) {
++		if (!ar93xx_wmac_otp_read(base, addr, hdr, 2))
++			return false;
++
++		addr -= 2;
++		offset += hdr[0];
++
++		if (offset <= dest_start + dest_len &&
++		    offset + len >= dest_start) {
++			int data_offset = 0;
++			int dest_offset = 0;
++			int copy_len;
++
++			if (offset < dest_start)
++				data_offset = dest_start - offset;
++			else
++				dest_offset = offset - dest_start;
++
++			copy_len = len - data_offset;
++			if (copy_len > dest_len - dest_offset)
++				copy_len = dest_len - dest_offset;
++
++			ar93xx_wmac_otp_read(base, addr - data_offset,
++					     dest + dest_offset,
++					     copy_len);
++
++			dest_bytes += copy_len;
++		}
++		addr -= hdr[1];
++	}
++	return !!dest_bytes;
++}
++
++bool __init ar93xx_wmac_read_mac_address(u8 *dest)
++{
++	void __iomem *base;
++	bool ret = false;
++	int addr = 0x1ff;
++	unsigned int len;
++	u32 hdr_u32;
++	u8 *hdr = (u8 *) &hdr_u32;
++	u8 mac[6] = { 0x00, 0x02, 0x03, 0x04, 0x05, 0x06 };
++	int mac_start = 2, mac_end = 8;
++
++	BUG_ON(!soc_is_ar933x() && !soc_is_ar934x());
++	base = ioremap_nocache(AR93XX_WMAC_BASE, AR93XX_WMAC_SIZE);
++	while (addr > sizeof(hdr_u32)) {
++		if (!ar93xx_wmac_otp_read(base, addr, hdr, sizeof(hdr_u32)))
++			break;
++
++		if (hdr_u32 == 0 || hdr_u32 == ~0)
++			break;
++
++		len = (hdr[1] << 4) | (hdr[2] >> 4);
++		addr -= 4;
++
++		switch (hdr[0] >> 5) {
++		case 0:
++			if (len < mac_end)
++				break;
++
++			ar93xx_wmac_otp_read(base, addr - mac_start, mac, 6);
++			ret = true;
++			break;
++		case 3:
++			ret |= ar93xx_wmac_otp_uncompress(base, addr, len, mac,
++							  mac_start, 6);
++			break;
++		default:
++			break;
++		}
++
++		addr -= len + 2;
++	}
++
++	iounmap(base);
++	if (ret)
++		memcpy(dest, mac, 6);
++
++	return ret;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -14,5 +14,6 @@
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+ void ath79_register_wmac_simple(void);
++bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -112,6 +112,14 @@
+ #define QCA955X_EHCI1_BASE	0x1b400000
+ #define QCA955X_EHCI_SIZE	0x1000
+ 
++#define AR9300_OTP_BASE		0x14000
++#define AR9300_OTP_STATUS	0x15f18
++#define AR9300_OTP_STATUS_TYPE		0x7
++#define AR9300_OTP_STATUS_VALID		0x4
++#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
++#define AR9300_OTP_STATUS_SM_BUSY	0x1
++#define AR9300_OTP_READ_DATA	0x15f1c
++
+ /*
+  * DDR_CTRL block
+  */
+@@ -149,6 +157,13 @@
+ #define AR934X_DDR_REG_FLUSH_PCIE	0xa8
+ #define AR934X_DDR_REG_FLUSH_WMAC	0xac
+ 
++#define AR934X_OTP_BASE					0x30000
++#define AR934X_OTP_STATUS				0x31018
++#define AR934X_OTP_READ_DATA				0x3101c
++#define AR934X_OTP_INTF2_ADDRESS			0x31008
++#define AR934X_OTP_INTF3_ADDRESS			0x3100c
++#define AR934X_OTP_PGENB_SETUP_HOLD_TIME_ADDRESS	0x31034
++
+ /*
+  * PLL block
+  */
diff --git a/target/linux/ar71xx/patches-4.14/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch b/target/linux/ar71xx/patches-4.14/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch
new file mode 100644
index 0000000000..91e037e247
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch
@@ -0,0 +1,31 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -309,6 +309,16 @@ bool __init ar93xx_wmac_read_mac_address
+ 	return ret;
+ }
+ 
++void __init ath79_wmac_disable_2ghz(void)
++{
++	ath79_wmac_data.disable_2ghz = true;
++}
++
++void __init ath79_wmac_disable_5ghz(void)
++{
++	ath79_wmac_data.disable_5ghz = true;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -14,6 +14,9 @@
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+ void ath79_register_wmac_simple(void);
++void ath79_wmac_disable_2ghz(void);
++void ath79_wmac_disable_5ghz(void);
++
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
diff --git a/target/linux/ar71xx/patches-4.14/525-MIPS-ath79-enable-qca-usb-quirks.patch b/target/linux/ar71xx/patches-4.14/525-MIPS-ath79-enable-qca-usb-quirks.patch
new file mode 100644
index 0000000000..0e33674adf
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/525-MIPS-ath79-enable-qca-usb-quirks.patch
@@ -0,0 +1,101 @@
+--- a/arch/mips/ath79/dev-usb.c
++++ b/arch/mips/ath79/dev-usb.c
+@@ -37,6 +37,8 @@ static struct usb_ehci_pdata ath79_ehci_
+ static struct usb_ehci_pdata ath79_ehci_pdata_v2 = {
+ 	.caps_offset		= 0x100,
+ 	.has_tt			= 1,
++	.qca_force_host_mode	= 1,
++	.qca_force_16bit_ptw	= 1,
+ };
+ 
+ static void __init ath79_usb_register(const char *name, int id,
+@@ -159,6 +161,9 @@ static void __init ar913x_usb_setup(void
+ 	ath79_device_reset_clear(AR913X_RESET_USB_PHY);
+ 	mdelay(10);
+ 
++	ath79_ehci_pdata_v2.qca_force_host_mode	= 0;
++	ath79_ehci_pdata_v2.qca_force_16bit_ptw	= 0;
++
+ 	ath79_usb_register("ehci-platform", -1,
+ 			   AR913X_EHCI_BASE, AR913X_EHCI_SIZE,
+ 			   ATH79_CPU_IRQ(3),
+@@ -182,14 +187,34 @@ static void __init ar933x_usb_setup(void
+ 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+ }
+ 
+-static void __init ar934x_usb_setup(void)
++static void enable_tx_tx_idp_violation_fix(unsigned base)
+ {
+-	u32 bootstrap;
++	void __iomem *phy_reg;
++	u32 t;
++
++	phy_reg = ioremap(base, 4);
++	if (!phy_reg)
++		return;
++
++	t = ioread32(phy_reg);
++	t &= ~0xff;
++	t |= 0x58;
++	iowrite32(t, phy_reg);
++
++	iounmap(phy_reg);
++}
+ 
+-	bootstrap = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+-	if (bootstrap & AR934X_BOOTSTRAP_USB_MODE_DEVICE)
++static void ar934x_usb_reset_notifier(struct platform_device *pdev)
++{
++	if (pdev->id != -1)
+ 		return;
+ 
++	enable_tx_tx_idp_violation_fix(0x18116c94);
++	dev_info(&pdev->dev, "TX-TX IDP fix enabled\n");
++}
++
++static void __init ar934x_usb_setup(void)
++{
+ 	ath79_device_reset_set(AR934X_RESET_USBSUS_OVERRIDE);
+ 	udelay(1000);
+ 
+@@ -202,14 +227,40 @@ static void __init ar934x_usb_setup(void
+ 	ath79_device_reset_clear(AR934X_RESET_USB_HOST);
+ 	udelay(1000);
+ 
++	if (ath79_soc_rev >= 3)
++		ath79_ehci_pdata_v2.reset_notifier = ar934x_usb_reset_notifier;
++
+ 	ath79_usb_register("ehci-platform", -1,
+ 			   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
+ 			   ATH79_CPU_IRQ(3),
+ 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+ }
+ 
++static void qca955x_usb_reset_notifier(struct platform_device *pdev)
++{
++	u32 base;
++
++	switch (pdev->id) {
++	case 0:
++		base = 0x18116c94;
++		break;
++
++	case 1:
++		base = 0x18116e54;
++		break;
++
++	default:
++		return;
++	}
++
++	enable_tx_tx_idp_violation_fix(base);
++	dev_info(&pdev->dev, "TX-TX IDP fix enabled\n");
++}
++
+ static void __init qca955x_usb_setup(void)
+ {
++	ath79_ehci_pdata_v2.reset_notifier = qca955x_usb_reset_notifier;
++
+ 	ath79_usb_register("ehci-platform", 0,
+ 			   QCA955X_EHCI0_BASE, QCA955X_EHCI_SIZE,
+ 			   ATH79_IP3_IRQ(0),
diff --git a/target/linux/ar71xx/patches-4.14/601-MIPS-ath79-add-more-register-defines.patch b/target/linux/ar71xx/patches-4.14/601-MIPS-ath79-add-more-register-defines.patch
new file mode 100644
index 0000000000..2b6cc9e3fb
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/601-MIPS-ath79-add-more-register-defines.patch
@@ -0,0 +1,456 @@
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -20,6 +20,10 @@
+ #include <linux/bitops.h>
+ 
+ #define AR71XX_APB_BASE		0x18000000
++#define AR71XX_GE0_BASE		0x19000000
++#define AR71XX_GE0_SIZE		0x10000
++#define AR71XX_GE1_BASE		0x1a000000
++#define AR71XX_GE1_SIZE		0x10000
+ #define AR71XX_EHCI_BASE	0x1b000000
+ #define AR71XX_EHCI_SIZE	0x1000
+ #define AR71XX_OHCI_BASE	0x1c000000
+@@ -39,6 +43,8 @@
+ #define AR71XX_PLL_SIZE		0x100
+ #define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+ #define AR71XX_RESET_SIZE	0x100
++#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
++#define AR71XX_MII_SIZE		0x100
+ 
+ #define AR71XX_PCI_MEM_BASE	0x10000000
+ #define AR71XX_PCI_MEM_SIZE	0x07000000
+@@ -81,15 +87,21 @@
+ 
+ #define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+ #define AR933X_UART_SIZE	0x14
++#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define AR933X_GMAC_SIZE	0x04
+ #define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define AR933X_WMAC_SIZE	0x20000
+ #define AR933X_EHCI_BASE	0x1b000000
+ #define AR933X_EHCI_SIZE	0x1000
+ 
++#define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define AR934X_GMAC_SIZE	0x14
+ #define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define AR934X_WMAC_SIZE	0x20000
+ #define AR934X_EHCI_BASE	0x1b000000
+ #define AR934X_EHCI_SIZE	0x200
++#define AR934X_NFC_BASE		0x1b000200
++#define AR934X_NFC_SIZE		0xb8
+ #define AR934X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
+ #define AR934X_SRIF_SIZE	0x1000
+ 
+@@ -106,11 +118,15 @@
+ #define QCA955X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
+ #define QCA955X_PCI_CTRL_SIZE	0x100
+ 
++#define QCA955X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA955X_GMAC_SIZE	0x40
+ #define QCA955X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+ #define QCA955X_WMAC_SIZE	0x20000
+ #define QCA955X_EHCI0_BASE	0x1b000000
+ #define QCA955X_EHCI1_BASE	0x1b400000
+ #define QCA955X_EHCI_SIZE	0x1000
++#define QCA955X_NFC_BASE	0x1b800200
++#define QCA955X_NFC_SIZE	0xb8
+ 
+ #define AR9300_OTP_BASE		0x14000
+ #define AR9300_OTP_STATUS	0x15f18
+@@ -181,6 +197,9 @@
+ #define AR71XX_AHB_DIV_SHIFT		20
+ #define AR71XX_AHB_DIV_MASK		0x7
+ 
++#define AR71XX_ETH0_PLL_SHIFT		17
++#define AR71XX_ETH1_PLL_SHIFT		19
++
+ #define AR724X_PLL_REG_CPU_CONFIG	0x00
+ #define AR724X_PLL_REG_PCIE_CONFIG	0x10
+ 
+@@ -193,6 +212,8 @@
+ #define AR724X_DDR_DIV_SHIFT		22
+ #define AR724X_DDR_DIV_MASK		0x3
+ 
++#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
++
+ #define AR913X_PLL_REG_CPU_CONFIG	0x00
+ #define AR913X_PLL_REG_ETH_CONFIG	0x04
+ #define AR913X_PLL_REG_ETH0_INT_CLOCK	0x14
+@@ -205,6 +226,9 @@
+ #define AR913X_AHB_DIV_SHIFT		19
+ #define AR913X_AHB_DIV_MASK		0x1
+ 
++#define AR913X_ETH0_PLL_SHIFT		20
++#define AR913X_ETH1_PLL_SHIFT		22
++
+ #define AR933X_PLL_CPU_CONFIG_REG	0x00
+ #define AR933X_PLL_CLOCK_CTRL_REG	0x08
+ 
+@@ -226,6 +250,8 @@
+ #define AR934X_PLL_CPU_CONFIG_REG		0x00
+ #define AR934X_PLL_DDR_CONFIG_REG		0x04
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_REG		0x08
++#define AR934X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
++#define AR934X_PLL_ETH_XMII_CONTROL_REG		0x2c
+ 
+ #define AR934X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+ #define AR934X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+@@ -258,9 +284,13 @@
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
+ #define AR934X_PLL_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
+ 
++#define AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL	BIT(6)
++
+ #define QCA955X_PLL_CPU_CONFIG_REG		0x00
+ #define QCA955X_PLL_DDR_CONFIG_REG		0x04
+ #define QCA955X_PLL_CLK_CTRL_REG		0x08
++#define QCA955X_PLL_ETH_XMII_CONTROL_REG	0x28
++#define QCA955X_PLL_ETH_SGMII_CONTROL_REG	0x48
+ 
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+@@ -385,16 +415,83 @@
+ #define AR913X_RESET_USB_HOST		BIT(5)
+ #define AR913X_RESET_USB_PHY		BIT(4)
+ 
++#define AR933X_RESET_GE1_MDIO		BIT(23)
++#define AR933X_RESET_GE0_MDIO		BIT(22)
++#define AR933X_RESET_GE1_MAC		BIT(13)
+ #define AR933X_RESET_WMAC		BIT(11)
++#define AR933X_RESET_GE0_MAC		BIT(9)
+ #define AR933X_RESET_USB_HOST		BIT(5)
+ #define AR933X_RESET_USB_PHY		BIT(4)
+ #define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
+ 
++#define AR934X_RESET_HOST		BIT(31)
++#define AR934X_RESET_SLIC		BIT(30)
++#define AR934X_RESET_HDMA		BIT(29)
++#define AR934X_RESET_EXTERNAL		BIT(28)
++#define AR934X_RESET_RTC		BIT(27)
++#define AR934X_RESET_PCIE_EP_INT	BIT(26)
++#define AR934X_RESET_CHKSUM_ACC		BIT(25)
++#define AR934X_RESET_FULL_CHIP		BIT(24)
++#define AR934X_RESET_GE1_MDIO		BIT(23)
++#define AR934X_RESET_GE0_MDIO		BIT(22)
++#define AR934X_RESET_CPU_NMI		BIT(21)
++#define AR934X_RESET_CPU_COLD		BIT(20)
++#define AR934X_RESET_HOST_RESET_INT	BIT(19)
++#define AR934X_RESET_PCIE_EP		BIT(18)
++#define AR934X_RESET_UART1		BIT(17)
++#define AR934X_RESET_DDR		BIT(16)
++#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define AR934X_RESET_NANDF		BIT(14)
++#define AR934X_RESET_GE1_MAC		BIT(13)
++#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
+ #define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
++#define AR934X_RESET_HOST_DMA_INT	BIT(10)
++#define AR934X_RESET_GE0_MAC		BIT(9)
++#define AR934X_RESET_ETH_SWITCH		BIT(8)
++#define AR934X_RESET_PCIE_PHY		BIT(7)
++#define AR934X_RESET_PCIE		BIT(6)
+ #define AR934X_RESET_USB_HOST		BIT(5)
+ #define AR934X_RESET_USB_PHY		BIT(4)
+ #define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
+-
++#define AR934X_RESET_LUT		BIT(2)
++#define AR934X_RESET_MBOX		BIT(1)
++#define AR934X_RESET_I2S		BIT(0)
++
++#define QCA955X_RESET_HOST		BIT(31)
++#define QCA955X_RESET_SLIC		BIT(30)
++#define QCA955X_RESET_HDMA		BIT(29)
++#define QCA955X_RESET_EXTERNAL		BIT(28)
++#define QCA955X_RESET_RTC		BIT(27)
++#define QCA955X_RESET_PCIE_EP_INT	BIT(26)
++#define QCA955X_RESET_CHKSUM_ACC	BIT(25)
++#define QCA955X_RESET_FULL_CHIP		BIT(24)
++#define QCA955X_RESET_GE1_MDIO		BIT(23)
++#define QCA955X_RESET_GE0_MDIO		BIT(22)
++#define QCA955X_RESET_CPU_NMI		BIT(21)
++#define QCA955X_RESET_CPU_COLD		BIT(20)
++#define QCA955X_RESET_HOST_RESET_INT	BIT(19)
++#define QCA955X_RESET_PCIE_EP		BIT(18)
++#define QCA955X_RESET_UART1		BIT(17)
++#define QCA955X_RESET_DDR		BIT(16)
++#define QCA955X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define QCA955X_RESET_NANDF		BIT(14)
++#define QCA955X_RESET_GE1_MAC		BIT(13)
++#define QCA955X_RESET_SGMII_ANALOG	BIT(12)
++#define QCA955X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA955X_RESET_HOST_DMA_INT	BIT(10)
++#define QCA955X_RESET_GE0_MAC		BIT(9)
++#define QCA955X_RESET_SGMII		BIT(8)
++#define QCA955X_RESET_PCIE_PHY		BIT(7)
++#define QCA955X_RESET_PCIE		BIT(6)
++#define QCA955X_RESET_USB_HOST		BIT(5)
++#define QCA955X_RESET_USB_PHY		BIT(4)
++#define QCA955X_RESET_USBSUS_OVERRIDE	BIT(3)
++#define QCA955X_RESET_LUT		BIT(2)
++#define QCA955X_RESET_MBOX		BIT(1)
++#define QCA955X_RESET_I2S		BIT(0)
++
++#define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
++#define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
+ #define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
+ 
+ #define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
+@@ -536,8 +633,22 @@
+ #define AR71XX_GPIO_REG_INT_ENABLE	0x24
+ #define AR71XX_GPIO_REG_FUNC		0x28
+ 
++#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
++#define AR934X_GPIO_REG_OUT_FUNC1	0x30
++#define AR934X_GPIO_REG_OUT_FUNC2	0x34
++#define AR934X_GPIO_REG_OUT_FUNC3	0x38
++#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
++#define AR934X_GPIO_REG_OUT_FUNC5	0x40
+ #define AR934X_GPIO_REG_FUNC		0x6c
+ 
++#define QCA955X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA955X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA955X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA955X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA955X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA955X_GPIO_REG_OUT_FUNC5	0x40
++#define QCA955X_GPIO_REG_FUNC		0x6c
++
+ #define AR71XX_GPIO_COUNT		16
+ #define AR7240_GPIO_COUNT		18
+ #define AR7241_GPIO_COUNT		20
+@@ -567,4 +678,235 @@
+ #define AR934X_SRIF_DPLL2_OUTDIV_SHIFT	13
+ #define AR934X_SRIF_DPLL2_OUTDIV_MASK	0x7
+ 
++#define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
++#define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
++#define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
++#define AR71XX_GPIO_FUNC_SPI_CS1_EN		BIT(12)
++#define AR71XX_GPIO_FUNC_UART_EN		BIT(8)
++#define AR71XX_GPIO_FUNC_USB_OC_EN		BIT(4)
++#define AR71XX_GPIO_FUNC_USB_CLK_EN		BIT(0)
++
++#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
++#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
++#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
++#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
++#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
++#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
++#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
++#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
++#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
++#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
++#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
++#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
++#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
++
++#define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
++#define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
++#define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
++#define AR913X_GPIO_FUNC_I2S_MCKEN		BIT(19)
++#define AR913X_GPIO_FUNC_I2S1_EN		BIT(18)
++#define AR913X_GPIO_FUNC_I2S0_EN		BIT(17)
++#define AR913X_GPIO_FUNC_SLIC_EN		BIT(16)
++#define AR913X_GPIO_FUNC_UART_RTSCTS_EN		BIT(9)
++#define AR913X_GPIO_FUNC_UART_EN		BIT(8)
++#define AR913X_GPIO_FUNC_USB_CLK_EN		BIT(4)
++
++#define AR933X_GPIO_FUNC_SPDIF2TCK		BIT(31)
++#define AR933X_GPIO_FUNC_SPDIF_EN		BIT(30)
++#define AR933X_GPIO_FUNC_I2SO_22_18_EN		BIT(29)
++#define AR933X_GPIO_FUNC_I2S_MCK_EN		BIT(27)
++#define AR933X_GPIO_FUNC_I2SO_EN		BIT(26)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_DUPL	BIT(25)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_COLL	BIT(24)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_ACT	BIT(23)
++#define AR933X_GPIO_FUNC_SPI_EN			BIT(18)
++#define AR933X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
++#define AR933X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
++#define AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
++#define AR933X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
++#define AR933X_GPIO_FUNC_UART_EN		BIT(1)
++#define AR933X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
++
++#define AR934X_GPIO_FUNC_CLK_OBS7_EN		BIT(9)
++#define AR934X_GPIO_FUNC_CLK_OBS6_EN		BIT(8)
++#define AR934X_GPIO_FUNC_CLK_OBS5_EN		BIT(7)
++#define AR934X_GPIO_FUNC_CLK_OBS4_EN		BIT(6)
++#define AR934X_GPIO_FUNC_CLK_OBS3_EN		BIT(5)
++#define AR934X_GPIO_FUNC_CLK_OBS2_EN		BIT(4)
++#define AR934X_GPIO_FUNC_CLK_OBS1_EN		BIT(3)
++#define AR934X_GPIO_FUNC_CLK_OBS0_EN		BIT(2)
++#define AR934X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
++
++#define AR934X_GPIO_OUT_GPIO		0
++#define AR934X_GPIO_OUT_SPI_CS1	7
++#define AR934X_GPIO_OUT_LED_LINK0	41
++#define AR934X_GPIO_OUT_LED_LINK1	42
++#define AR934X_GPIO_OUT_LED_LINK2	43
++#define AR934X_GPIO_OUT_LED_LINK3	44
++#define AR934X_GPIO_OUT_LED_LINK4	45
++#define AR934X_GPIO_OUT_EXT_LNA0	46
++#define AR934X_GPIO_OUT_EXT_LNA1	47
++
++#define QCA955X_GPIO_FUNC_CLK_OBS7_EN		BIT(9)
++#define QCA955X_GPIO_FUNC_CLK_OBS6_EN		BIT(8)
++#define QCA955X_GPIO_FUNC_CLK_OBS5_EN		BIT(7)
++#define QCA955X_GPIO_FUNC_CLK_OBS4_EN		BIT(6)
++#define QCA955X_GPIO_FUNC_CLK_OBS3_EN		BIT(5)
++#define QCA955X_GPIO_FUNC_CLK_OBS2_EN		BIT(4)
++#define QCA955X_GPIO_FUNC_CLK_OBS1_EN		BIT(3)
++#define QCA955X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
++
++#define QCA955X_GPIO_OUT_GPIO		0
++#define QCA955X_MII_EXT_MDI		1
++#define QCA955X_SLIC_DATA_OUT		3
++#define QCA955X_SLIC_PCM_FS		4
++#define QCA955X_SLIC_PCM_CLK		5
++#define QCA955X_SPI_CLK			8
++#define QCA955X_SPI_CS_0		9
++#define QCA955X_SPI_CS_1		10
++#define QCA955X_SPI_CS_2		11
++#define QCA955X_SPI_MISO		12
++#define QCA955X_I2S_CLK			13
++#define QCA955X_I2S_WS			14
++#define QCA955X_I2S_SD			15
++#define QCA955X_I2S_MCK			16
++#define QCA955X_SPDIF_OUT		17
++#define QCA955X_UART1_TD		18
++#define QCA955X_UART1_RTS		19
++#define QCA955X_UART1_RD		20
++#define QCA955X_UART1_CTS		21
++#define QCA955X_UART0_SOUT		22
++#define QCA955X_SPDIF2_OUT		23
++#define QCA955X_LED_SGMII_SPEED0	24
++#define QCA955X_LED_SGMII_SPEED1	25
++#define QCA955X_LED_SGMII_DUPLEX	26
++#define QCA955X_LED_SGMII_LINK_UP	27
++#define QCA955X_SGMII_SPEED0_INVERT	28
++#define QCA955X_SGMII_SPEED1_INVERT	29
++#define QCA955X_SGMII_DUPLEX_INVERT	30
++#define QCA955X_SGMII_LINK_UP_INVERT	31
++#define QCA955X_GE1_MII_MDO		32
++#define QCA955X_GE1_MII_MDC		33
++#define QCA955X_SWCOM2			38
++#define QCA955X_SWCOM3			39
++#define QCA955X_MAC2_GPIO		40
++#define QCA955X_MAC3_GPIO		41
++#define QCA955X_ATT_LED			42
++#define QCA955X_PWR_LED			43
++#define QCA955X_TX_FRAME		44
++#define QCA955X_RX_CLEAR_EXTERNAL	45
++#define QCA955X_LED_NETWORK_EN		46
++#define QCA955X_LED_POWER_EN		47
++#define QCA955X_WMAC_GLUE_WOW		68
++#define QCA955X_RX_CLEAR_EXTENSION	70
++#define QCA955X_CP_NAND_CS1		73
++#define QCA955X_USB_SUSPEND		74
++#define QCA955X_ETH_TX_ERR		75
++#define QCA955X_DDR_DQ_OE		76
++#define QCA955X_CLKREQ_N_EP		77
++#define QCA955X_CLKREQ_N_RC		78
++#define QCA955X_CLK_OBS0		79
++#define QCA955X_CLK_OBS1		80
++#define QCA955X_CLK_OBS2		81
++#define QCA955X_CLK_OBS3		82
++#define QCA955X_CLK_OBS4		83
++#define QCA955X_CLK_OBS5		84
++
++/*
++ * MII_CTRL block
++ */
++#define AR71XX_MII_REG_MII0_CTRL	0x00
++#define AR71XX_MII_REG_MII1_CTRL	0x04
++
++#define AR71XX_MII_CTRL_IF_MASK		3
++#define AR71XX_MII_CTRL_SPEED_SHIFT	4
++#define AR71XX_MII_CTRL_SPEED_MASK	3
++#define AR71XX_MII_CTRL_SPEED_10	0
++#define AR71XX_MII_CTRL_SPEED_100	1
++#define AR71XX_MII_CTRL_SPEED_1000	2
++
++#define AR71XX_MII0_CTRL_IF_GMII	0
++#define AR71XX_MII0_CTRL_IF_MII		1
++#define AR71XX_MII0_CTRL_IF_RGMII	2
++#define AR71XX_MII0_CTRL_IF_RMII	3
++
++#define AR71XX_MII1_CTRL_IF_RGMII	0
++#define AR71XX_MII1_CTRL_IF_RMII	1
++
++/*
++ * AR933X GMAC interface
++ */
++#define AR933X_GMAC_REG_ETH_CFG		0x00
++
++#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
++#define AR933X_ETH_CFG_MII_GE0		BIT(1)
++#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
++#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
++#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
++#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
++#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
++#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
++#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
++#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
++#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
++
++/*
++ * AR934X GMAC Interface
++ */
++#define AR934X_GMAC_REG_ETH_CFG		0x00
++
++#define AR934X_ETH_CFG_RGMII_GMAC0	BIT(0)
++#define AR934X_ETH_CFG_MII_GMAC0	BIT(1)
++#define AR934X_ETH_CFG_GMII_GMAC0	BIT(2)
++#define AR934X_ETH_CFG_MII_GMAC0_MASTER	BIT(3)
++#define AR934X_ETH_CFG_MII_GMAC0_SLAVE	BIT(4)
++#define AR934X_ETH_CFG_MII_GMAC0_ERR_EN	BIT(5)
++#define AR934X_ETH_CFG_SW_ONLY_MODE	BIT(6)
++#define AR934X_ETH_CFG_SW_PHY_SWAP	BIT(7)
++#define AR934X_ETH_CFG_SW_APB_ACCESS	BIT(9)
++#define AR934X_ETH_CFG_RMII_GMAC0	BIT(10)
++#define AR933X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
++#define AR934X_ETH_CFG_RMII_GMAC0_MASTER BIT(12)
++#define AR933X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++#define AR934X_ETH_CFG_RXD_DELAY        BIT(14)
++#define AR934X_ETH_CFG_RXD_DELAY_MASK   0x3
++#define AR934X_ETH_CFG_RXD_DELAY_SHIFT  14
++#define AR934X_ETH_CFG_RDV_DELAY        BIT(16)
++#define AR934X_ETH_CFG_RDV_DELAY_MASK   0x3
++#define AR934X_ETH_CFG_RDV_DELAY_SHIFT  16
++
++/*
++ * QCA955X GMAC Interface
++ */
++
++#define QCA955X_GMAC_REG_ETH_CFG	0x00
++
++#define QCA955X_ETH_CFG_RGMII_EN	BIT(0)
++#define QCA955X_ETH_CFG_MII_GE0		BIT(1)
++#define QCA955X_ETH_CFG_GMII_GE0	BIT(2)
++#define QCA955X_ETH_CFG_MII_GE0_MASTER	BIT(3)
++#define QCA955X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
++#define QCA955X_ETH_CFG_GE0_ERR_EN	BIT(5)
++#define QCA955X_ETH_CFG_GE0_SGMII	BIT(6)
++#define QCA955X_ETH_CFG_RMII_GE0	BIT(10)
++#define QCA955X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
++#define QCA955X_ETH_CFG_RMII_GE0_MASTER	BIT(12)
++#define QCA955X_ETH_CFG_RXD_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_RXD_DELAY_SHIFT	14
++#define QCA955X_ETH_CFG_RDV_DELAY	BIT(16)
++#define QCA955X_ETH_CFG_RDV_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_RDV_DELAY_SHIFT	16
++#define QCA955X_ETH_CFG_TXD_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_TXD_DELAY_SHIFT	18
++#define QCA955X_ETH_CFG_TXE_DELAY_MASK	0x3
++#define QCA955X_ETH_CFG_TXE_DELAY_SHIFT	20
++
+ #endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/ar71xx/patches-4.14/602-MIPS-ath79-add-openwrt-stuff.patch b/target/linux/ar71xx/patches-4.14/602-MIPS-ath79-add-openwrt-stuff.patch
new file mode 100644
index 0000000000..047be0c7fd
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/602-MIPS-ath79-add-openwrt-stuff.patch
@@ -0,0 +1,49 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -99,6 +99,20 @@ config SOC_QCA955X
+ 	select PCI_AR724X if PCI
+ 	def_bool n
+ 
++config ATH79_DEV_M25P80
++	select ATH79_DEV_SPI
++	def_bool n
++
++config ATH79_DEV_AP9X_PCI
++	select ATH79_PCI_ATH9K_FIXUP
++	def_bool n
++
++config ATH79_DEV_DSA
++	def_bool n
++
++config ATH79_DEV_ETH
++	def_bool n
++
+ config PCI_AR724X
+ 	def_bool n
+ 
+@@ -108,6 +122,10 @@ config ATH79_DEV_GPIO_BUTTONS
+ config ATH79_DEV_LEDS_GPIO
+ 	def_bool n
+ 
++config ATH79_DEV_NFC
++	depends on (SOC_AR934X || SOC_QCA955X)
++	def_bool n
++
+ config ATH79_DEV_SPI
+ 	def_bool n
+ 
+@@ -118,4 +136,14 @@ config ATH79_DEV_WMAC
+ 	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA955X)
+ 	def_bool n
+ 
++config ATH79_NVRAM
++	def_bool n
++
++config ATH79_PCI_ATH9K_FIXUP
++	def_bool n
++
++config ATH79_ROUTERBOOT
++	select LZO_DECOMPRESS
++	def_bool n
++
+ endif
diff --git a/target/linux/ar71xx/patches-4.14/603-MIPS-ath79-ap121-fixes.patch b/target/linux/ar71xx/patches-4.14/603-MIPS-ath79-ap121-fixes.patch
new file mode 100644
index 0000000000..7c71d11601
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/603-MIPS-ath79-ap121-fixes.patch
@@ -0,0 +1,149 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -6,9 +6,10 @@ menu "Atheros AR71XX/AR724X/AR913X machine selection"
+ config ATH79_MACH_AP121
+ 	bool "Atheros AP121 reference board"
+ 	select SOC_AR933X
++	select ATH79_DEV_ETH
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
++	select ATH79_DEV_M25P80
+ 	select ATH79_DEV_USB
+ 	select ATH79_DEV_WMAC
+ 	help
+--- a/arch/mips/ath79/mach-ap121.c
++++ b/arch/mips/ath79/mach-ap121.c
+@@ -1,19 +1,21 @@
+ /*
+  *  Atheros AP121 board support
+  *
+- *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
++ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+  *
+  *  This program is free software; you can redistribute it and/or modify it
+  *  under the terms of the GNU General Public License version 2 as published
+  *  by the Free Software Foundation.
+  */
+ 
+-#include "machtypes.h"
++#include "dev-eth.h"
+ #include "dev-gpio-buttons.h"
+ #include "dev-leds-gpio.h"
++#include "dev-m25p80.h"
+ #include "dev-spi.h"
+ #include "dev-usb.h"
+ #include "dev-wmac.h"
++#include "machtypes.h"
+ 
+ #define AP121_GPIO_LED_WLAN		0
+ #define AP121_GPIO_LED_USB		1
+@@ -24,7 +26,14 @@
+ #define AP121_KEYS_POLL_INTERVAL	20	/* msecs */
+ #define AP121_KEYS_DEBOUNCE_INTERVAL	(3 * AP121_KEYS_POLL_INTERVAL)
+ 
+-#define AP121_CAL_DATA_ADDR	0x1fff1000
++#define AP121_MAC0_OFFSET		0x0000
++#define AP121_MAC1_OFFSET		0x0006
++#define AP121_CALDATA_OFFSET		0x1000
++#define AP121_WMAC_MAC_OFFSET		0x1002
++
++#define AP121_MINI_GPIO_LED_WLAN	0
++#define AP121_MINI_GPIO_BTN_JUMPSTART	12
++#define AP121_MINI_GPIO_BTN_RESET	11
+ 
+ static struct gpio_led ap121_leds_gpio[] __initdata = {
+ 	{
+@@ -58,35 +67,78 @@ static struct gpio_keys_button ap121_gpio_keys[] __initdata = {
+ 	}
+ };
+ 
+-static struct spi_board_info ap121_spi_info[] = {
++static struct gpio_led ap121_mini_leds_gpio[] __initdata = {
+ 	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "mx25l1606e",
+-	}
++		.name		= "ap121:green:wlan",
++		.gpio		= AP121_MINI_GPIO_LED_WLAN,
++		.active_low	= 0,
++	},
+ };
+ 
+-static struct ath79_spi_platform_data ap121_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect = 1,
++static struct gpio_keys_button ap121_mini_gpio_keys[] __initdata = {
++	{
++		.desc		= "jumpstart button",
++		.type		= EV_KEY,
++		.code		= KEY_WPS_BUTTON,
++		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
++		.gpio		= AP121_MINI_GPIO_BTN_JUMPSTART,
++		.active_low	= 1,
++	},
++	{
++		.desc		= "reset button",
++		.type		= EV_KEY,
++		.code		= KEY_RESTART,
++		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
++		.gpio		= AP121_MINI_GPIO_BTN_RESET,
++		.active_low	= 1,
++	}
+ };
+ 
++static void __init ap121_common_setup(void)
++{
++	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
++
++	ath79_register_m25p80(NULL);
++	ath79_register_wmac(art + AP121_CALDATA_OFFSET,
++			    art + AP121_WMAC_MAC_OFFSET);
++
++	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP121_MAC0_OFFSET, 0);
++	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP121_MAC1_OFFSET, 0);
++
++	ath79_register_mdio(0, 0x0);
++
++	/* LAN ports */
++	ath79_register_eth(1);
++
++	/* WAN port */
++	ath79_register_eth(0);
++}
++
+ static void __init ap121_setup(void)
+ {
+-	u8 *cal_data = (u8 *) KSEG1ADDR(AP121_CAL_DATA_ADDR);
++	ap121_common_setup();
+ 
+ 	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121_leds_gpio),
+ 				 ap121_leds_gpio);
+ 	ath79_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+ 					ARRAY_SIZE(ap121_gpio_keys),
+ 					ap121_gpio_keys);
+-
+-	ath79_register_spi(&ap121_spi_data, ap121_spi_info,
+-			   ARRAY_SIZE(ap121_spi_info));
+ 	ath79_register_usb();
+-	ath79_register_wmac(cal_data, NULL);
+ }
+ 
+ MIPS_MACHINE(ATH79_MACH_AP121, "AP121", "Atheros AP121 reference board",
+ 	     ap121_setup);
++
++static void __init ap121_mini_setup(void)
++{
++	ap121_common_setup();
++
++	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121_mini_leds_gpio),
++				 ap121_mini_leds_gpio);
++	ath79_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
++					ARRAY_SIZE(ap121_mini_gpio_keys),
++					ap121_mini_gpio_keys);
++}
++
++MIPS_MACHINE(ATH79_MACH_AP121_MINI, "AP121-MINI", "Atheros AP121-MINI",
++	     ap121_mini_setup);
diff --git a/target/linux/ar71xx/patches-4.14/605-MIPS-ath79-db120-fixes.patch b/target/linux/ar71xx/patches-4.14/605-MIPS-ath79-db120-fixes.patch
new file mode 100644
index 0000000000..7682a55840
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/605-MIPS-ath79-db120-fixes.patch
@@ -0,0 +1,205 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -43,9 +43,12 @@ config ATH79_MACH_AP81
+ config ATH79_MACH_DB120
+ 	bool "Atheros DB120 reference board"
+ 	select SOC_AR934X
++	select ATH79_DEV_AP9X_PCI if PCI
++	select ATH79_DEV_ETH
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
++	select ATH79_DEV_M25P80
++	select ATH79_DEV_NFC
+ 	select ATH79_DEV_USB
+ 	select ATH79_DEV_WMAC
+ 	help
+--- a/arch/mips/ath79/mach-db120.c
++++ b/arch/mips/ath79/mach-db120.c
+@@ -2,7 +2,7 @@
+  * Atheros DB120 reference board support
+  *
+  * Copyright (c) 2011 Qualcomm Atheros
+- * Copyright (c) 2011 Gabor Juhos <juhosg@openwrt.org>
++ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+  *
+  * Permission to use, copy, modify, and/or distribute this software for any
+  * purpose with or without fee is hereby granted, provided that the above
+@@ -19,16 +19,26 @@
+  */
+ 
+ #include <linux/pci.h>
++#include <linux/phy.h>
++#include <linux/platform_device.h>
+ #include <linux/ath9k_platform.h>
++#include <linux/ar8216_platform.h>
+ 
+-#include "machtypes.h"
++#include <asm/mach-ath79/ar71xx_regs.h>
++
++#include "common.h"
++#include "dev-ap9x-pci.h"
++#include "dev-eth.h"
+ #include "dev-gpio-buttons.h"
+ #include "dev-leds-gpio.h"
++#include "dev-m25p80.h"
++#include "dev-nfc.h"
+ #include "dev-spi.h"
+ #include "dev-usb.h"
+ #include "dev-wmac.h"
+-#include "pci.h"
++#include "machtypes.h"
+ 
++#define DB120_GPIO_LED_USB		11
+ #define DB120_GPIO_LED_WLAN_5G		12
+ #define DB120_GPIO_LED_WLAN_2G		13
+ #define DB120_GPIO_LED_STATUS		14
+@@ -39,8 +49,10 @@
+ #define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
+ #define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
+ 
+-#define DB120_WMAC_CALDATA_OFFSET 0x1000
+-#define DB120_PCIE_CALDATA_OFFSET 0x5000
++#define DB120_MAC0_OFFSET		0
++#define DB120_MAC1_OFFSET		6
++#define DB120_WMAC_CALDATA_OFFSET	0x1000
++#define DB120_PCIE_CALDATA_OFFSET	0x5000
+ 
+ static struct gpio_led db120_leds_gpio[] __initdata = {
+ 	{
+@@ -63,6 +75,11 @@ static struct gpio_led db120_leds_gpio[] __initdata = {
+ 		.gpio		= DB120_GPIO_LED_WLAN_2G,
+ 		.active_low	= 1,
+ 	},
++	{
++		.name		= "db120:green:usb",
++		.gpio		= DB120_GPIO_LED_USB,
++		.active_low	= 1,
++	}
+ };
+ 
+ static struct gpio_keys_button db120_gpio_keys[] __initdata = {
+@@ -76,60 +93,86 @@ static struct gpio_keys_button db120_gpio_keys[] __initdata = {
+ 	},
+ };
+ 
+-static struct spi_board_info db120_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "s25sl064a",
+-	}
++static struct ar8327_pad_cfg db120_ar8327_pad0_cfg = {
++	.mode = AR8327_PAD_MAC_RGMII,
++	.txclk_delay_en = true,
++	.rxclk_delay_en = true,
++	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
++	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+ };
+ 
+-static struct ath79_spi_platform_data db120_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect = 1,
++static struct ar8327_led_cfg db120_ar8327_led_cfg = {
++	.led_ctrl0 = 0x00000000,
++	.led_ctrl1 = 0xc737c737,
++	.led_ctrl2 = 0x00000000,
++	.led_ctrl3 = 0x00c30c00,
++	.open_drain = true,
+ };
+ 
+-#ifdef CONFIG_PCI
+-static struct ath9k_platform_data db120_ath9k_data;
+-
+-static int db120_pci_plat_dev_init(struct pci_dev *dev)
+-{
+-	switch (PCI_SLOT(dev->devfn)) {
+-	case 0:
+-		dev->dev.platform_data = &db120_ath9k_data;
+-		break;
+-	}
+-
+-	return 0;
+-}
+-
+-static void __init db120_pci_init(u8 *eeprom)
+-{
+-	memcpy(db120_ath9k_data.eeprom_data, eeprom,
+-	       sizeof(db120_ath9k_data.eeprom_data));
++static struct ar8327_platform_data db120_ar8327_data = {
++	.pad0_cfg = &db120_ar8327_pad0_cfg,
++	.port0_cfg = {
++		.force_link = 1,
++		.speed = AR8327_PORT_SPEED_1000,
++		.duplex = 1,
++		.txpause = 1,
++		.rxpause = 1,
++	},
++	.led_cfg = &db120_ar8327_led_cfg,
++};
+ 
+-	ath79_pci_set_plat_dev_init(db120_pci_plat_dev_init);
+-	ath79_register_pci();
+-}
+-#else
+-static inline void db120_pci_init(u8 *eeprom) {}
+-#endif /* CONFIG_PCI */
++static struct mdio_board_info db120_mdio0_info[] = {
++	{
++		.bus_id = "ag71xx-mdio.0",
++		.modalias = "db120",
++		.mdio_addr = 0,
++		.platform_data = &db120_ar8327_data,
++	},
++};
+ 
+ static void __init db120_setup(void)
+ {
+ 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+ 
++	ath79_gpio_output_select(DB120_GPIO_LED_USB, AR934X_GPIO_OUT_GPIO);
++	ath79_register_m25p80(NULL);
++
+ 	ath79_register_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
+ 				 db120_leds_gpio);
+ 	ath79_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
+ 					ARRAY_SIZE(db120_gpio_keys),
+ 					db120_gpio_keys);
+-	ath79_register_spi(&db120_spi_data, db120_spi_info,
+-			   ARRAY_SIZE(db120_spi_info));
+ 	ath79_register_usb();
+ 	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET, NULL);
+-	db120_pci_init(art + DB120_PCIE_CALDATA_OFFSET);
++	ap91_pci_init(art + DB120_PCIE_CALDATA_OFFSET, NULL);
++
++	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
++				   AR934X_ETH_CFG_SW_ONLY_MODE);
++
++	ath79_register_mdio(1, 0x0);
++	ath79_register_mdio(0, 0x0);
++
++	ath79_init_mac(ath79_eth0_data.mac_addr, art + DB120_MAC0_OFFSET, 0);
++
++	mdiobus_register_board_info(db120_mdio0_info,
++				    ARRAY_SIZE(db120_mdio0_info));
++
++	/* GMAC0 is connected to an AR8327 switch */
++	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
++	ath79_eth0_data.phy_mask = BIT(0);
++	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
++	ath79_eth0_pll_data.pll_1000 = 0x06000000;
++	ath79_register_eth(0);
++
++	/* GMAC1 is connected to the internal switch */
++	ath79_init_mac(ath79_eth1_data.mac_addr, art + DB120_MAC1_OFFSET, 0);
++	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
++	ath79_eth1_data.speed = SPEED_1000;
++	ath79_eth1_data.duplex = DUPLEX_FULL;
++
++	ath79_register_eth(1);
++
++	ath79_register_nfc();
+ }
+ 
+ MIPS_MACHINE(ATH79_MACH_DB120, "DB120", "Atheros DB120 reference board",
diff --git a/target/linux/ar71xx/patches-4.14/606-MIPS-ath79-pb44-fixes.patch b/target/linux/ar71xx/patches-4.14/606-MIPS-ath79-pb44-fixes.patch
new file mode 100644
index 0000000000..655fee988c
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/606-MIPS-ath79-pb44-fixes.patch
@@ -0,0 +1,145 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -58,6 +58,7 @@ config ATH79_MACH_DB120
+ config ATH79_MACH_PB44
+ 	bool "Atheros PB44 reference board"
+ 	select SOC_AR71XX
++	select ATH79_DEV_ETH
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
+ 	select ATH79_DEV_SPI
+--- a/arch/mips/ath79/mach-pb44.c
++++ b/arch/mips/ath79/mach-pb44.c
+@@ -8,23 +8,47 @@
+  *  by the Free Software Foundation.
+  */
+ 
++#include <linux/delay.h>
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/i2c.h>
+ #include <linux/i2c-gpio.h>
+ #include <linux/platform_data/pcf857x.h>
++#include <linux/spi/flash.h>
++#include <linux/spi/vsc7385.h>
+ 
+-#include "machtypes.h"
++#include <asm/mach-ath79/ar71xx_regs.h>
++#include <asm/mach-ath79/ath79.h>
++
++#include "dev-eth.h"
+ #include "dev-gpio-buttons.h"
+ #include "dev-leds-gpio.h"
+ #include "dev-spi.h"
+ #include "dev-usb.h"
++#include "machtypes.h"
+ #include "pci.h"
+ 
+ #define PB44_GPIO_I2C_SCL	0
+ #define PB44_GPIO_I2C_SDA	1
+ 
++#define PB44_PCF8757_VSC7395_CS	0
++#define PB44_PCF8757_STEREO_CS	1
++#define PB44_PCF8757_SLIC_CS0	2
++#define PB44_PCF8757_SLIC_TEST	3
++#define PB44_PCF8757_SLIC_INT0	4
++#define PB44_PCF8757_SLIC_INT1	5
++#define PB44_PCF8757_SW_RESET	6
++#define PB44_PCF8757_SW_JUMP	8
++#define PB44_PCF8757_LED_JUMP1	9
++#define PB44_PCF8757_LED_JUMP2	10
++#define PB44_PCF8757_TP24	11
++#define PB44_PCF8757_TP25	12
++#define PB44_PCF8757_TP26	13
++#define PB44_PCF8757_TP27	14
++#define PB44_PCF8757_TP28	15
++
+ #define PB44_GPIO_EXP_BASE	16
++#define PB44_GPIO_VSC7395_CS	(PB44_GPIO_EXP_BASE + PB44_PCF8757_VSC7395_CS)
+ #define PB44_GPIO_SW_RESET	(PB44_GPIO_EXP_BASE + 6)
+ #define PB44_GPIO_SW_JUMP	(PB44_GPIO_EXP_BASE + 8)
+ #define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + 9)
+@@ -87,20 +111,59 @@ static struct gpio_keys_button pb44_gpio_keys[] __initdata = {
+ 	}
+ };
+ 
++static void pb44_vsc7395_reset(void)
++{
++	ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
++	udelay(10);
++	ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
++	mdelay(50);
++}
++
++static struct vsc7385_platform_data pb44_vsc7395_data = {
++	.reset		= pb44_vsc7395_reset,
++	.ucode_name	= "vsc7395_ucode_pb44.bin",
++	.mac_cfg = {
++		.tx_ipg		= 6,
++		.bit2		= 1,
++		.clk_sel	= 0,
++	},
++};
++
++static const char *pb44_part_probes[] = {
++	"RedBoot",
++	NULL,
++};
++
++static struct flash_platform_data pb44_flash_data = {
++	.part_probes	= pb44_part_probes,
++};
++
+ static struct spi_board_info pb44_spi_info[] = {
+ 	{
+ 		.bus_num	= 0,
+ 		.chip_select	= 0,
+ 		.max_speed_hz	= 25000000,
+ 		.modalias	= "m25p64",
++		.platform_data	= &pb44_flash_data,
+ 	},
++	{
++		.bus_num	= 0,
++		.chip_select	= 1,
++		.max_speed_hz	= 25000000,
++		.modalias	= "spi-vsc7385",
++		.platform_data	= &pb44_vsc7395_data,
++	}
+ };
+ 
+ static struct ath79_spi_platform_data pb44_spi_data = {
+ 	.bus_num		= 0,
+-	.num_chipselect		= 1,
++	.num_chipselect		= 2,
+ };
+ 
++#define PB44_WAN_PHYMASK	BIT(0)
++#define PB44_LAN_PHYMASK	0
++#define PB44_MDIO_PHYMASK	(PB44_LAN_PHYMASK | PB44_WAN_PHYMASK)
++
+ static void __init pb44_init(void)
+ {
+ 	i2c_register_board_info(0, pb44_i2c_board_info,
+@@ -116,6 +179,22 @@ static void __init pb44_init(void)
+ 			   ARRAY_SIZE(pb44_spi_info));
+ 	ath79_register_usb();
+ 	ath79_register_pci();
++
++	ath79_register_mdio(0, ~PB44_MDIO_PHYMASK);
++
++	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
++	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
++	ath79_eth0_data.phy_mask = PB44_WAN_PHYMASK;
++
++	ath79_register_eth(0);
++
++	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
++	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
++	ath79_eth1_data.speed = SPEED_1000;
++	ath79_eth1_data.duplex = DUPLEX_FULL;
++	ath79_eth1_pll_data.pll_1000 = 0x110000;
++
++	ath79_register_eth(1);
+ }
+ 
+ MIPS_MACHINE(ATH79_MACH_PB44, "PB44", "Atheros PB44 reference board",
diff --git a/target/linux/ar71xx/patches-4.14/607-MIPS-ath79-ubnt-xm-fixes.patch b/target/linux/ar71xx/patches-4.14/607-MIPS-ath79-ubnt-xm-fixes.patch
new file mode 100644
index 0000000000..4699c82746
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/607-MIPS-ath79-ubnt-xm-fixes.patch
@@ -0,0 +1,14 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -70,9 +70,10 @@ config ATH79_MACH_PB44
+ config ATH79_MACH_UBNT_XM
+ 	bool "Ubiquiti Networks XM (rev 1.0) board"
+ 	select SOC_AR724X
++	select ATH79_DEV_AP9X_PCI if PCI
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
+-	select ATH79_DEV_SPI
++	select ATH79_DEV_M25P80
+ 	help
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  Ubiquiti Networks XM (rev 1.0) board.
diff --git a/target/linux/ar71xx/patches-4.14/608-MIPS-ath79-ubnt-xm-add-more-boards.patch b/target/linux/ar71xx/patches-4.14/608-MIPS-ath79-ubnt-xm-add-more-boards.patch
new file mode 100644
index 0000000000..b33db4dd0d
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/608-MIPS-ath79-ubnt-xm-add-more-boards.patch
@@ -0,0 +1,20 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -68,12 +68,16 @@ config ATH79_MACH_PB44
+ 	  Atheros PB44 reference board.
+ 
+ config ATH79_MACH_UBNT_XM
+-	bool "Ubiquiti Networks XM (rev 1.0) board"
++	bool "Ubiquiti Networks XM/UniFi boards"
+ 	select SOC_AR724X
++	select SOC_AR934X
+ 	select ATH79_DEV_AP9X_PCI if PCI
++	select ATH79_DEV_ETH
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
+ 	select ATH79_DEV_M25P80
++	select ATH79_DEV_USB
++	select ATH79_DEV_WMAC
+ 	help
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  Ubiquiti Networks XM (rev 1.0) board.
diff --git a/target/linux/ar71xx/patches-4.14/609-MIPS-ath79-ap136-fixes.patch b/target/linux/ar71xx/patches-4.14/609-MIPS-ath79-ap136-fixes.patch
new file mode 100644
index 0000000000..9aa9bae6c7
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/609-MIPS-ath79-ap136-fixes.patch
@@ -0,0 +1,301 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -17,16 +17,17 @@ config ATH79_MACH_AP121
+ 	  Atheros AP121 reference board.
+ 
+ config ATH79_MACH_AP136
+-	bool "Atheros AP136 reference board"
++	bool "Atheros AP136/AP135 reference board"
+ 	select SOC_QCA955X
+ 	select ATH79_DEV_GPIO_BUTTONS
+ 	select ATH79_DEV_LEDS_GPIO
++	select ATH79_DEV_NFC
+ 	select ATH79_DEV_SPI
+ 	select ATH79_DEV_USB
+ 	select ATH79_DEV_WMAC
+ 	help
+ 	  Say 'Y' here if you want your kernel to support the
+-	  Atheros AP136 reference board.
++	  Atheros AP136 or AP135 reference boards.
+ 
+ config ATH79_MACH_AP81
+ 	bool "Atheros AP81 reference board"
+--- a/arch/mips/ath79/mach-ap136.c
++++ b/arch/mips/ath79/mach-ap136.c
+@@ -18,23 +18,29 @@
+  *
+  */
+ 
+-#include <linux/pci.h>
+-#include <linux/ath9k_platform.h>
++#include <linux/platform_device.h>
++#include <linux/ar8216_platform.h>
+ 
+-#include "machtypes.h"
++#include <asm/mach-ath79/ar71xx_regs.h>
++
++#include "common.h"
++#include "pci.h"
++#include "dev-ap9x-pci.h"
+ #include "dev-gpio-buttons.h"
++#include "dev-eth.h"
+ #include "dev-leds-gpio.h"
+-#include "dev-spi.h"
++#include "dev-m25p80.h"
++#include "dev-nfc.h"
+ #include "dev-usb.h"
+ #include "dev-wmac.h"
+-#include "pci.h"
++#include "machtypes.h"
+ 
+-#define AP136_GPIO_LED_STATUS_RED	14
+-#define AP136_GPIO_LED_STATUS_GREEN	19
+ #define AP136_GPIO_LED_USB		4
+-#define AP136_GPIO_LED_WLAN_2G		13
+ #define AP136_GPIO_LED_WLAN_5G		12
++#define AP136_GPIO_LED_WLAN_2G		13
++#define AP136_GPIO_LED_STATUS_RED	14
+ #define AP136_GPIO_LED_WPS_RED		15
++#define AP136_GPIO_LED_STATUS_GREEN	19
+ #define AP136_GPIO_LED_WPS_GREEN	20
+ 
+ #define AP136_GPIO_BTN_WPS		16
+@@ -43,37 +49,39 @@
+ #define AP136_KEYS_POLL_INTERVAL	20	/* msecs */
+ #define AP136_KEYS_DEBOUNCE_INTERVAL	(3 * AP136_KEYS_POLL_INTERVAL)
+ 
+-#define AP136_WMAC_CALDATA_OFFSET 0x1000
+-#define AP136_PCIE_CALDATA_OFFSET 0x5000
++#define AP136_MAC0_OFFSET		0
++#define AP136_MAC1_OFFSET		6
++#define AP136_WMAC_CALDATA_OFFSET	0x1000
++#define AP136_PCIE_CALDATA_OFFSET	0x5000
+ 
+ static struct gpio_led ap136_leds_gpio[] __initdata = {
+ 	{
+-		.name		= "qca:green:status",
++		.name		= "ap136:green:status",
+ 		.gpio		= AP136_GPIO_LED_STATUS_GREEN,
+ 		.active_low	= 1,
+ 	},
+ 	{
+-		.name		= "qca:red:status",
++		.name		= "ap136:red:status",
+ 		.gpio		= AP136_GPIO_LED_STATUS_RED,
+ 		.active_low	= 1,
+ 	},
+ 	{
+-		.name		= "qca:green:wps",
++		.name		= "ap136:green:wps",
+ 		.gpio		= AP136_GPIO_LED_WPS_GREEN,
+ 		.active_low	= 1,
+ 	},
+ 	{
+-		.name		= "qca:red:wps",
++		.name		= "ap136:red:wps",
+ 		.gpio		= AP136_GPIO_LED_WPS_RED,
+ 		.active_low	= 1,
+ 	},
+ 	{
+-		.name		= "qca:red:wlan-2g",
++		.name		= "ap136:red:wlan-2g",
+ 		.gpio		= AP136_GPIO_LED_WLAN_2G,
+ 		.active_low	= 1,
+ 	},
+ 	{
+-		.name		= "qca:red:usb",
++		.name		= "ap136:red:usb",
+ 		.gpio		= AP136_GPIO_LED_USB,
+ 		.active_low	= 1,
+ 	}
+@@ -98,59 +106,152 @@ static struct gpio_keys_button ap136_gpio_keys[] __initdata = {
+ 	},
+ };
+ 
+-static struct spi_board_info ap136_spi_info[] = {
+-	{
+-		.bus_num	= 0,
+-		.chip_select	= 0,
+-		.max_speed_hz	= 25000000,
+-		.modalias	= "mx25l6405d",
+-	}
++static struct ar8327_pad_cfg ap136_ar8327_pad0_cfg;
++static struct ar8327_pad_cfg ap136_ar8327_pad6_cfg;
++
++static struct ar8327_platform_data ap136_ar8327_data = {
++	.pad0_cfg = &ap136_ar8327_pad0_cfg,
++	.pad6_cfg = &ap136_ar8327_pad6_cfg,
++	.port0_cfg = {
++		.force_link = 1,
++		.speed = AR8327_PORT_SPEED_1000,
++		.duplex = 1,
++		.txpause = 1,
++		.rxpause = 1,
++	},
++	.port6_cfg = {
++		.force_link = 1,
++		.speed = AR8327_PORT_SPEED_1000,
++		.duplex = 1,
++		.txpause = 1,
++		.rxpause = 1,
++	},
+ };
+ 
+-static struct ath79_spi_platform_data ap136_spi_data = {
+-	.bus_num	= 0,
+-	.num_chipselect	= 1,
++static struct mdio_board_info ap136_mdio0_info[] = {
++	{
++		.bus_id = "ag71xx-mdio.0",
++		.modalias = "ap136",
++		.mdio_addr = 0,
++		.platform_data = &ap136_ar8327_data,
++	},
+ };
+ 
+-#ifdef CONFIG_PCI
+-static struct ath9k_platform_data ap136_ath9k_data;
++static void __init ap136_common_setup(void)
++{
++	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
++
++	ath79_register_m25p80(NULL);
++
++	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
++				 ap136_leds_gpio);
++	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
++					ARRAY_SIZE(ap136_gpio_keys),
++					ap136_gpio_keys);
++
++	ath79_register_usb();
++	ath79_register_nfc();
++
++	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET, NULL);
++
++	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
++
++	ath79_register_mdio(0, 0x0);
++	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP136_MAC0_OFFSET, 0);
+ 
+-static int ap136_pci_plat_dev_init(struct pci_dev *dev)
++	mdiobus_register_board_info(ap136_mdio0_info,
++				    ARRAY_SIZE(ap136_mdio0_info));
++
++	/* GMAC0 is connected to the RMGII interface */
++	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
++	ath79_eth0_data.phy_mask = BIT(0);
++	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
++
++	ath79_register_eth(0);
++
++	/* GMAC1 is connected tot eh SGMII interface */
++	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
++	ath79_eth1_data.speed = SPEED_1000;
++	ath79_eth1_data.duplex = DUPLEX_FULL;
++
++	ath79_register_eth(1);
++}
++
++static void __init ap136_010_setup(void)
+ {
+-	if (dev->bus->number == 1 && (PCI_SLOT(dev->devfn)) == 0)
+-		dev->dev.platform_data = &ap136_ath9k_data;
++	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
++
++	/* GMAC0 of the AR8327 switch is connected to GMAC0 via RGMII */
++	ap136_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
++	ap136_ar8327_pad0_cfg.txclk_delay_en = true;
++	ap136_ar8327_pad0_cfg.rxclk_delay_en = true;
++	ap136_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
++	ap136_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+ 
+-	return 0;
++	/* GMAC6 of the AR8327 switch is connected to GMAC1 via SGMII */
++	ap136_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
++	ap136_ar8327_pad6_cfg.rxclk_delay_en = true;
++	ap136_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
++
++	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
++	ath79_eth1_pll_data.pll_1000 = 0x03000101;
++
++	ap136_common_setup();
++	ap91_pci_init(art + AP136_PCIE_CALDATA_OFFSET, NULL);
+ }
+ 
+-static void __init ap136_pci_init(u8 *eeprom)
++MIPS_MACHINE(ATH79_MACH_AP136_010, "AP136-010",
++	     "Atheros AP136-010 reference board",
++	     ap136_010_setup);
++
++static void __init ap136_020_common_setup(void)
+ {
+-	memcpy(ap136_ath9k_data.eeprom_data, eeprom,
+-	       sizeof(ap136_ath9k_data.eeprom_data));
++	/* GMAC0 of the AR8327 switch is connected to GMAC1 via SGMII */
++	ap136_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_SGMII;
++	ap136_ar8327_pad0_cfg.sgmii_delay_en = true;
+ 
+-	ath79_pci_set_plat_dev_init(ap136_pci_plat_dev_init);
+-	ath79_register_pci();
++	/* GMAC6 of the AR8327 switch is connected to GMAC0 via RGMII */
++	ap136_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_RGMII;
++	ap136_ar8327_pad6_cfg.txclk_delay_en = true;
++	ap136_ar8327_pad6_cfg.rxclk_delay_en = true;
++	ap136_ar8327_pad6_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
++	ap136_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
++
++	ath79_eth0_pll_data.pll_1000 = 0x56000000;
++	ath79_eth1_pll_data.pll_1000 = 0x03000101;
++
++	ap136_common_setup();
+ }
+-#else
+-static inline void ap136_pci_init(u8 *eeprom) {}
+-#endif /* CONFIG_PCI */
+ 
+-static void __init ap136_setup(void)
++static void __init ap136_020_setup(void)
+ {
+ 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+ 
+-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
+-				 ap136_leds_gpio);
+-	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
+-					ARRAY_SIZE(ap136_gpio_keys),
+-					ap136_gpio_keys);
+-	ath79_register_spi(&ap136_spi_data, ap136_spi_info,
+-			   ARRAY_SIZE(ap136_spi_info));
+-	ath79_register_usb();
+-	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET);
+-	ap136_pci_init(art + AP136_PCIE_CALDATA_OFFSET);
++	ap136_020_common_setup();
++	ap91_pci_init(art + AP136_PCIE_CALDATA_OFFSET, NULL);
+ }
+ 
+-MIPS_MACHINE(ATH79_MACH_AP136_010, "AP136-010",
+-	     "Atheros AP136-010 reference board",
+-	     ap136_setup);
++MIPS_MACHINE(ATH79_MACH_AP136_020, "AP136-020",
++	     "Atheros AP136-020 reference board",
++	     ap136_020_setup);
++
++/*
++ * AP135-020 is similar to AP136-020, any future AP135 specific init
++ * code can be added here.
++ */
++static void __init ap135_020_setup(void)
++{
++	ap136_leds_gpio[0].name = "ap135:green:status";
++	ap136_leds_gpio[1].name = "ap135:red:status";
++	ap136_leds_gpio[2].name = "ap135:green:wps";
++	ap136_leds_gpio[3].name = "ap135:red:wps";
++	ap136_leds_gpio[4].name = "ap135:red:wlan-2g";
++	ap136_leds_gpio[5].name = "ap135:red:usb";
++
++	ap136_020_common_setup();
++	ath79_register_pci();
++}
++
++MIPS_MACHINE(ATH79_MACH_AP135_020, "AP135-020",
++	     "Atheros AP135-020 reference board",
++	     ap135_020_setup);
diff --git a/target/linux/ar71xx/patches-4.14/611-MIPS-ath79-wdt-timeout.patch b/target/linux/ar71xx/patches-4.14/611-MIPS-ath79-wdt-timeout.patch
new file mode 100644
index 0000000000..0927d5a977
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/611-MIPS-ath79-wdt-timeout.patch
@@ -0,0 +1,25 @@
+MIPS: ath79: fix maximum timeout
+
+If the userland tries to set a timeout higher than the max_timeout, then we should fallback to max_timeout.
+
+Signed-off-by: John Crispin <blogic@openwrt.org>
+
+--- a/drivers/watchdog/ath79_wdt.c
++++ b/drivers/watchdog/ath79_wdt.c
+@@ -115,10 +115,14 @@ static inline void ath79_wdt_disable(voi
+ 
+ static int ath79_wdt_set_timeout(int val)
+ {
+-	if (val < 1 || val > max_timeout)
++	if (val < 1)
+ 		return -EINVAL;
+ 
+-	timeout = val;
++	if (val > max_timeout)
++		timeout = max_timeout;
++	else
++		timeout = val;
++
+ 	ath79_wdt_keepalive();
+ 
+ 	return 0;
diff --git a/target/linux/ar71xx/patches-4.14/612-MIPS-ath79-set-buffalo-txgain.patch b/target/linux/ar71xx/patches-4.14/612-MIPS-ath79-set-buffalo-txgain.patch
new file mode 100644
index 0000000000..3d100e0549
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/612-MIPS-ath79-set-buffalo-txgain.patch
@@ -0,0 +1,24 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -319,6 +319,11 @@ void __init ath79_wmac_disable_5ghz(void
+ 	ath79_wmac_data.disable_5ghz = true;
+ }
+ 
++void __init ath79_wmac_set_tx_gain_buffalo(void)
++{
++	ath79_wmac_data.tx_gain_buffalo = true;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -16,6 +16,7 @@ void ath79_register_wmac(u8 *cal_data, u
+ void ath79_register_wmac_simple(void);
+ void ath79_wmac_disable_2ghz(void);
+ void ath79_wmac_disable_5ghz(void);
++void ath79_wmac_set_tx_gain_buffalo(void);
+ 
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
diff --git a/target/linux/ar71xx/patches-4.14/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch b/target/linux/ar71xx/patches-4.14/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch
new file mode 100644
index 0000000000..5c1205d59f
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch
@@ -0,0 +1,76 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -18,9 +18,11 @@
+ #include <linux/etherdevice.h>
+ #include <linux/platform_device.h>
+ #include <linux/ath9k_platform.h>
++#include <linux/gpio.h>
+ 
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
++#include "common.h"
+ #include "dev-wmac.h"
+ 
+ static u8 ath79_wmac_mac[ETH_ALEN];
+@@ -324,6 +326,51 @@ void __init ath79_wmac_set_tx_gain_buffa
+ 	ath79_wmac_data.tx_gain_buffalo = true;
+ }
+ 
++static int ath79_request_ext_lna_gpio(unsigned chain, int gpio)
++{
++	char *label;
++	int err;
++
++	label = kasprintf(GFP_KERNEL, "external LNA%u", chain);
++	if (!label)
++		return -ENOMEM;
++
++	err = gpio_request_one(gpio, GPIOF_DIR_OUT | GPIOF_INIT_LOW, label);
++	if (err) {
++		pr_err("unable to request GPIO%d for external LNA%u\n",
++			gpio, chain);
++		kfree(label);
++	}
++
++	return err;
++}
++
++static void ar934x_set_ext_lna_gpio(unsigned chain, int gpio)
++{
++	unsigned int sel;
++	int err;
++
++	if (WARN_ON(chain > 1))
++		return;
++
++	err = ath79_request_ext_lna_gpio(chain, gpio);
++	if (err)
++		return;
++
++	if (chain == 0)
++		sel = AR934X_GPIO_OUT_EXT_LNA0;
++	else
++		sel = AR934X_GPIO_OUT_EXT_LNA1;
++
++	ath79_gpio_output_select(gpio, sel);
++}
++
++void __init ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio)
++{
++	if (soc_is_ar934x())
++		ar934x_set_ext_lna_gpio(chain, gpio);
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -17,6 +17,7 @@ void ath79_register_wmac_simple(void);
+ void ath79_wmac_disable_2ghz(void);
+ void ath79_wmac_disable_5ghz(void);
+ void ath79_wmac_set_tx_gain_buffalo(void);
++void ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio);
+ 
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
diff --git a/target/linux/ar71xx/patches-4.14/620-MIPS-ath79-add-support-for-QCA953x-SoC.patch b/target/linux/ar71xx/patches-4.14/620-MIPS-ath79-add-support-for-QCA953x-SoC.patch
new file mode 100644
index 0000000000..74d2475587
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/620-MIPS-ath79-add-support-for-QCA953x-SoC.patch
@@ -0,0 +1,696 @@
+From 5300a7cd7ed2f88488ddba62947b9c6bb9663777 Mon Sep 17 00:00:00 2001
+Message-Id: <5300a7cd7ed2f88488ddba62947b9c6bb9663777.1396122227.git.mschiffer@universe-factory.net>
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sat, 29 Mar 2014 20:26:08 +0100
+Subject: [PATCH 1/2] MIPS: ath79: add support for QCA953x SoC
+
+Note that the clock calculation looks very similar to the QCA955x, but the
+meaning of the bits CPUCLK_FROM_CPUPLL and DDRCLK_FROM_DDRPLL is reversed.
+---
+ arch/mips/ath79/Kconfig                        |  6 +-
+ arch/mips/ath79/clock.c                        | 78 ++++++++++++++++++++++++++
+ arch/mips/ath79/common.c                       |  4 ++
+ arch/mips/ath79/dev-common.c                   |  1 +
+ arch/mips/ath79/dev-wmac.c                     | 20 +++++++
+ arch/mips/ath79/early_printk.c                 |  1 +
+ arch/mips/ath79/gpio.c                         |  4 +-
+ arch/mips/ath79/irq.c                          |  4 ++
+ arch/mips/ath79/setup.c                        |  8 ++-
+ arch/mips/include/asm/mach-ath79/ar71xx_regs.h | 48 ++++++++++++++++
+ arch/mips/include/asm/mach-ath79/ath79.h       | 11 ++++
+ 11 files changed, 182 insertions(+), 3 deletions(-)
+
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -105,6 +105,10 @@ config SOC_AR934X
+ 	select PCI_AR724X if PCI
+ 	def_bool n
+ 
++config SOC_QCA953X
++	select USB_ARCH_HAS_EHCI
++	def_bool n
++
+ config SOC_QCA955X
+ 	select HW_HAS_PCI
+ 	select PCI_AR724X if PCI
+@@ -144,7 +148,7 @@ config ATH79_DEV_USB
+ 	def_bool n
+ 
+ config ATH79_DEV_WMAC
+-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA955X)
++	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
+ 	def_bool n
+ 
+ config ATH79_NVRAM
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -355,6 +355,87 @@ static void __init ar934x_clocks_init(void)
+ 	iounmap(dpll_base);
+ }
+ 
++static void __init qca953x_clocks_init(void)
++{
++	unsigned long ref_rate;
++	unsigned long cpu_rate;
++	unsigned long ddr_rate;
++	unsigned long ahb_rate;
++	u32 pll, out_div, ref_div, nint, frac, clk_ctrl, postdiv;
++	u32 cpu_pll, ddr_pll;
++
++	/* QCA953X only supports 25MHz ref_clk */
++	ref_rate = 25 * 1000 * 1000;
++
++	pll = ath79_pll_rr(QCA953X_PLL_CPU_CONFIG_REG);
++	out_div = (pll >> QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
++		  QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
++		  QCA953X_PLL_CPU_CONFIG_REFDIV_MASK;
++	nint = (pll >> QCA953X_PLL_CPU_CONFIG_NINT_SHIFT) &
++	       QCA953X_PLL_CPU_CONFIG_NINT_MASK;
++	frac = (pll >> QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT) &
++	       QCA953X_PLL_CPU_CONFIG_NFRAC_MASK;
++
++	cpu_pll = nint * ref_rate / ref_div;
++	cpu_pll += frac * (ref_rate >> 6) / ref_div;
++	cpu_pll /= (1 << out_div);
++
++	pll = ath79_pll_rr(QCA953X_PLL_DDR_CONFIG_REG);
++	out_div = (pll >> QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
++		  QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
++		  QCA953X_PLL_DDR_CONFIG_REFDIV_MASK;
++	nint = (pll >> QCA953X_PLL_DDR_CONFIG_NINT_SHIFT) &
++	       QCA953X_PLL_DDR_CONFIG_NINT_MASK;
++	frac = (pll >> QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT) &
++	       QCA953X_PLL_DDR_CONFIG_NFRAC_MASK;
++
++	ddr_pll = nint * ref_rate / ref_div;
++	ddr_pll += frac * (ref_rate >> 6) / (ref_div << 4);
++	ddr_pll /= (1 << out_div);
++
++	clk_ctrl = ath79_pll_rr(QCA953X_PLL_CLK_CTRL_REG);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
++		cpu_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL)
++		cpu_rate = cpu_pll / (postdiv + 1);
++	else
++		cpu_rate = ddr_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
++		ddr_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL)
++		ddr_rate = ddr_pll / (postdiv + 1);
++	else
++		ddr_rate = cpu_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
++		  QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
++		ahb_rate = ref_rate;
++	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
++		ahb_rate = ddr_pll / (postdiv + 1);
++	else
++		ahb_rate = cpu_pll / (postdiv + 1);
++
++	ath79_add_sys_clkdev("ref", ref_rate);
++	ath79_add_sys_clkdev("cpu", cpu_rate);
++	ath79_add_sys_clkdev("ddr", ddr_rate);
++	ath79_add_sys_clkdev("ahb", ahb_rate);
++
++	clk_add_alias("wdt", NULL, "ref", NULL);
++	clk_add_alias("uart", NULL, "ref", NULL);
++}
++
+ static void __init qca955x_clocks_init(void)
+ {
+ 	unsigned long ref_rate;
+@@ -450,6 +531,8 @@ void __init ath79_clocks_init(void)
+ 		ar933x_clocks_init();
+ 	else if (soc_is_ar934x())
+ 		ar934x_clocks_init();
++	else if (soc_is_qca953x())
++		qca953x_clocks_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_clocks_init();
+ 	else
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -103,6 +103,8 @@ void ath79_device_reset_set(u32 mask)
+ 		reg = AR933X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_ar934x())
+ 		reg = AR934X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca953x())
++		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+@@ -131,6 +133,8 @@ void ath79_device_reset_clear(u32 mask)
+ 		reg = AR933X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_ar934x())
+ 		reg = AR934X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca953x())
++		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
+ 	else
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -94,6 +94,7 @@ void __init ath79_register_uart(void)
+ 	    soc_is_ar724x() ||
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar934x() ||
++	    soc_is_qca953x() ||
+ 	    soc_is_qca955x()) {
+ 		ath79_uart_data[0].uartclk = uart_clk_rate;
+ 		platform_device_register(&ath79_uart_device);
+@@ -157,6 +158,9 @@ void __init ath79_gpio_init(void)
+ 	} else if (soc_is_ar934x()) {
+ 		ath79_gpio_pdata.ngpios = AR934X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
++	} else if (soc_is_qca953x()) {
++		ath79_gpio_pdata.ngpios = QCA953X_GPIO_COUNT;
++		ath79_gpio_pdata.oe_inverted = 1;
+ 	} else if (soc_is_qca955x()) {
+ 		ath79_gpio_pdata.ngpios = QCA955X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
+--- a/arch/mips/ath79/dev-usb.c
++++ b/arch/mips/ath79/dev-usb.c
+@@ -236,6 +236,30 @@ static void __init ar934x_usb_setup(void)
+ 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+ }
+ 
++static void __init qca953x_usb_setup(void)
++{
++	u32 bootstrap;
++
++	bootstrap = ath79_reset_rr(QCA953X_RESET_REG_BOOTSTRAP);
++
++	ath79_device_reset_set(QCA953X_RESET_USBSUS_OVERRIDE);
++	udelay(1000);
++
++	ath79_device_reset_clear(QCA953X_RESET_USB_PHY);
++	udelay(1000);
++
++	ath79_device_reset_clear(QCA953X_RESET_USB_PHY_ANALOG);
++	udelay(1000);
++
++	ath79_device_reset_clear(QCA953X_RESET_USB_HOST);
++	udelay(1000);
++
++	ath79_usb_register("ehci-platform", -1,
++			   QCA953X_EHCI_BASE, QCA953X_EHCI_SIZE,
++			   ATH79_CPU_IRQ(3),
++			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++}
++
+ static void qca955x_usb_reset_notifier(struct platform_device *pdev)
+ {
+ 	u32 base;
+@@ -286,6 +310,8 @@ void __init ath79_register_usb(void)
+ 		ar933x_usb_setup();
+ 	else if (soc_is_ar934x())
+ 		ar934x_usb_setup();
++	else if (soc_is_qca953x())
++		qca953x_usb_setup();
+ 	else if (soc_is_qca955x())
+ 		qca955x_usb_setup();
+ 	else
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -100,7 +100,7 @@ static int ar933x_wmac_reset(void)
+ 	return -ETIMEDOUT;
+ }
+ 
+-static int ar933x_r1_get_wmac_revision(void)
++static int ar93xx_get_soc_revision(void)
+ {
+ 	return ath79_soc_rev;
+ }
+@@ -125,7 +125,7 @@ static void __init ar933x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = true;
+ 
+ 	if (ath79_soc_rev == 1)
+-		ath79_wmac_data.get_mac_revision = ar933x_r1_get_wmac_revision;
++		ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
+ 
+ 	ath79_wmac_data.external_reset = ar933x_wmac_reset;
+ }
+@@ -150,6 +150,21 @@ static void ar934x_wmac_setup(void)
+ 	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
+ }
+ 
++static void qca953x_wmac_setup(void)
++{
++	ath79_wmac_device.name = "qca953x_wmac";
++
++	ath79_wmac_resources[0].start = QCA953X_WMAC_BASE;
++	ath79_wmac_resources[0].end = QCA953X_WMAC_BASE + QCA953X_WMAC_SIZE - 1;
++	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
++	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
++
++	/* QCA953X only supports 25MHz ref_clk */
++	ath79_wmac_data.is_clk_25mhz = true;
++
++	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
++}
++
+ static void qca955x_wmac_setup(void)
+ {
+ 	u32 t;
+@@ -379,6 +394,8 @@ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ 		ar933x_wmac_setup();
+ 	else if (soc_is_ar934x())
+ 		ar934x_wmac_setup();
++	else if (soc_is_qca953x())
++		qca953x_wmac_setup();
+ 	else if (soc_is_qca955x())
+ 		qca955x_wmac_setup();
+ 	else
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -116,6 +116,8 @@ static void prom_putchar_init(void)
+ 	case REV_ID_MAJOR_AR9341:
+ 	case REV_ID_MAJOR_AR9342:
+ 	case REV_ID_MAJOR_AR9344:
++	case REV_ID_MAJOR_QCA9533:
++	case REV_ID_MAJOR_QCA9533_V2:
+ 	case REV_ID_MAJOR_QCA9556:
+ 	case REV_ID_MAJOR_QCA9558:
+ 		_prom_putchar = prom_putchar_ar71xx;
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -31,7 +31,7 @@ static void __iomem *ath79_gpio_get_function_reg(void)
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar933x())
+ 		reg = AR71XX_GPIO_REG_FUNC;
+-	else if (soc_is_ar934x())
++	else if (soc_is_ar934x() || soc_is_qca953x())
+ 		reg = AR934X_GPIO_REG_FUNC;
+ 	else
+ 		BUG();
+@@ -64,7 +64,7 @@ void __init ath79_gpio_output_select(unsigned gpio, u8 val)
+ 	unsigned int reg;
+ 	u32 t, s;
+ 
+-	BUG_ON(!soc_is_ar934x());
++	BUG_ON(!soc_is_ar934x() && !soc_is_qca953x());
+ 
+ 	if (gpio >= AR934X_GPIO_COUNT)
+ 		return;
+--- a/arch/mips/ath79/irq.c
++++ b/arch/mips/ath79/irq.c
+@@ -56,6 +56,34 @@ static void ar934x_ip2_irq_init(void)
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), ar934x_ip2_irq_dispatch);
+ }
+ 
++static void qca953x_ip2_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS);
++
++	if (status & QCA953X_PCIE_WMAC_INT_PCIE_ALL) {
++		ath79_ddr_wb_flush(3);
++		generic_handle_irq(ATH79_IP2_IRQ(0));
++	} else if (status & QCA953X_PCIE_WMAC_INT_WMAC_ALL) {
++		ath79_ddr_wb_flush(4);
++		generic_handle_irq(ATH79_IP2_IRQ(1));
++	} else {
++		spurious_interrupt();
++	}
++}
++
++static void qca953x_irq_init(void)
++{
++	int i;
++
++	for (i = ATH79_IP2_IRQ_BASE;
++	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca953x_ip2_irq_dispatch);
++}
++
+ static void qca955x_ip2_irq_dispatch(struct irq_desc *desc)
+ {
+ 	u32 status;
+@@ -143,7 +171,7 @@ void __init arch_init_irq(void)
+ 	    soc_is_ar913x() || soc_is_ar933x()) {
+ 		irq_wb_chan2 = 3;
+ 		irq_wb_chan3 = 2;
+-	} else if (soc_is_ar934x()) {
++	} else if (soc_is_ar934x() || soc_is_qca953x()) {
+ 		irq_wb_chan3 = 2;
+ 	}
+ 
+@@ -154,6 +182,7 @@ void __init arch_init_irq(void)
+ 	else if (soc_is_ar724x() ||
+ 		 soc_is_ar933x() ||
+ 		 soc_is_ar934x() ||
++		 soc_is_qca953x() ||
+ 		 soc_is_qca955x())
+ 		misc_is_ar71xx = false;
+ 	else
+@@ -164,6 +193,8 @@ void __init arch_init_irq(void)
+ 
+ 	if (soc_is_ar934x())
+ 		ar934x_ip2_irq_init();
++	else if (soc_is_qca953x())
++		qca953x_irq_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_irq_init();
+ }
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -60,6 +60,7 @@ static void __init ath79_detect_sys_type(void)
+ 	u32 major;
+ 	u32 minor;
+ 	u32 rev = 0;
++	u32 ver = 1;
+ 
+ 	id = ath79_reset_rr(AR71XX_RESET_REG_REV_ID);
+ 	major = id & REV_ID_MAJOR_MASK;
+@@ -152,6 +153,17 @@ static void __init ath79_detect_sys_type(void)
+ 		rev = id & AR934X_REV_ID_REVISION_MASK;
+ 		break;
+ 
++	case REV_ID_MAJOR_QCA9533_V2:
++		ver = 2;
++		ath79_soc_rev = 2;
++		/* drop through */
++
++	case REV_ID_MAJOR_QCA9533:
++		ath79_soc = ATH79_SOC_QCA9533;
++		chip = "9533";
++		rev = id & QCA953X_REV_ID_REVISION_MASK;
++		break;
++
+ 	case REV_ID_MAJOR_QCA9556:
+ 		ath79_soc = ATH79_SOC_QCA9556;
+ 		chip = "9556";
+@@ -168,11 +180,12 @@ static void __init ath79_detect_sys_type(void)
+ 		panic("ath79: unknown SoC, id:0x%08x", id);
+ 	}
+ 
+-	ath79_soc_rev = rev;
++	if (ver == 1)
++		ath79_soc_rev = rev;
+ 
+-	if (soc_is_qca955x())
+-		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s rev %u",
+-			chip, rev);
++	if (soc_is_qca953x() || soc_is_qca955x())
++		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s ver %u rev %u",
++			chip, ver, rev);
+ 	else
+ 		sprintf(ath79_sys_type, "Atheros AR%s rev %u", chip, rev);
+ 	pr_info("SoC: %s\n", ath79_sys_type);
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -105,6 +105,21 @@
+ #define AR934X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
+ #define AR934X_SRIF_SIZE	0x1000
+ 
++#define QCA953X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA953X_GMAC_SIZE	0x14
++#define QCA953X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
++#define QCA953X_WMAC_SIZE	0x20000
++#define QCA953X_EHCI_BASE	0x1b000000
++#define QCA953X_EHCI_SIZE	0x200
++#define QCA953X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
++#define QCA953X_SRIF_SIZE	0x1000
++
++#define QCA953X_PCI_CFG_BASE0	0x14000000
++#define QCA953X_PCI_CTRL_BASE0	(AR71XX_APB_BASE + 0x000f0000)
++#define QCA953X_PCI_CRP_BASE0	(AR71XX_APB_BASE + 0x000c0000)
++#define QCA953X_PCI_MEM_BASE0	0x10000000
++#define QCA953X_PCI_MEM_SIZE	0x02000000
++
+ #define QCA955X_PCI_MEM_BASE0	0x10000000
+ #define QCA955X_PCI_MEM_BASE1	0x12000000
+ #define QCA955X_PCI_MEM_SIZE	0x02000000
+@@ -180,6 +195,12 @@
+ #define AR934X_OTP_INTF3_ADDRESS			0x3100c
+ #define AR934X_OTP_PGENB_SETUP_HOLD_TIME_ADDRESS	0x31034
+ 
++#define QCA953X_DDR_REG_FLUSH_GE0	0x9c
++#define QCA953X_DDR_REG_FLUSH_GE1	0xa0
++#define QCA953X_DDR_REG_FLUSH_USB	0xa4
++#define QCA953X_DDR_REG_FLUSH_PCIE	0xa8
++#define QCA953X_DDR_REG_FLUSH_WMAC	0xac
++
+ /*
+  * PLL block
+  */
+@@ -286,6 +307,44 @@
+ 
+ #define AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL	BIT(6)
+ 
++#define QCA953X_PLL_CPU_CONFIG_REG		0x00
++#define QCA953X_PLL_DDR_CONFIG_REG		0x04
++#define QCA953X_PLL_CLK_CTRL_REG		0x08
++#define QCA953X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
++#define QCA953X_PLL_ETH_XMII_CONTROL_REG	0x2c
++#define QCA953X_PLL_ETH_SGMII_CONTROL_REG	0x48
++
++#define QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
++#define QCA953X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
++#define QCA953X_PLL_CPU_CONFIG_NINT_SHIFT	6
++#define QCA953X_PLL_CPU_CONFIG_NINT_MASK	0x3f
++#define QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
++#define QCA953X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
++#define QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
++#define QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
++
++#define QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
++#define QCA953X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
++#define QCA953X_PLL_DDR_CONFIG_NINT_SHIFT	10
++#define QCA953X_PLL_DDR_CONFIG_NINT_MASK	0x3f
++#define QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
++#define QCA953X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
++#define QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
++#define QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
++
++#define QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
++#define QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
++#define QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
++#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
++#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
++#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
++#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
++#define QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL		BIT(20)
++#define QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
++#define QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
++
+ #define QCA955X_PLL_CPU_CONFIG_REG		0x00
+ #define QCA955X_PLL_DDR_CONFIG_REG		0x04
+ #define QCA955X_PLL_CLK_CTRL_REG		0x08
+@@ -362,6 +421,10 @@
+ #define AR934X_RESET_REG_BOOTSTRAP		0xb0
+ #define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
+ 
++#define QCA953X_RESET_REG_RESET_MODULE		0x1c
++#define QCA953X_RESET_REG_BOOTSTRAP		0xb0
++#define QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
++
+ #define QCA955X_RESET_REG_RESET_MODULE		0x1c
+ #define QCA955X_RESET_REG_BOOTSTRAP		0xb0
+ #define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
+@@ -457,6 +520,27 @@
+ #define AR934X_RESET_MBOX		BIT(1)
+ #define AR934X_RESET_I2S		BIT(0)
+ 
++#define QCA953X_RESET_USB_EXT_PWR	BIT(29)
++#define QCA953X_RESET_EXTERNAL		BIT(28)
++#define QCA953X_RESET_RTC		BIT(27)
++#define QCA953X_RESET_FULL_CHIP		BIT(24)
++#define QCA953X_RESET_GE1_MDIO		BIT(23)
++#define QCA953X_RESET_GE0_MDIO		BIT(22)
++#define QCA953X_RESET_CPU_NMI		BIT(21)
++#define QCA953X_RESET_CPU_COLD		BIT(20)
++#define QCA953X_RESET_DDR		BIT(16)
++#define QCA953X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
++#define QCA953X_RESET_GE1_MAC		BIT(13)
++#define QCA953X_RESET_ETH_SWITCH_ANALOG	BIT(12)
++#define QCA953X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA953X_RESET_GE0_MAC		BIT(9)
++#define QCA953X_RESET_ETH_SWITCH	BIT(8)
++#define QCA953X_RESET_PCIE_PHY		BIT(7)
++#define QCA953X_RESET_PCIE		BIT(6)
++#define QCA953X_RESET_USB_HOST		BIT(5)
++#define QCA953X_RESET_USB_PHY		BIT(4)
++#define QCA953X_RESET_USBSUS_OVERRIDE	BIT(3)
++
+ #define QCA955X_RESET_HOST		BIT(31)
+ #define QCA955X_RESET_SLIC		BIT(30)
+ #define QCA955X_RESET_HDMA		BIT(29)
+@@ -510,6 +594,13 @@
+ #define AR934X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
+ #define AR934X_BOOTSTRAP_DDR1		BIT(0)
+ 
++#define QCA953X_BOOTSTRAP_SW_OPTION2	BIT(12)
++#define QCA953X_BOOTSTRAP_SW_OPTION1	BIT(11)
++#define QCA953X_BOOTSTRAP_EJTAG_MODE	BIT(5)
++#define QCA953X_BOOTSTRAP_REF_CLK_40	BIT(4)
++#define QCA953X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
++#define QCA953X_BOOTSTRAP_DDR1		BIT(0)
++
+ #define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
+ 
+ #define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+@@ -530,6 +621,24 @@
+ 	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
+ 	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
+ 
++#define QCA953X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
++#define QCA953X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
++#define QCA953X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
++#define QCA953X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
++#define QCA953X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
++#define QCA953X_PCIE_WMAC_INT_WMAC_ALL \
++	(QCA953X_PCIE_WMAC_INT_WMAC_MISC | QCA953X_PCIE_WMAC_INT_WMAC_TX | \
++	 QCA953X_PCIE_WMAC_INT_WMAC_RXLP | QCA953X_PCIE_WMAC_INT_WMAC_RXHP)
++
++#define QCA953X_PCIE_WMAC_INT_PCIE_ALL \
++	(QCA953X_PCIE_WMAC_INT_PCIE_RC | QCA953X_PCIE_WMAC_INT_PCIE_RC0 | \
++	 QCA953X_PCIE_WMAC_INT_PCIE_RC1 | QCA953X_PCIE_WMAC_INT_PCIE_RC2 | \
++	 QCA953X_PCIE_WMAC_INT_PCIE_RC3)
++
+ #define QCA955X_EXT_INT_WMAC_MISC		BIT(0)
+ #define QCA955X_EXT_INT_WMAC_TX			BIT(1)
+ #define QCA955X_EXT_INT_WMAC_RXLP		BIT(2)
+@@ -572,6 +681,8 @@
+ #define REV_ID_MAJOR_AR9341		0x0120
+ #define REV_ID_MAJOR_AR9342		0x1120
+ #define REV_ID_MAJOR_AR9344		0x2120
++#define REV_ID_MAJOR_QCA9533		0x0140
++#define REV_ID_MAJOR_QCA9533_V2		0x0160
+ #define REV_ID_MAJOR_QCA9556		0x0130
+ #define REV_ID_MAJOR_QCA9558		0x1130
+ 
+@@ -594,6 +705,8 @@
+ 
+ #define AR934X_REV_ID_REVISION_MASK	0xf
+ 
++#define QCA953X_REV_ID_REVISION_MASK	0xf
++
+ #define QCA955X_REV_ID_REVISION_MASK	0xf
+ 
+ /*
+@@ -641,6 +754,25 @@
+ #define AR934X_GPIO_REG_OUT_FUNC5	0x40
+ #define AR934X_GPIO_REG_FUNC		0x6c
+ 
++#define QCA953X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA953X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA953X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA953X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA953X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA953X_GPIO_REG_IN_ENABLE0	0x44
++#define QCA953X_GPIO_REG_FUNC		0x6c
++
++#define QCA953X_GPIO_OUT_MUX_SPI_CS1		10
++#define QCA953X_GPIO_OUT_MUX_SPI_CS2		11
++#define QCA953X_GPIO_OUT_MUX_SPI_CS0		9
++#define QCA953X_GPIO_OUT_MUX_SPI_CLK		8
++#define QCA953X_GPIO_OUT_MUX_SPI_MOSI		12
++#define QCA953X_GPIO_OUT_MUX_LED_LINK1		41
++#define QCA953X_GPIO_OUT_MUX_LED_LINK2		42
++#define QCA953X_GPIO_OUT_MUX_LED_LINK3		43
++#define QCA953X_GPIO_OUT_MUX_LED_LINK4		44
++#define QCA953X_GPIO_OUT_MUX_LED_LINK5		45
++
+ #define QCA955X_GPIO_REG_OUT_FUNC0	0x2c
+ #define QCA955X_GPIO_REG_OUT_FUNC1	0x30
+ #define QCA955X_GPIO_REG_OUT_FUNC2	0x34
+@@ -655,6 +787,7 @@
+ #define AR913X_GPIO_COUNT		22
+ #define AR933X_GPIO_COUNT		30
+ #define AR934X_GPIO_COUNT		23
++#define QCA953X_GPIO_COUNT		18
+ #define QCA955X_GPIO_COUNT		24
+ 
+ /*
+@@ -678,6 +811,24 @@
+ #define AR934X_SRIF_DPLL2_OUTDIV_SHIFT	13
+ #define AR934X_SRIF_DPLL2_OUTDIV_MASK	0x7
+ 
++#define QCA953X_SRIF_CPU_DPLL1_REG	0x1c0
++#define QCA953X_SRIF_CPU_DPLL2_REG	0x1c4
++#define QCA953X_SRIF_CPU_DPLL3_REG	0x1c8
++
++#define QCA953X_SRIF_DDR_DPLL1_REG	0x240
++#define QCA953X_SRIF_DDR_DPLL2_REG	0x244
++#define QCA953X_SRIF_DDR_DPLL3_REG	0x248
++
++#define QCA953X_SRIF_DPLL1_REFDIV_SHIFT	27
++#define QCA953X_SRIF_DPLL1_REFDIV_MASK	0x1f
++#define QCA953X_SRIF_DPLL1_NINT_SHIFT	18
++#define QCA953X_SRIF_DPLL1_NINT_MASK	0x1ff
++#define QCA953X_SRIF_DPLL1_NFRAC_MASK	0x0003ffff
++
++#define QCA953X_SRIF_DPLL2_LOCAL_PLL	BIT(30)
++#define QCA953X_SRIF_DPLL2_OUTDIV_SHIFT	13
++#define QCA953X_SRIF_DPLL2_OUTDIV_MASK	0x7
++
+ #define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
+ #define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
+ #define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
+@@ -883,6 +1034,16 @@
+ #define AR934X_ETH_CFG_RDV_DELAY_MASK   0x3
+ #define AR934X_ETH_CFG_RDV_DELAY_SHIFT  16
+ 
++/*
++ * QCA953X GMAC Interface
++ */
++#define QCA953X_GMAC_REG_ETH_CFG		0x00
++
++#define QCA953X_ETH_CFG_SW_ONLY_MODE		BIT(6)
++#define QCA953X_ETH_CFG_SW_PHY_SWAP		BIT(7)
++#define QCA953X_ETH_CFG_SW_APB_ACCESS		BIT(9)
++#define QCA953X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++
+ /*
+  * QCA955X GMAC Interface
+  */
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -32,6 +32,7 @@ enum ath79_soc_type {
+ 	ATH79_SOC_AR9341,
+ 	ATH79_SOC_AR9342,
+ 	ATH79_SOC_AR9344,
++	ATH79_SOC_QCA9533,
+ 	ATH79_SOC_QCA9556,
+ 	ATH79_SOC_QCA9558,
+ };
+@@ -100,6 +101,16 @@ static inline int soc_is_ar934x(void)
+ 	return soc_is_ar9341() || soc_is_ar9342() || soc_is_ar9344();
+ }
+ 
++static inline int soc_is_qca9533(void)
++{
++	return ath79_soc == ATH79_SOC_QCA9533;
++}
++
++static inline int soc_is_qca953x(void)
++{
++	return soc_is_qca9533();
++}
++
+ static inline int soc_is_qca9556(void)
+ {
+ 	return ath79_soc == ATH79_SOC_QCA9556;
diff --git a/target/linux/ar71xx/patches-4.14/621-MIPS-ath79-add-support-for-QCA956x-SoC.patch b/target/linux/ar71xx/patches-4.14/621-MIPS-ath79-add-support-for-QCA956x-SoC.patch
new file mode 100644
index 0000000000..bfe8b8e9f9
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/621-MIPS-ath79-add-support-for-QCA956x-SoC.patch
@@ -0,0 +1,717 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -114,6 +114,12 @@ config SOC_QCA955X
+ 	select PCI_AR724X if PCI
+ 	def_bool n
+ 
++config SOC_QCA956X
++	select USB_ARCH_HAS_EHCI
++	select HW_HAS_PCI
++	select PCI_AR724X if PCI
++	def_bool n
++
+ config ATH79_DEV_M25P80
+ 	select ATH79_DEV_SPI
+ 	def_bool n
+@@ -148,7 +154,7 @@ config ATH79_DEV_USB
+ 	def_bool n
+ 
+ config ATH79_DEV_WMAC
+-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
++	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X || SOC_QCA956X)
+ 	def_bool n
+ 
+ config ATH79_NVRAM
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -521,6 +521,100 @@ static void __init qca955x_clocks_init(void)
+ 	clk_add_alias("uart", NULL, "ref", NULL);
+ }
+ 
++static void __init qca956x_clocks_init(void)
++{
++	unsigned long ref_rate;
++	unsigned long cpu_rate;
++	unsigned long ddr_rate;
++	unsigned long ahb_rate;
++	u32 pll, out_div, ref_div, nint, hfrac, lfrac, clk_ctrl, postdiv;
++	u32 cpu_pll, ddr_pll;
++	u32 bootstrap;
++
++	bootstrap = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
++	if (bootstrap &	QCA956X_BOOTSTRAP_REF_CLK_40)
++		ref_rate = 40 * 1000 * 1000;
++	else
++		ref_rate = 25 * 1000 * 1000;
++
++	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG_REG);
++	out_div = (pll >> QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
++		  QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
++		  QCA956X_PLL_CPU_CONFIG_REFDIV_MASK;
++
++	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG1_REG);
++	nint = (pll >> QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NINT_MASK;
++	hfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK;
++	lfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT) &
++	       QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK;
++
++	cpu_pll = nint * ref_rate / ref_div;
++	cpu_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
++	cpu_pll += (hfrac >> 13) * ref_rate / ref_div;
++	cpu_pll /= (1 << out_div);
++
++	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG_REG);
++	out_div = (pll >> QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
++		  QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK;
++	ref_div = (pll >> QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
++		  QCA956X_PLL_DDR_CONFIG_REFDIV_MASK;
++	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG1_REG);
++	nint = (pll >> QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NINT_MASK;
++	hfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK;
++	lfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT) &
++	       QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK;
++
++	ddr_pll = nint * ref_rate / ref_div;
++	ddr_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
++	ddr_pll += (hfrac >> 13) * ref_rate / ref_div;
++	ddr_pll /= (1 << out_div);
++
++	clk_ctrl = ath79_pll_rr(QCA956X_PLL_CLK_CTRL_REG);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
++		cpu_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL)
++		cpu_rate = ddr_pll / (postdiv + 1);
++	else
++		cpu_rate = cpu_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
++		ddr_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL)
++		ddr_rate = cpu_pll / (postdiv + 1);
++	else
++		ddr_rate = ddr_pll / (postdiv + 1);
++
++	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
++		  QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
++
++	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
++		ahb_rate = ref_rate;
++	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
++		ahb_rate = ddr_pll / (postdiv + 1);
++	else
++		ahb_rate = cpu_pll / (postdiv + 1);
++
++	ath79_add_sys_clkdev("ref", ref_rate);
++	ath79_add_sys_clkdev("cpu", cpu_rate);
++	ath79_add_sys_clkdev("ddr", ddr_rate);
++	ath79_add_sys_clkdev("ahb", ahb_rate);
++
++	clk_add_alias("wdt", NULL, "ref", NULL);
++	clk_add_alias("uart", NULL, "ref", NULL);
++}
++
+ void __init ath79_clocks_init(void)
+ {
+ 	if (soc_is_ar71xx())
+@@ -535,6 +629,8 @@ void __init ath79_clocks_init(void)
+ 		qca953x_clocks_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_clocks_init();
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		qca956x_clocks_init();
+ 	else
+ 		BUG();
+ }
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -107,6 +107,8 @@ void ath79_device_reset_set(u32 mask)
+ 		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		reg = QCA956X_RESET_REG_RESET_MODULE;
+ 	else
+ 		panic("Reset register not defined for this SOC");
+ 
+@@ -137,6 +139,8 @@ void ath79_device_reset_clear(u32 mask)
+ 		reg = QCA953X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_qca955x())
+ 		reg = QCA955X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		reg = QCA956X_RESET_REG_RESET_MODULE;
+ 	else
+ 		panic("Reset register not defined for this SOC");
+ 
+@@ -163,6 +167,8 @@ u32 ath79_device_reset_get(u32 mask)
+ 		reg = AR933X_RESET_REG_RESET_MODULE;
+ 	else if (soc_is_ar934x())
+ 		reg = AR934X_RESET_REG_RESET_MODULE;
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		reg = QCA956X_RESET_REG_RESET_MODULE;
+ 	else
+ 		BUG();
+ 
+--- a/arch/mips/ath79/dev-common.c
++++ b/arch/mips/ath79/dev-common.c
+@@ -95,7 +95,9 @@ void __init ath79_register_uart(void)
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar934x() ||
+ 	    soc_is_qca953x() ||
+-	    soc_is_qca955x()) {
++	    soc_is_qca955x() ||
++	    soc_is_qca956x() ||
++	    soc_is_tp9343()) {
+ 		ath79_uart_data[0].uartclk = uart_clk_rate;
+ 		platform_device_register(&ath79_uart_device);
+ 	} else if (soc_is_ar933x()) {
+@@ -164,6 +166,9 @@ void __init ath79_gpio_init(void)
+ 	} else if (soc_is_qca955x()) {
+ 		ath79_gpio_pdata.ngpios = QCA955X_GPIO_COUNT;
+ 		ath79_gpio_pdata.oe_inverted = 1;
++	} else if (soc_is_qca956x() || soc_is_tp9343()) {
++		ath79_gpio_pdata.ngpios = QCA956X_GPIO_COUNT;
++		ath79_gpio_pdata.oe_inverted = 1;
+ 	} else {
+ 		BUG();
+ 	}
+--- a/arch/mips/ath79/dev-usb.c
++++ b/arch/mips/ath79/dev-usb.c
+@@ -296,6 +296,19 @@ static void __init qca955x_usb_setup(void)
+ 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+ }
+ 
++static void __init qca956x_usb_setup(void)
++{
++	ath79_usb_register("ehci-platform", 0,
++			   QCA956X_EHCI0_BASE, QCA956X_EHCI_SIZE,
++			   ATH79_IP3_IRQ(0),
++			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++
++	ath79_usb_register("ehci-platform", 1,
++			   QCA956X_EHCI1_BASE, QCA956X_EHCI_SIZE,
++			   ATH79_IP3_IRQ(1),
++			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++}
++
+ void __init ath79_register_usb(void)
+ {
+ 	if (soc_is_ar71xx())
+@@ -314,6 +327,8 @@ void __init ath79_register_usb(void)
+ 		qca953x_usb_setup();
+ 	else if (soc_is_qca955x())
+ 		qca955x_usb_setup();
++	else if (soc_is_qca956x())
++		qca956x_usb_setup();
+ 	else
+ 		BUG();
+ }
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -195,6 +195,26 @@ static void qca955x_wmac_setup(void)
+ #define AR93XX_OTP_READ_DATA \
+ 	(soc_is_ar934x() ? AR934X_OTP_READ_DATA : AR9300_OTP_READ_DATA)
+ 
++static void qca956x_wmac_setup(void)
++{
++	u32 t;
++
++	ath79_wmac_device.name = "qca956x_wmac";
++
++	ath79_wmac_resources[0].start = QCA956X_WMAC_BASE;
++	ath79_wmac_resources[0].end = QCA956X_WMAC_BASE + QCA956X_WMAC_SIZE - 1;
++	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
++	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
++
++	t = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
++	if (t & QCA956X_BOOTSTRAP_REF_CLK_40)
++		ath79_wmac_data.is_clk_25mhz = false;
++	else
++		ath79_wmac_data.is_clk_25mhz = true;
++
++	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
++}
++
+ static bool __init
+ ar93xx_wmac_otp_read_word(void __iomem *base, int addr, u32 *data)
+ {
+@@ -398,6 +418,8 @@ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ 		qca953x_wmac_setup();
+ 	else if (soc_is_qca955x())
+ 		qca955x_wmac_setup();
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		qca956x_wmac_setup();
+ 	else
+ 		BUG();
+ 
+--- a/arch/mips/ath79/early_printk.c
++++ b/arch/mips/ath79/early_printk.c
+@@ -120,6 +120,8 @@ static void prom_putchar_init(void)
+ 	case REV_ID_MAJOR_QCA9533_V2:
+ 	case REV_ID_MAJOR_QCA9556:
+ 	case REV_ID_MAJOR_QCA9558:
++	case REV_ID_MAJOR_TP9343:
++	case REV_ID_MAJOR_QCA956X:
+ 		_prom_putchar = prom_putchar_ar71xx;
+ 		break;
+ 
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -31,7 +31,10 @@ static void __iomem *ath79_gpio_get_function_reg(void)
+ 	    soc_is_ar913x() ||
+ 	    soc_is_ar933x())
+ 		reg = AR71XX_GPIO_REG_FUNC;
+-	else if (soc_is_ar934x() || soc_is_qca953x())
++	else if (soc_is_ar934x() ||
++		 soc_is_qca953x() ||
++		 soc_is_qca956x() ||
++		 soc_is_tp9343())
+ 		reg = AR934X_GPIO_REG_FUNC;
+ 	else
+ 		BUG();
+@@ -64,7 +67,7 @@ void __init ath79_gpio_output_select(unsigned gpio, u8 val)
+ 	unsigned int reg;
+ 	u32 t, s;
+ 
+-	BUG_ON(!soc_is_ar934x() && !soc_is_qca953x());
++	BUG_ON(!soc_is_ar934x() && !soc_is_qca953x() && !soc_is_qca956x());
+ 
+ 	if (gpio >= AR934X_GPIO_COUNT)
+ 		return;
+--- a/arch/mips/ath79/irq.c
++++ b/arch/mips/ath79/irq.c
+@@ -156,6 +156,87 @@ static void qca955x_irq_init(void)
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca955x_ip3_irq_dispatch);
+ }
+ 
++static void qca956x_ip2_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
++	status &= QCA956X_EXT_INT_PCIE_RC1_ALL | QCA956X_EXT_INT_WMAC_ALL;
++
++	if (status == 0) {
++		spurious_interrupt();
++		return;
++	}
++
++	if (status & QCA956X_EXT_INT_PCIE_RC1_ALL) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP2_IRQ(0));
++	}
++
++	if (status & QCA956X_EXT_INT_WMAC_ALL) {
++		/* TODO: flsuh DDR? */
++		generic_handle_irq(ATH79_IP2_IRQ(1));
++	}
++}
++
++static void qca956x_ip3_irq_dispatch(struct irq_desc *desc)
++{
++	u32 status;
++
++	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
++	status &= QCA956X_EXT_INT_PCIE_RC2_ALL |
++		  QCA956X_EXT_INT_USB1 | QCA956X_EXT_INT_USB2;
++
++	if (status == 0) {
++		spurious_interrupt();
++		return;
++	}
++
++	if (status & QCA956X_EXT_INT_USB1) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(0));
++	}
++
++	if (status & QCA956X_EXT_INT_USB2) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(1));
++	}
++
++	if (status & QCA956X_EXT_INT_PCIE_RC2_ALL) {
++		/* TODO: flush DDR? */
++		generic_handle_irq(ATH79_IP3_IRQ(2));
++	}
++}
++
++static void qca956x_enable_timer_cb(void) {
++	u32 misc;
++
++	misc = ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
++	misc |= MISC_INT_MIPS_SI_TIMERINT_MASK;
++	ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_ENABLE, misc);
++}
++
++static void qca956x_irq_init(void)
++{
++	int i;
++
++	for (i = ATH79_IP2_IRQ_BASE;
++	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca956x_ip2_irq_dispatch);
++
++	for (i = ATH79_IP3_IRQ_BASE;
++	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
++		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++
++	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca956x_ip3_irq_dispatch);
++
++	/* QCA956x timer init workaround has to be applied right before setting
++	 * up the clock. Else, there will be no jiffies */
++	late_time_init = &qca956x_enable_timer_cb;
++}
++
+ void __init arch_init_irq(void)
+ {
+ 	unsigned irq_wb_chan2 = -1;
+@@ -183,7 +264,9 @@ void __init arch_init_irq(void)
+ 		 soc_is_ar933x() ||
+ 		 soc_is_ar934x() ||
+ 		 soc_is_qca953x() ||
+-		 soc_is_qca955x())
++		 soc_is_qca955x() ||
++		 soc_is_qca956x() ||
++		 soc_is_tp9343())
+ 		misc_is_ar71xx = false;
+ 	else
+ 		BUG();
+@@ -197,4 +280,6 @@ void __init arch_init_irq(void)
+ 		qca953x_irq_init();
+ 	else if (soc_is_qca955x())
+ 		qca955x_irq_init();
++	else if (soc_is_qca956x() || soc_is_tp9343())
++		qca956x_irq_init();
+ }
+--- a/arch/mips/ath79/pci.c
++++ b/arch/mips/ath79/pci.c
+@@ -68,6 +68,21 @@ static const struct ath79_pci_irq qca955x_pci_irq_map[] = {
+ 	},
+ };
+ 
++static const struct ath79_pci_irq qca956x_pci_irq_map[] = {
++	{
++		.bus    = 0,
++		.slot   = 0,
++		.pin    = 1,
++		.irq    = ATH79_PCI_IRQ(0),
++	},
++	{
++		.bus    = 1,
++		.slot   = 0,
++		.pin    = 1,
++		.irq    = ATH79_PCI_IRQ(1),
++	},
++};
++
+ int pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+ {
+ 	int irq = -1;
+@@ -86,6 +101,9 @@ int pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+ 		} else if (soc_is_qca955x()) {
+ 			ath79_pci_irq_map = qca955x_pci_irq_map;
+ 			ath79_pci_nr_irqs = ARRAY_SIZE(qca955x_pci_irq_map);
++		} else if (soc_is_qca956x()) {
++			ath79_pci_irq_map = qca956x_pci_irq_map;
++			ath79_pci_nr_irqs = ARRAY_SIZE(qca956x_pci_irq_map);
+ 		} else {
+ 			pr_crit("pci %s: invalid irq map\n",
+ 				pci_name((struct pci_dev *) dev));
+@@ -303,6 +321,15 @@ int __init ath79_register_pci(void)
+ 						 QCA955X_PCI_MEM_SIZE,
+ 						 1,
+ 						 ATH79_IP3_IRQ(2));
++	} else if (soc_is_qca956x()) {
++		pdev = ath79_register_pci_ar724x(0,
++						 QCA956X_PCI_CFG_BASE1,
++						 QCA956X_PCI_CTRL_BASE1,
++						 QCA956X_PCI_CRP_BASE1,
++						 QCA956X_PCI_MEM_BASE1,
++						 QCA956X_PCI_MEM_SIZE,
++						 1,
++						 ATH79_IP3_IRQ(2));
+ 	} else {
+ 		/* No PCI support */
+ 		return -ENODEV;
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -176,6 +176,18 @@ static void __init ath79_detect_sys_type(void)
+ 		rev = id & QCA955X_REV_ID_REVISION_MASK;
+ 		break;
+ 
++	case REV_ID_MAJOR_QCA956X:
++		ath79_soc = ATH79_SOC_QCA956X;
++		chip = "956X";
++		rev = id & QCA956X_REV_ID_REVISION_MASK;
++		break;
++
++	case REV_ID_MAJOR_TP9343:
++		ath79_soc = ATH79_SOC_TP9343;
++		chip = "9343";
++		rev = id & QCA956X_REV_ID_REVISION_MASK;
++		break;
++
+ 	default:
+ 		panic("ath79: unknown SoC, id:0x%08x", id);
+ 	}
+@@ -183,9 +195,12 @@ static void __init ath79_detect_sys_type(void)
+ 	if (ver == 1)
+ 		ath79_soc_rev = rev;
+ 
+-	if (soc_is_qca953x() || soc_is_qca955x())
++	if (soc_is_qca953x() || soc_is_qca955x() || soc_is_qca956x())
+ 		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s ver %u rev %u",
+ 			chip, ver, rev);
++	else if (soc_is_tp9343())
++		sprintf(ath79_sys_type, "Qualcomm Atheros TP%s rev %u",
++			chip, rev);
+ 	else
+ 		sprintf(ath79_sys_type, "Atheros AR%s rev %u", chip, rev);
+ 	pr_info("SoC: %s\n", ath79_sys_type);
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -143,6 +143,23 @@
+ #define QCA955X_NFC_BASE	0x1b800200
+ #define QCA955X_NFC_SIZE	0xb8
+ 
++#define QCA956X_PCI_MEM_BASE1	0x12000000
++#define QCA956X_PCI_MEM_SIZE	0x02000000
++#define QCA956X_PCI_CFG_BASE1	0x16000000
++#define QCA956X_PCI_CFG_SIZE	0x1000
++#define QCA956X_PCI_CRP_BASE1	(AR71XX_APB_BASE + 0x00250000)
++#define QCA956X_PCI_CRP_SIZE	0x1000
++#define QCA956X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
++#define QCA956X_PCI_CTRL_SIZE	0x100
++
++#define QCA956X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
++#define QCA956X_WMAC_SIZE	0x20000
++#define QCA956X_EHCI0_BASE	0x1b000000
++#define QCA956X_EHCI1_BASE	0x1b400000
++#define QCA956X_EHCI_SIZE	0x200
++#define QCA956X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA956X_GMAC_SIZE	0x64
++
+ #define AR9300_OTP_BASE		0x14000
+ #define AR9300_OTP_STATUS	0x15f18
+ #define AR9300_OTP_STATUS_TYPE		0x7
+@@ -151,6 +168,13 @@
+ #define AR9300_OTP_STATUS_SM_BUSY	0x1
+ #define AR9300_OTP_READ_DATA	0x15f1c
+ 
++/*
++ * Hidden Registers
++ */
++#define QCA956X_DAM_RESET_OFFSET	0xb90001bc
++#define QCA956X_DAM_RESET_SIZE		0x4
++#define QCA956X_INLINE_CHKSUM_ENG	BIT(27)
++
+ /*
+  * DDR_CTRL block
+  */
+@@ -382,6 +406,49 @@
+ #define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
+ #define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+ 
++#define QCA956X_PLL_CPU_CONFIG_REG			0x00
++#define QCA956X_PLL_CPU_CONFIG1_REG			0x04
++#define QCA956X_PLL_DDR_CONFIG_REG			0x08
++#define QCA956X_PLL_DDR_CONFIG1_REG			0x0c
++#define QCA956X_PLL_CLK_CTRL_REG			0x10
++
++#define QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT		12
++#define QCA956X_PLL_CPU_CONFIG_REFDIV_MASK		0x1f
++#define QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT		19
++#define QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK		0x7
++
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT		0
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK		0x1f
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT		5
++#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK		0x1fff
++#define QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT		18
++#define QCA956X_PLL_CPU_CONFIG1_NINT_MASK		0x1ff
++
++#define QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT		16
++#define QCA956X_PLL_DDR_CONFIG_REFDIV_MASK		0x1f
++#define QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT		23
++#define QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK		0x7
++
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT		0
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK		0x1f
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT		5
++#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK		0x1fff
++#define QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT		18
++#define QCA956X_PLL_DDR_CONFIG1_NINT_MASK		0x1ff
++
++#define QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
++#define QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
++#define QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
++#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
++#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
++#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
++#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
++#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL	BIT(20)
++#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL	BIT(21)
++#define QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
++
+ /*
+  * USB_CONFIG block
+  */
+@@ -429,6 +496,11 @@
+ #define QCA955X_RESET_REG_BOOTSTRAP		0xb0
+ #define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
+ 
++#define QCA956X_RESET_REG_RESET_MODULE		0x1c
++#define QCA956X_RESET_REG_BOOTSTRAP		0xb0
++#define QCA956X_RESET_REG_EXT_INT_STATUS	0xac
++
++#define MISC_INT_MIPS_SI_TIMERINT_MASK	BIT(28)
+ #define MISC_INT_ETHSW			BIT(12)
+ #define MISC_INT_TIMER4			BIT(10)
+ #define MISC_INT_TIMER3			BIT(9)
+@@ -603,6 +675,8 @@
+ 
+ #define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
+ 
++#define QCA956X_BOOTSTRAP_REF_CLK_40	BIT(2)
++
+ #define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+ #define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+ #define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
+@@ -670,6 +744,37 @@
+ 	 QCA955X_EXT_INT_PCIE_RC2_INT1 | QCA955X_EXT_INT_PCIE_RC2_INT2 | \
+ 	 QCA955X_EXT_INT_PCIE_RC2_INT3)
+ 
++#define QCA956X_EXT_INT_WMAC_MISC		BIT(0)
++#define QCA956X_EXT_INT_WMAC_TX			BIT(1)
++#define QCA956X_EXT_INT_WMAC_RXLP		BIT(2)
++#define QCA956X_EXT_INT_WMAC_RXHP		BIT(3)
++#define QCA956X_EXT_INT_PCIE_RC1		BIT(4)
++#define QCA956X_EXT_INT_PCIE_RC1_INT0		BIT(5)
++#define QCA956X_EXT_INT_PCIE_RC1_INT1		BIT(6)
++#define QCA956X_EXT_INT_PCIE_RC1_INT2		BIT(7)
++#define QCA956X_EXT_INT_PCIE_RC1_INT3		BIT(8)
++#define QCA956X_EXT_INT_PCIE_RC2		BIT(12)
++#define QCA956X_EXT_INT_PCIE_RC2_INT0		BIT(13)
++#define QCA956X_EXT_INT_PCIE_RC2_INT1		BIT(14)
++#define QCA956X_EXT_INT_PCIE_RC2_INT2		BIT(15)
++#define QCA956X_EXT_INT_PCIE_RC2_INT3		BIT(16)
++#define QCA956X_EXT_INT_USB1			BIT(24)
++#define QCA956X_EXT_INT_USB2			BIT(28)
++
++#define QCA956X_EXT_INT_WMAC_ALL \
++	(QCA956X_EXT_INT_WMAC_MISC | QCA956X_EXT_INT_WMAC_TX | \
++	 QCA956X_EXT_INT_WMAC_RXLP | QCA956X_EXT_INT_WMAC_RXHP)
++
++#define QCA956X_EXT_INT_PCIE_RC1_ALL \
++	(QCA956X_EXT_INT_PCIE_RC1 | QCA956X_EXT_INT_PCIE_RC1_INT0 | \
++	 QCA956X_EXT_INT_PCIE_RC1_INT1 | QCA956X_EXT_INT_PCIE_RC1_INT2 | \
++	 QCA956X_EXT_INT_PCIE_RC1_INT3)
++
++#define QCA956X_EXT_INT_PCIE_RC2_ALL \
++	(QCA956X_EXT_INT_PCIE_RC2 | QCA956X_EXT_INT_PCIE_RC2_INT0 | \
++	 QCA956X_EXT_INT_PCIE_RC2_INT1 | QCA956X_EXT_INT_PCIE_RC2_INT2 | \
++	 QCA956X_EXT_INT_PCIE_RC2_INT3)
++
+ #define REV_ID_MAJOR_MASK		0xfff0
+ #define REV_ID_MAJOR_AR71XX		0x00a0
+ #define REV_ID_MAJOR_AR913X		0x00b0
+@@ -685,6 +790,8 @@
+ #define REV_ID_MAJOR_QCA9533_V2		0x0160
+ #define REV_ID_MAJOR_QCA9556		0x0130
+ #define REV_ID_MAJOR_QCA9558		0x1130
++#define REV_ID_MAJOR_TP9343		0x0150
++#define REV_ID_MAJOR_QCA956X		0x1150
+ 
+ #define AR71XX_REV_ID_MINOR_MASK	0x3
+ #define AR71XX_REV_ID_MINOR_AR7130	0x0
+@@ -709,6 +816,8 @@
+ 
+ #define QCA955X_REV_ID_REVISION_MASK	0xf
+ 
++#define QCA956X_REV_ID_REVISION_MASK	0xf
++
+ /*
+  * SPI block
+  */
+@@ -781,6 +890,19 @@
+ #define QCA955X_GPIO_REG_OUT_FUNC5	0x40
+ #define QCA955X_GPIO_REG_FUNC		0x6c
+ 
++#define QCA956X_GPIO_REG_OUT_FUNC0	0x2c
++#define QCA956X_GPIO_REG_OUT_FUNC1	0x30
++#define QCA956X_GPIO_REG_OUT_FUNC2	0x34
++#define QCA956X_GPIO_REG_OUT_FUNC3	0x38
++#define QCA956X_GPIO_REG_OUT_FUNC4	0x3c
++#define QCA956X_GPIO_REG_OUT_FUNC5	0x40
++#define QCA956X_GPIO_REG_IN_ENABLE0	0x44
++#define QCA956X_GPIO_REG_IN_ENABLE3	0x50
++#define QCA956X_GPIO_REG_FUNC		0x6c
++
++#define QCA956X_GPIO_OUT_MUX_GE0_MDO	32
++#define QCA956X_GPIO_OUT_MUX_GE0_MDC	33
++
+ #define AR71XX_GPIO_COUNT		16
+ #define AR7240_GPIO_COUNT		18
+ #define AR7241_GPIO_COUNT		20
+@@ -789,6 +911,7 @@
+ #define AR934X_GPIO_COUNT		23
+ #define QCA953X_GPIO_COUNT		18
+ #define QCA955X_GPIO_COUNT		24
++#define QCA956X_GPIO_COUNT		23
+ 
+ /*
+  * SRIF block
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -35,6 +35,8 @@ enum ath79_soc_type {
+ 	ATH79_SOC_QCA9533,
+ 	ATH79_SOC_QCA9556,
+ 	ATH79_SOC_QCA9558,
++	ATH79_SOC_TP9343,
++	ATH79_SOC_QCA956X,
+ };
+ 
+ extern enum ath79_soc_type ath79_soc;
+@@ -126,6 +128,26 @@ static inline int soc_is_qca955x(void)
+ 	return soc_is_qca9556() || soc_is_qca9558();
+ }
+ 
++static inline int soc_is_tp9343(void)
++{
++	return ath79_soc == ATH79_SOC_TP9343;
++}
++
++static inline int soc_is_qca9561(void)
++{
++	return ath79_soc == ATH79_SOC_QCA956X;
++}
++
++static inline int soc_is_qca9563(void)
++{
++	return ath79_soc == ATH79_SOC_QCA956X;
++}
++
++static inline int soc_is_qca956x(void)
++{
++	return soc_is_qca9561() || soc_is_qca9563();
++}
++
+ void ath79_ddr_wb_flush(unsigned int reg);
+ void ath79_ddr_set_pci_windows(void);
+ 
diff --git a/target/linux/ar71xx/patches-4.14/622-MIPS-ath79-add-more-register-defines-for-QCA956x-SoC.patch b/target/linux/ar71xx/patches-4.14/622-MIPS-ath79-add-more-register-defines-for-QCA956x-SoC.patch
new file mode 100644
index 0000000000..6573b298a5
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/622-MIPS-ath79-add-more-register-defines-for-QCA956x-SoC.patch
@@ -0,0 +1,38 @@
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -157,6 +157,10 @@
+ #define QCA956X_EHCI0_BASE	0x1b000000
+ #define QCA956X_EHCI1_BASE	0x1b400000
+ #define QCA956X_EHCI_SIZE	0x200
++#define QCA956X_GMAC_SGMII_BASE	(AR71XX_APB_BASE + 0x00070000)
++#define QCA956X_GMAC_SGMII_SIZE	0x64
++#define QCA956X_PLL_BASE	(AR71XX_APB_BASE + 0x00050000)
++#define QCA956X_PLL_SIZE	0x50
+ #define QCA956X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+ #define QCA956X_GMAC_SIZE	0x64
+ 
+@@ -411,6 +415,7 @@
+ #define QCA956X_PLL_DDR_CONFIG_REG			0x08
+ #define QCA956X_PLL_DDR_CONFIG1_REG			0x0c
+ #define QCA956X_PLL_CLK_CTRL_REG			0x10
++#define QCA956X_PLL_ETH_XMII_CONTROL_REG		0x30
+ 
+ #define QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT		12
+ #define QCA956X_PLL_CPU_CONFIG_REFDIV_MASK		0x1f
+@@ -1193,4 +1198,16 @@
+ #define QCA955X_ETH_CFG_TXE_DELAY_MASK	0x3
+ #define QCA955X_ETH_CFG_TXE_DELAY_SHIFT	20
+ 
++/*
++ * QCA956X GMAC Interface
++ */
++
++#define QCA956X_GMAC_REG_ETH_CFG		0x00
++
++#define QCA956X_ETH_CFG_SW_ONLY_MODE		BIT(7)
++#define QCA956X_ETH_CFG_SW_PHY_SWAP		    BIT(8)
++#define QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(9)
++#define QCA956X_ETH_CFG_SW_APB_ACCESS		BIT(10)
++#define QCA956X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++
+ #endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/ar71xx/patches-4.14/630-MIPS-ath79-fix-chained-irq-disable.patch b/target/linux/ar71xx/patches-4.14/630-MIPS-ath79-fix-chained-irq-disable.patch
new file mode 100644
index 0000000000..2b92b88d03
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/630-MIPS-ath79-fix-chained-irq-disable.patch
@@ -0,0 +1,106 @@
+--- a/arch/mips/ath79/irq.c
++++ b/arch/mips/ath79/irq.c
+@@ -27,6 +27,9 @@
+ #include "machtypes.h"
+ 
+ 
++static struct irq_chip ip2_chip;
++static struct irq_chip ip3_chip;
++
+ static void ar934x_ip2_irq_dispatch(struct irq_desc *desc)
+ {
+ 	u32 status;
+@@ -50,8 +53,7 @@ static void ar934x_ip2_irq_init(void)
+ 
+ 	for (i = ATH79_IP2_IRQ_BASE;
+ 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
++		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), ar934x_ip2_irq_dispatch);
+ }
+@@ -79,7 +81,7 @@ static void qca953x_irq_init(void)
+ 
+ 	for (i = ATH79_IP2_IRQ_BASE;
+ 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca953x_ip2_irq_dispatch);
+ }
+@@ -143,15 +145,13 @@ static void qca955x_irq_init(void)
+ 
+ 	for (i = ATH79_IP2_IRQ_BASE;
+ 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
++		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca955x_ip2_irq_dispatch);
+ 
+ 	for (i = ATH79_IP3_IRQ_BASE;
+ 	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip,
+-					 handle_level_irq);
++		irq_set_chip_and_handler(i, &ip3_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca955x_ip3_irq_dispatch);
+ }
+@@ -222,13 +222,13 @@ static void qca956x_irq_init(void)
+ 
+ 	for (i = ATH79_IP2_IRQ_BASE;
+ 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca956x_ip2_irq_dispatch);
+ 
+ 	for (i = ATH79_IP3_IRQ_BASE;
+ 	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
+-		irq_set_chip_and_handler(i, &dummy_irq_chip, handle_level_irq);
++		irq_set_chip_and_handler(i, &ip3_chip, handle_level_irq);
+ 
+ 	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca956x_ip3_irq_dispatch);
+ 
+@@ -237,12 +237,40 @@ static void qca956x_irq_init(void)
+ 	late_time_init = &qca956x_enable_timer_cb;
+ }
+ 
++static void ath79_ip2_disable(struct irq_data *data)
++{
++	disable_irq(ATH79_CPU_IRQ(2));
++}
++
++static void ath79_ip2_enable(struct irq_data *data)
++{
++	enable_irq(ATH79_CPU_IRQ(2));
++}
++
++static void ath79_ip3_disable(struct irq_data *data)
++{
++	disable_irq(ATH79_CPU_IRQ(3));
++}
++
++static void ath79_ip3_enable(struct irq_data *data)
++{
++	enable_irq(ATH79_CPU_IRQ(3));
++}
++
+ void __init arch_init_irq(void)
+ {
+ 	unsigned irq_wb_chan2 = -1;
+ 	unsigned irq_wb_chan3 = -1;
+ 	bool misc_is_ar71xx;
+ 
++	ip2_chip = dummy_irq_chip;
++	ip2_chip.irq_disable = ath79_ip2_disable;
++	ip2_chip.irq_enable = ath79_ip2_enable;
++
++	ip3_chip = dummy_irq_chip;
++	ip3_chip.irq_disable = ath79_ip3_disable;
++	ip3_chip.irq_enable = ath79_ip3_enable;
++
+ 	if (mips_machtype == ATH79_MACH_GENERIC_OF) {
+ 		irqchip_init();
+ 		return;
diff --git a/target/linux/ar71xx/patches-4.14/631-MIPS-ath79-wmac-enable-set-led-pin.patch b/target/linux/ar71xx/patches-4.14/631-MIPS-ath79-wmac-enable-set-led-pin.patch
new file mode 100644
index 0000000000..a312217711
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/631-MIPS-ath79-wmac-enable-set-led-pin.patch
@@ -0,0 +1,24 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -406,6 +406,11 @@ void __init ath79_wmac_set_ext_lna_gpio(
+ 		ar934x_set_ext_lna_gpio(chain, gpio);
+ }
+ 
++void __init ath79_wmac_set_led_pin(int gpio)
++{
++	ath79_wmac_data.led_pin = gpio;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -18,6 +18,7 @@ void ath79_wmac_disable_2ghz(void);
+ void ath79_wmac_disable_5ghz(void);
+ void ath79_wmac_set_tx_gain_buffalo(void);
+ void ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio);
++void ath79_wmac_set_led_pin(int gpio);
+ 
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
diff --git a/target/linux/ar71xx/patches-4.14/632-MIPS-ath79-gpio-enable-set-direction.patch b/target/linux/ar71xx/patches-4.14/632-MIPS-ath79-gpio-enable-set-direction.patch
new file mode 100644
index 0000000000..4cf36325e1
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/632-MIPS-ath79-gpio-enable-set-direction.patch
@@ -0,0 +1,32 @@
+--- a/arch/mips/ath79/common.h
++++ b/arch/mips/ath79/common.h
+@@ -28,6 +28,7 @@ void ath79_gpio_function_enable(u32 mask
+ void ath79_gpio_function_disable(u32 mask);
+ void ath79_gpio_function_setup(u32 set, u32 clear);
+ void ath79_gpio_output_select(unsigned gpio, u8 val);
++int ath79_gpio_direction_select(unsigned gpio, bool oe);
+ void ath79_gpio_init(void);
+ 
+ #endif /* __ATH79_COMMON_H */
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -83,3 +83,19 @@ void __init ath79_gpio_output_select(uns
+ 	/* flush write */
+ 	(void) __raw_readl(base + reg);
+ }
++
++int ath79_gpio_direction_select(unsigned gpio, bool oe)
++{
++	void __iomem *base = ath79_gpio_base;
++	bool ieq_1 = (soc_is_ar934x() ||
++			soc_is_qca953x());
++
++	if ((ieq_1 && oe) || (!ieq_1 && !oe))
++		__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << gpio),
++				base + AR71XX_GPIO_REG_OE);
++	else
++		__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) | (1 << gpio),
++				base + AR71XX_GPIO_REG_OE);
++
++	return 0;
++}
diff --git a/target/linux/ar71xx/patches-4.14/640-MIPS-ath79-add-QCA955x-wmac-reset.patch b/target/linux/ar71xx/patches-4.14/640-MIPS-ath79-add-QCA955x-wmac-reset.patch
new file mode 100644
index 0000000000..bb315a1e65
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/640-MIPS-ath79-add-QCA955x-wmac-reset.patch
@@ -0,0 +1,82 @@
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -38,7 +38,7 @@ unsigned int ath79_soc_rev;
+ void __iomem *ath79_pll_base;
+ void __iomem *ath79_reset_base;
+ EXPORT_SYMBOL_GPL(ath79_reset_base);
+-static void __iomem *ath79_ddr_base;
++void __iomem *ath79_ddr_base;
+ static void __iomem *ath79_ddr_wb_flush_base;
+ static void __iomem *ath79_ddr_pci_win_base;
+ 
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -32,7 +32,7 @@
+ #define AR71XX_SPI_SIZE		0x01000000
+ 
+ #define AR71XX_DDR_CTRL_BASE	(AR71XX_APB_BASE + 0x00000000)
+-#define AR71XX_DDR_CTRL_SIZE	0x100
++#define AR71XX_DDR_CTRL_SIZE	0x200
+ #define AR71XX_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+ #define AR71XX_UART_SIZE	0x100
+ #define AR71XX_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
+@@ -229,6 +229,9 @@
+ #define QCA953X_DDR_REG_FLUSH_PCIE	0xa8
+ #define QCA953X_DDR_REG_FLUSH_WMAC	0xac
+ 
++#define QCA955X_DDR_CTL_CONFIG		0x108
++#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC	BIT(23)
++
+ /*
+  * PLL block
+  */
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -165,6 +165,27 @@ static void qca953x_wmac_setup(void)
+ 	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
+ }
+ 
++static int ar955x_wmac_reset(void)
++{
++	int i;
++
++	/* Try to wait for WMAC DDR activity to stop */
++	for (i = 0; i < 10; i++) {
++		if (!(__raw_readl(ath79_ddr_base + QCA955X_DDR_CTL_CONFIG) &
++		      QCA955X_DDR_CTL_CONFIG_ACT_WMAC))
++			break;
++
++		udelay(10);
++	}
++
++	ath79_device_reset_set(QCA955X_RESET_RTC);
++	udelay(10);
++	ath79_device_reset_clear(QCA955X_RESET_RTC);
++	udelay(10);
++
++	return 0;
++}
++
+ static void qca955x_wmac_setup(void)
+ {
+ 	u32 t;
+@@ -181,6 +202,8 @@ static void qca955x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = false;
+ 	else
+ 		ath79_wmac_data.is_clk_25mhz = true;
++
++	ath79_wmac_data.external_reset = ar955x_wmac_reset;
+ }
+ 
+ #define AR93XX_WMAC_SIZE \
+--- a/arch/mips/ath79/common.h
++++ b/arch/mips/ath79/common.h
+@@ -19,6 +19,8 @@
+ #define ATH79_MEM_SIZE_MIN	(2 * 1024 * 1024)
+ #define ATH79_MEM_SIZE_MAX	(256 * 1024 * 1024)
+ 
++extern void __iomem *ath79_ddr_base;
++
+ void ath79_clocks_init(void);
+ unsigned long ath79_get_sys_clk_rate(const char *id);
+ 
diff --git a/target/linux/ar71xx/patches-4.14/641-MIPS-ath79-ath9k-exports.patch b/target/linux/ar71xx/patches-4.14/641-MIPS-ath79-ath9k-exports.patch
new file mode 100644
index 0000000000..acf0017c12
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/641-MIPS-ath79-ath9k-exports.patch
@@ -0,0 +1,26 @@
+--- a/arch/mips/ath79/common.c
++++ b/arch/mips/ath79/common.c
+@@ -34,11 +34,13 @@ EXPORT_SYMBOL_GPL(ath79_ddr_freq);
+ 
+ enum ath79_soc_type ath79_soc;
+ unsigned int ath79_soc_rev;
++EXPORT_SYMBOL_GPL(ath79_soc_rev);
+ 
+ void __iomem *ath79_pll_base;
+ void __iomem *ath79_reset_base;
+ EXPORT_SYMBOL_GPL(ath79_reset_base);
+ void __iomem *ath79_ddr_base;
++EXPORT_SYMBOL_GPL(ath79_ddr_base);
+ static void __iomem *ath79_ddr_wb_flush_base;
+ static void __iomem *ath79_ddr_pci_win_base;
+ 
+--- a/arch/mips/include/asm/mach-ath79/ath79.h
++++ b/arch/mips/include/asm/mach-ath79/ath79.h
+@@ -153,6 +153,7 @@ void ath79_ddr_set_pci_windows(void);
+ 
+ extern void __iomem *ath79_gpio_base;
+ extern void __iomem *ath79_pll_base;
++extern void __iomem *ath79_ddr_base;
+ extern void __iomem *ath79_reset_base;
+ 
+ static inline void ath79_pll_wr(unsigned reg, u32 val)
diff --git a/target/linux/ar71xx/patches-4.14/642-MIPS-ath79-no-of.patch b/target/linux/ar71xx/patches-4.14/642-MIPS-ath79-no-of.patch
new file mode 100644
index 0000000000..b2ef8a73c0
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/642-MIPS-ath79-no-of.patch
@@ -0,0 +1,70 @@
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -202,7 +202,6 @@ config ATH79
+ 	select SYS_SUPPORTS_BIG_ENDIAN
+ 	select SYS_SUPPORTS_MIPS16
+ 	select SYS_SUPPORTS_ZBOOT_UART_PROM
+-	select USE_OF
+ 	help
+ 	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
+ 
+--- a/arch/mips/ath79/clock.c
++++ b/arch/mips/ath79/clock.c
+@@ -32,10 +32,12 @@
+ #define AR724X_BASE_FREQ	40000000
+ 
+ static struct clk *clks[ATH79_CLK_END];
++#ifdef CONFIG_OF
+ static struct clk_onecell_data clk_data = {
+ 	.clks = clks,
+ 	.clk_num = ARRAY_SIZE(clks),
+ };
++#endif
+ 
+ static struct clk *__init ath79_add_sys_clkdev(
+ 	const char *id, unsigned long rate)
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -224,16 +224,20 @@ unsigned int get_c0_compare_int(void)
+ 
+ void __init plat_mem_setup(void)
+ {
++#ifdef CONFIG_OF
+ 	unsigned long fdt_start;
++#endif
+ 
+ 	set_io_port_base(KSEG1);
+ 
++#ifdef CONFIG_OF
+ 	/* Get the position of the FDT passed by the bootloader */
+ 	fdt_start = fw_getenvl("fdt_start");
+ 	if (fdt_start)
+ 		__dt_setup_arch((void *)KSEG0ADDR(fdt_start));
+ 	else if (fw_passed_dtb)
+ 		__dt_setup_arch((void *)KSEG0ADDR(fw_passed_dtb));
++#endif
+ 
+ 	if (mips_machtype != ATH79_MACH_GENERIC_OF) {
+ 		ath79_reset_base = ioremap_nocache(AR71XX_RESET_BASE,
+@@ -329,17 +333,21 @@ static int __init ath79_setup(void)
+ 
+ arch_initcall(ath79_setup);
+ 
++#ifdef CONFIG_OF
+ void __init device_tree_init(void)
+ {
+ 	unflatten_and_copy_device_tree();
+ }
++#endif
+ 
+ MIPS_MACHINE(ATH79_MACH_GENERIC,
+ 	     "Generic",
+ 	     "Generic AR71XX/AR724X/AR913X based board",
+ 	     NULL);
+ 
++#ifdef CONFIG_OF
+ MIPS_MACHINE(ATH79_MACH_GENERIC_OF,
+ 	     "DTB",
+ 	     "Generic AR71XX/AR724X/AR913X based board (DT)",
+ 	     NULL);
++#endif
diff --git a/target/linux/ar71xx/patches-4.14/700-MIPS-ath79-add-openwrt-Kconfig.patch b/target/linux/ar71xx/patches-4.14/700-MIPS-ath79-add-openwrt-Kconfig.patch
new file mode 100644
index 0000000000..093def8d11
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/700-MIPS-ath79-add-openwrt-Kconfig.patch
@@ -0,0 +1,11 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -83,6 +83,8 @@ config ATH79_MACH_UBNT_XM
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  Ubiquiti Networks XM (rev 1.0) board.
+ 
++source "arch/mips/ath79/Kconfig.openwrt"
++
+ endmenu
+ 
+ config SOC_AR71XX
diff --git a/target/linux/ar71xx/patches-4.14/701-MIPS-ath79-add-routerboard-detection.patch b/target/linux/ar71xx/patches-4.14/701-MIPS-ath79-add-routerboard-detection.patch
new file mode 100644
index 0000000000..64c7e881a7
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/701-MIPS-ath79-add-routerboard-detection.patch
@@ -0,0 +1,34 @@
+--- a/arch/mips/ath79/prom.c
++++ b/arch/mips/ath79/prom.c
+@@ -136,6 +136,31 @@ void __init prom_init(void)
+ 		initrd_end = initrd_start + fw_getenvl("initrd_size");
+ 	}
+ #endif
++
++	if (strstr(arcs_cmdline, "board=750Gr3") ||
++	    strstr(arcs_cmdline, "board=750i") ||
++	    strstr(arcs_cmdline, "board=750-hb") ||
++	    strstr(arcs_cmdline, "board=411") ||
++	    strstr(arcs_cmdline, "board=433") ||
++	    strstr(arcs_cmdline, "board=435") ||
++	    strstr(arcs_cmdline, "board=450") ||
++	    strstr(arcs_cmdline, "board=493") ||
++	    strstr(arcs_cmdline, "board=951G") ||
++	    strstr(arcs_cmdline, "board=H951L") ||
++	    strstr(arcs_cmdline, "board=952-hb") ||
++	    strstr(arcs_cmdline, "board=953gs") ||
++	    strstr(arcs_cmdline, "board=962") ||
++	    strstr(arcs_cmdline, "board=lhg") ||
++	    strstr(arcs_cmdline, "board=map-hb") ||
++	    strstr(arcs_cmdline, "board=map2-hb") ||
++	    strstr(arcs_cmdline, "board=wap-hb") ||
++	    strstr(arcs_cmdline, "board=wapg-sc") ||
++	    strstr(arcs_cmdline, "board=2011L") ||
++	    strstr(arcs_cmdline, "board=2011r") ||
++	    strstr(arcs_cmdline, "board=711Gr100") ||
++	    strstr(arcs_cmdline, "board=911L") ||
++	    strstr(arcs_cmdline, "board=922gs"))
++		ath79_prom_append_cmdline("console", "ttyS0,115200");
+ }
+ 
+ void __init prom_free_prom_memory(void)
diff --git a/target/linux/ar71xx/patches-4.14/702-MIPS-ath79-fixup-routerboot-board-parameter.patch b/target/linux/ar71xx/patches-4.14/702-MIPS-ath79-fixup-routerboot-board-parameter.patch
new file mode 100644
index 0000000000..b8715bba9e
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/702-MIPS-ath79-fixup-routerboot-board-parameter.patch
@@ -0,0 +1,43 @@
+From: Gabor Juhos <juhosg@freemail.hu>
+Date: Sat, 2 Dec 2017 19:15:29 +0100
+Subject: [PATCH] MIPS: ath79: fix board detection with newer RouterBOOT versions
+
+Recent RouterBOOT version (at least version 3.41 on RB911G-5HPacD)
+use "Board=" kernel parameter instead of "board=" to pass the board
+name to the kernel. Due to this change the board detection code is
+not working on the devices shipped with the new RouterBOOT version.
+Because the kernel is unable to identify these boards they become
+unusable despite that they are supported by the current code.
+
+Update the prom_init code to convert the 'Board' kernel parameter to
+'board'. After this change, the board detection works also with the
+new RouterBOOT versions.
+
+Signed-off-by: Gabor Juhos <juhosg@freemail.hu>
+---
+--- a/arch/mips/ath79/prom.c
++++ b/arch/mips/ath79/prom.c
+@@ -104,6 +104,7 @@ static int __init ath79_prom_init_myload
+ void __init prom_init(void)
+ {
+ 	const char *env;
++	char *c;
+ 
+ 	if (ath79_prom_init_myloader())
+ 		return;
+@@ -137,6 +138,15 @@ void __init prom_init(void)
+ 	}
+ #endif
+ 
++	/*
++	 * RouterBOOT uses "Board" kernel parameter instead of "board" since
++	 * version 3.41 (or so). Replace the first character of the parameter
++	 * to keep board detection working.
++	 */
++	c = strstr(arcs_cmdline, "Board=");
++	if (c)
++		c[0] = 'b';
++
+ 	if (strstr(arcs_cmdline, "board=750Gr3") ||
+ 	    strstr(arcs_cmdline, "board=750i") ||
+ 	    strstr(arcs_cmdline, "board=750-hb") ||
diff --git a/target/linux/ar71xx/patches-4.14/739-MIPS-ath79-add-gpio-func-register-for-QCA955x-SoC.patch b/target/linux/ar71xx/patches-4.14/739-MIPS-ath79-add-gpio-func-register-for-QCA955x-SoC.patch
new file mode 100644
index 0000000000..a65f7d993f
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/739-MIPS-ath79-add-gpio-func-register-for-QCA955x-SoC.patch
@@ -0,0 +1,38 @@
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -33,6 +33,7 @@ static void __iomem *ath79_gpio_get_func
+ 		reg = AR71XX_GPIO_REG_FUNC;
+ 	else if (soc_is_ar934x() ||
+ 		 soc_is_qca953x() ||
++		 soc_is_qca955x() ||
+ 		 soc_is_qca956x() ||
+ 		 soc_is_tp9343())
+ 		reg = AR934X_GPIO_REG_FUNC;
+@@ -64,15 +65,21 @@ void ath79_gpio_function_disable(u32 mas
+ void __init ath79_gpio_output_select(unsigned gpio, u8 val)
+ {
+ 	void __iomem *base = ath79_gpio_base;
+-	unsigned int reg;
++	unsigned int reg, reg_base;
+ 	u32 t, s;
+ 
+-	BUG_ON(!soc_is_ar934x() && !soc_is_qca953x() && !soc_is_qca956x());
+-
+-	if (gpio >= AR934X_GPIO_COUNT)
+-		return;
++	if (soc_is_ar934x())
++		reg_base = AR934X_GPIO_REG_OUT_FUNC0;
++	else if (soc_is_qca953x())
++		reg_base = QCA953X_GPIO_REG_OUT_FUNC0;
++	else if (soc_is_qca955x())
++		reg_base = QCA955X_GPIO_REG_OUT_FUNC0;
++	else if (soc_is_qca956x())
++		reg_base = QCA956X_GPIO_REG_OUT_FUNC0;
++	else
++		BUG();
+ 
+-	reg = AR934X_GPIO_REG_OUT_FUNC0 + 4 * (gpio / 4);
++	reg = reg_base + 4 * (gpio / 4);
+ 	s = 8 * (gpio % 4);
+ 
+ 	t = __raw_readl(base + reg);
diff --git a/target/linux/ar71xx/patches-4.14/740-MIPS-ath79-add-PCI-for-QCA953x-SoC.patch b/target/linux/ar71xx/patches-4.14/740-MIPS-ath79-add-PCI-for-QCA953x-SoC.patch
new file mode 100644
index 0000000000..1358fd3916
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/740-MIPS-ath79-add-PCI-for-QCA953x-SoC.patch
@@ -0,0 +1,44 @@
+--- a/arch/mips/ath79/pci.c
++++ b/arch/mips/ath79/pci.c
+@@ -53,6 +53,15 @@ static const struct ath79_pci_irq ar724x_pci_irq_map[] = {
+ 	}
+ };
+ 
++static const struct ath79_pci_irq qca953x_pci_irq_map[] = {
++	{
++		.bus	= 0,
++		.slot	= 0,
++		.pin	= 1,
++		.irq	= ATH79_PCI_IRQ(0),
++	},
++};
++
+ static const struct ath79_pci_irq qca955x_pci_irq_map[] = {
+ 	{
+ 		.bus	= 0,
+@@ -98,6 +107,9 @@ int pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+ 			   soc_is_ar9344()) {
+ 			ath79_pci_irq_map = ar724x_pci_irq_map;
+ 			ath79_pci_nr_irqs = ARRAY_SIZE(ar724x_pci_irq_map);
++		} else if (soc_is_qca953x()) {
++			ath79_pci_irq_map = qca953x_pci_irq_map;
++			ath79_pci_nr_irqs = ARRAY_SIZE(qca953x_pci_irq_map);
+ 		} else if (soc_is_qca955x()) {
+ 			ath79_pci_irq_map = qca955x_pci_irq_map;
+ 			ath79_pci_nr_irqs = ARRAY_SIZE(qca955x_pci_irq_map);
+@@ -303,6 +315,15 @@ int __init ath79_register_pci(void)
+ 						 AR724X_PCI_MEM_SIZE,
+ 						 0,
+ 						 ATH79_IP2_IRQ(0));
++	} else if (soc_is_qca9533()) {
++		pdev = ath79_register_pci_ar724x(0,
++						 QCA953X_PCI_CFG_BASE0,
++						 QCA953X_PCI_CTRL_BASE0,
++						 QCA953X_PCI_CRP_BASE0,
++						 QCA953X_PCI_MEM_BASE0,
++						 QCA953X_PCI_MEM_SIZE,
++						 0,
++						 ATH79_IP2_IRQ(0));
+ 	} else if (soc_is_qca9558()) {
+ 		pdev = ath79_register_pci_ar724x(0,
+ 						 QCA955X_PCI_CFG_BASE0,
diff --git a/target/linux/ar71xx/patches-4.14/741-MIPS-ath79-add-PCI-for-QCA9556-SoC.patch b/target/linux/ar71xx/patches-4.14/741-MIPS-ath79-add-PCI-for-QCA9556-SoC.patch
new file mode 100644
index 0000000000..5ca0784253
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/741-MIPS-ath79-add-PCI-for-QCA9556-SoC.patch
@@ -0,0 +1,12 @@
+--- a/arch/mips/ath79/pci.c
++++ b/arch/mips/ath79/pci.c
+@@ -324,7 +324,8 @@ int __init ath79_register_pci(void)
+ 						 QCA953X_PCI_MEM_SIZE,
+ 						 0,
+ 						 ATH79_IP2_IRQ(0));
+-	} else if (soc_is_qca9558()) {
++	} else if (soc_is_qca9558() ||
++		   soc_is_qca9556()) {
+ 		pdev = ath79_register_pci_ar724x(0,
+ 						 QCA955X_PCI_CFG_BASE0,
+ 						 QCA955X_PCI_CTRL_BASE0,
diff --git a/target/linux/ar71xx/patches-4.14/818-MIPS-ath79-add-nu801-led-driver.patch b/target/linux/ar71xx/patches-4.14/818-MIPS-ath79-add-nu801-led-driver.patch
new file mode 100644
index 0000000000..a9e9cc2fcd
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/818-MIPS-ath79-add-nu801-led-driver.patch
@@ -0,0 +1,26 @@
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -632,6 +632,13 @@ config LEDS_IS31FL32XX
+ 
+ comment "LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)"
+ 
++config LEDS_NU801
++	tristate "LED driver for NU801 RGB LED"
++	depends on LEDS_CLASS && (ATH79_MACH_MR18 || ATH79_MACH_Z1)
++	help
++	  This option enables support for NU801 RGB LED driver chips
++	  accessed via GPIO.
++
+ config LEDS_BLINKM
+ 	tristate "LED support for the BlinkM I2C RGB LED"
+ 	depends on LEDS_CLASS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -58,6 +58,7 @@ obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
+ obj-$(CONFIG_LEDS_ADP5520)		+= leds-adp5520.o
+ obj-$(CONFIG_LEDS_MC13783)		+= leds-mc13783.o
+ obj-$(CONFIG_LEDS_RB750)		+= leds-rb750.o
++obj-$(CONFIG_LEDS_NU801)		+= leds-nu801.o
+ obj-$(CONFIG_LEDS_NS2)			+= leds-ns2.o
+ obj-$(CONFIG_LEDS_NETXBIG)		+= leds-netxbig.o
+ obj-$(CONFIG_LEDS_ASIC3)		+= leds-asic3.o
diff --git a/target/linux/ar71xx/patches-4.14/820-MIPS-ath79-add_gpio_function2_setup.patch b/target/linux/ar71xx/patches-4.14/820-MIPS-ath79-add_gpio_function2_setup.patch
new file mode 100644
index 0000000000..98fb1d826f
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/820-MIPS-ath79-add_gpio_function2_setup.patch
@@ -0,0 +1,67 @@
+Add access to the function2 gpio register. This probably has to be
+converted into a pimux driver later on. This is needed for some setup
+functions on the Arduino Yun.
+
+--- a/arch/mips/ath79/common.h
++++ b/arch/mips/ath79/common.h
+@@ -29,6 +29,7 @@ void ath79_ddr_ctrl_init(void);
+ void ath79_gpio_function_enable(u32 mask);
+ void ath79_gpio_function_disable(u32 mask);
+ void ath79_gpio_function_setup(u32 set, u32 clear);
++void ath79_gpio_function2_setup(u32 set, u32 clear);
+ void ath79_gpio_output_select(unsigned gpio, u8 val);
+ int ath79_gpio_direction_select(unsigned gpio, bool oe);
+ void ath79_gpio_init(void);
+--- a/arch/mips/ath79/gpio.c
++++ b/arch/mips/ath79/gpio.c
+@@ -43,6 +43,31 @@ static void __iomem *ath79_gpio_get_function_reg(void)
+ 	return ath79_gpio_base + reg;
+ }
+ 
++static void __iomem *ath79_gpio_get_function2_reg(void)
++{
++	u32 reg = 0;
++
++	if (soc_is_ar71xx() ||
++	    soc_is_ar724x() ||
++	    soc_is_ar913x() ||
++	    soc_is_ar933x())
++		reg = AR71XX_GPIO_REG_FUNC_2;
++	else
++		BUG();
++
++	return ath79_gpio_base + reg;
++}
++
++
++void ath79_gpio_function2_setup(u32 set, u32 clear)
++{
++	void __iomem *reg = ath79_gpio_get_function2_reg();
++
++	__raw_writel((__raw_readl(reg) & ~clear) | set, reg);
++	/* flush write */
++	__raw_readl(reg);
++}
++
+ void ath79_gpio_function_setup(u32 set, u32 clear)
+ {
+ 	void __iomem *reg = ath79_gpio_get_function_reg();
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -862,6 +862,7 @@
+ #define AR71XX_GPIO_REG_INT_PENDING	0x20
+ #define AR71XX_GPIO_REG_INT_ENABLE	0x24
+ #define AR71XX_GPIO_REG_FUNC		0x28
++#define AR71XX_GPIO_REG_FUNC_2		0x30
+ 
+ #define AR934X_GPIO_REG_OUT_FUNC0	0x2c
+ #define AR934X_GPIO_REG_OUT_FUNC1	0x30
+@@ -986,6 +987,8 @@
+ #define AR724X_GPIO_FUNC_UART_EN		BIT(1)
+ #define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+ 
++#define AR933X_GPIO_FUNC2_JUMPSTART_DISABLE 	BIT(9)
++
+ #define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
+ #define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
+ #define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
diff --git a/target/linux/ar71xx/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch b/target/linux/ar71xx/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
new file mode 100644
index 0000000000..8f8f349a66
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/900-mdio_bitbang_ignore_ta_value.patch
@@ -0,0 +1,32 @@
+--- a/drivers/net/phy/mdio-bitbang.c
++++ b/drivers/net/phy/mdio-bitbang.c
+@@ -155,7 +155,7 @@ static int mdiobb_cmd_addr(struct mdiobb
+ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
+-	int ret, i;
++	int ret;
+ 
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+@@ -165,19 +165,7 @@ static int mdiobb_read(struct mii_bus *b
+ 
+ 	ctrl->ops->set_mdio_dir(ctrl, 0);
+ 
+-	/* check the turnaround bit: the PHY should be driving it to zero, if this
+-	 * PHY is listed in phy_ignore_ta_mask as having broken TA, skip that
+-	 */
+-	if (mdiobb_get_bit(ctrl) != 0 &&
+-	    !(bus->phy_ignore_ta_mask & (1 << phy))) {
+-		/* PHY didn't drive TA low -- flush any bits it
+-		 * may be trying to send.
+-		 */
+-		for (i = 0; i < 32; i++)
+-			mdiobb_get_bit(ctrl);
+-
+-		return 0xffff;
+-	}
++	mdiobb_get_bit(ctrl);
+ 
+ 	ret = mdiobb_get_num(ctrl, 16);
+ 	mdiobb_get_bit(ctrl);
diff --git a/target/linux/ar71xx/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch b/target/linux/ar71xx/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
new file mode 100644
index 0000000000..a830346a31
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/901-phy-mdio-bitbang-prevent-rescheduling-during-command.patch
@@ -0,0 +1,61 @@
+From 66e584435ac0de6e0abeb6d7166fe4fe25d6bb73 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Tue, 16 Jun 2015 13:15:08 +0200
+Subject: [PATCH] phy/mdio-bitbang: prevent rescheduling during command
+
+It seems some phys have some maximum timings for accessing the MDIO line,
+resulting in bit errors under cpu stress. Prevent this from happening by
+disabling interrupts when sending commands.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ drivers/net/phy/mdio-bitbang.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+--- a/drivers/net/phy/mdio-bitbang.c
++++ b/drivers/net/phy/mdio-bitbang.c
+@@ -17,6 +17,7 @@
+  * kind, whether express or implied.
+  */
+ 
++#include <linux/irqflags.h>
+ #include <linux/module.h>
+ #include <linux/mdio-bitbang.h>
+ #include <linux/types.h>
+@@ -156,7 +157,9 @@ static int mdiobb_read(struct mii_bus *b
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
+ 	int ret;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+ 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
+@@ -169,13 +172,17 @@ static int mdiobb_read(struct mii_bus *b
+ 
+ 	ret = mdiobb_get_num(ctrl, 16);
+ 	mdiobb_get_bit(ctrl);
++	local_irq_restore(flags);
++
+ 	return ret;
+ }
+ 
+ static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
+ {
+ 	struct mdiobb_ctrl *ctrl = bus->priv;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+ 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
+@@ -190,6 +197,8 @@ static int mdiobb_write(struct mii_bus *
+ 
+ 	ctrl->ops->set_mdio_dir(ctrl, 0);
+ 	mdiobb_get_bit(ctrl);
++	local_irq_restore(flags);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/ar71xx/patches-4.14/902-at803x-add-reset-gpio-pdata.patch b/target/linux/ar71xx/patches-4.14/902-at803x-add-reset-gpio-pdata.patch
new file mode 100644
index 0000000000..aace08c116
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/902-at803x-add-reset-gpio-pdata.patch
@@ -0,0 +1,68 @@
+Add support for configuring AT803x GPIO reset via platform data.
+This is necessary, because ath79 is not converted to device tree yet.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -261,6 +261,7 @@ static int at803x_resume(struct phy_device *phydev)
+ 
+ static int at803x_probe(struct phy_device *phydev)
+ {
++	struct at803x_platform_data *pdata;
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct at803x_priv *priv;
+ 	struct gpio_desc *gpiod_reset;
+@@ -273,6 +274,12 @@ static int at803x_probe(struct phy_device *phydev)
+ 	    phydev->drv->phy_id != ATH8032_PHY_ID)
+ 		goto does_not_require_reset_workaround;
+ 
++	pdata = dev_get_platdata(dev);
++	if (pdata && pdata->has_reset_gpio) {
++		devm_gpio_request(dev, pdata->reset_gpio, "reset");
++		gpio_direction_output(pdata->reset_gpio, 1);
++	}
++
+ 	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+ 	if (IS_ERR(gpiod_reset))
+ 		return PTR_ERR(gpiod_reset);
+@@ -404,15 +411,23 @@ static void at803x_link_change_notify(struct phy_device *phydev)
+ 	 * cannot recover from by software.
+ 	 */
+ 	if (phydev->state == PHY_NOLINK) {
+-		if (priv->gpiod_reset && !priv->phy_reset) {
++		if ((priv->gpiod_reset || (pdata && pdata->has_reset_gpio)) &&
++		    !priv->phy_reset) {
+ 			struct at803x_context context;
+ 
+ 			at803x_context_save(phydev, &context);
+ 
+-			gpiod_set_value(priv->gpiod_reset, 1);
+-			msleep(1);
+-			gpiod_set_value(priv->gpiod_reset, 0);
+-			msleep(1);
++			if (pdata && pdata->has_reset_gpio) {
++				gpio_set_value_cansleep(pdata->reset_gpio, 0);
++				msleep(1);
++				gpio_set_value_cansleep(pdata->reset_gpio, 1);
++				msleep(1);
++			} else {
++				gpiod_set_value(priv->gpiod_reset, 1);
++				msleep(1);
++				gpiod_set_value(priv->gpiod_reset, 0);
++				msleep(1);
++			}
+ 
+ 			at803x_context_restore(phydev, &context);
+ 
+--- a/include/linux/platform_data/phy-at803x.h
++++ b/include/linux/platform_data/phy-at803x.h
+@@ -6,6 +6,8 @@ struct at803x_platform_data {
+ 	int enable_rgmii_tx_delay:1;
+ 	int enable_rgmii_rx_delay:1;
+ 	int fixup_rgmii_tx_delay:1;
++	int has_reset_gpio:1;
++	int reset_gpio;
+ };
+ 
+ #endif /* _PHY_AT803X_PDATA_H */
diff --git a/target/linux/ar71xx/patches-4.14/910-unaligned_access_hacks.patch b/target/linux/ar71xx/patches-4.14/910-unaligned_access_hacks.patch
new file mode 100644
index 0000000000..61eac6d450
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/910-unaligned_access_hacks.patch
@@ -0,0 +1,933 @@
+--- a/arch/mips/include/asm/checksum.h
++++ b/arch/mips/include/asm/checksum.h
+@@ -134,26 +134,30 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+ 	const unsigned int *stop = word + ihl;
+ 	unsigned int csum;
+ 	int carry;
++	unsigned int w;
+ 
+-	csum = word[0];
+-	csum += word[1];
+-	carry = (csum < word[1]);
++	csum = net_hdr_word(word++);
++
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	csum += word[2];
+-	carry = (csum < word[2]);
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	csum += word[3];
+-	carry = (csum < word[3]);
++	w = net_hdr_word(word++);
++	csum += w;
++	carry = (csum < w);
+ 	csum += carry;
+ 
+-	word += 4;
+ 	do {
+-		csum += *word;
+-		carry = (csum < *word);
++		w = net_hdr_word(word++);
++		csum += w;
++		carry = (csum < w);
+ 		csum += carry;
+-		word++;
+ 	} while (word != stop);
+ 
+ 	return csum_fold(csum);
+@@ -214,73 +218,6 @@ static inline __sum16 ip_compute_csum(const void *buff, int len)
+ 	return csum_fold(csum_partial(buff, len, 0));
+ }
+ 
+-#define _HAVE_ARCH_IPV6_CSUM
+-static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
+-					  const struct in6_addr *daddr,
+-					  __u32 len, __u8 proto,
+-					  __wsum sum)
+-{
+-	__wsum tmp;
+-
+-	__asm__(
+-	"	.set	push		# csum_ipv6_magic\n"
+-	"	.set	noreorder	\n"
+-	"	.set	noat		\n"
+-	"	addu	%0, %5		# proto (long in network byte order)\n"
+-	"	sltu	$1, %0, %5	\n"
+-	"	addu	%0, $1		\n"
+-
+-	"	addu	%0, %6		# csum\n"
+-	"	sltu	$1, %0, %6	\n"
+-	"	lw	%1, 0(%2)	# four words source address\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 4(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 8(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 12(%2)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 0(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 4(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 8(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	lw	%1, 12(%3)	\n"
+-	"	addu	%0, $1		\n"
+-	"	addu	%0, %1		\n"
+-	"	sltu	$1, %0, %1	\n"
+-
+-	"	addu	%0, $1		# Add final carry\n"
+-	"	.set	pop"
+-	: "=&r" (sum), "=&r" (tmp)
+-	: "r" (saddr), "r" (daddr),
+-	  "0" (htonl(len)), "r" (htonl(proto)), "r" (sum));
+-
+-	return csum_fold(sum);
+-}
+-
+ #include <asm-generic/checksum.h>
+ #endif /* CONFIG_GENERIC_CSUM */
+ 
+--- a/drivers/net/vxlan.c
++++ b/drivers/net/vxlan.c
+@@ -1824,15 +1824,15 @@ static int vxlan_build_skb(struct sk_buff *skb, struct dst_entry *dst,
+ 		return err;
+ 
+ 	vxh = __skb_push(skb, sizeof(*vxh));
+-	vxh->vx_flags = VXLAN_HF_VNI;
+-	vxh->vx_vni = vxlan_vni_field(vni);
++	net_hdr_word(&vxh->vx_flags) = VXLAN_HF_VNI;
++	net_hdr_word(&vxh->vx_vni) = vxlan_vni_field(vni);
+ 
+ 	if (type & SKB_GSO_TUNNEL_REMCSUM) {
+ 		unsigned int start;
+ 
+ 		start = skb_checksum_start_offset(skb) - sizeof(struct vxlanhdr);
+-		vxh->vx_vni |= vxlan_compute_rco(start, skb->csum_offset);
+-		vxh->vx_flags |= VXLAN_HF_RCO;
++		net_hdr_word(&vxh->vx_vni) |= vxlan_compute_rco(start, skb->csum_offset);
++		net_hdr_word(&vxh->vx_flags) |= VXLAN_HF_RCO;
+ 
+ 		if (!skb_is_gso(skb)) {
+ 			skb->ip_summed = CHECKSUM_NONE;
+--- a/include/linux/etherdevice.h
++++ b/include/linux/etherdevice.h
+@@ -480,7 +480,7 @@ static inline bool is_etherdev_addr(const struct net_device *dev,
+  * @b: Pointer to Ethernet header
+  *
+  * Compare two Ethernet headers, returns 0 if equal.
+- * This assumes that the network header (i.e., IP header) is 4-byte
++ * This assumes that the network header (i.e., IP header) is 2-byte
+  * aligned OR the platform can handle unaligned access.  This is the
+  * case for all packets coming into netif_receive_skb or similar
+  * entry points.
+@@ -503,11 +503,12 @@ static inline unsigned long compare_ether_header(const void *a, const void *b)
+ 	fold |= *(unsigned long *)(a + 6) ^ *(unsigned long *)(b + 6);
+ 	return fold;
+ #else
+-	u32 *a32 = (u32 *)((u8 *)a + 2);
+-	u32 *b32 = (u32 *)((u8 *)b + 2);
++	const u16 *a16 = a;
++	const u16 *b16 = b;
+ 
+-	return (*(u16 *)a ^ *(u16 *)b) | (a32[0] ^ b32[0]) |
+-	       (a32[1] ^ b32[1]) | (a32[2] ^ b32[2]);
++	return (a16[0] ^ b16[0]) | (a16[1] ^ b16[1]) | (a16[2] ^ b16[2]) |
++	       (a16[3] ^ b16[3]) | (a16[4] ^ b16[4]) | (a16[5] ^ b16[5]) |
++	       (a16[6] ^ b16[6]);
+ #endif
+ }
+ 
+--- a/include/linux/ipv6.h
++++ b/include/linux/ipv6.h
+@@ -6,6 +6,7 @@
+ 
+ #define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
+ #define ipv6_authlen(p) (((p)->hdrlen+2) << 2)
++
+ /*
+  * This structure contains configuration options per IPv6 link.
+  */
+--- a/include/linux/types.h
++++ b/include/linux/types.h
+@@ -229,5 +229,11 @@ struct callback_head {
+ typedef void (*rcu_callback_t)(struct rcu_head *head);
+ typedef void (*call_rcu_func_t)(struct rcu_head *head, rcu_callback_t func);
+ 
++struct net_hdr_word {
++       u32 words[1];
++} __attribute__((packed, aligned(2)));
++
++#define net_hdr_word(_p) (((struct net_hdr_word *) (_p))->words[0])
++
+ #endif /*  __ASSEMBLY__ */
+ #endif /* _LINUX_TYPES_H */
+--- a/include/net/addrconf.h
++++ b/include/net/addrconf.h
+@@ -47,7 +47,7 @@ struct prefix_info {
+ 	__be32			reserved2;
+ 
+ 	struct in6_addr		prefix;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #include <linux/netdevice.h>
+ #include <net/if_inet6.h>
+--- a/include/net/inet_ecn.h
++++ b/include/net/inet_ecn.h
+@@ -125,9 +125,9 @@ static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)
+ 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
+ 		return 0;
+ 
+-	from = *(__be32 *)iph;
++	from = net_hdr_word(iph);
+ 	to = from | htonl(INET_ECN_CE << 20);
+-	*(__be32 *)iph = to;
++	net_hdr_word(iph) = to;
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_add(csum_sub(skb->csum, (__force __wsum)from),
+ 				     (__force __wsum)to);
+@@ -136,7 +136,7 @@ static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)
+ 
+ static inline void IP6_ECN_clear(struct ipv6hdr *iph)
+ {
+-	*(__be32*)iph &= ~htonl(INET_ECN_MASK << 20);
++	net_hdr_word(iph) &= ~htonl(INET_ECN_MASK << 20);
+ }
+ 
+ static inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
+--- a/include/net/ipv6.h
++++ b/include/net/ipv6.h
+@@ -108,7 +108,7 @@ struct frag_hdr {
+ 	__u8	reserved;
+ 	__be16	frag_off;
+ 	__be32	identification;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #define	IP6_MF		0x0001
+ #define	IP6_OFFSET	0xFFF8
+@@ -451,8 +451,8 @@ static inline void __ipv6_addr_set_half(__be32 *addr,
+ 	}
+ #endif
+ #endif
+-	addr[0] = wh;
+-	addr[1] = wl;
++	net_hdr_word(&addr[0]) = wh;
++	net_hdr_word(&addr[1]) = wl;
+ }
+ 
+ static inline void ipv6_addr_set(struct in6_addr *addr, 
+@@ -511,6 +511,8 @@ static inline bool ipv6_prefix_equal(const struct in6_addr *addr1,
+ 	const __be32 *a1 = addr1->s6_addr32;
+ 	const __be32 *a2 = addr2->s6_addr32;
+ 	unsigned int pdw, pbi;
++	/* Used for last <32-bit fraction of prefix */
++	u32 pbia1, pbia2;
+ 
+ 	/* check complete u32 in prefix */
+ 	pdw = prefixlen >> 5;
+@@ -519,7 +521,9 @@ static inline bool ipv6_prefix_equal(const struct in6_addr *addr1,
+ 
+ 	/* check incomplete u32 in prefix */
+ 	pbi = prefixlen & 0x1f;
+-	if (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))
++	pbia1 = net_hdr_word(&a1[pdw]);
++	pbia2 = net_hdr_word(&a2[pdw]);
++	if (pbi && ((pbia1 ^ pbia2) & htonl((0xffffffff) << (32 - pbi))))
+ 		return false;
+ 
+ 	return true;
+@@ -663,13 +667,13 @@ static inline void ipv6_addr_set_v4mapped(const __be32 addr,
+  */
+ static inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)
+ {
+-	const __be32 *a1 = token1, *a2 = token2;
++	const struct in6_addr *a1 = token1, *a2 = token2;
+ 	int i;
+ 
+ 	addrlen >>= 2;
+ 
+ 	for (i = 0; i < addrlen; i++) {
+-		__be32 xb = a1[i] ^ a2[i];
++		__be32 xb = a1->s6_addr32[i] ^ a2->s6_addr32[i];
+ 		if (xb)
+ 			return i * 32 + 31 - __fls(ntohl(xb));
+ 	}
+@@ -838,17 +842,18 @@ static inline int ip6_default_np_autolabel(struct net *net)
+ static inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,
+ 				__be32 flowlabel)
+ {
+-	*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;
++	net_hdr_word((__be32 *)hdr) =
++		htonl(0x60000000 | (tclass << 20)) | flowlabel;
+ }
+ 
+ static inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)
+ {
+-	return *(__be32 *)hdr & IPV6_FLOWINFO_MASK;
++	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWINFO_MASK;
+ }
+ 
+ static inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)
+ {
+-	return *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;
++	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWLABEL_MASK;
+ }
+ 
+ static inline u8 ip6_tclass(__be32 flowinfo)
+--- a/include/net/ndisc.h
++++ b/include/net/ndisc.h
+@@ -89,7 +89,7 @@ struct ra_msg {
+         struct icmp6hdr		icmph;
+ 	__be32			reachable_time;
+ 	__be32			retrans_timer;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct rd_msg {
+ 	struct icmp6hdr icmph;
+@@ -368,10 +368,10 @@ static inline u32 ndisc_hashfn(const void *pkey, const struct net_device *dev, _
+ {
+ 	const u32 *p32 = pkey;
+ 
+-	return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
+-		(p32[1] * hash_rnd[1]) +
+-		(p32[2] * hash_rnd[2]) +
+-		(p32[3] * hash_rnd[3]));
++	return (((net_hdr_word(&p32[0]) ^ hash32_ptr(dev)) * hash_rnd[0]) +
++		(net_hdr_word(&p32[1]) * hash_rnd[1]) +
++		(net_hdr_word(&p32[2]) * hash_rnd[2]) +
++		(net_hdr_word(&p32[3]) * hash_rnd[3]));
+ }
+ 
+ static inline struct neighbour *__ipv6_neigh_lookup_noref(struct net_device *dev, const void *pkey)
+--- a/include/net/neighbour.h
++++ b/include/net/neighbour.h
+@@ -265,8 +265,10 @@ static inline bool neigh_key_eq128(const struct neighbour *n, const void *pkey)
+ 	const u32 *n32 = (const u32 *)n->primary_key;
+ 	const u32 *p32 = pkey;
+ 
+-	return ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
+-		(n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0;
++	return ((n32[0] ^ net_hdr_word(&p32[0])) |
++		(n32[1] ^ net_hdr_word(&p32[1])) |
++		(n32[2] ^ net_hdr_word(&p32[2])) |
++		(n32[3] ^ net_hdr_word(&p32[3]))) == 0;
+ }
+ 
+ static inline struct neighbour *___neigh_lookup_noref(
+--- a/include/net/secure_seq.h
++++ b/include/net/secure_seq.h
+@@ -3,6 +3,7 @@
+ #define _NET_SECURE_SEQ
+ 
+ #include <linux/types.h>
++#include <linux/in6.h>
+ 
+ u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
+ u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
+--- a/include/uapi/linux/icmp.h
++++ b/include/uapi/linux/icmp.h
+@@ -82,7 +82,7 @@ struct icmphdr {
+ 	} frag;
+ 	__u8	reserved[4];
+   } un;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ /*
+--- a/include/uapi/linux/icmpv6.h
++++ b/include/uapi/linux/icmpv6.h
+@@ -77,7 +77,7 @@ struct icmp6hdr {
+ #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
+ #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
+ #define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ #define ICMPV6_ROUTER_PREF_LOW		0x3
+--- a/include/uapi/linux/if_pppox.h
++++ b/include/uapi/linux/if_pppox.h
+@@ -51,6 +51,7 @@ struct pppoe_addr {
+  */
+ struct pptp_addr {
+ 	__u16		call_id;
++	__u16		pad;
+ 	struct in_addr	sin_addr;
+ };
+ 
+--- a/include/uapi/linux/igmp.h
++++ b/include/uapi/linux/igmp.h
+@@ -33,7 +33,7 @@ struct igmphdr {
+ 	__u8 code;		/* For newer IGMP */
+ 	__sum16 csum;
+ 	__be32 group;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /* V3 group record types [grec_type] */
+ #define IGMPV3_MODE_IS_INCLUDE		1
+@@ -49,7 +49,7 @@ struct igmpv3_grec {
+ 	__be16	grec_nsrcs;
+ 	__be32	grec_mca;
+ 	__be32	grec_src[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct igmpv3_report {
+ 	__u8 type;
+@@ -58,7 +58,7 @@ struct igmpv3_report {
+ 	__be16 resv2;
+ 	__be16 ngrec;
+ 	struct igmpv3_grec grec[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ struct igmpv3_query {
+ 	__u8 type;
+@@ -79,7 +79,7 @@ struct igmpv3_query {
+ 	__u8 qqic;
+ 	__be16 nsrcs;
+ 	__be32 srcs[0];
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
+ #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
+--- a/include/uapi/linux/in.h
++++ b/include/uapi/linux/in.h
+@@ -84,7 +84,7 @@ enum {
+ /* Internet address. */
+ struct in_addr {
+ 	__be32	s_addr;
+-};
++} __attribute__((packed, aligned(2)));
+ #endif
+ 
+ #define IP_TOS		1
+--- a/include/uapi/linux/in6.h
++++ b/include/uapi/linux/in6.h
+@@ -43,7 +43,7 @@ struct in6_addr {
+ #define s6_addr16		in6_u.u6_addr16
+ #define s6_addr32		in6_u.u6_addr32
+ #endif
+-};
++} __attribute__((packed, aligned(2)));
+ #endif /* __UAPI_DEF_IN6_ADDR */
+ 
+ #if __UAPI_DEF_SOCKADDR_IN6
+--- a/include/uapi/linux/ip.h
++++ b/include/uapi/linux/ip.h
+@@ -103,7 +103,7 @@ struct iphdr {
+ 	__be32	saddr;
+ 	__be32	daddr;
+ 	/*The options start here. */
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ struct ip_auth_hdr {
+--- a/include/uapi/linux/ipv6.h
++++ b/include/uapi/linux/ipv6.h
+@@ -131,7 +131,7 @@ struct ipv6hdr {
+ 
+ 	struct	in6_addr	saddr;
+ 	struct	in6_addr	daddr;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ 
+ /* index values for the variables in ipv6_devconf */
+--- a/include/uapi/linux/netfilter_arp/arp_tables.h
++++ b/include/uapi/linux/netfilter_arp/arp_tables.h
+@@ -70,7 +70,7 @@ struct arpt_arp {
+ 	__u8 flags;
+ 	/* Inverse flags */
+ 	__u16 invflags;
+-};
++} __attribute__((aligned(4)));
+ 
+ /* Values for "flag" field in struct arpt_ip (general arp structure).
+  * No flags defined yet.
+--- a/include/uapi/linux/tcp.h
++++ b/include/uapi/linux/tcp.h
+@@ -55,7 +55,7 @@ struct tcphdr {
+ 	__be16	window;
+ 	__sum16	check;
+ 	__be16	urg_ptr;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /*
+  *	The union cast uses a gcc extension to avoid aliasing problems
+@@ -65,7 +65,7 @@ struct tcphdr {
+ union tcp_word_hdr { 
+ 	struct tcphdr hdr;
+ 	__be32 		  words[5];
+-}; 
++} __attribute__((packed, aligned(2)));
+ 
+ #define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+ 
+--- a/include/uapi/linux/udp.h
++++ b/include/uapi/linux/udp.h
+@@ -25,7 +25,7 @@ struct udphdr {
+ 	__be16	dest;
+ 	__be16	len;
+ 	__sum16	check;
+-};
++} __attribute__((packed, aligned(2)));
+ 
+ /* UDP socket options */
+ #define UDP_CORK	1	/* Never send partially complete segments */
+--- a/net/core/flow_dissector.c
++++ b/net/core/flow_dissector.c
+@@ -108,7 +108,7 @@ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 		ports = __skb_header_pointer(skb, thoff + poff,
+ 					     sizeof(_ports), data, hlen, &_ports);
+ 		if (ports)
+-			return *ports;
++			return (__be32)net_hdr_word(ports);
+ 	}
+ 
+ 	return 0;
+--- a/net/core/utils.c
++++ b/net/core/utils.c
+@@ -424,8 +424,14 @@ void inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,
+ 			       bool pseudohdr)
+ {
+ 	__be32 diff[] = {
+-		~from[0], ~from[1], ~from[2], ~from[3],
+-		to[0], to[1], to[2], to[3],
++		~net_hdr_word(&from[0]),
++		~net_hdr_word(&from[1]),
++		~net_hdr_word(&from[2]),
++		~net_hdr_word(&from[3]),
++		net_hdr_word(&to[0]),
++		net_hdr_word(&to[1]),
++		net_hdr_word(&to[2]),
++		net_hdr_word(&to[3]),
+ 	};
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+ 		*sum = csum_fold(csum_partial(diff, sizeof(diff),
+--- a/net/ipv4/af_inet.c
++++ b/net/ipv4/af_inet.c
+@@ -1351,8 +1351,8 @@ struct sk_buff **inet_gro_receive(struct sk_buff **head, struct sk_buff *skb)
+ 	if (unlikely(ip_fast_csum((u8 *)iph, 5)))
+ 		goto out_unlock;
+ 
+-	id = ntohl(*(__be32 *)&iph->id);
+-	flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));
++	id = ntohl(net_hdr_word(&iph->id));
++	flush = (u16)((ntohl(net_hdr_word(iph)) ^ skb_gro_len(skb)) | (id & ~IP_DF));
+ 	id >>= 16;
+ 
+ 	for (p = *head; p; p = p->next) {
+--- a/net/ipv4/igmp.c
++++ b/net/ipv4/igmp.c
+@@ -537,7 +537,7 @@ static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,
+ 		if (!skb)
+ 			return NULL;
+ 		psrc = skb_put(skb, sizeof(__be32));
+-		*psrc = psf->sf_inaddr;
++		net_hdr_word(psrc) = psf->sf_inaddr;
+ 		scount++; stotal++;
+ 		if ((type == IGMPV3_ALLOW_NEW_SOURCES ||
+ 		     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {
+--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
++++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+@@ -48,8 +48,8 @@ static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
+ 	if (ap == NULL)
+ 		return false;
+ 
+-	tuple->src.u3.ip = ap[0];
+-	tuple->dst.u3.ip = ap[1];
++	tuple->src.u3.ip = net_hdr_word(ap++);
++	tuple->dst.u3.ip = net_hdr_word(ap);
+ 
+ 	return true;
+ }
+--- a/net/ipv4/route.c
++++ b/net/ipv4/route.c
+@@ -465,7 +465,7 @@ static struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,
+ 	else if (skb)
+ 		pkey = &ip_hdr(skb)->daddr;
+ 
+-	n = __ipv4_neigh_lookup(dev, *(__force u32 *)pkey);
++	n = __ipv4_neigh_lookup(dev, net_hdr_word(pkey));
+ 	if (n)
+ 		return n;
+ 	return neigh_create(&arp_tbl, pkey, dev);
+--- a/net/ipv4/tcp_input.c
++++ b/net/ipv4/tcp_input.c
+@@ -3844,14 +3844,16 @@ static bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr
+ {
+ 	const __be32 *ptr = (const __be32 *)(th + 1);
+ 
+-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
+-			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
++	if (net_hdr_word(ptr) ==
++	    htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++		  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
+ 		tp->rx_opt.saw_tstamp = 1;
+ 		++ptr;
+-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
++		tp->rx_opt.rcv_tsval = get_unaligned_be32(ptr);
+ 		++ptr;
+-		if (*ptr)
+-			tp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;
++		if (net_hdr_word(ptr))
++			tp->rx_opt.rcv_tsecr = get_unaligned_be32(ptr) -
++					       tp->tsoffset;
+ 		else
+ 			tp->rx_opt.rcv_tsecr = 0;
+ 		return true;
+--- a/net/ipv4/tcp_offload.c
++++ b/net/ipv4/tcp_offload.c
+@@ -226,7 +226,7 @@ struct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb)
+ 
+ 		th2 = tcp_hdr(p);
+ 
+-		if (*(u32 *)&th->source ^ *(u32 *)&th2->source) {
++		if (net_hdr_word(&th->source) ^ net_hdr_word(&th2->source)) {
+ 			NAPI_GRO_CB(p)->same_flow = 0;
+ 			continue;
+ 		}
+@@ -244,8 +244,8 @@ struct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb)
+ 		  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));
+ 	flush |= (__force int)(th->ack_seq ^ th2->ack_seq);
+ 	for (i = sizeof(*th); i < thlen; i += 4)
+-		flush |= *(u32 *)((u8 *)th + i) ^
+-			 *(u32 *)((u8 *)th2 + i);
++		flush |= net_hdr_word((u8 *)th + i) ^
++			 net_hdr_word((u8 *)th2 + i);
+ 
+ 	/* When we receive our second frame we can made a decision on if we
+ 	 * continue this flow as an atomic flow with a fixed ID or if we use
+--- a/net/ipv4/tcp_output.c
++++ b/net/ipv4/tcp_output.c
+@@ -449,48 +449,53 @@ static void tcp_options_write(__be32 *ptr, struct tcp_sock *tp,
+ 	u16 options = opts->options;	/* mungable copy */
+ 
+ 	if (unlikely(OPTION_MD5 & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+-			       (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++			      (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
+ 		/* overload cookie hash location */
+ 		opts->hash_location = (__u8 *)ptr;
+ 		ptr += 4;
+ 	}
+ 
+ 	if (unlikely(opts->mss)) {
+-		*ptr++ = htonl((TCPOPT_MSS << 24) |
+-			       (TCPOLEN_MSS << 16) |
+-			       opts->mss);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) |
++			      opts->mss);
+ 	}
+ 
+ 	if (likely(OPTION_TS & options)) {
+ 		if (unlikely(OPTION_SACK_ADVERTISE & options)) {
+-			*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |
+-				       (TCPOLEN_SACK_PERM << 16) |
+-				       (TCPOPT_TIMESTAMP << 8) |
+-				       TCPOLEN_TIMESTAMP);
++			net_hdr_word(ptr++) =
++				htonl((TCPOPT_SACK_PERM << 24) |
++				      (TCPOLEN_SACK_PERM << 16) |
++				      (TCPOPT_TIMESTAMP << 8) |
++				      TCPOLEN_TIMESTAMP);
+ 			options &= ~OPTION_SACK_ADVERTISE;
+ 		} else {
+-			*ptr++ = htonl((TCPOPT_NOP << 24) |
+-				       (TCPOPT_NOP << 16) |
+-				       (TCPOPT_TIMESTAMP << 8) |
+-				       TCPOLEN_TIMESTAMP);
++			net_hdr_word(ptr++) =
++				htonl((TCPOPT_NOP << 24) |
++				      (TCPOPT_NOP << 16) |
++				      (TCPOPT_TIMESTAMP << 8) |
++				      TCPOLEN_TIMESTAMP);
+ 		}
+-		*ptr++ = htonl(opts->tsval);
+-		*ptr++ = htonl(opts->tsecr);
++		net_hdr_word(ptr++) = htonl(opts->tsval);
++		net_hdr_word(ptr++) = htonl(opts->tsecr);
+ 	}
+ 
+ 	if (unlikely(OPTION_SACK_ADVERTISE & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) |
+-			       (TCPOPT_NOP << 16) |
+-			       (TCPOPT_SACK_PERM << 8) |
+-			       TCPOLEN_SACK_PERM);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_NOP << 16) |
++			      (TCPOPT_SACK_PERM << 8) |
++			      TCPOLEN_SACK_PERM);
+ 	}
+ 
+ 	if (unlikely(OPTION_WSCALE & options)) {
+-		*ptr++ = htonl((TCPOPT_NOP << 24) |
+-			       (TCPOPT_WINDOW << 16) |
+-			       (TCPOLEN_WINDOW << 8) |
+-			       opts->ws);
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_WINDOW << 16) |
++			      (TCPOLEN_WINDOW << 8) |
++			      opts->ws);
+ 	}
+ 
+ 	if (unlikely(opts->num_sack_blocks)) {
+@@ -498,16 +503,17 @@ static void tcp_options_write(__be32 *ptr, struct tcp_sock *tp,
+ 			tp->duplicate_sack : tp->selective_acks;
+ 		int this_sack;
+ 
+-		*ptr++ = htonl((TCPOPT_NOP  << 24) |
+-			       (TCPOPT_NOP  << 16) |
+-			       (TCPOPT_SACK <<  8) |
+-			       (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
++		net_hdr_word(ptr++) =
++			htonl((TCPOPT_NOP << 24) |
++			      (TCPOPT_NOP << 16) |
++			      (TCPOPT_SACK << 8) |
++			      (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
+ 						     TCPOLEN_SACK_PERBLOCK)));
+ 
+ 		for (this_sack = 0; this_sack < opts->num_sack_blocks;
+ 		     ++this_sack) {
+-			*ptr++ = htonl(sp[this_sack].start_seq);
+-			*ptr++ = htonl(sp[this_sack].end_seq);
++			net_hdr_word(ptr++) = htonl(sp[this_sack].start_seq);
++			net_hdr_word(ptr++) = htonl(sp[this_sack].end_seq);
+ 		}
+ 
+ 		tp->rx_opt.dsack = 0;
+@@ -520,13 +526,14 @@ static void tcp_options_write(__be32 *ptr, struct tcp_sock *tp,
+ 
+ 		if (foc->exp) {
+ 			len = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
+-			*ptr = htonl((TCPOPT_EXP << 24) | (len << 16) |
++			net_hdr_word(ptr) =
++				htonl((TCPOPT_EXP << 24) | (len << 16) |
+ 				     TCPOPT_FASTOPEN_MAGIC);
+ 			p += TCPOLEN_EXP_FASTOPEN_BASE;
+ 		} else {
+ 			len = TCPOLEN_FASTOPEN_BASE + foc->len;
+-			*p++ = TCPOPT_FASTOPEN;
+-			*p++ = len;
++			net_hdr_word(p++) = TCPOPT_FASTOPEN;
++			net_hdr_word(p++) = len;
+ 		}
+ 
+ 		memcpy(p, foc->val, foc->len);
+--- a/net/ipv6/datagram.c
++++ b/net/ipv6/datagram.c
+@@ -485,7 +485,7 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
+ 				ipv6_iface_scope_id(&sin->sin6_addr,
+ 						    IP6CB(skb)->iif);
+ 		} else {
+-			ipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),
++			ipv6_addr_set_v4mapped(net_hdr_word(nh + serr->addr_offset),
+ 					       &sin->sin6_addr);
+ 			sin->sin6_scope_id = 0;
+ 		}
+@@ -833,12 +833,12 @@ int ip6_datagram_send_ctl(struct net *net, struct sock *sk,
+ 			}
+ 
+ 			if (fl6->flowlabel&IPV6_FLOWINFO_MASK) {
+-				if ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {
++				if ((fl6->flowlabel^net_hdr_word(CMSG_DATA(cmsg)))&~IPV6_FLOWINFO_MASK) {
+ 					err = -EINVAL;
+ 					goto exit_f;
+ 				}
+ 			}
+-			fl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);
++			fl6->flowlabel = IPV6_FLOWINFO_MASK & net_hdr_word(CMSG_DATA(cmsg));
+ 			break;
+ 
+ 		case IPV6_2292HOPOPTS:
+--- a/net/ipv6/exthdrs.c
++++ b/net/ipv6/exthdrs.c
+@@ -733,7 +733,7 @@ static bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
+ 		goto drop;
+ 	}
+ 
+-	pkt_len = ntohl(*(__be32 *)(nh + optoff + 2));
++	pkt_len = ntohl(net_hdr_word(nh + optoff + 2));
+ 	if (pkt_len <= IPV6_MAXPLEN) {
+ 		__IP6_INC_STATS(net, ipv6_skb_idev(skb),
+ 				IPSTATS_MIB_INHDRERRORS);
+--- a/net/ipv6/ip6_fib.c
++++ b/net/ipv6/ip6_fib.c
+@@ -137,7 +137,7 @@ static __be32 addr_bit_set(const void *token, int fn_bit)
+ 	 * See include/asm-generic/bitops/le.h.
+ 	 */
+ 	return (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &
+-	       addr[fn_bit >> 5];
++	       net_hdr_word(&addr[fn_bit >> 5]);
+ }
+ 
+ static struct fib6_node *node_alloc(void)
+--- a/net/ipv6/ip6_gre.c
++++ b/net/ipv6/ip6_gre.c
+@@ -397,7 +397,7 @@ static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+ 		return;
+ 	ipv6h = (const struct ipv6hdr *)skb->data;
+ 	greh = (const struct gre_base_hdr *)(skb->data + offset);
+-	key = key_off ? *(__be32 *)(skb->data + key_off) : 0;
++	key = key_off ? net_hdr_word((__be32 *)(skb->data + key_off)) : 0;
+ 
+ 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
+ 				 key, greh->protocol);
+--- a/net/ipv6/ip6_offload.c
++++ b/net/ipv6/ip6_offload.c
+@@ -220,7 +220,7 @@ static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,
+ 			continue;
+ 
+ 		iph2 = (struct ipv6hdr *)(p->data + off);
+-		first_word = *(__be32 *)iph ^ *(__be32 *)iph2;
++		first_word = net_hdr_word(iph) ^ net_hdr_word(iph2);
+ 
+ 		/* All fields must match except length and Traffic Class.
+ 		 * XXX skbs on the gro_list have all been parsed and pulled
+--- a/net/ipv6/netfilter/ip6table_mangle.c
++++ b/net/ipv6/netfilter/ip6table_mangle.c
+@@ -50,7 +50,7 @@ ip6t_mangle_out(struct sk_buff *skb, const struct nf_hook_state *state)
+ 	hop_limit = ipv6_hdr(skb)->hop_limit;
+ 
+ 	/* flowlabel and prio (includes version, which shouldn't change either */
+-	flowlabel = *((u_int32_t *)ipv6_hdr(skb));
++	flowlabel = net_hdr_word(ipv6_hdr(skb));
+ 
+ 	ret = ip6t_do_table(skb, state, state->net->ipv6.ip6table_mangle);
+ 
+@@ -59,7 +59,7 @@ ip6t_mangle_out(struct sk_buff *skb, const struct nf_hook_state *state)
+ 	     !ipv6_addr_equal(&ipv6_hdr(skb)->daddr, &daddr) ||
+ 	     skb->mark != mark ||
+ 	     ipv6_hdr(skb)->hop_limit != hop_limit ||
+-	     flowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {
++	     flowlabel != net_hdr_word(ipv6_hdr(skb)))) {
+ 		err = ip6_route_me_harder(state->net, skb);
+ 		if (err < 0)
+ 			ret = NF_DROP_ERR(err);
+--- a/net/ipv6/netfilter/nf_log_ipv6.c
++++ b/net/ipv6/netfilter/nf_log_ipv6.c
+@@ -66,9 +66,9 @@ static void dump_ipv6_packet(struct nf_log_buf *m,
+ 	/* Max length: 44 "LEN=65535 TC=255 HOPLIMIT=255 FLOWLBL=FFFFF " */
+ 	nf_log_buf_add(m, "LEN=%zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",
+ 	       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),
+-	       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,
++	       (ntohl(net_hdr_word(ih)) & 0x0ff00000) >> 20,
+ 	       ih->hop_limit,
+-	       (ntohl(*(__be32 *)ih) & 0x000fffff));
++	       (ntohl(net_hdr_word(ih)) & 0x000fffff));
+ 
+ 	fragment = 0;
+ 	ptr = ip6hoff + sizeof(struct ipv6hdr);
+--- a/net/ipv6/tcp_ipv6.c
++++ b/net/ipv6/tcp_ipv6.c
+@@ -39,6 +39,7 @@
+ #include <linux/ipsec.h>
+ #include <linux/times.h>
+ #include <linux/slab.h>
++#include <asm/unaligned.h>
+ #include <linux/uaccess.h>
+ #include <linux/ipv6.h>
+ #include <linux/icmpv6.h>
+@@ -819,10 +820,10 @@ static void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32
+ 	topt = (__be32 *)(t1 + 1);
+ 
+ 	if (tsecr) {
+-		*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+-				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
+-		*topt++ = htonl(tsval);
+-		*topt++ = htonl(tsecr);
++		put_unaligned_be32((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
++				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP, topt++);
++		put_unaligned_be32(tsval, topt++);
++		put_unaligned_be32(tsecr, topt++);
+ 	}
+ 
+ #ifdef CONFIG_TCP_MD5SIG
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -448,7 +448,7 @@ static void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,
+ 
+ 	/* Fast path for timestamp-only option */
+ 	if (length == TCPOLEN_TSTAMP_ALIGNED
+-	    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)
++	    && net_hdr_word(ptr) == htonl((TCPOPT_NOP << 24)
+ 				       | (TCPOPT_NOP << 16)
+ 				       | (TCPOPT_TIMESTAMP << 8)
+ 				       | TCPOLEN_TIMESTAMP))
+--- a/net/sched/cls_u32.c
++++ b/net/sched/cls_u32.c
+@@ -165,7 +165,7 @@ static int u32_classify(struct sk_buff *skb, const struct tcf_proto *tp,
+ 			data = skb_header_pointer(skb, toff, 4, &hdata);
+ 			if (!data)
+ 				goto out;
+-			if ((*data ^ key->val) & key->mask) {
++			if ((net_hdr_word(data) ^ key->val) & key->mask) {
+ 				n = rcu_dereference_bh(n->next);
+ 				goto next_knode;
+ 			}
+@@ -218,8 +218,8 @@ static int u32_classify(struct sk_buff *skb, const struct tcf_proto *tp,
+ 						  &hdata);
+ 			if (!data)
+ 				goto out;
+-			sel = ht->divisor & u32_hash_fold(*data, &n->sel,
+-							  n->fshift);
++			sel = ht->divisor & u32_hash_fold(net_hdr_word(data),
++							  &n->sel, n->fshift);
+ 		}
+ 		if (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))
+ 			goto next_ht;
+--- a/net/xfrm/xfrm_input.c
++++ b/net/xfrm/xfrm_input.c
+@@ -193,8 +193,8 @@ int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
+ 	if (!pskb_may_pull(skb, hlen))
+ 		return -EINVAL;
+ 
+-	*spi = *(__be32 *)(skb_transport_header(skb) + offset);
+-	*seq = *(__be32 *)(skb_transport_header(skb) + offset_seq);
++	*spi = net_hdr_word(skb_transport_header(skb) + offset);
++	*seq = net_hdr_word(skb_transport_header(skb) + offset_seq);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(xfrm_parse_spi);
diff --git a/target/linux/ar71xx/patches-4.14/920-usb-chipidea-AR933x-platform-support.patch b/target/linux/ar71xx/patches-4.14/920-usb-chipidea-AR933x-platform-support.patch
new file mode 100644
index 0000000000..1753308379
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/920-usb-chipidea-AR933x-platform-support.patch
@@ -0,0 +1,128 @@
+diff --git a/arch/mips/ath79/dev-usb.c b/arch/mips/ath79/dev-usb.c
+index 2558f973..c2872ab3 100644
+--- a/arch/mips/ath79/dev-usb.c
++++ b/arch/mips/ath79/dev-usb.c
+@@ -19,6 +19,9 @@
+ #include <linux/platform_device.h>
+ #include <linux/usb/ehci_pdriver.h>
+ #include <linux/usb/ohci_pdriver.h>
++#include <linux/usb/otg.h>
++#include <linux/usb/chipidea.h>
++#include <linux/usb/usb_phy_generic.h>
+ 
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
+@@ -170,6 +173,44 @@ static void __init ar913x_usb_setup(void)
+ 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+ }
+ 
++static void __init ar9xxx_ci_usb_setup(int bus_id, int irq)
++{
++	struct ci_hdrc_platform_data ci_pdata;
++	bool host_mode = true;
++
++	if (soc_is_ar933x())
++		host_mode = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP) &
++			    AR933X_BOOTSTRAP_USB_MODE_HOST;
++	else
++		host_mode = !(ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP) &
++			      AR934X_BOOTSTRAP_USB_MODE_DEVICE);
++
++	if (host_mode) {
++		ath79_usb_register("ehci-platform", bus_id,
++				   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
++				   irq, &ath79_ehci_pdata_v2,
++				   sizeof(ath79_ehci_pdata_v2));
++
++		return;
++	}
++
++	memset(&ci_pdata, 0, sizeof(ci_pdata));
++	ci_pdata.name = "ci_hdrc_ar9xxx";
++	ci_pdata.capoffset = DEF_CAPOFFSET;
++	ci_pdata.dr_mode = USB_DR_MODE_PERIPHERAL;
++	ci_pdata.flags = CI_HDRC_DUAL_ROLE_NOT_OTG | CI_HDRC_DP_ALWAYS_PULLUP;
++	ci_pdata.vbus_extcon.edev = ERR_PTR(-ENODEV);
++	ci_pdata.id_extcon.edev = ERR_PTR(-ENODEV);
++	ci_pdata.itc_setting = 1;
++
++	platform_device_register_simple("usb_phy_generic",
++					PLATFORM_DEVID_AUTO, NULL, 0);
++
++	ath79_usb_register("ci_hdrc", -1,
++			   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
++			   irq, &ci_pdata, sizeof(ci_pdata));
++}
++
+ static void __init ar933x_usb_setup(void)
+ {
+ 	ath79_device_reset_set(AR933X_RESET_USBSUS_OVERRIDE);
+@@ -181,10 +222,7 @@ static void __init ar933x_usb_setup(void)
+ 	ath79_device_reset_clear(AR933X_RESET_USB_PHY);
+ 	mdelay(10);
+ 
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR933X_EHCI_BASE, AR933X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++	ar9xxx_ci_usb_setup(-1, ATH79_CPU_IRQ(3));
+ }
+ 
+ static void enable_tx_tx_idp_violation_fix(unsigned base)
+@@ -230,10 +268,7 @@ static void __init ar934x_usb_setup(void)
+ 	if (ath79_soc_rev >= 3)
+ 		ath79_ehci_pdata_v2.reset_notifier = ar934x_usb_reset_notifier;
+ 
+-	ath79_usb_register("ehci-platform", -1,
+-			   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++	ar9xxx_ci_usb_setup(-1, ATH79_CPU_IRQ(3));
+ }
+ 
+ static void __init qca953x_usb_setup(void)
+@@ -254,10 +289,7 @@ static void __init qca953x_usb_setup(void)
+ 	ath79_device_reset_clear(QCA953X_RESET_USB_HOST);
+ 	udelay(1000);
+ 
+-	ath79_usb_register("ehci-platform", -1,
+-			   QCA953X_EHCI_BASE, QCA953X_EHCI_SIZE,
+-			   ATH79_CPU_IRQ(3),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++	ar9xxx_ci_usb_setup(-1, ATH79_CPU_IRQ(3));
+ }
+ 
+ static void qca955x_usb_reset_notifier(struct platform_device *pdev)
+@@ -285,10 +317,7 @@ static void __init qca955x_usb_setup(void)
+ {
+ 	ath79_ehci_pdata_v2.reset_notifier = qca955x_usb_reset_notifier;
+ 
+-	ath79_usb_register("ehci-platform", 0,
+-			   QCA955X_EHCI0_BASE, QCA955X_EHCI_SIZE,
+-			   ATH79_IP3_IRQ(0),
+-			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
++	ar9xxx_ci_usb_setup(0, ATH79_IP3_IRQ(0));
+ 
+ 	ath79_usb_register("ehci-platform", 1,
+ 			   QCA955X_EHCI1_BASE, QCA955X_EHCI_SIZE,
+diff --git a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+index 70c8e657..c275e12e 100644
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -656,6 +656,7 @@
+ 
+ #define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
+ #define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
++#define AR933X_BOOTSTRAP_USB_MODE_HOST	BIT(3)
+ #define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
+ 
+ #define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
+@@ -685,6 +686,8 @@
+ 
+ #define QCA956X_BOOTSTRAP_REF_CLK_40	BIT(2)
+ 
++#define AR933X_USB_CONFIG_HOST_ONLY   BIT(8)
++
+ #define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+ #define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+ #define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
diff --git a/target/linux/ar71xx/patches-4.14/921-MIPS-ath79-add-even-more-register-defines-for-QCA956x-SoC.patch b/target/linux/ar71xx/patches-4.14/921-MIPS-ath79-add-even-more-register-defines-for-QCA956x-SoC.patch
new file mode 100644
index 0000000000..1c0f18e317
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/921-MIPS-ath79-add-even-more-register-defines-for-QCA956x-SoC.patch
@@ -0,0 +1,194 @@
+diff --git a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+index c275e12e..fdba433c 100644
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -175,6 +175,35 @@
+ /*
+  * Hidden Registers
+  */
++#define QCA956X_MAC_CFG_BASE		0xb9000000
++#define QCA956X_MAC_CFG_SIZE		0x64
++
++#define QCA956X_MAC_CFG1_REG		0x00
++#define QCA956X_MAC_CFG1_SOFT_RST	BIT(31)
++#define QCA956X_MAC_CFG1_RX_RST		BIT(19)
++#define QCA956X_MAC_CFG1_TX_RST		BIT(18)
++#define QCA956X_MAC_CFG1_LOOPBACK	BIT(8)
++#define QCA956X_MAC_CFG1_RX_EN		BIT(2)
++#define QCA956X_MAC_CFG1_TX_EN		BIT(0)
++
++#define QCA956X_MAC_CFG2_REG		0x04
++#define QCA956X_MAC_CFG2_IF_1000	BIT(9)
++#define QCA956X_MAC_CFG2_IF_10_100	BIT(8)
++#define QCA956X_MAC_CFG2_HUGE_FRAME_EN	BIT(5)
++#define QCA956X_MAC_CFG2_LEN_CHECK	BIT(4)
++#define QCA956X_MAC_CFG2_PAD_CRC_EN	BIT(2)
++#define QCA956X_MAC_CFG2_FDX		BIT(0)
++
++#define QCA956X_MAC_MII_MGMT_CFG_REG	0x20
++#define QCA956X_MGMT_CFG_CLK_DIV_20	0x07
++
++#define QCA956X_MAC_FIFO_CFG0_REG	0x48
++#define QCA956X_MAC_FIFO_CFG1_REG	0x4c
++#define QCA956X_MAC_FIFO_CFG2_REG	0x50
++#define QCA956X_MAC_FIFO_CFG3_REG	0x54
++#define QCA956X_MAC_FIFO_CFG4_REG	0x58
++#define QCA956X_MAC_FIFO_CFG5_REG	0x5c
++
+ #define QCA956X_DAM_RESET_OFFSET	0xb90001bc
+ #define QCA956X_DAM_RESET_SIZE		0x4
+ #define QCA956X_INLINE_CHKSUM_ENG	BIT(27)
+@@ -381,6 +410,7 @@
+ #define QCA955X_PLL_CLK_CTRL_REG		0x08
+ #define QCA955X_PLL_ETH_XMII_CONTROL_REG	0x28
+ #define QCA955X_PLL_ETH_SGMII_CONTROL_REG	0x48
++#define QCA955X_PLL_ETH_SGMII_SERDES_REG	0x4c
+ 
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+ #define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+@@ -413,12 +443,18 @@
+ #define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
+ #define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+ 
++#define QCA955X_PLL_ETH_SGMII_SERDES_LOCK_DETECT	BIT(2)
++#define QCA955X_PLL_ETH_SGMII_SERDES_PLL_REFCLK		BIT(1)
++#define QCA955X_PLL_ETH_SGMII_SERDES_EN_PLL		BIT(0)
++
+ #define QCA956X_PLL_CPU_CONFIG_REG			0x00
+ #define QCA956X_PLL_CPU_CONFIG1_REG			0x04
+ #define QCA956X_PLL_DDR_CONFIG_REG			0x08
+ #define QCA956X_PLL_DDR_CONFIG1_REG			0x0c
+ #define QCA956X_PLL_CLK_CTRL_REG			0x10
++#define QCA956X_PLL_SWITCH_CLOCK_CONTROL_REG		0x28
+ #define QCA956X_PLL_ETH_XMII_CONTROL_REG		0x30
++#define QCA956X_PLL_ETH_SGMII_SERDES_REG		0x4c
+ 
+ #define QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT		12
+ #define QCA956X_PLL_CPU_CONFIG_REFDIV_MASK		0x1f
+@@ -457,6 +493,31 @@
+ #define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL	BIT(21)
+ #define QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+ 
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_I2C_CLK_SELB		BIT(5)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1		BIT(6)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_UART1_CLK_SEL		BIT(7)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SHIFT 8
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK	 0xf
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_EN_PLL_TOP		BIT(12)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2		BIT(13)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1		BIT(14)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2		BIT(15)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE	BIT(16)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_EEE_ENABLE		BIT(17)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL		BIT(18)
++#define QCA956X_PLL_SWITCH_CLOCK_SPARE_SWITCHCLK_SEL		BIT(19)
++
++#define QCA956X_PLL_ETH_XMII_TX_INVERT			BIT(1)
++#define QCA956X_PLL_ETH_XMII_GIGE			BIT(25)
++#define QCA956X_PLL_ETH_XMII_RX_DELAY_SHIFT		28
++#define QCA956X_PLL_ETH_XMII_RX_DELAY_MASK		0x3
++#define QCA956X_PLL_ETH_XMII_TX_DELAY_SHIFT		26
++#define QCA956X_PLL_ETH_XMII_TX_DELAY_MASK		3
++
++#define QCA956X_PLL_ETH_SGMII_SERDES_LOCK_DETECT		BIT(2)
++#define QCA956X_PLL_ETH_SGMII_SERDES_PLL_REFCLK			BIT(1)
++#define QCA956X_PLL_ETH_SGMII_SERDES_EN_PLL			BIT(0)
++
+ /*
+  * USB_CONFIG block
+  */
+@@ -654,6 +715,25 @@
+ #define QCA955X_RESET_MBOX		BIT(1)
+ #define QCA955X_RESET_I2S		BIT(0)
+ 
++#define QCA956X_RESET_EXTERNAL		BIT(28)
++#define QCA956X_RESET_FULL_CHIP		BIT(24)
++#define QCA956X_RESET_GE1_MDIO		BIT(23)
++#define QCA956X_RESET_GE0_MDIO		BIT(22)
++#define QCA956X_RESET_CPU_NMI		BIT(21)
++#define QCA956X_RESET_CPU_COLD		BIT(20)
++#define QCA956X_RESET_DMA		BIT(19)
++#define QCA956X_RESET_DDR		BIT(16)
++#define QCA956X_RESET_GE1_MAC		BIT(13)
++#define QCA956X_RESET_SGMII_ANALOG	BIT(12)
++#define QCA956X_RESET_USB_PHY_ANALOG	BIT(11)
++#define QCA956X_RESET_GE0_MAC		BIT(9)
++#define QCA956X_RESET_SGMII		BIT(8)
++#define QCA956X_RESET_USB_HOST		BIT(5)
++#define QCA956X_RESET_USB_PHY		BIT(4)
++#define QCA956X_RESET_USBSUS_OVERRIDE	BIT(3)
++#define QCA956X_RESET_SWITCH_ANALOG	BIT(2)
++#define QCA956X_RESET_SWITCH		BIT(0)
++
+ #define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
+ #define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
+ #define AR933X_BOOTSTRAP_USB_MODE_HOST	BIT(3)
+@@ -1186,6 +1266,7 @@
+  */
+ 
+ #define QCA955X_GMAC_REG_ETH_CFG	0x00
++#define QCA955X_GMAC_REG_SGMII_SERDES	0x18
+ 
+ #define QCA955X_ETH_CFG_RGMII_EN	BIT(0)
+ #define QCA955X_ETH_CFG_MII_GE0		BIT(1)
+@@ -1207,16 +1288,58 @@
+ #define QCA955X_ETH_CFG_TXE_DELAY_MASK	0x3
+ #define QCA955X_ETH_CFG_TXE_DELAY_SHIFT	20
+ 
++#define QCA955X_SGMII_SERDES_LOCK_DETECT_STATUS	BIT(15)
++#define QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT 23
++#define QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK 0xf
+ /*
+  * QCA956X GMAC Interface
+  */
+ 
+-#define QCA956X_GMAC_REG_ETH_CFG		0x00
++#define QCA956X_GMAC_REG_ETH_CFG	0x00
++#define QCA956X_GMAC_REG_SGMII_RESET	0x14
++#define QCA956X_GMAC_REG_SGMII_SERDES	0x18
++#define QCA956X_GMAC_REG_MR_AN_CONTROL	0x1c
++#define QCA956X_GMAC_REG_SGMII_CONFIG	0x34
++#define QCA956X_GMAC_REG_SGMII_DEBUG	0x58
+ 
++#define QCA956X_ETH_CFG_RGMII_EN		BIT(0)
++#define QCA956X_ETH_CFG_GE0_SGMII		BIT(6)
+ #define QCA956X_ETH_CFG_SW_ONLY_MODE		BIT(7)
+-#define QCA956X_ETH_CFG_SW_PHY_SWAP		    BIT(8)
++#define QCA956X_ETH_CFG_SW_PHY_SWAP		BIT(8)
+ #define QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(9)
+ #define QCA956X_ETH_CFG_SW_APB_ACCESS		BIT(10)
+ #define QCA956X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
++#define QCA956X_ETH_CFG_RXD_DELAY_MASK		0x3
++#define QCA956X_ETH_CFG_RXD_DELAY_SHIFT		14
++#define QCA956X_ETH_CFG_RDV_DELAY_MASK		0x3
++#define QCA956X_ETH_CFG_RDV_DELAY_SHIFT		16
++
++#define QCA956X_SGMII_RESET_RX_CLK_N_RESET	0x0
++#define QCA956X_SGMII_RESET_RX_CLK_N		BIT(0)
++#define QCA956X_SGMII_RESET_TX_CLK_N		BIT(1)
++#define QCA956X_SGMII_RESET_RX_125M_N		BIT(2)
++#define QCA956X_SGMII_RESET_TX_125M_N		BIT(3)
++#define QCA956X_SGMII_RESET_HW_RX_125M_N	BIT(4)
++
++#define QCA956X_SGMII_SERDES_CDR_BW_MASK	0x3
++#define QCA956X_SGMII_SERDES_CDR_BW_SHIFT	1
++#define QCA956X_SGMII_SERDES_TX_DR_CTRL_MASK	0x7
++#define QCA956X_SGMII_SERDES_TX_DR_CTRL_SHIFT	4
++#define QCA956X_SGMII_SERDES_PLL_BW		BIT(8)
++#define QCA956X_SGMII_SERDES_VCO_FAST		BIT(9)
++#define QCA956X_SGMII_SERDES_VCO_SLOW		BIT(10)
++#define QCA956X_SGMII_SERDES_LOCK_DETECT_STATUS	BIT(15)
++#define QCA956X_SGMII_SERDES_EN_SIGNAL_DETECT	BIT(16)
++#define QCA956X_SGMII_SERDES_FIBER_SDO		BIT(17)
++#define QCA956X_SGMII_SERDES_RES_CALIBRATION_SHIFT 23
++#define QCA956X_SGMII_SERDES_RES_CALIBRATION_MASK 0xf
++#define QCA956X_SGMII_SERDES_VCO_REG_SHIFT	27
++#define QCA956X_SGMII_SERDES_VCO_REG_MASK	0xf
++
++#define QCA956X_MR_AN_CONTROL_AN_ENABLE		BIT(12)
++#define QCA956X_MR_AN_CONTROL_PHY_RESET		BIT(15)
++
++#define QCA956X_SGMII_CONFIG_MODE_CTRL_SHIFT	0
++#define QCA956X_SGMII_CONFIG_MODE_CTRL_MASK	0x7
+ 
+ #endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/ar71xx/patches-4.14/930-chipidea-pullup.patch b/target/linux/ar71xx/patches-4.14/930-chipidea-pullup.patch
new file mode 100644
index 0000000000..f6a4f01611
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.14/930-chipidea-pullup.patch
@@ -0,0 +1,72 @@
+--- a/drivers/usb/chipidea/ci.h
++++ b/drivers/usb/chipidea/ci.h
+@@ -205,6 +205,7 @@ struct hw_bank {
+  * @in_lpm: if the core in low power mode
+  * @wakeup_int: if wakeup interrupt occur
+  * @rev: The revision number for controller
++ * @dp_always_pullup: keep dp always pullup at device mode
+  */
+ struct ci_hdrc {
+ 	struct device			*dev;
+@@ -259,6 +260,7 @@ struct ci_hdrc {
+ 	bool				in_lpm;
+ 	bool				wakeup_int;
+ 	enum ci_revision		rev;
++	bool				dp_always_pullup;
+ };
+ 
+ static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)
+--- a/drivers/usb/chipidea/core.c
++++ b/drivers/usb/chipidea/core.c
+@@ -818,7 +818,7 @@ static inline void ci_role_destroy(struct ci_hdrc *ci)
+ {
+ 	ci_hdrc_gadget_destroy(ci);
+ 	ci_hdrc_host_destroy(ci);
+-	if (ci->is_otg && ci->roles[CI_ROLE_GADGET])
++	if (!ci->dp_always_pullup && ci->roles[CI_ROLE_GADGET])
+ 		ci_hdrc_otg_destroy(ci);
+ }
+ 
+@@ -923,6 +923,9 @@ static int ci_hdrc_probe(struct platform_device *pdev)
+ 		CI_HDRC_SUPPORTS_RUNTIME_PM);
+ 	platform_set_drvdata(pdev, ci);
+ 
++	ci->dp_always_pullup = !!(ci->platdata->flags &
++					 CI_HDRC_DP_ALWAYS_PULLUP);
++
+ 	ret = hw_device_init(ci, base);
+ 	if (ret < 0) {
+ 		dev_err(dev, "can't initialize hardware\n");
+@@ -1004,7 +1007,7 @@ static int ci_hdrc_probe(struct platform_device *pdev)
+ 		goto deinit_gadget;
+ 	}
+ 
+-	if (ci->is_otg && ci->roles[CI_ROLE_GADGET]) {
++	if (!ci->dp_always_pullup && ci->roles[CI_ROLE_GADGET]) {
+ 		ret = ci_hdrc_otg_init(ci);
+ 		if (ret) {
+ 			dev_err(dev, "init otg fails, ret = %d\n", ret);
+--- a/drivers/usb/chipidea/otg.c
++++ b/drivers/usb/chipidea/otg.c
+@@ -131,8 +131,10 @@ enum ci_role ci_otg_role(struct ci_hdrc *ci)
+ 
+ void ci_handle_vbus_change(struct ci_hdrc *ci)
+ {
+-	if (!ci->is_otg)
++	if (ci->dp_always_pullup) {
++		usb_gadget_vbus_connect(&ci->gadget);
+ 		return;
++	}
+ 
+ 	if (hw_read_otgsc(ci, OTGSC_BSV) && !ci->vbus_active)
+ 		usb_gadget_vbus_connect(&ci->gadget);
+--- a/include/linux/usb/chipidea.h
++++ b/include/linux/usb/chipidea.h
+@@ -59,6 +59,7 @@ struct ci_hdrc_platform_data {
+ #define CI_HDRC_OVERRIDE_TX_BURST	BIT(10)
+ #define CI_HDRC_OVERRIDE_RX_BURST	BIT(11)
+ #define CI_HDRC_OVERRIDE_PHY_CONTROL	BIT(12) /* Glue layer manages phy */
++#define CI_HDRC_DP_ALWAYS_PULLUP	BIT(12)
+ #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
+ 	enum usb_dr_mode	dr_mode;
+ #define CI_HDRC_CONTROLLER_RESET_EVENT		0
-- 
2.17.1

